# Comparing `tmp/cobra_io-0.0.3-py3-none-any.whl.zip` & `tmp/cobra_io-0.0.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,25 @@
-Zip file size: 17904 bytes, number of entries: 22
--rw-rw-r--  2.0 unx      149 b- defN 23-Aug-03 13:30 cobra/__init__.py
+Zip file size: 18276 bytes, number of entries: 23
+-rw-rw-r--  2.0 unx      149 b- defN 24-Apr-15 10:53 cobra/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jul-06 08:39 cobra/asset/__init__.py
--rw-rw-r--  2.0 unx     1111 b- defN 23-Jul-13 12:05 cobra/asset/asset.py
+-rw-rw-r--  2.0 unx     1134 b- defN 24-Apr-15 10:53 cobra/asset/asset.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jul-06 08:39 cobra/robot/__init__.py
--rw-rw-r--  2.0 unx     5226 b- defN 23-Jul-25 11:25 cobra/robot/robot.py
+-rw-rw-r--  2.0 unx     5248 b- defN 24-Apr-15 10:53 cobra/robot/robot.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jul-06 08:39 cobra/solution/__init__.py
--rw-rw-r--  2.0 unx     9062 b- defN 23-Jul-25 11:25 cobra/solution/solution.py
+-rw-rw-r--  2.0 unx     9078 b- defN 24-Apr-15 10:53 cobra/solution/solution.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jul-06 08:39 cobra/task/__init__.py
--rw-rw-r--  2.0 unx     6772 b- defN 23-Jul-25 11:25 cobra/task/task.py
--rw-rw-r--  2.0 unx     1222 b- defN 23-Jul-13 12:05 cobra/user/user.py
+-rw-rw-r--  2.0 unx     6793 b- defN 24-Apr-15 10:53 cobra/task/task.py
+-rw-rw-r--  2.0 unx     1244 b- defN 24-Apr-15 10:53 cobra/user/user.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jul-06 08:39 cobra/utils/__init__.py
 -rw-rw-r--  2.0 unx      975 b- defN 23-Jul-13 12:05 cobra/utils/caches.py
 -rw-rw-r--  2.0 unx     1026 b- defN 23-Aug-03 13:30 cobra/utils/cobra.config.sample
 -rw-rw-r--  2.0 unx     1252 b- defN 23-Jul-13 12:05 cobra/utils/configurations.py
 -rw-rw-r--  2.0 unx     3340 b- defN 23-Jul-13 12:05 cobra/utils/logging.py
+-rw-rw-r--  2.0 unx      219 b- defN 24-Apr-15 10:53 cobra/utils/requests.py
 -rw-rw-r--  2.0 unx      335 b- defN 23-Jul-25 07:23 cobra/utils/urls.py
--rw-rw-r--  2.0 unx     3800 b- defN 23-Jul-25 11:25 cobra/utils/utils.py
--rw-rw-r--  2.0 unx     1064 b- defN 23-Aug-03 13:31 cobra_io-0.0.3.dist-info/LICENSE
--rw-rw-r--  2.0 unx     4565 b- defN 23-Aug-03 13:31 cobra_io-0.0.3.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Aug-03 13:31 cobra_io-0.0.3.dist-info/WHEEL
--rw-rw-r--  2.0 unx        6 b- defN 23-Aug-03 13:31 cobra_io-0.0.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1719 b- defN 23-Aug-03 13:31 cobra_io-0.0.3.dist-info/RECORD
-22 files, 41716 bytes uncompressed, 15126 bytes compressed:  63.7%
+-rw-rw-r--  2.0 unx     3824 b- defN 24-Apr-15 10:53 cobra/utils/utils.py
+-rw-rw-r--  2.0 unx     1064 b- defN 24-Apr-15 10:55 cobra_io-0.0.4.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     4605 b- defN 24-Apr-15 10:55 cobra_io-0.0.4.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-Apr-15 10:55 cobra_io-0.0.4.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        6 b- defN 24-Apr-15 10:55 cobra_io-0.0.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1798 b- defN 24-Apr-15 10:55 cobra_io-0.0.4.dist-info/RECORD
+23 files, 42182 bytes uncompressed, 15376 bytes compressed:  63.5%
```

## zipnote {}

```diff
@@ -39,29 +39,32 @@
 
 Filename: cobra/utils/configurations.py
 Comment: 
 
 Filename: cobra/utils/logging.py
 Comment: 
 
+Filename: cobra/utils/requests.py
+Comment: 
+
 Filename: cobra/utils/urls.py
 Comment: 
 
 Filename: cobra/utils/utils.py
 Comment: 
 
-Filename: cobra_io-0.0.3.dist-info/LICENSE
+Filename: cobra_io-0.0.4.dist-info/LICENSE
 Comment: 
 
-Filename: cobra_io-0.0.3.dist-info/METADATA
+Filename: cobra_io-0.0.4.dist-info/METADATA
 Comment: 
 
-Filename: cobra_io-0.0.3.dist-info/WHEEL
+Filename: cobra_io-0.0.4.dist-info/WHEEL
 Comment: 
 
-Filename: cobra_io-0.0.3.dist-info/top_level.txt
+Filename: cobra_io-0.0.4.dist-info/top_level.txt
 Comment: 
 
-Filename: cobra_io-0.0.3.dist-info/RECORD
+Filename: cobra_io-0.0.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cobra/__init__.py

```diff
@@ -1,6 +1,6 @@
-__version__ = "0.0.3"
+__version__ = "0.0.4"
 from .asset import asset
 from .robot import robot
 from .task import task
 from .solution import solution
 from .user import user
```

## cobra/asset/asset.py

```diff
@@ -1,12 +1,11 @@
-import requests
-
 from cobra.utils.caches import ASSET_CACHE
 from cobra.utils.configurations import COBRA_VERSION
 from cobra.utils.urls import ASSET_URL
+from cobra.utils.requests import session
 
 
 def get_asset(name, version=COBRA_VERSION, force_download=False):
     """
     Returns asset from CoBRA if it exists.
 
     :param name: Name of asset to look for.
@@ -15,15 +14,15 @@
     :return: Path to asset file.
     :raises FileNotFoundError: If asset does not exist in CoBRA of specific version.
     """
     asset_file = ASSET_CACHE.joinpath(version).joinpath(name)
     if not force_download and asset_file.exists():
         return asset_file
     asset_URI = f"{ASSET_URL}{name}?version={version}"
-    r = requests.get(asset_URI)
+    r = session.get(asset_URI)
     if r.status_code == 200:
         asset_file.parent.mkdir(parents=True, exist_ok=True)
         with open(asset_file, 'wb') as f:
             f.write(r.content)
         return asset_file
     else:
         raise FileNotFoundError(f"Asset {name} (version {version}) does not exist in CoBRA.")
```

## cobra/robot/robot.py

```diff
@@ -1,18 +1,18 @@
 import io
 from pathlib import Path
 from typing import List, Set, Tuple, Dict
 
 import jsonschema
-import requests
 import zipfile
 
 from cobra.utils.caches import MODULE_DB_CACHE
 from cobra.utils.configurations import COBRA_VERSION
 from cobra.utils import logging, utils
+from cobra.utils.requests import session
 from cobra.utils.urls import MODULE_DB_URL
 
 
 def get_module_db(name: str, version: str = COBRA_VERSION, force_download: bool = False) -> Path:
     """
     Returns module database from CoBRA if it exists.
 
@@ -24,15 +24,15 @@
     """
     module_db_dir = MODULE_DB_CACHE.joinpath(version).joinpath(name)
     module_db_file = module_db_dir.joinpath('modules.json')
     if not force_download and module_db_file.exists():
         return module_db_file
     module_db_uri = f"{MODULE_DB_URL}/{name}?zip=True"
     logging.debug(f"Trying to get {module_db_uri}")
-    r = requests.get(module_db_uri)
+    r = session.get(module_db_uri)
     logging.debug(f"Request status: {r.status_code}")
     if r.status_code == 200:
         module_db_dir.mkdir(parents=True, exist_ok=True)
         zipfile.ZipFile(io.BytesIO(r.content)).extractall(module_db_dir)
         return module_db_file
     else:
         raise FileNotFoundError(f"Asset {name} (version {version}) does not exist in CoBRA.")
@@ -46,15 +46,15 @@
     :param locally: If True, will return module databases available in cache.
     :return: Set of module databases available in CoBRA of specific version.
     :raises ValueError: If module databases could not be retrieved from CoBRA.
     """
     if locally:
         return {x.name for x in MODULE_DB_CACHE.joinpath(version).iterdir()}
     else:
-        r = requests.get(MODULE_DB_URL)
+        r = session.get(MODULE_DB_URL)
         if r.status_code == 200:
             return set(r.json())
         else:
             raise ValueError(f"Could not get available module databases from CoBRA (error {r.status_code}).")
 
 
 def get_schema(version: str = COBRA_VERSION, force_download: bool = False) -> Path:
@@ -98,15 +98,15 @@
     """
     get_module_db(module_db, version, force_download)  # Get module db such that assets are downloaded
     urdf_file = MODULE_DB_CACHE.joinpath(version).joinpath(module_db).joinpath(f"robot-{'-'.join(module_order)}.urdf")
     if urdf_file.exists() and not force_download:
         return urdf_file
     module_order_string = '"' + '", "'.join(module_order) + '"'
     query = f'{MODULE_DB_URL}/{module_db}?urdf=True&moduleOrder=[{module_order_string}]&wrl={accept_wrl}'
-    r = requests.get(query)
+    r = session.get(query)
     if r.status_code != 200:
         raise ValueError(f"Could not get URDF from CoBRA (error {r.status_code}).")
     urdf_file.write_text(r.text)
     return urdf_file
 
 
 def upload_task(task: Path, user: str):
```

## cobra/solution/solution.py

```diff
@@ -1,21 +1,21 @@
 import argparse
 import json
 import re
 from pathlib import Path
 from typing import Optional, Tuple, Union, Dict, List, Any
 
 import jsonschema
-import requests
 
 from cobra.user.user import login
 from cobra.utils import utils
 from cobra.utils.caches import SOLUTION_CACHE
 from cobra.utils.configurations import COBRA_VERSION
 import cobra.utils.logging as logging
+from cobra.utils.requests import session
 from cobra.task.task import find_tasks, get_task
 from cobra.utils.urls import RANKING_URL, SOLUTION_URL
 from cobra.utils.utils import map2path
 
 
 def find_solutions(task_id: Optional[str] = None, task_uuid: Optional[str] = None, version: str = COBRA_VERSION,
                    cost_function: Optional[str] = None) -> Tuple[List[str], List[Dict[str, Any]]]:
@@ -34,30 +34,30 @@
         _, details = find_tasks(id=task_id, version=version)
         if len(details) != 1:
             raise KeyError(f"Task with id {task_id} not unique in version {version}.")
         task_uuid = details[0]['id']
     query = RANKING_URL + task_uuid + "/"
     if cost_function is not None:
         query += f"?costFunction__icontains={cost_function}"
-    r = requests.get(query)
+    r = session.get(query)
     if r.status_code != 200:
         raise ValueError(f"Solutions for task with uuid {task_uuid} not found.")
     if r.json()['next'] is not None:
         logging.warning(f"Only the first {r.json()['count']} solutions are returned.")
     return [res["id"] for res in r.json()['results']], r.json()['results']
 
 
 def get_solution_details(solution_uuid: str) -> Dict[str, Any]:
     """
     Return the details of a solution from the CoBRA API.
 
     :param solution_uuid: The uuid of the solution to return.
     :return: The details of the solution as given by https://cobra.cps.cit.tum.de/api/ -> solutioncrok_read
     """
-    r = requests.get(SOLUTION_URL + solution_uuid + '/')
+    r = session.get(SOLUTION_URL + solution_uuid + '/')
     if r.status_code != 200:
         raise ValueError(f"Solution with uuid {solution_uuid} not available.")
     return r.json()
 
 
 def get_solution(solution_uuid: str, force_download: bool = False) -> Tuple[Path, Path]:
     """
@@ -69,18 +69,18 @@
     """
     solution_file = SOLUTION_CACHE.joinpath(solution_uuid + ".json")
     if solution_file.exists() and not force_download:
         logging.debug("Solution file already exists. Returning cached version.")
         solution_data = json.load(solution_file.open("r"))
         return solution_file, get_task(id=solution_data["taskID"], version=solution_data["version"])
 
-    r = requests.get(SOLUTION_URL + solution_uuid + "/")
+    r = session.get(SOLUTION_URL + solution_uuid + "/")
     if r.status_code != 200:
         raise ValueError(f"Solution with uuid {solution_uuid} not available.")
-    r_json = requests.get(r.json()["json"])
+    r_json = session.get(r.json()["json"])
     if r_json.status_code != 200:
         raise ValueError(f"Solution json for uuid {solution_uuid} not available.")
 
     with open(solution_file, "wb") as f:
         f.write(r_json.content)
 
     task_file = get_task(uuid=r.json()["scenario_id"], force_download=force_download)
@@ -95,17 +95,17 @@
 
     :param solution_file: The solution file to submit.
     :param user_email: The email of the user submitting the solution.
     :param password: The password of the user submitting the solution. Alternative enter via CLI input.
     :return: True if successful + UUID of solution.
     """
     access_token = login(user_email, password)
-    r = requests.post(SOLUTION_URL + 'solutionsupload/upload/',
-                      files={"json": map2path(solution_file).open("rb")},
-                      headers={"Authorization": f"Bearer {access_token}"})
+    r = session.post(SOLUTION_URL + 'solutionsupload/upload/',
+                     files={"json": map2path(solution_file).open("rb")},
+                     headers={"Authorization": f"Bearer {access_token}"})
     if r.status_code != 201:
         if r.status_code == 400 and b'Set overwrite=True in order to overwrite' in r.content:
             logging.info("Solution already exists. Did not overwrite.")
             uuid = re.findall("((?<=uuid: )[0-9a-f-]+)", str(r.content))
             if len(uuid) == 1:
                 return True, uuid[0]
         raise ValueError(f"Solution upload failed with status code {r.status_code}; details: {r.content}.")
@@ -119,16 +119,16 @@
     :param solution_uuid: The uuid of the solution to delete.
     :param user_email: The email of the user deleting the solution.
     :param password: The password of the user deleting the solution. Alternative enter via CLI input.
     :return: True if successful.
     :raises ValueError: If deletion fails.
     """
     access_token = login(user_email, password)
-    r = requests.delete(SOLUTION_URL + f"{solution_uuid}/",
-                        headers={"Authorization": f"Bearer {access_token}"})
+    r = session.delete(SOLUTION_URL + f"{solution_uuid}/",
+                       headers={"Authorization": f"Bearer {access_token}"})
     if r.status_code != 204:
         raise ValueError(f"Solution deletion failed with status code {r.status_code}; details: {r.content}.")
     solution_file = SOLUTION_CACHE.joinpath(solution_uuid + ".json")
     solution_file.unlink(missing_ok=True)  # Also remove from cache
     return True
```

## cobra/task/task.py

```diff
@@ -2,20 +2,20 @@
 import json
 import logging
 import os
 from pathlib import Path
 from typing import Any, Dict, List, Optional, Tuple
 
 import jsonschema
-import requests
 
 from cobra.asset.asset import get_asset
 from cobra.utils import utils
 from cobra.utils.caches import TASK_CACHE
 from cobra.utils.configurations import COBRA_VERSION
+from cobra.utils.requests import session
 from cobra.utils.urls import TASK_URL
 from cobra.utils.utils import find_key
 
 
 def find_tasks(version: str = COBRA_VERSION,
                id: str = None,
                id_contains: str = None,
@@ -40,27 +40,27 @@
     if version is not None:
         query.append(f"version={version}")
     # tags: Set[str] = None,
     # if tags is not None:
     #     query.append(f"metadata__tags={tags}")
     # goal_types: Set[str] = None,
     query = query[0] + "&".join(query[1:])
-    r = requests.get(query)
+    r = session.get(query)
     if r.status_code == 200:
         return [res["id"] for res in r.json()['results']], r.json()["results"]
 
 
 def get_task_details(task_uuid: str) -> Dict[str, Any]:
     """
     Return the details of a task from the CoBRA API.
 
     :param task_uuid: The uuid of the task to return.
     :return: The details of the task as given by https://cobra.cps.cit.tum.de/api/ -> scenariocrok_read
     """
-    r = requests.get(TASK_URL + task_uuid + '/')
+    r = session.get(TASK_URL + task_uuid + '/')
     if r.status_code != 200:
         raise ValueError(f"Task with uuid {task_uuid} not available.")
     return r.json()
 
 
 def get_task(uuid: Optional[str] = None,
              id: Optional[str] = None,
@@ -70,15 +70,15 @@
     """Return a task with the given id and version."""
     if uuid is None and id is None:
         raise ValueError("Either uuid or id must be given.")
 
     if uuid is not None:
         if id is not None:
             logging.info("Both uuid and id were given. Ignoring id.")
-        r_task_overview = requests.get(TASK_URL + uuid + "/")
+        r_task_overview = session.get(TASK_URL + uuid + "/")
         if r_task_overview.status_code != 200:
             raise KeyError(f"Task with UUID = {uuid} not found.")
         id = r_task_overview.json()['scenario_id']
         task_overview = r_task_overview.json()
     base_path = TASK_CACHE.joinpath(version)
     task_file = base_path.joinpath(id + ".json")
 
@@ -98,15 +98,15 @@
             raise KeyError(f"Task with id = {id} not found in version {version}.")
         elif len(tasks_uuids) > 1:
             raise KeyError(f"Multiple tasks with id = {id} found in version {version}.")
         uuid = tasks_uuids[0]
         task_overview = task_results[0]
 
     # Get json
-    r_task_json = requests.get(task_overview['json'])
+    r_task_json = session.get(task_overview['json'])
     if r_task_json.status_code != 200:
         raise ValueError(f"Task json not available: {task_overview['json']}; Error code: {r_task_json.status_code}")
     task_file.parent.mkdir(parents=True, exist_ok=True)
     with open(task_file, 'wb') as f:
         f.write(r_task_json.content)
 
     # Get assets and symlink relative to task
```

## cobra/user/user.py

```diff
@@ -1,13 +1,12 @@
 from getpass import getpass
 from typing import Optional
 
-import requests
-
 from cobra.utils.urls import BASE_URL
+from cobra.utils.requests import session
 
 
 _refresh_token = None
 
 
 def login(e_mail: str, password: Optional[str] = None) -> str:
     """
@@ -15,21 +14,21 @@
 
     :param e_mail: The e-mail address of the user.
     :param password: The password of the user; alternatively, the user will be prompted to enter the password.
     :return: The access token.
     """
     global _refresh_token
     if _refresh_token is not None:
-        r_refresh = requests.post(BASE_URL + 'token/refresh/', data={'refresh': _refresh_token})
+        r_refresh = session.post(BASE_URL + 'token/refresh/', data={'refresh': _refresh_token})
         if r_refresh.status_code == 200:
             return r_refresh.json()['access']
         # Fall through if refresh token is invalid.
     if password is None:
         password = getpass(f"Please enter the password for {e_mail}: ")
-    r_login = requests.post(BASE_URL + 'token/', data={'email': e_mail, 'password': password})
+    r_login = session.post(BASE_URL + 'token/', data={'email': e_mail, 'password': password})
     if r_login.status_code != 200:
         raise ValueError("Invalid credentials.")
     _refresh_token = r_login.json()['refresh']
     return r_login.json()['access']
 
 
 def logout():
```

## cobra/utils/utils.py

```diff
@@ -1,17 +1,17 @@
 import json
 from pathlib import Path
 from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union
 
 import jsonschema.validators
-import requests
 
 from cobra.utils.caches import SCHEMA_CACHE
 from cobra.utils.configurations import COBRA_VERSION
 from cobra.utils.urls import SCHEMA_URL
+from cobra.utils.requests import session
 
 
 def find_key(key: str, data: Union[Dict, Sequence], modifier: Optional[Callable[[Any], Any]] = None,
              search_depth: int = 20) -> Tuple[List[Any], List[Any]]:
     """
     Find all appearances of key in a nested dict / sequence combination and return references to each.
 
@@ -58,15 +58,15 @@
     :return: The path to the downloaded schema.
     """
     if version != COBRA_VERSION:
         raise NotImplementedError
     schema_file = SCHEMA_CACHE.joinpath(f"{schema}.json")
     if not force_download and schema_file.exists():
         return schema_file
-    r = requests.get(SCHEMA_URL + f"{schema}.json")
+    r = session.get(SCHEMA_URL + f"{schema}.json")
     if r.status_code != 200:
         raise ValueError(f"Could not get schema {schema} from CoBRA (error {r.status_code}).")
     schema_file.write_text(r.text)
     return schema_file
 
 
 def get_schema_validator(schema: str, version: str = COBRA_VERSION,
```

## Comparing `cobra_io-0.0.3.dist-info/LICENSE` & `cobra_io-0.0.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cobra_io-0.0.3.dist-info/METADATA` & `cobra_io-0.0.4.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,34 +1,35 @@
 Metadata-Version: 2.1
 Name: cobra-io
-Version: 0.0.3
+Version: 0.0.4
 Summary: Composable Benchmark for Robotics Applications - Input/Output
 Author-email: Matthias Mayer <matthias.mayer@tum.de>
 License: MIT
 Project-URL: Source Code, https://gitlab.lrz.de/tum-cps/cobra-io
 Project-URL: Documentation, https://cobra-io.readthedocs.io/en/latest/
 Project-URL: Bug Tracker, https://gitlab.lrz.de/tum-cps/cobra-io/-/issues
 Keywords: Modular Reconfigurable Robots,Robot Design,Model Generation,Simulation,Benchmark,Path Planning
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3 :: Only
 Requires-Python: >=3.7
 Description-Content-Type: text/x-rst
 License-File: LICENSE
-Requires-Dist: jsonschema (>=4.10)
-Requires-Dist: requests (>=2.28.1)
+Requires-Dist: jsonschema >=4.10
+Requires-Dist: requests >=2.28.1
+Requires-Dist: requests-ratelimiter >=0.6.0
 Provides-Extra: dev
-Requires-Dist: flake8 (>=5.0) ; extra == 'dev'
-Requires-Dist: coverage (>=6.3) ; extra == 'dev'
+Requires-Dist: flake8 >=5.0 ; extra == 'dev'
+Requires-Dist: coverage >=6.3 ; extra == 'dev'
 Requires-Dist: pre-commit ; extra == 'dev'
 Requires-Dist: pip-tools ; extra == 'dev'
-Requires-Dist: pytest (>=6.0) ; extra == 'dev'
-Requires-Dist: setuptools (>=61.0.0) ; extra == 'dev'
-Requires-Dist: timor-python ; extra == 'dev'
+Requires-Dist: pytest >=6.0 ; extra == 'dev'
+Requires-Dist: setuptools >=61.0.0 ; extra == 'dev'
+Requires-Dist: timor-python >=1.0.0 ; extra == 'dev'
 Requires-Dist: nb-clean ; extra == 'dev'
 Requires-Dist: nbconvert ; extra == 'dev'
 Requires-Dist: nbformat ; extra == 'dev'
 Provides-Extra: full
 Requires-Dist: cobra-io[dev] ; extra == 'full'
 Requires-Dist: notebook ; extra == 'full'
```

## Comparing `cobra_io-0.0.3.dist-info/RECORD` & `cobra_io-0.0.4.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,22 +1,23 @@
-cobra/__init__.py,sha256=9lJNhtLd2MhM6sKKunP3h7ytz6rzyFMI5uqf9dXwb08,149
+cobra/__init__.py,sha256=PgkNnBIe5Uu_KP9aeRx4e-Ssi7KejlGEK0m8Xpp3nnk,149
 cobra/asset/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cobra/asset/asset.py,sha256=UOlmjLkRkqdUuP4MvDMVMMadYRnEQNpGgsuKnGv6swc,1111
+cobra/asset/asset.py,sha256=ve6tCtWv2ppQFjyOVjoUpu5N4OXMeg2hX6CQb8MpJE8,1134
 cobra/robot/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cobra/robot/robot.py,sha256=pVp8VWgFFx5pcqA1tUhH7VCCh7GllH5dWGclKXzGSqs,5226
+cobra/robot/robot.py,sha256=mBKoeLkDKk2jXoEA_eIgztizRThSEsiZSWD63xIaod4,5248
 cobra/solution/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cobra/solution/solution.py,sha256=nk-Wxn4xI0k_eLRS1K-u8UBXxYMdaFgNnXJK-YuVAeg,9062
+cobra/solution/solution.py,sha256=MGYI_TU1xr_aDsN-EqEproyKi7Y2PuzhE7w3LOPJBJo,9078
 cobra/task/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cobra/task/task.py,sha256=xqcGijDHzx9xUPnHbARzbKIEd3bOGOVeYHelv0SyB2Q,6772
-cobra/user/user.py,sha256=SvGKuMDJ1qJ2d6a8oehVe1wBoZKtF1KDiq3MJc5tZ7c,1222
+cobra/task/task.py,sha256=kz_60BaU1zn_FHwy6RuGP2O5ILQvUapJ96PHW0jgCrQ,6793
+cobra/user/user.py,sha256=44FcLWDWVZlXyse7v6obBcG25V1HIwKISwtirlhdE90,1244
 cobra/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cobra/utils/caches.py,sha256=v-wVaQGmXY69flLxfYaySDJwaZ8Chy9ljQb0MuzLnLk,975
 cobra/utils/cobra.config.sample,sha256=7_xNB0SkKiY6HB-LvQ17-oG4K1s09LTL3u5a4j88e5k,1026
 cobra/utils/configurations.py,sha256=zSGFsc_RTitjRs7vC_hP-wxbxvyPWYBayLbWrHJI-08,1252
 cobra/utils/logging.py,sha256=_zABBV3S4einE7UT19WY4vJ7T7fgOWqKoeM5jznC6dk,3340
+cobra/utils/requests.py,sha256=UA24JeD0Mr9UC9AuWDvbcWh-eBfKwCXn86GBcesAhiI,219
 cobra/utils/urls.py,sha256=JamfmH3UgXgc2e_7o66eTTP-fWS6rNiu-rcf1clTgxo,335
-cobra/utils/utils.py,sha256=LtnJfTMsivp4rDIj71GctsP9BNoQmuPdHYmJYOo79c8,3800
-cobra_io-0.0.3.dist-info/LICENSE,sha256=HkUglOilukiAaKStefgjNm645flvvv1UwNYFj2E1dE4,1064
-cobra_io-0.0.3.dist-info/METADATA,sha256=Y3wNufdLCHxn4tmyOl-VmYxPnd2Bm45CFELoJVkFvR4,4565
-cobra_io-0.0.3.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
-cobra_io-0.0.3.dist-info/top_level.txt,sha256=LeT4BKKqEqFNqc-EGNWRSpdtIvqG4eLt-Qn3Rf1EmG8,6
-cobra_io-0.0.3.dist-info/RECORD,,
+cobra/utils/utils.py,sha256=X3u7U88ar4qiZBygaCoXolAEONA74YcW8ujNUlotHTk,3824
+cobra_io-0.0.4.dist-info/LICENSE,sha256=HkUglOilukiAaKStefgjNm645flvvv1UwNYFj2E1dE4,1064
+cobra_io-0.0.4.dist-info/METADATA,sha256=TvGwjFbighVroq7RWpf2pSWQ8RBxEpeXYQ1f8-lpV4E,4605
+cobra_io-0.0.4.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+cobra_io-0.0.4.dist-info/top_level.txt,sha256=LeT4BKKqEqFNqc-EGNWRSpdtIvqG4eLt-Qn3Rf1EmG8,6
+cobra_io-0.0.4.dist-info/RECORD,,
```

