# Comparing `tmp/bpf4-1.9.0-cp39-cp39-win_amd64.whl.zip` & `tmp/bpf4-1.9.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,21 @@
-Zip file size: 417690 bytes, number of entries: 19
--rw-rw-rw-  2.0 fat      204 b- defN 24-Apr-07 19:28 bpf4/__init__.py
--rw-rw-rw-  2.0 fat    16180 b- defN 24-Apr-07 19:28 bpf4/api.py
--rw-rw-rw-  2.0 fat     1937 b- defN 24-Apr-07 19:28 bpf4/arraytools.py
--rw-rw-rw-  2.0 fat      415 b- defN 24-Apr-07 19:28 bpf4/bench.py
--rw-rw-rw-  2.0 fat      356 b- defN 24-Apr-07 19:28 bpf4/config.py
--rw-rw-rw-  2.0 fat   922624 b- defN 24-Apr-07 19:31 bpf4/core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     9973 b- defN 24-Apr-07 19:28 bpf4/core.pyi
--rw-rw-rw-  2.0 fat   182484 b- defN 24-Apr-07 19:28 bpf4/core.pyx
--rw-rw-rw-  2.0 fat     8380 b- defN 24-Apr-07 19:28 bpf4/csvtools.py
--rw-rw-rw-  2.0 fat     4168 b- defN 24-Apr-07 19:28 bpf4/plot.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-07 19:28 bpf4/py.typed
--rw-rw-rw-  2.0 fat     1334 b- defN 24-Apr-07 19:28 bpf4/pyinterp.py
--rw-rw-rw-  2.0 fat     1466 b- defN 24-Apr-07 19:28 bpf4/tests.py
--rw-rw-rw-  2.0 fat    31458 b- defN 24-Apr-07 19:28 bpf4/util.py
--rw-rw-rw-  2.0 fat       89 b- defN 24-Apr-07 19:28 bpf4/version.py
--rw-rw-rw-  2.0 fat     5354 b- defN 24-Apr-07 19:31 bpf4-1.9.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-07 19:31 bpf4-1.9.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        5 b- defN 24-Apr-07 19:30 bpf4-1.9.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1362 b- defN 24-Apr-07 19:31 bpf4-1.9.0.dist-info/RECORD
-19 files, 1187889 bytes uncompressed, 415546 bytes compressed:  65.0%
+Zip file size: 418281 bytes, number of entries: 19
+-rw-rw-rw-  2.0 fat      204 b- defN 24-Apr-10 12:59 bpf4/__init__.py
+-rw-rw-rw-  2.0 fat    16180 b- defN 24-Apr-10 12:59 bpf4/api.py
+-rw-rw-rw-  2.0 fat     1937 b- defN 24-Apr-10 12:59 bpf4/arraytools.py
+-rw-rw-rw-  2.0 fat      415 b- defN 24-Apr-10 12:59 bpf4/bench.py
+-rw-rw-rw-  2.0 fat      356 b- defN 24-Apr-10 12:59 bpf4/config.py
+-rw-rw-rw-  2.0 fat   922624 b- defN 24-Apr-10 13:04 bpf4/core.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     9973 b- defN 24-Apr-10 12:59 bpf4/core.pyi
+-rw-rw-rw-  2.0 fat   182484 b- defN 24-Apr-10 12:59 bpf4/core.pyx
+-rw-rw-rw-  2.0 fat     8380 b- defN 24-Apr-10 12:59 bpf4/csvtools.py
+-rw-rw-rw-  2.0 fat     4149 b- defN 24-Apr-10 12:59 bpf4/plot.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-10 12:59 bpf4/py.typed
+-rw-rw-rw-  2.0 fat     1334 b- defN 24-Apr-10 12:59 bpf4/pyinterp.py
+-rw-rw-rw-  2.0 fat     1466 b- defN 24-Apr-10 12:59 bpf4/tests.py
+-rw-rw-rw-  2.0 fat    33294 b- defN 24-Apr-10 12:59 bpf4/util.py
+-rw-rw-rw-  2.0 fat       89 b- defN 24-Apr-10 12:59 bpf4/version.py
+-rw-rw-rw-  2.0 fat     5354 b- defN 24-Apr-10 13:04 bpf4-1.9.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-10 13:04 bpf4-1.9.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        5 b- defN 24-Apr-10 13:03 bpf4-1.9.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1362 b- defN 24-Apr-10 13:04 bpf4-1.9.1.dist-info/RECORD
+19 files, 1189706 bytes uncompressed, 416137 bytes compressed:  65.0%
```

## zipnote {}

```diff
@@ -39,20 +39,20 @@
 
 Filename: bpf4/util.py
 Comment: 
 
 Filename: bpf4/version.py
 Comment: 
 
-Filename: bpf4-1.9.0.dist-info/METADATA
+Filename: bpf4-1.9.1.dist-info/METADATA
 Comment: 
 
-Filename: bpf4-1.9.0.dist-info/WHEEL
+Filename: bpf4-1.9.1.dist-info/WHEEL
 Comment: 
 
-Filename: bpf4-1.9.0.dist-info/top_level.txt
+Filename: bpf4-1.9.1.dist-info/top_level.txt
 Comment: 
 
-Filename: bpf4-1.9.0.dist-info/RECORD
+Filename: bpf4-1.9.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## bpf4/plot.py

```diff
@@ -1,20 +1,20 @@
 from __future__ import annotations
 from .config import CONFIG
 import matplotlib.pyplot as plt
 import numpy as np
 
 from typing import TYPE_CHECKING
 if TYPE_CHECKING:
-    from typing import Sequence, Union
+    from typing import Sequence
     from bpf4 import core
 
 
-def plot_coords(xs: Union[list[float], np.ndarray],
-                ys: Union[list[float], np.ndarray],
+def plot_coords(xs: list[float] | np.ndarray,
+                ys: list[float] | np.ndarray,
                 show:bool=None, 
                 kind='line', 
                 axes: plt.Axes = None,
                 figsize:tuple(float, float)=None,
                 **keys
                 ) -> plt.Axes:
     """
```

## bpf4/util.py

```diff
@@ -3,14 +3,15 @@
 """
 from __future__ import annotations
 import operator as _operator
 import os as _os
 import itertools as _itertools
 from functools import reduce
 from typing import Sequence
+from math import isnan, sqrt
 
 import numpy as np
 from scipy.integrate import quad as _quad
 from scipy.optimize import brentq as _brentq
 from . import core
 
 
@@ -765,45 +766,48 @@
         bpf: the bpf 
         rmstime: the time to calculate the rms over
 
     Returns:
         a bpf representing the rms of this bpf at any x coord
     """
     bpf2 = bpf**2
-    from math import sqrt
 
     def func(x):
         return sqrt(bpf2.integrate_between(x, x+rmstime) / rmstime)
     return asbpf(func, bounds=(bpf.x0, bpf.x1))
 
 
-def rmsbpf(samples: np.ndarray, sr:int, dt=0.01, overlap=1) -> core.Sampled:
+def rmsbpf(samples: np.ndarray, sr: int, dt=0.01, overlap=2, smoothen=0.) -> core.BpfInterface:
     """
     Return a bpf representing the rms of the given samples as a function of time
 
     Args:
         samples: the audio samples
         sr: the sample rate
         dt: analysis time period
         overlap: overlap of analysis frames
+        smoothen: if given, the returned bpf is smoothen using the given value as window
 
     Returns:
-        a samples bpf
+        a sampled bpf if not smoothening operation is performed, or a linear
+        bpf if smoothening is required
     """
     s = samples
     period = int(sr * dt + 0.5)
     hopsamps = period // overlap
     dt2 = hopsamps / sr
     numperiods = len(s) // hopsamps
     data = np.empty((numperiods,), dtype=float)
     for i in range(numperiods):
         idx0 = i * hopsamps
         chunk = s[idx0:idx0+period]
-        data[i] = rms(chunk)
-    return bpf4.core.Sampled(data, x0=0, dx=dt2)
+        data[i] = sqrt(np.mean(np.square(chunk)))
+    out = bpf4.core.Sampled(data, x0=0, dx=dt2)
+    if smoothen:
+        out = smoothen(out, window=smoothen)
 
 
 def calculate_projection(x0, x1, p0, p1):
     """
     Calculate a projection needed to map the interval x0:x1 to p0:p1
 
     Returns:
@@ -960,42 +964,57 @@
     return core.blend(b, asbpf(b(maximum(b))), mix)[b.x0:b.x1]
     
     
 def blendwithceil(b, mix=0.5) -> core._BpfBlend:
     return core.blend(b, asbpf(b(maximum(b))), mix)[b.x0:b.x1]
     
 
-def smoothen(b: core.BpfInterface, window:int, N=1000, interpol='linear') -> core.BpfInterface:
+def smoothen(b: core.BpfInterface, window: float, N=1000, interpol='linear') -> core.BpfInterface:
     """
-    Return a linear bpf representing a smooth version of b
+    Return a bpf representing a smooth version of b
 
     Args:
         b: a bpf
         window: the width (in x coords) of the smoothing window
         N: number of points to resample the bpf
-        interpol: the interpolation to use. One of 'linear', 'smooth', 'halfcos'
+        interpol: the interpolation to use. One of 'linear' or 'smooth'
 
     Returns:
         a bpf representing a smoother version of b
+
+    ## Example
+
+    ```python
+    >>> import bpf4 as bpf
+    >>> b = bpf.linear(0, 0, 0.1, 1, 0.2, 10, 0.3, 1, 0.5, 3, 0.8, -2)
+    >>> bsmooth = bpf.util.smoothen(b, window=0.05)
+    >>> axes = b.plot(show=False)
+    >>> bsmooth.plot(axes=axes)
+    ```
+
+    ![](assets/smoothen.png)
+
     """
     dx = min((b.x1 - b.x0) / N, window/7)
     nwin = int(window / dx)
     box = np.ones(nwin)/nwin
-    Y = b[::dx].ys
-    Y2 = np.convolve(Y, box, mode="same")
-    X = np.linspace(b.x0, b.x1, len(Y2))
+    Y0 = b[::dx].ys
+
+    Ypad = np.ones(shape=(nwin,), dtype='float') * Y0[-1]
+    Y = np.concatenate((Y0, Ypad))
+    Ysmooth = np.convolve(Y, box, mode="same")[:len(Y0)]
+    X = np.linspace(b.x0, b.x1, len(Ysmooth))
+
     if interpol == 'linear':
-        return core.Linear(X, Y2)
+        return core.Linear(X, Ysmooth)
     elif interpol == 'smooth':
-        return core.Smooth(X, Y2)
-    elif interpol == 'halfcos':
-        return core.Halfcos(X, Y2)
+        return core.Smooth(X, Ysmooth)
     else:
-        raise ValueError(f"Interpolation {interpol} not supported here. "
-                          "Possible values: linear, smooth, halfcos")
+        raise ValueError(f"Interpolation '{interpol}' not supported here. "
+                          "Possible values: linear, smooth")
 
 
 def zigzag(b0: core.BpfInterface,
            b1: core.BpfInterface,
            xs: Sequence[float],
            shape='linear'
            ) -> core.BpfInterface:
@@ -1063,47 +1082,93 @@
         *b* over a sliding period of *dx*
     """
     dx2 = dx/2
     avg = ((b<<dx2)+b+(b>>dx2))/3.0
     return avg[b.x0:b.x1]
 
 
-def histbpf(b: core.BpfInterface, numbins=10, numsamples=200, interpolation='linear'
-            ) -> core.BpfInterface:
+def histbpf(b: core.BpfInterface, numbins=20, numsamples=400
+            ) -> core.Linear:
     """
     Create a historgram of *b*
 
     Args:
         b: the bpf
         numbins: the number of bins
         numsamples: how many samples to take to determine the histogram
         interpolation: the kind of interpolation of the returned bpf
 
     Returns:
-        a bpf representing the percentile associated with a given value of *b*
-        Percentiles are given between 0 and 1
+        a bpf mapping values to percentiles. The returned bpf can be inverted
+        (see example) to map percentiles to values
 
     Example
     ~~~~~~~
 
     >>> from sndfileio import *
+    >>> import bpf4
     >>> samples, sr = sndread("path/to/soundfile.wav")
-    >>> dbcurve = rmsbpf(samples, sr=sr).amp2db()
-    >>> dbhist = histbpf(dbcurve)
+    >>> dbcurve = bpf4.util.rmsbpf(samples, sr=sr).amp2db()
+    >>> dbval2hist = bpf4.util.histbpf(dbcurve)
     # Find the db percentile at a given time, this gives a measurement of the
     # relative strength of the sound at a given moment
     >>> dur = len(samples)/sr
-    >>> percentile = dbhist(dur*0.5)
-    0.312
+    >>> percentile = dbval2hist(dur*0.5)
+    0.312Z
+    >>> dbhist2val = dbval2hist.inverted()
 
     This indicates that at the middle of the sound the amplitude is at percentile ~30
 
     """
     samples = b.map(numsamples)
     edges, hist = np.histogram(b, bins=numbins)
     percentile = np.linspace(0, 1, len(hist))
     if interpolation == 'linear':
         return core.Linear(hist, percentile)
     elif interpolation == 'nointerpol':
         return core.NoInterpol(hist, percentile)
     else:
         raise ValueError("Only 'linear' or 'nointerpol' are supported")
+
+
+def split_fragments(b: core.BpfBase) -> list[core.BpfBase]:
+    """
+    Split a bpf into its fragments
+
+    A fragmented bpf is one with nan values, dividing the bpf
+    into fragments left and right from nan values. A fragment
+    must at least have two items
+
+    Args:
+        b: the bpf to split.
+
+    Returns:
+        a list of bpfs representing the fragments
+
+    ## Example
+
+    ```python
+
+    >>> a = bpf.linear(0, 0, 1, 10, 2, 5, 3, 30, 4, nan, 5, nan, 6, 0, 7, 1, 8, 0.5, 9, nan, 10, 2, 11, 3)
+    >>> split_fragments(a)
+    [Linear[0.0:3.0], Linear[6.0:8.0], Linear[10.0:11.0]]
+    ```
+    """
+    xs, ys = b.points()
+    parts = []
+    lastpart: list[tuple[float, float]] = None
+    for x, y in zip(xs, ys):
+        if not isnan(y):
+            if lastpart is None:
+                lastpart = []
+                parts.append(lastpart)
+            lastpart.append((x, y))
+        else:
+            lastpart = None
+    cls = b.__class__
+    bpfs = []
+    for part in parts:
+        xs, ys = zip(*part)
+        if len(xs) >= 2:
+            bpfs.append(cls(xs, ys))
+    return bpfs
+
```

## bpf4/version.py

```diff
@@ -1,4 +1,4 @@
-__version__ = (1, 9, 0)
+__version__ = (1, 9, 1)
     
 def versionstr():
     return ("%d.%d.%d" % __version__)
```

## Comparing `bpf4-1.9.0.dist-info/METADATA` & `bpf4-1.9.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: bpf4
-Version: 1.9.0
+Version: 1.9.1
 Summary: Piece-wise interpolation and lazy evaluation in cython
 Home-page: https://github.com/gesellkammer/bpf4
 Download-URL: https://github.com/gesellkammer/bpf4
 Author: eduardo moguillansky
 Author-email: eduardo.moguillansky@gmail.com
 Maintainer: 
 Maintainer-email:
```

## Comparing `bpf4-1.9.0.dist-info/RECORD` & `bpf4-1.9.1.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 bpf4/__init__.py,sha256=liWnrS8_fRGVxLXuwDZjUqWMUMg4ulFPfsJxXyK7LTI,204
 bpf4/api.py,sha256=TIyfkr_9fihI-07dmKAfniRTejjIB9yJU1m6L019Rd4,16180
 bpf4/arraytools.py,sha256=JrqCymk-jR2BEkePTgEsUUu_3sJdjfQ_NdrGiaBjQn4,1937
 bpf4/bench.py,sha256=937QqS6thuWALnhmd7x5-g5WcySFtAtuii1qxW6YdmU,415
 bpf4/config.py,sha256=DUSKtWvWogSDXpVG4fkBaIwQo0qsIaP8Wj1QY2_nNLo,356
-bpf4/core.cp39-win_amd64.pyd,sha256=dkw-jbE6rKdy5m5_NDqM9HLJepU_phg-nGRM1hPjC7Y,922624
+bpf4/core.cp39-win_amd64.pyd,sha256=yStsvh64aQms19fYJ6Fm47H88QBrLlnZdj8fvS3oeFA,922624
 bpf4/core.pyi,sha256=QjouSIva_1SxpGDpHWNG9-kL0wHf9smrIhTsExPzE-g,9973
 bpf4/core.pyx,sha256=DnCeLUNtIaLs_ZcQMRLXPYUddhFQFAnzBzZew9ZO09I,182484
 bpf4/csvtools.py,sha256=tB1WsC1RV-eAk7wObrvWtIVYQ0vYr0ZSPx39Uhcsooo,8380
-bpf4/plot.py,sha256=vgJUvMhW6gpYjt7rY966BqgdgbRFS1LoA2gmxpNxfdw,4168
+bpf4/plot.py,sha256=IuWvbr6VIEtAlrLat8gHzEwv1GEnhInOzPWe3BdEcow,4149
 bpf4/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 bpf4/pyinterp.py,sha256=69l7rEzBKTjhZckHOXxYXb62h7zzLbwiLCIjIlZB_8s,1334
 bpf4/tests.py,sha256=wljYbEmIPzlWuKk222k2kFDdfVSfKBG5DMX7ytuzx8o,1466
-bpf4/util.py,sha256=-CpuV6fUlgQrQ0qF9QwEFhJ_eP8kYgiWWjbLZZJl_-Q,31458
-bpf4/version.py,sha256=CmEXRMLvVOQz2-4tgDfN8h0H_OCCUAMFgLCiwYaV-Ns,89
-bpf4-1.9.0.dist-info/METADATA,sha256=rzXuOODr_9Hjiad1vVawHRl0qWukpEx2YA9cJhZ8WIk,5354
-bpf4-1.9.0.dist-info/WHEEL,sha256=Z6c-bE0pUM47a70GvqO_SvH_XXU0lm62gEAKtoNJ08A,100
-bpf4-1.9.0.dist-info/top_level.txt,sha256=B59MQCcNA0f7BzFnz2Dk2257JgvWLzNNkl7NHrG0lHk,5
-bpf4-1.9.0.dist-info/RECORD,,
+bpf4/util.py,sha256=kc-1Q8Q780DA8QrGXnd_ZZrcIdf-jNZ-zIH05Z0cupI,33294
+bpf4/version.py,sha256=93sVfM_CoHu96hL8XH2Jye7oSk6Szsz60-VsiEGMVlg,89
+bpf4-1.9.1.dist-info/METADATA,sha256=o4ajuoRTQao3meMbjiL7wfUSuswxQC-71JlgCl2aGNo,5354
+bpf4-1.9.1.dist-info/WHEEL,sha256=Z6c-bE0pUM47a70GvqO_SvH_XXU0lm62gEAKtoNJ08A,100
+bpf4-1.9.1.dist-info/top_level.txt,sha256=B59MQCcNA0f7BzFnz2Dk2257JgvWLzNNkl7NHrG0lHk,5
+bpf4-1.9.1.dist-info/RECORD,,
```

