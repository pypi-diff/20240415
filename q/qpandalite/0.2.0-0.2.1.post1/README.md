# Comparing `tmp/qpandalite-0.2.0-cp39-cp39-win_amd64.whl.zip` & `tmp/qpandalite-0.2.1.post1-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,47 +1,47 @@
-Zip file size: 218369 bytes, number of entries: 45
--rw-rw-rw-  2.0 fat   362496 b- defN 23-Dec-26 13:29 QPandaLitePy.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      911 b- defN 24-Jan-06 02:22 qpandalite/__init__.py
+Zip file size: 228345 bytes, number of entries: 45
+-rw-rw-rw-  2.0 fat   385536 b- defN 24-Apr-15 06:25 QPandaLitePy.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     1060 b- defN 24-Mar-29 03:56 qpandalite/__init__.py
 -rw-rw-rw-  2.0 fat      200 b- defN 23-Dec-01 06:51 qpandalite/pybind11_stubgen_QPandaLiteCpp.py
 -rw-rw-rw-  2.0 fat      119 b- defN 23-Sep-25 14:17 qpandalite/analyzer/__init__.py
--rw-rw-rw-  2.0 fat     3323 b- defN 23-Sep-26 07:04 qpandalite/analyzer/expectation.py
--rw-rw-rw-  2.0 fat     5423 b- defN 24-Jan-06 11:56 qpandalite/analyzer/result_adapter.py
+-rw-rw-rw-  2.0 fat     3425 b- defN 24-Mar-29 03:58 qpandalite/analyzer/expectation.py
+-rw-rw-rw-  2.0 fat     5646 b- defN 24-Mar-29 04:00 qpandalite/analyzer/result_adapter.py
 -rw-rw-rw-  2.0 fat       33 b- defN 23-Sep-27 09:26 qpandalite/circuit_builder/__init__.py
 -rw-rw-rw-  2.0 fat     4402 b- defN 23-Sep-27 09:26 qpandalite/circuit_builder/basic_gates.py
 -rw-rw-rw-  2.0 fat    23267 b- defN 24-Jan-06 02:22 qpandalite/circuit_builder/qcircuit.py
 -rw-rw-rw-  2.0 fat      104 b- defN 23-Oct-20 00:54 qpandalite/originir/__init__.py
 -rw-rw-rw-  2.0 fat     9104 b- defN 24-Jan-06 02:22 qpandalite/originir/originir_base_parser.py
 -rw-rw-rw-  2.0 fat    17227 b- defN 24-Jan-06 02:22 qpandalite/originir/originir_line_parser.py
 -rw-rw-rw-  2.0 fat     3966 b- defN 23-Sep-26 09:09 qpandalite/originir/parser.py
 -rw-rw-rw-  2.0 fat       46 b- defN 23-Nov-01 06:43 qpandalite/qasm_origin/__init__.py
 -rw-rw-rw-  2.0 fat     6854 b- defN 23-Nov-01 06:43 qpandalite/qasm_origin/qasm_line_parser.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Aug-31 08:03 qpandalite/qcloud_config/__init__.py
--rw-rw-rw-  2.0 fat      528 b- defN 23-Sep-19 08:12 qpandalite/qcloud_config/ibm_online_config.py
--rw-rw-rw-  2.0 fat     3312 b- defN 24-Jan-06 02:22 qpandalite/qcloud_config/originq_cloud_config.py
--rw-rw-rw-  2.0 fat     4836 b- defN 24-Jan-06 02:22 qpandalite/qcloud_config/originq_online_config.py
--rw-rw-rw-  2.0 fat      534 b- defN 23-Aug-29 05:25 qpandalite/qcloud_config/quafu_online_config.py
--rw-rw-rw-  2.0 fat      469 b- defN 23-Dec-01 07:02 qpandalite/simulator/__init__.py
--rw-rw-rw-  2.0 fat    13549 b- defN 23-Dec-12 05:34 qpandalite/simulator/originir_simulator.py
+-rw-rw-rw-  2.0 fat      602 b- defN 24-Mar-29 03:56 qpandalite/qcloud_config/ibm_online_config.py
+-rw-rw-rw-  2.0 fat     3521 b- defN 24-Mar-29 03:56 qpandalite/qcloud_config/originq_cloud_config.py
+-rw-rw-rw-  2.0 fat     5126 b- defN 24-Mar-29 03:56 qpandalite/qcloud_config/originq_online_config.py
+-rw-rw-rw-  2.0 fat      636 b- defN 24-Mar-29 03:56 qpandalite/qcloud_config/quafu_online_config.py
+-rw-rw-rw-  2.0 fat      526 b- defN 24-Mar-29 03:56 qpandalite/simulator/__init__.py
+-rw-rw-rw-  2.0 fat    14231 b- defN 24-Mar-29 09:13 qpandalite/simulator/originir_simulator.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Aug-29 05:25 qpandalite/task/__init__.py
 -rw-rw-rw-  2.0 fat     3907 b- defN 24-Jan-09 08:41 qpandalite/task/task_utils.py
 -rw-rw-rw-  2.0 fat       19 b- defN 23-Sep-26 07:06 qpandalite/task/dummy/__init__.py
 -rw-rw-rw-  2.0 fat    10844 b- defN 23-Sep-26 10:49 qpandalite/task/dummy/task.py
 -rw-rw-rw-  2.0 fat       19 b- defN 23-Sep-19 08:12 qpandalite/task/ibm/__init__.py
--rw-rw-rw-  2.0 fat    15452 b- defN 23-Nov-01 08:21 qpandalite/task/ibm/task.py
+-rw-rw-rw-  2.0 fat    15657 b- defN 24-Apr-08 08:04 qpandalite/task/ibm/task.py
 -rw-rw-rw-  2.0 fat       19 b- defN 24-Jan-06 02:22 qpandalite/task/origin_qcloud/__init__.py
--rw-rw-rw-  2.0 fat    21952 b- defN 24-Jan-09 09:18 qpandalite/task/origin_qcloud/task.py
+-rw-rw-rw-  2.0 fat    22539 b- defN 24-Mar-29 05:07 qpandalite/task/origin_qcloud/task.py
 -rw-rw-rw-  2.0 fat       19 b- defN 23-Aug-29 05:25 qpandalite/task/originq/__init__.py
--rw-rw-rw-  2.0 fat    25133 b- defN 24-Jan-06 02:22 qpandalite/task/originq/task.py
+-rw-rw-rw-  2.0 fat    23072 b- defN 24-Mar-29 05:07 qpandalite/task/originq/task.py
 -rw-rw-rw-  2.0 fat       19 b- defN 23-Sep-30 11:45 qpandalite/task/originq_dummy/__init__.py
--rw-rw-rw-  2.0 fat    15927 b- defN 24-Jan-09 08:27 qpandalite/task/originq_dummy/task.py
+-rw-rw-rw-  2.0 fat    16105 b- defN 24-Apr-01 08:03 qpandalite/task/originq_dummy/task.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-01 06:30 qpandalite/task/platform_template/__init__.py
 -rw-rw-rw-  2.0 fat     1216 b- defN 23-Dec-01 06:30 qpandalite/task/platform_template/task.py
 -rw-rw-rw-  2.0 fat       19 b- defN 23-Aug-29 05:25 qpandalite/task/quafu/__init__.py
--rw-rw-rw-  2.0 fat    14080 b- defN 24-Jan-06 02:22 qpandalite/task/quafu/task.py
+-rw-rw-rw-  2.0 fat    14284 b- defN 24-Mar-29 05:08 qpandalite/task/quafu/task.py
 -rw-rw-rw-  2.0 fat       36 b- defN 23-Sep-22 13:34 qpandalite/transpiler/__init__.py
 -rw-rw-rw-  2.0 fat     4062 b- defN 23-Sep-22 13:12 qpandalite/transpiler/timeline.py
--rw-rw-rw-  2.0 fat    11524 b- defN 24-Jan-09 09:35 qpandalite-0.2.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9339 b- defN 24-Jan-09 09:35 qpandalite-0.2.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Jan-09 09:35 qpandalite-0.2.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       24 b- defN 24-Jan-09 09:35 qpandalite-0.2.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     4109 b- defN 24-Jan-09 09:35 qpandalite-0.2.0.dist-info/RECORD
-45 files, 598522 bytes uncompressed, 211681 bytes compressed:  64.6%
+-rw-rw-rw-  2.0 fat    11524 b- defN 24-Apr-15 06:25 qpandalite-0.2.1.post1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     9364 b- defN 24-Apr-15 06:25 qpandalite-0.2.1.post1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-15 06:25 qpandalite-0.2.1.post1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       24 b- defN 24-Apr-15 06:25 qpandalite-0.2.1.post1.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     4140 b- defN 24-Apr-15 06:25 qpandalite-0.2.1.post1.dist-info/RECORD
+45 files, 622619 bytes uncompressed, 221597 bytes compressed:  64.4%
```

## zipnote {}

```diff
@@ -114,23 +114,23 @@
 
 Filename: qpandalite/transpiler/__init__.py
 Comment: 
 
 Filename: qpandalite/transpiler/timeline.py
 Comment: 
 
-Filename: qpandalite-0.2.0.dist-info/LICENSE
+Filename: qpandalite-0.2.1.post1.dist-info/LICENSE
 Comment: 
 
-Filename: qpandalite-0.2.0.dist-info/METADATA
+Filename: qpandalite-0.2.1.post1.dist-info/METADATA
 Comment: 
 
-Filename: qpandalite-0.2.0.dist-info/WHEEL
+Filename: qpandalite-0.2.1.post1.dist-info/WHEEL
 Comment: 
 
-Filename: qpandalite-0.2.0.dist-info/top_level.txt
+Filename: qpandalite-0.2.1.post1.dist-info/top_level.txt
 Comment: 
 
-Filename: qpandalite-0.2.0.dist-info/RECORD
+Filename: qpandalite-0.2.1.post1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qpandalite/__init__.py

```diff
@@ -1,7 +1,13 @@
+from pathlib import Path
+import os
+def change_working_directory(new_directory):
+    if new_directory:
+        os.chdir(new_directory)
+        
 from .circuit_builder import Circuit
 from .originir import OriginIR_Parser
 try:
     from .simulator import OriginIR_Simulator
 except:
     # warning has been omitted in the submodule.
     pass
```

## qpandalite/analyzer/expectation.py

```diff
@@ -77,16 +77,19 @@
 if __name__ == '__main__':
     from result_adapter import convert_originq_result
 
     result = {'key': ['001','010','100'], 'value': [10, 20, 9970]}
     kvresult = convert_originq_result(result, 
                                     style='keyvalue', 
                                     prob_or_shots='prob', 
-                                    reverse_key=False)
+                                    reverse_key=False,
+                                    qubit_num=3)
     
     print(calculate_expectation(kvresult, ['IIZ', 'IZI', 'ZII', 'ZZZ']))
     
     listresult = convert_originq_result(result, 
                                     style='list', 
                                     prob_or_shots='prob', 
-                                    reverse_key=False)
+                                    reverse_key=False,
+                                    qubit_num=3)
+
     print(calculate_expectation(listresult, ['IIZ', 'IZI', 'ZII', 'ZZZ']))
```

## qpandalite/analyzer/result_adapter.py

```diff
@@ -7,23 +7,23 @@
 from typing import Dict, Union, List
 
 def convert_originq_result(key_value_result : Union[List[Dict[str,int]],
                                                     Dict[str, int]], 
                            style = 'keyvalue', 
                            prob_or_shots = 'prob',
                            reverse_key = True, 
-                           key_style = 'dec',
+                           key_style = 'bin',
                            qubit_num = None):
     '''OriginQ result general adapter. Return adapted format given by the arguments. 
 
     Args:
         key_value_result (Dict[str, int] or a list of Dict[str, int]): The raw result produced by machine.
         style (str): Accepts "keyvalue" or "list". Defaults to 'keyvalue'.
         prob_or_shots (str): Accepts "prob" or "shots". Defaults to 'prob'.
-        key_style (str): Accepts "bin" (as str) or "dec" (as int). Defaults to 'dec'.
+        key_style (str): Accepts "bin" (as str) or "dec" (as int). Defaults to 'bin'.
         reverse_key (bool, optional): Reverse the key (Change endian). Defaults to True.
 
     Raises:
         ValueError: style is not "keyvalue" or "list"
         ValueError: prob_or_shots is not "prob" or "shots"
 
     Returns:
@@ -31,27 +31,32 @@
     '''
 
     if isinstance(key_value_result, list):
         return [convert_originq_result(result,
                                        style=style,
                                        prob_or_shots=prob_or_shots,
                                        reverse_key=reverse_key,
-                                       key_style=key_style) 
+                                       key_style=key_style,
+                                       qubit_num=qubit_num) 
                                        for result in key_value_result]
 
     keys = deepcopy(key_value_result['key'])
+    # for results which contain binary keys    
     keys = [int(key, base=16) for key in keys]
     
     values = deepcopy(key_value_result['value'])
 
     max_key = max(keys)
     if qubit_num:
         guessed_qubit_num = qubit_num
     else:
-        guessed_qubit_num = math.ceil(math.log2(max_key))
+        guessed_qubit_num = len(bin(max_key)) - 2
+
+    if style == 'list':
+        key_style = 'dec'
 
     if reverse_key:        
         if key_style == 'bin':
             keys = [np.binary_repr(key, guessed_qubit_num)[::-1] for key in keys]
         elif key_style == 'dec':
             keys = [int(np.binary_repr(key, guessed_qubit_num)[::-1], 2) for key in keys]
         else:
@@ -85,17 +90,18 @@
     if not total_shots:
         total_shots = np.sum(list(measured_result.values()))
 
     return {k : measured_result[k] / total_shots for k in measured_result}
 
 def kv2list(kv_result : dict, guessed_qubit_num):
     ret = [0] * (2 ** guessed_qubit_num)
+    # The key style of kv_result needs to be specified.
     for k in kv_result:
         ret[k] = kv_result[k]
-
+        
     return ret
 
 if __name__ == '__main__':
 
     result = {'key': ['0x1','0x2','0x7'], 'value': [10, 20, 9970]}
     print(convert_originq_result(result, 
                                  style='keyvalue', 
@@ -132,8 +138,8 @@
                                  prob_or_shots='shots', 
                                  reverse_key=False))
     
     print(convert_originq_result(result, 
                                  style='list', 
                                  prob_or_shots='shots', 
                                  reverse_key=False))
-    
+
```

## qpandalite/qcloud_config/ibm_online_config.py

```diff
@@ -1,20 +1,23 @@
 import json
 from pathlib import Path
 
-def create_ibm_online_config(default_token = None):    
+def create_ibm_online_config(default_token = None, savepath = None):    
 
     if not default_token:
         raise RuntimeError('You should input your token.')
+    
+    if not savepath:
+        savepath = Path.cwd()
 
     default_online_config = {
         'default_token' : default_token,
     }
 
-    with open(Path.cwd() / 'ibm_online_config.json', 'w') as fp:
+    with open(savepath / 'ibm_online_config.json', 'w') as fp:
         json.dump(default_online_config, fp)
 
 if __name__ == '__main__':
 
     # The originq qpilot login state token
     token = ''
```

## qpandalite/qcloud_config/originq_cloud_config.py

```diff
@@ -3,15 +3,16 @@
 
 
 def create_originq_cloud_config(apitoken=None,
                           submit_url=None,
                           query_url=None,
                           available_qubits=None,
                           available_topology=None,
-                          task_group_size=200):
+                          task_group_size=200,
+                          savepath = None):
     if not apitoken:
         raise RuntimeError('You should input your api key.')
 
     if not submit_url:
         raise RuntimeError('You should input the submitting url (url 1).')
 
     if not query_url:
@@ -21,54 +22,61 @@
         raise RuntimeError('Available qubits must be a list.')
 
     if not isinstance(available_topology, list):
         raise RuntimeError('Available topology must be a list.')
 
     if not isinstance(task_group_size, int):
         raise RuntimeError('Task group size (task_group_size) must be a number.')
+    
+    if not savepath:
+        savepath = Path.cwd()
 
     default_online_config = {
         'apitoken': apitoken,
         'submit_url': submit_url,
         'query_url': query_url,
         'available_qubits': available_qubits,
         'available_topology': available_topology,
         'task_group_size': task_group_size,
     }
 
-    with open(Path.cwd() / 'originq_cloud_config.json', 'w') as fp:
+    with open(savepath / 'originq_cloud_config.json', 'w') as fp:
         json.dump(default_online_config, fp, indent=2)
 
 
 def create_originq_online_cloud_config(apitoken=None,
                                  submit_url=None,
                                  query_url=None,
-                                 task_group_size=200):
+                                 task_group_size=200,
+                                 savepath = None):
     if not apitoken:
         raise RuntimeError('You should input your api key.')
 
     if not submit_url:
         raise RuntimeError('You should input the submitting url (url 1).')
 
     if not query_url:
         raise RuntimeError('You should input the querying url (url 2).')
 
     if not isinstance(task_group_size, int):
         raise RuntimeError('Task group size (task_group_size) must be a number.')
+    
+    if not savepath:
+        savepath = Path.cwd()
 
     default_online_config = {
         'apitoken': apitoken,
         'submit_url': submit_url,
         'query_url': query_url,
         'available_qubits': None,
         'available_topology': None,
         'task_group_size': task_group_size,
     }
 
-    with open(Path.cwd() / 'originq_cloud_config.json', 'w') as fp:
+    with open(savepath / 'originq_cloud_config.json', 'w') as fp:
         json.dump(default_online_config, fp, indent=2)
 
 
 if __name__ == '__main__':
     # The originq qpilot login apitoken
     apitoken = 'TOKEN'
```

## qpandalite/qcloud_config/originq_online_config.py

```diff
@@ -3,15 +3,16 @@
 
 def create_originq_config(login_apitoken = None, 
                           login_url = None,
                           submit_url = None, 
                           query_url = None, 
                           available_qubits = None,
                           available_topology = None,
-                          task_group_size = 200):    
+                          task_group_size = 200,
+                          savepath = None):    
 
     if not login_apitoken:
         raise RuntimeError('You should input your token.')
 
     if not login_url:
         raise RuntimeError('You should input the login url (url 0).')
 
@@ -25,33 +26,37 @@
         raise RuntimeError('Available qubits must be a list.')
 
     if not isinstance(available_topology, list):
         raise RuntimeError('Available topology must be a list.')
 
     if not isinstance(task_group_size, int):
         raise RuntimeError('Task group size (task_group_size) must be a number.')
+    
+    if not savepath:
+        savepath = Path.cwd()
 
     default_online_config = {
         'login_apitoken' : login_apitoken,
         'login_url' : login_url,
         'submit_url' : submit_url,
         'query_url': query_url,
         'available_qubits': available_qubits,
         'available_topology': available_topology,
         'task_group_size': task_group_size,
     }
 
-    with open(Path.cwd() / 'originq_online_config.json', 'w') as fp:
+    with open(savepath / 'originq_online_config.json', 'w') as fp:
         json.dump(default_online_config, fp, indent=2)
 
 def create_originq_online_config(login_apitoken = None, 
                                  login_url = None,
                                  submit_url = None, 
                                  query_url = None, 
-                                 task_group_size = 200):    
+                                 task_group_size = 200,
+                                 savepath = None):    
 
     if not login_apitoken:
         raise RuntimeError('You should input your token.')
 
     if not login_url:
         raise RuntimeError('You should input the login url (url 0).')
 
@@ -59,56 +64,64 @@
         raise RuntimeError('You should input the submitting url (url 1).')
     
     if not query_url:
         raise RuntimeError('You should input the querying url (url 2).')
 
     if not isinstance(task_group_size, int):
         raise RuntimeError('Task group size (task_group_size) must be a number.')
+    
+    if not savepath:
+        savepath = Path.cwd()
 
     default_online_config = {
         'login_apitoken' : login_apitoken,
         'login_url' : login_url,
         'submit_url' : submit_url,
         'query_url': query_url,
         'available_qubits': None,
         'available_topology': None,
         'task_group_size': task_group_size,
     }
 
-    with open(Path.cwd() / 'originq_online_config.json', 'w') as fp:
+    with open(savepath / 'originq_online_config.json', 'w') as fp:
         json.dump(default_online_config, fp, indent=2)
 
 def create_originq_dummy_config(
     available_qubits = None,
     available_topology = None,
-    task_group_size = 200):    
+    task_group_size = 200,
+    savepath = None):    
 
     if not isinstance(available_qubits, list):
         raise RuntimeError('Available qubits must be a list.')
 
     if not isinstance(available_topology, list):
         raise RuntimeError('Available topology must be a list.')
 
     if not isinstance(task_group_size, int):
         raise RuntimeError('Task group size (task_group_size) must be a number.')
+    
+    if not savepath:
+        savepath = Path.cwd()
 
     default_online_config = {
         'login_apitoken' : 'DUMMY',
         'login_url' : 'DUMMY',
         'submit_url' : 'DUMMY',
         'query_url': 'DUMMY',
         'available_qubits': available_qubits,
         'available_topology': available_topology,
         'task_group_size': task_group_size,
     }
 
-    with open(Path.cwd() / 'originq_online_config.json', 'w') as fp:
+    with open(savepath / 'originq_online_config.json', 'w') as fp:
         json.dump(default_online_config, fp, indent=2)
 
 
+
 if __name__ == '__main__':
 
     # The originq qpilot login apitoken
     apitoken = 'TOKEN'
 
     # The url for logging
     login_url = 'LOGIN_URL'
```

## qpandalite/qcloud_config/quafu_online_config.py

```diff
@@ -1,20 +1,24 @@
 import json
 from pathlib import Path
 
-def create_quafu_online_config(default_token = None):    
+def create_quafu_online_config(default_token = None,
+                               savepath = None):    
 
     if not default_token:
         raise RuntimeError('You should input your token here.')
 
+    if not savepath:
+        savepath = Path.cwd()
+
     default_online_config = {
         'default_token' : default_token,
     }
 
-    with open(Path.cwd() / 'quafu_online_config.json', 'w') as fp:
+    with open(savepath / 'quafu_online_config.json', 'w') as fp:
         json.dump(default_online_config, fp)
 
 if __name__ == '__main__':
     
     # The quafu account token
     token = ''
```

## qpandalite/simulator/__init__.py

```diff
@@ -6,8 +6,9 @@
     if TYPE_CHECKING:
         from .QPandaLitePy import *
 except ImportError as e:
     # Note: Without compiling the QPandaLiteCpp, you can also use qpandalite.
     # Only the C++ simulator is disabled.
     warnings.warn('qpandalite is not install with QPandaLiteCpp.')
 
-from .originir_simulator import OriginIR_Simulator
+from .originir_simulator import OriginIR_Simulator
+from .originir_simulator import OriginIR_NoisySimulator
```

## qpandalite/simulator/originir_simulator.py

```diff
@@ -21,14 +21,15 @@
         self.reverse_key = reverse_key
         self.parser = OriginIR_BaseParser()
         
     def _clear(self):
         self.qubit_num = 0
         self.measure_qubit = []
         self.qubit_mapping = dict()
+        self.parser = OriginIR_BaseParser()
         self._make_simulator()
 
     def _make_simulator(self):        
         self.simulator = Simulator()
 
     def simulate_gate(self, operation, qubit, cbit, parameter, is_dagger):
         if operation == 'RX':
@@ -115,15 +116,15 @@
 
         Args:
             originir (str): OriginIR.
             available_qubits (List[int], optional): Available qubits (if need checking). Defaults to None.
             available_topology (list[Tuple[int, int]], optional): Available topology (if need checking). Defaults to None.
 
         Returns:
-            _type_: _description_
+            List[float]: The probability list of output from the ideal simulator
         '''
         # extract the actual used qubit, and build qubit mapping
         # like q45 -> 0, q46 -> 1, etc..
         self._clear()
         self.parser.parse(originir)
         self.extract_actual_used_qubits(self.parser.program_body)
 
@@ -164,25 +165,30 @@
     
     @property
     def state(self):
         return self.simulator.state
 
 
 class OriginIR_NoisySimulator(OriginIR_Simulator):
-    def __init__(self, noise_description, gate_noise_description={}, reverse_key=False):
+    def __init__(self, noise_description, gate_noise_description={}, 
+                 measurement_error=[], reverse_key=False):
         # Initialize noise-related attributes
         self.noise_description = noise_description
         self.gate_noise_description = gate_noise_description
+        self.measurement_error = measurement_error
         # Initialize the superclass with the reverse_key parameter
         super().__init__(reverse_key=reverse_key)
 
     def _make_simulator(self):
         # Overriding the parent class's _make_simulator method
         # to create an instance of NoisySimulator instead of Simulator
-        self.simulator = NoisySimulator(self.qubit_num, self.noise_description, self.gate_noise_description)
+        self.simulator = NoisySimulator(self.qubit_num, 
+                                        self.noise_description, 
+                                        self.gate_noise_description,
+                                        self.measurement_error)
 
     def simulate_gate(self, operation, qubit, cbit, parameter, is_dagger):
         # print(operation, qubit, cbit, parameter, is_dagger)
         if operation == 'RX':
             self.simulator.rx(self.qubit_mapping[int(qubit)], parameter, is_dagger)
         elif operation == 'RY':
             self.simulator.ry(self.qubit_mapping[int(qubit)], parameter, is_dagger)
@@ -228,14 +234,15 @@
             pass
         else:
             raise RuntimeError('Unknown OriginIR operation. '
                                f'Operation: {operation}.')
 
     def simulate(self, 
                  originir, 
+                 shots = 1000,
                  available_qubits : List[int] = None, 
                  available_topology : List[List[int]] = None):
         '''Simulate originir.
         Free mode: let available_qubits = None, then simulate any topology.
         Strict mode: input available_qubits and available_topology, then the originir is automatically checked.
 
         Args:
@@ -275,18 +282,29 @@
                     # i+2 because QINIT CREG are always excluded.
                     raise ValueError('Unsupported topology.\n'
                                      f'Line {i + 2} ({splitted_lines[i + 2]}).')
                     
             self.simulate_gate(operation, qubit, cbit, parameter, dagger_flag)
         
         self.qubit_num = len(self.qubit_mapping)
-        # measure_qubit_cbit = sorted(self.measure_qubit, key = lambda k : k[1], reverse=self.reverse_key)
-        # measure_qubit = []
-        # for qubit in measure_qubit_cbit:
-        #     measure_qubit.append(qubit[0])
-        # prob_list = self.simulator.measure_shots(1024)
-        # return prob_list
+        measure_qubit_cbit = sorted(self.measure_qubit, key = lambda k : k[1], reverse=self.reverse_key)
+        measure_qubit = []
+        for qubit in measure_qubit_cbit:
+            measure_qubit.append(qubit[0])
+        prob_list = self.simulator.measure_shots(measure_qubit, shots)
+        return prob_list
     
+    def measure_shots(self, shots):
+        '''Call this to actually perform simulation
+
+        Args:
+            shots (int): number of shots
+
+        Returns:
+            List[float]: Probability list produced by the noisy simulator.
+        '''
+        return self.simulator.measure_shots(shots)
+
     @property
     def state(self):
         return self.simulator.state
```

## qpandalite/task/ibm/task.py

```diff
@@ -321,15 +321,15 @@
         make_savepath(savepath)
         with open(savepath / 'online_info.txt', 'a') as fp:
             fp.write(json.dumps(ret) + '\n')
 
     return task_id
 
 
-def query_all_task(savepath=None):
+def query_all_tasks(savepath=None):
     if not savepath:
         savepath = Path.cwd() / 'online_info'
 
     online_info = load_all_online_info(savepath)
     task_count = len(online_info)
     finished = 0
 
@@ -339,14 +339,19 @@
             ret = query_by_taskid(taskid).copy()
             write_taskinfo(taskid, taskinfo=ret, savepath=savepath)
             finished += 1
         else:
             finished += 1
     return finished, task_count
 
+def query_all_task(savepath = None):
+    '''Deprecated!! Use query_all_tasks instead
+    '''
+    warnings.warn(DeprecationWarning("Use query_all_tasks instead"))
+    return query_all_tasks(savepath)
 
 if __name__ == '__main__':
     import numpy as np
     from qiskit import QuantumCircuit
     circ = QuantumCircuit(3)
     
     circ.h(0)
```

## qpandalite/task/origin_qcloud/task.py

```diff
@@ -19,29 +19,33 @@
 default_online_config = {
     'apitoken': 'default_api_token',
     'submit_url': 'default_submit_url',
     'query_url': 'default_query_url',
     'task_group_size': 'default_task_group_size'
 }
 
+TASK_STATUS_FAILED = 'failed'
+TASK_STATUS_SUCCESS = 'success'
+TASK_STATUS_RUNNING = 'running'
+
 # Only attempt to read the config file if we're not generating docs
 if os.getenv('SPHINX_DOC_GEN') != '1':
     try:
         with open('originq_cloud_config.json', 'r') as fp:
             default_online_config = json.load(fp)
     except FileNotFoundError as e:
         raise ImportError('Import origin qcloud backend failed.\n'
                           'originq_cloud_config.json is not found. '
                           'It should be always placed at current working directory (cwd).')
     except JSONDecodeError as e:
         raise ImportError('Import origin qcloud  backend failed.\n'
                           'Cannot load json from the originq_cloud_config.json. '
                           'Please check the content.')
     except Exception as e:
-        raise ImportError('Import origin qcloud  failed.\n'
+        raise ImportError('Import origin qcloud failed.\n'
                           'Unknown import error.'
                           '\n===== Original exception ======\n'
                           f'{traceback.format_exc()}')
 
     try:
         default_apitoken = default_online_config['apitoken']
         default_submit_url = default_online_config['submit_url']
@@ -87,34 +91,34 @@
     result_list = recv_dict["obj"]
 
     ret['taskid'] = result_list['taskId']    
 
     task_status = result_list['taskStatus']
     if task_status == '3':
         # successfully finished !
-        ret['status'] = 'success'
+        ret['status'] = TASK_STATUS_SUCCESS
 
         # task_result
         task_result = result_list['taskResult']
         try:
             # task_result is a list of json
             task_result = [json.loads(task_result_json) for task_result_json in task_result]
         except json.decoder.JSONDecodeError as e:
             raise RuntimeError('Error when parsing the response task_result. '
                                f'task_result = {result_list["taskResult"]}')
         
         ret['result'] = task_result
         return ret
     elif task_status == '4':
-        ret['status'] = 'failed'
+        ret['status'] = TASK_STATUS_FAILED
         ret['result'] = {'errcode': result_list['errorDetail'], 'errinfo': result_list['errorMessage']}
 
         return ret
     else:
-        ret['status'] = 'running'
+        ret['status'] = TASK_STATUS_RUNNING
         return ret
 
 
 def query_by_taskid_single(taskid: str, 
                            url=default_query_url, 
                            savepath=Path.cwd() / 'online_info', 
                            **kwargs):
@@ -175,15 +179,16 @@
         text = bz2.decompress(response.content)
     else:
         text = response.text
 
     response_body = json.loads(text)
     taskinfo = parse_response_body(response_body)
     
-    if savepath and (taskinfo['status'] == 'success' or taskinfo['status'] == 'failed'):
+    if savepath and (taskinfo['status'] == TASK_STATUS_SUCCESS or 
+                     taskinfo['status'] == TASK_STATUS_FAILED):
         write_taskinfo(taskid, taskinfo, savepath)
 
     return taskinfo
 
 
 def query_by_taskid(taskid: Union[List[str], str],
                     url=default_query_url,
@@ -208,27 +213,27 @@
             result (when failed): {'errcode': str, 'errinfo': str}
             result (when running): N/A
     '''
     if not taskid: raise ValueError('Task id ??')
 
     if isinstance(taskid, list):
         taskinfo = dict()
-        taskinfo['status'] = 'success'
+        taskinfo['status'] = TASK_STATUS_SUCCESS
         taskinfo['result'] = []
         for taskid_i in taskid:
             taskinfo_i = query_by_taskid_single(taskid_i, url, savepath)
-            if taskinfo_i['status'] == 'failed':
+            if taskinfo_i['status'] == TASK_STATUS_FAILED:
                 # if any task is failed, then this group is failed.
-                taskinfo['status'] = 'failed'
+                taskinfo['status'] = TASK_STATUS_FAILED
                 break
-            elif taskinfo_i['status'] == 'running':
+            elif taskinfo_i['status'] == TASK_STATUS_RUNNING:
                 # if any task is running, then set to running
-                taskinfo['status'] = 'running'
-            if taskinfo_i['status'] == 'success':
-                if taskinfo['status'] == 'success':
+                taskinfo['status'] = TASK_STATUS_RUNNING
+            if taskinfo_i['status'] == TASK_STATUS_SUCCESS:
+                if taskinfo['status'] == TASK_STATUS_SUCCESS:
                     # update if task is successfully finished (so far)
                     taskinfo['result'].extend(taskinfo_i['result'])
 
     elif isinstance(taskid, str):
         taskinfo = query_by_taskid_single(taskid, url, savepath)
     else:
         raise ValueError('Invalid Taskid')
@@ -268,20 +273,20 @@
             now = time.time()
             if now - starttime > timeout:
                 raise TimeoutError(f'Reach the maximum timeout.')
 
             time.sleep(interval)
 
             taskinfo = query_by_taskid(taskid, url, savepath)
-            if taskinfo['status'] == 'running':
+            if taskinfo['status'] == TASK_STATUS_RUNNING:
                 continue
-            if taskinfo['status'] == 'success':
+            if taskinfo['status'] == TASK_STATUS_SUCCESS:
                 result = taskinfo['result']
                 return result
-            if taskinfo['status'] == 'failed':
+            if taskinfo['status'] == TASK_STATUS_FAILED:
                 errorinfo = taskinfo['result']
                 raise RuntimeError(f'Failed to execute, errorinfo = {errorinfo}')
         except Exception as e:
             if retry > 0:
                 retry -= 1
                 warnings.warn(f'Query failed. Retry remains {retry} times.')
             else:
@@ -314,15 +319,15 @@
         shots (int, optional): Number of shots for every circuit. Defaults to 1000.
         circuit_optimize (bool, optional): Automatically optimize and transpile the circuit. Defaults to True.
         measurement_amend (bool, optional): Amend the measurement result using an internal algorithm. Defaults to True.
         auto_mapping (bool, optional): Automatically select the mapping. Defaults to False.
         compile_only (bool, optional): Only compile time sequence data, without really executing it. Defaults to False.
         specified_block (int, optional): The specified block on chip. Defaults to None. (Note: reserved field.)
         url (str, optional): The URL for submitting the task. Defaults to default_submit_url.
-        timeout (float, optional): The timeout for submitting each task
+        timeout (float, optional): The timeout for submitting each task (passed to request.post)
         savepath (str, optional): str. Defaults to Path.cwd()/'online_info'. If None, it will not save the task info.
 
     Raises:
         ValueError: Circuit not input
         RuntimeError: Circuit number exceeds the default_task_group_size
         RuntimeError: Error when submitting the task
 
@@ -500,15 +505,15 @@
         make_savepath(savepath)
         with open(savepath / 'online_info.txt', 'a') as fp:
             fp.write(json.dumps(ret) + '\n')
 
     return taskid
 
 
-def query_all_task(url=default_query_url, savepath=None, **kwargs):
+def query_all_tasks(url=default_query_url, savepath=None, **kwargs):
     '''Query all task info in the savepath. If you only want to query from taskid, then you can use query_by_taskid instead.
 
     Args:
         url (str, optional): The url for querying. Defaults to default_query_url.
         savepath (PathLikeObject(str, pathlib.Path, etc...), optional): The savepath for loading the online info. Defaults to None.
 
     Returns:
@@ -524,33 +529,38 @@
         taskid = task['taskid']
 
         if isinstance(taskid, list):
             status = 'finished'
             for taskid_i in taskid:
                 if not os.path.exists(savepath / '{}.txt'.format(taskid)):
                     taskinfo = query_by_taskid(taskid_i, url)
-                    if taskinfo['status'] == 'success' or taskinfo['status'] == 'failed':
+                    if taskinfo['status'] == TASK_STATUS_SUCCESS or taskinfo['status'] == TASK_STATUS_FAILED:
                         write_taskinfo(taskid_i, taskinfo, savepath)
                     else:
                         status = 'unfinished'
             if status == 'finished':
                 finished += 1
 
         elif isinstance(taskid, str):
             if not os.path.exists(savepath / '{}.txt'.format(taskid)):
                 taskinfo = query_by_taskid(taskid, url)
-                if taskinfo['status'] == 'success' or taskinfo['status'] == 'failed':
+                if taskinfo['status'] == TASK_STATUS_SUCCESS or taskinfo['status'] == TASK_STATUS_FAILED:
                     write_taskinfo(taskid, taskinfo, savepath)
                     finished += 1
             else:
                 finished += 1
         else:
             raise RuntimeError('Invalid Taskid.')
     return finished, task_count
 
+def query_all_task(url=default_query_url, savepath=None, **kwargs):
+    '''Deprecated!! Use query_all_tasks instead
+    '''
+    warnings.warn(DeprecationWarning("Use query_all_tasks instead"))
+    return query_all_tasks(url, savepath, **kwargs)
 
 if __name__ == '__main__':
     result = query_by_taskid_single("55775D4858EF3D2C3813945703243A01")
     print(result)
 #     ir = """QINIT 2
 # CREG 2
 # H q[0]
```

## qpandalite/task/originq/task.py

```diff
@@ -385,71 +385,14 @@
         task_id = response_body['taskId']
     except Exception as e:
         raise RuntimeError(f'Error in submit_task. The response body is corrupted. '
                            f'Response body: {response_body}')
 
     return task_id
 
-# def submit_task_old(
-#     circuit, 
-#     task_name = None, 
-#     tasktype = None, 
-#     chip_id = 72,
-#     shots = 1000,
-#     circuit_optimize = True,
-#     measurement_amend = False,
-#     auto_mapping = False,
-#     specified_block = None,
-#     url = default_submit_url,
-#     savepath = Path.cwd() / 'online_info'
-# ):
-#     ''' !!!! DEPRECATED !!!!
-#     submit a single circuit
-
-#     Note:
-#         Actual implementation is _submit_task_group
-
-#     Note:
-#         If wanting compile_only=True, use submit_task_compile_only()
-
-#     Args:
-#         circuit (str): A quantum circuit to be submitted. 
-#         task_name (str, optional): The name of the task. Defaults to None.
-#         tasktype (int): The tasktype. Defaults to None. (Note: reserved field.)
-#         chip_id (int, optional): The chip id used to identify the quantum chip. Defaults to 72.
-#         shots (int, optional): Number of shots for every circuit. Defaults to 1000.
-#         circuit_optimize (bool, optional): Automatically optimize and transpile the circuit. Defaults to True.
-#         measurement_amend (bool, optional): Amend the measurement result using an internal algorithm. Defaults to True.
-#         auto_mapping (bool, optional): Automatically select the mapping. Defaults to False.
-#         specified_block (int, optional): The specified block on chip. Defaults to None. (Note: reserved field.)
-#         url (str, optional): The URL for submitting the task. Defaults to default_submit_url.
-#         savepath (str, optional): str. Defaults to Path.cwd()/'online_info'. If None, it will not save the task info.
-
-#     Raises:
-#         RuntimeError: Circuit not input
-#         RuntimeError: Error when submitting the task
-
-#     Returns:
-#         int: The taskid of this taskgroup
-#     '''
-
-#     return _submit_task_group(
-#         circuits = [circuit], 
-#         task_name = task_name, 
-#         tasktype = tasktype, 
-#         chip_id = chip_id,
-#         shots = shots,
-#         circuit_optimize = circuit_optimize,
-#         measurement_amend = measurement_amend,
-#         auto_mapping = auto_mapping,
-#         compile_only=False,
-#         specified_block = specified_block,
-#         url = url,
-#         savepath = savepath
-#     )
 
 def submit_task(
     circuit, 
     task_name = None, 
     tasktype = None, 
     chip_id = 72,
     shots = 1000,
@@ -584,15 +527,15 @@
         circuit_optimize = circuit_optimize,
         auto_mapping = auto_mapping,
         compile_only=True,
         url = url,
         savepath = savepath
     )
 
-def query_all_task(url = default_query_url, savepath = None, **kwargs): 
+def query_all_tasks(url = default_query_url, savepath = None, **kwargs): 
     '''Query all task info in the savepath. If you only want to query from taskid, then you can use query_by_taskid instead.
 
     Args:
         url (str, optional): The url for querying. Defaults to default_query_url.
         savepath (PathLikeObject(str, pathlib.Path, etc...), optional): The savepath for loading the online info. Defaults to None.
 
     Returns:
@@ -627,9 +570,15 @@
                     finished += 1
             else:
                 finished += 1
         else:
             raise RuntimeError('Invalid Taskid.')
     return finished, task_count
 
+def query_all_task(url=default_query_url, savepath=None, **kwargs):
+    '''Deprecated!! Use query_all_tasks instead
+    '''
+    warnings.warn(DeprecationWarning("Use query_all_tasks instead"))
+    return query_all_tasks(url, savepath, **kwargs)
+
 if __name__ == '__main__':
     make_savepath()
```

## qpandalite/task/originq_dummy/task.py

```diff
@@ -160,17 +160,15 @@
     return md5.hexdigest()
 
 def _submit_task_group_dummy_impl(
     circuits, 
     task_name,
     shots,
     auto_mapping,
-    savepath,
     **kwargs
-
 ):
     # print("hi")
     if len(circuits) > default_task_group_size:
         # list of circuits
         groups = []
         group = []
         for circuit in circuits:
@@ -182,68 +180,69 @@
             groups.append(group)
 
         # recursively call, and return a list of taskid
         return [_submit_task_group_dummy_impl(group, 
                 '{}_{}'.format(task_name, i), 
                 shots, 
                 auto_mapping,
-                savepath) for i, group in enumerate(groups)]
+                **kwargs) for i, group in enumerate(groups)]
     
     # generate taskid
     taskid = _random_taskid()
     results = []
 
     noise_description = kwargs.get('noise_description', None)
     gate_noise_description = kwargs.get('gate_noise_description', None)
-    measurement_error = kwargs.get('measurement_error', None)
+    measurement_error = kwargs.get('measurement_error', [])
 
     for circuit in circuits:
         # If there is noise_description
         if noise_description:
-            my_sim = OriginIR_NoisySimulator(noise_description, gate_noise_description, measurement_error)
-            my_sim.simulate(circuit)
-            prob_result = my_sim.simulator.measure_shots(shots)
+            my_sim = OriginIR_NoisySimulator(noise_description, gate_noise_description, 
+                                             measurement_error, reverse_key=False)
             
             if auto_mapping:
-                pass
-                # prob_result = simulator.simulate(circuit)
+                prob_result = my_sim.simulate(circuit, shots)
             else:
-                # prob_result = simulator.simulate(circuit, available_qubits=available_qubits, available_topology=available_topology)
-                n_qubits = my_sim.qubit_num
-                key = []
-                value = []
-
-                # get probs from probability list
-                # Note: originq server will directly produce prob list instead of shots list.
-                # print(n_qubits)
-                for i, meas_result in prob_result.items():
-                    # print(i, meas_result)
-                    key.append(bin(i)[2:].zfill(n_qubits))
-                    value.append(meas_result/shots)
-                results.append({'key':key, 'value': value})
+                prob_result = my_sim.simulate(circuit, shots=shots, 
+                                                 available_qubits=available_qubits, 
+                                                 available_topology=available_topology)
+            # n_qubits = my_sim.qubit_num
+            n_qubits = len(my_sim.measure_qubit)    
+            key = []
+            value = []
+
+            # get probs from probability list
+            # Note: originq server will directly produce prob list instead of shots list.
+
+            for i, meas_result in prob_result.items():
+                # print(i, meas_result)
+                key.append(hex(i))
+                value.append(meas_result/shots)
+            results.append({'key':key, 'value': value})
 
         else:
             simulator = sim.OriginIR_Simulator()
 
             if auto_mapping:
                 prob_result = simulator.simulate(circuit)
             else:
                 prob_result = simulator.simulate(circuit, 
                                                 available_qubits=available_qubits,
                                                 available_topology=available_topology)
-                n_qubits = simulator.qubit_num
-                key = []
-                value = []
-
-                # get probs from probability list
-                # Note: originq server will directly produce prob list instead of shots list.
-                for i, meas_result in enumerate(prob_result):
-                    key.append(hex(i))
-                    value.append(meas_result)
-                results.append({'key':key, 'value': value})
+            n_qubits = simulator.qubit_num
+            key = []
+            value = []
+
+            # get probs from probability list
+            # Note: originq server will directly produce prob list instead of shots list.
+            for i, meas_result in enumerate(prob_result):
+                key.append(hex(i))
+                value.append(meas_result)
+            results.append({'key':key, 'value': value})
     
     # write cache, ready for loading results
     _write_dummy_cache(taskid, task_name, results)
     # print(results)
     return taskid
 
 def submit_task(
@@ -270,24 +269,22 @@
                 raise ValueError('Input is not a valid circuit list (a.k.a List[str]).')
 
         taskid = _submit_task_group_dummy_impl(
             circuits = circuit, 
             task_name = task_name, 
             shots = shots,
             auto_mapping = auto_mapping,
-            savepath = savepath,
             **kwargs
         )
     elif isinstance(circuit, str):
         taskid = _submit_task_group_dummy_impl(
             circuits = [circuit], 
             task_name = task_name, 
             shots = shots,
             auto_mapping = auto_mapping,
-            savepath = savepath,
             **kwargs
         )
     else:
         raise ValueError('Input must be a str or List[str], where each str is a valid originir string.')
         
     ret = {'taskid': taskid, 'taskname': task_name}
     if savepath:
@@ -383,15 +380,15 @@
             return result
         if taskinfo['status'] == 'failed':
             errorinfo = taskinfo['result']
             raise RuntimeError(f'Failed to execute, errorinfo = {errorinfo}')
         
         time.sleep(interval)
 
-def query_all_task(savepath = None, 
+def query_all_tasks(savepath = None, 
                    url = None, # dummy parameter
                    ): 
     '''Query all task info in the savepath. If you only want to query from taskid, then you can use query_by_taskid instead.
 
     Args:
         url (str, optional): The url for querying. Defaults to default_query_url.
         savepath (PathLikeObject(str, pathlib.Path, etc...), optional): The savepath for loading the online info. Defaults to None.
@@ -428,9 +425,17 @@
                     finished += 1
             else:
                 finished += 1
         else:
             raise RuntimeError('Invalid Taskid.')
     return finished, task_count
 
+def query_all_task(savepath = None, 
+                   url = None, # dummy parameter
+                   ):
+    '''Deprecated!! Use query_all_tasks instead
+    '''
+    warnings.warn(DeprecationWarning("Use query_all_tasks instead"))
+    return query_all_tasks(savepath, url)
+
 if __name__ == '__main__':
     _random_taskid()
```

## qpandalite/task/quafu/task.py

```diff
@@ -347,15 +347,15 @@
                 retry -= 1
                 print(f'Query failed. Retry remains {retry} times.')
             else:
                 print(f'Retry count exhausted.')
                 raise e
 
 
-def query_all_task(savepath = None):
+def query_all_tasks(savepath = None):
     if not savepath:
         savepath = Path.cwd() / 'quafu_online_info'
     
     online_info = load_all_online_info(savepath)
     for task in online_info:
         taskid = task['taskid']
         if not os.path.exists(savepath / '{}.txt'.format(taskid)):
@@ -364,7 +364,13 @@
                 continue
             elif ret == 'Failed':
                 # write_taskinfo(savepath, taskid, {})
                 write_taskinfo(taskid, taskinfo={}, savepath=savepath)
             else:                
                 # write_taskinfo(savepath, taskid, ret)
                 write_taskinfo(taskid, taskinfo=ret, savepath=savepath)
+
+def query_all_task(savepath = None):
+    '''Deprecated!! Use query_all_tasks instead
+    '''
+    warnings.warn(DeprecationWarning("Use query_all_tasks instead"))
+    return query_all_task(savepath)
```

## Comparing `qpandalite-0.2.0.dist-info/LICENSE` & `qpandalite-0.2.1.post1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `qpandalite-0.2.0.dist-info/METADATA` & `qpandalite-0.2.1.post1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: qpandalite
-Version: 0.2.0
+Version: 0.2.1.post1
 Summary: QPanda-Lite. A python-native version for pyqpanda. Simple, easy, and transparent.
 Author: Agony
 Author-email: chenzhaoyun@iai.ustc.edu.cn
 Project-URL: Source Code, https://github.com/Agony5757/QPanda-Lite.git
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: Developers
@@ -58,15 +58,15 @@
 ### OS
 - Windows 
 - Linux (not fully tested)
 - MacOS (not fully tested)
 
 ### Requirements
  
- - Python >= 3.7
+ - Python >= 3.8
 
 #### Optional for quafu execution
 manually install via pip : 
  - pyquafu (**pip install pyquafu**)
 #### Optional for qiskit execution
 manually install via pip : 
  - qiskit (**pip install qiskit**) and
@@ -154,15 +154,15 @@
 | Function  | Code sample | Explanation | 
 |----------------|--------------|--------------|
 | "Import" the platform | import qpandalite.task.originq as originq  | This importing is independent from "import qpandalite". Available platforms are under qpandalite.task
 | Prepare the account |  | See [qcloud_config_template](qcloud_config_template)
 | Task submission | taskid = originq.submit_task(circuits)| Circuits is str or List[str]. Returned taskid can be either list or one str, depending on the number of inputting circuits. All returns are native python data structures. See [Circuit build](#circuit-build).|
 | Query (synchronously)  |  results = originq.query_by_taskid_sync(taskid) | Inputting the taskid by the return of submit_task. The results are always a list (even if you only submit one circuit). All returns are native python data structures. |
 | Query (asynchronously)  | status_and_result = originq.query_by_taskid(taskid)  | Inputting the taskid by the return of submit_task. This will immediately return without waiting. Use status_and_result['status'] to see if the computing is finished; use status_and_result['result'] to view results (the same with Query (synchronously), always being a list). All returns are native python data structures. |
-| Handle measurement result | results = originq.convert_originq_result(results, style = 'keyvalue', prob_or_shots = 'prob') | Convert the raw data to a more human-friendly format. Style includes "keyvalue" and "list", prob_or_shots includes "prob" and "shots". When inputting a list, the output is also a list corresponding to all inputs. All returns are native python data structures. |
+| Handle measurement result | results = originq.convert_originq_result(results, style = 'keyvalue', prob_or_shots = 'prob', key_style = 'bin') | Convert the raw data to a more human-friendly format. Style includes "keyvalue" and "list", prob_or_shots includes "prob" and "shots". When inputting a list, the output is also a list corresponding to all inputs. All returns are native python data structures. |
 | Calculate expectation | exps = [calculate_expectation(result, ['ZII', 'IZI', 'IIZ']) for result in results] | Calculate the Z/I expectations accroding to the measurement results. Note that it only accepts the diagonal Hamiltonians. The hamiltonians can be a list, where the output is also a list. However, the input "result" cannot be a list.|
 
 ### 2.1 OriginQ
 #### Step 1. Create online config
 
 Refer to [qcloud_config_template/originq_template.py](qcloud_config_template/originq_template.py)
```

## Comparing `qpandalite-0.2.0.dist-info/RECORD` & `qpandalite-0.2.1.post1.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-QPandaLitePy.cp39-win_amd64.pyd,sha256=mjhmwxUIUmGhTW4N1qmLgUqnQyal_mGh6cfecWk6-w8,362496
-qpandalite/__init__.py,sha256=CgaGqB4_NJ-m3UMPcfdrNB6IUpUX3mVbSCR8FA6VS3U,911
+QPandaLitePy.cp39-win_amd64.pyd,sha256=WlU4XelYyT1UHF_GCrSvClmCpgR1ZUuXtp5cnhpxTV0,385536
+qpandalite/__init__.py,sha256=sMc5P1Aaw1uSKL-Go_xQiZ-wFFGbPZyEfz3pNT_LsYA,1060
 qpandalite/pybind11_stubgen_QPandaLiteCpp.py,sha256=t7N4JDYFbAkDo9gL8TpSRmeAnyJIv0FOqG3cPhRajlk,200
 qpandalite/analyzer/__init__.py,sha256=-0nKFs48R6YmeooJJfx_rYhP_ki7Ln9jlgfPKLktZgM,119
-qpandalite/analyzer/expectation.py,sha256=3WZBCkNABdmOepu6ufU5bdigb2rMVvwCKq3YJRhP4EI,3323
-qpandalite/analyzer/result_adapter.py,sha256=6NRbN4Cj7QrbIsvX2asl20BQobjpdhTIE74nZPsRlmc,5423
+qpandalite/analyzer/expectation.py,sha256=isrCZTLwmkiVTEG7rh87b90uZfG84iCWmuJxiOeqoCw,3425
+qpandalite/analyzer/result_adapter.py,sha256=AvrFCwF7_hHwrowJomC3Dvncx2tpN8T6Q8fWndPiiFE,5646
 qpandalite/circuit_builder/__init__.py,sha256=iMBytezAiHoUw7u2RjowPFk2WaPPHgJh3PGRsHIKRAQ,33
 qpandalite/circuit_builder/basic_gates.py,sha256=9kAVxXGJmP5K2h6mHgMESrl3aNnGG5oviOpiQmWXKjg,4402
 qpandalite/circuit_builder/qcircuit.py,sha256=k7e4hRRyrNhWlUy4lE36r0_LnlreEOt_7GlCopgKJqc,23267
 qpandalite/originir/__init__.py,sha256=5DOoJ9--g_NCwl9fnicSFiw5MR71PgQ5_aep3pMuFbc,104
 qpandalite/originir/originir_base_parser.py,sha256=A61z2pj4Etbv-mU5pxzU8PVvPvFvxzHxNEeFioFZn6A,9104
 qpandalite/originir/originir_line_parser.py,sha256=GAIabCTcRS_Qo7FdhaEHNL2KXysV3PkYu9pDj2rtbOs,17227
 qpandalite/originir/parser.py,sha256=63le8j1uWNBBdvpH0t7kVQrkEUNHxhVmcznp_5vh_gk,3966
 qpandalite/qasm_origin/__init__.py,sha256=E5BxL9zJF8u_FMenHfpGf5P7shJWb1hj76A-tZ2jZek,46
 qpandalite/qasm_origin/qasm_line_parser.py,sha256=0o8Y8WjtRFdP2vDf7NRW1hY0drqj3yZFwzFpFgscO3M,6854
 qpandalite/qcloud_config/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-qpandalite/qcloud_config/ibm_online_config.py,sha256=OcYdvYktL-MDQszRimcZVEvq9qbiuCUD_eS3jOll7H8,528
-qpandalite/qcloud_config/originq_cloud_config.py,sha256=cMTY57VDzqbujbsiPD5AjcjuyCHCFuJ4E-SNV2vvAGo,3312
-qpandalite/qcloud_config/originq_online_config.py,sha256=px62hM8_M3vlK0wVFHnoRgow2Vrn81zIlxLze46o-hQ,4836
-qpandalite/qcloud_config/quafu_online_config.py,sha256=QvQZCfdQ1OyLIEtAjrrpCmUzvDvtj3gk68aocMiodrY,534
-qpandalite/simulator/__init__.py,sha256=8egFgIkmelZInoFjBdr6_Z3c0ARx3QxQ5UxzWYWMUA4,469
-qpandalite/simulator/originir_simulator.py,sha256=qTNYGR2RY5DBA3zNF6V-AfsvCbwtQGLfoo2PaIH-nFc,13549
+qpandalite/qcloud_config/ibm_online_config.py,sha256=u3NnbCR3-vO6PdNvtPwUXNSnyyNHr0LJlrfv-IHOMMc,602
+qpandalite/qcloud_config/originq_cloud_config.py,sha256=NvCIkEC1z-n712FsUFsYU8awW3wEPjYWQMkprv_xhoE,3521
+qpandalite/qcloud_config/originq_online_config.py,sha256=NdOirfM_AmBbAEX600DQDb3kUYq7v1_ImjWuXzel3Cs,5126
+qpandalite/qcloud_config/quafu_online_config.py,sha256=bK5mJtXkcFVF1-hGbQnAbPjrm70-WnYFUtB2Z30EMU0,636
+qpandalite/simulator/__init__.py,sha256=oLMXe2R17Y2MnnBvmmm8rV-SoXzkkqROGnnGMUmdi30,526
+qpandalite/simulator/originir_simulator.py,sha256=WFIRBtD16348SOq73gBL-dLoXqqzBlQ8dTgpNMUtnXg,14231
 qpandalite/task/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 qpandalite/task/task_utils.py,sha256=4MOngBVuctuwSpQmM_ae95hvqQJEZEkQc04cuSNG24E,3907
 qpandalite/task/dummy/__init__.py,sha256=eRY_lgNb6bTQHeVrHYNgbTYHhvv2e3OmfBlrcnmidQA,19
 qpandalite/task/dummy/task.py,sha256=iJ2GTh07Rn5lU6HhO6XLYA6aWqbHt3Ib2sOVfZ4shHE,10844
 qpandalite/task/ibm/__init__.py,sha256=eRY_lgNb6bTQHeVrHYNgbTYHhvv2e3OmfBlrcnmidQA,19
-qpandalite/task/ibm/task.py,sha256=6pnxai3QYs0x9A6YXjEcdhtLPnM0PY-MxLOBPG4rw_w,15452
+qpandalite/task/ibm/task.py,sha256=9qZdqtS3FjezCM-tfKjbYZsq_z8KzYJWLAXAGINqMHI,15657
 qpandalite/task/origin_qcloud/__init__.py,sha256=eRY_lgNb6bTQHeVrHYNgbTYHhvv2e3OmfBlrcnmidQA,19
-qpandalite/task/origin_qcloud/task.py,sha256=8Gx_i7pEI7we0WgMupSOpwjpRs3lFjtSmWsnrG1Ixvw,21952
+qpandalite/task/origin_qcloud/task.py,sha256=IvdOdO5QAeJsgDf-eF0fJvGWVt8FJvOBDVWvySBCjuQ,22539
 qpandalite/task/originq/__init__.py,sha256=eRY_lgNb6bTQHeVrHYNgbTYHhvv2e3OmfBlrcnmidQA,19
-qpandalite/task/originq/task.py,sha256=1P7-a-QhTyWh6k3j6waJR2zUZSUJp6Cc5-C0GQMos_8,25133
+qpandalite/task/originq/task.py,sha256=mR0kn9Hv39CFJFixduvf4-jdi0qpHjDpFszjm_2x-0g,23072
 qpandalite/task/originq_dummy/__init__.py,sha256=eRY_lgNb6bTQHeVrHYNgbTYHhvv2e3OmfBlrcnmidQA,19
-qpandalite/task/originq_dummy/task.py,sha256=2eY_hgZe1C38ScH_Tx6WB5K4M5eGYHsPZaWCYJH7TNE,15927
+qpandalite/task/originq_dummy/task.py,sha256=NZpfu7ooL--JJBcjSRlv1LybgnkDu5yyZAXCSZ4LPXQ,16105
 qpandalite/task/platform_template/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 qpandalite/task/platform_template/task.py,sha256=qs3iWoGmjqPc2AzLD6D_Xf0f9tgGrbA8ofGzkCtAyb8,1216
 qpandalite/task/quafu/__init__.py,sha256=eRY_lgNb6bTQHeVrHYNgbTYHhvv2e3OmfBlrcnmidQA,19
-qpandalite/task/quafu/task.py,sha256=RSbi2uUjX0w5i9eZgEtmG8MgdbANzxHqomu6ewJm32U,14080
+qpandalite/task/quafu/task.py,sha256=qb2Vx2Y8tgUjCOuNBLqH5TWzTqazSads-HGiZMLs2_w,14284
 qpandalite/transpiler/__init__.py,sha256=6Rqv3VKYj1Oe_CQippWEG0UG2YqKdrsuU7rZUWxJrkM,36
 qpandalite/transpiler/timeline.py,sha256=8N6PIo4Ap-WwI-pG-cHT5sSmTlJxJb6cRIMrMaysoJo,4062
-qpandalite-0.2.0.dist-info/LICENSE,sha256=F96EzotgWhhpnQTW2TcdoqrMDir1jyEo6H915tGQ-QE,11524
-qpandalite-0.2.0.dist-info/METADATA,sha256=7cuP6sDdIXEWma7JRtcLoWq2I-hI72j_fORppmv8ixA,9339
-qpandalite-0.2.0.dist-info/WHEEL,sha256=J_4V_gB-O6Y7Pn6lk91K27JaIhI-q07YM5J8Ufzqla4,100
-qpandalite-0.2.0.dist-info/top_level.txt,sha256=IP5h0kLHCU0mvuYzQwVPSv0bVUyDZNs2kRkAu_mCqkU,24
-qpandalite-0.2.0.dist-info/RECORD,,
+qpandalite-0.2.1.post1.dist-info/LICENSE,sha256=F96EzotgWhhpnQTW2TcdoqrMDir1jyEo6H915tGQ-QE,11524
+qpandalite-0.2.1.post1.dist-info/METADATA,sha256=3FyUbBRoY3zCUKopicvnL6FTybtZCPtBQImr709Vbdw,9364
+qpandalite-0.2.1.post1.dist-info/WHEEL,sha256=J_4V_gB-O6Y7Pn6lk91K27JaIhI-q07YM5J8Ufzqla4,100
+qpandalite-0.2.1.post1.dist-info/top_level.txt,sha256=IP5h0kLHCU0mvuYzQwVPSv0bVUyDZNs2kRkAu_mCqkU,24
+qpandalite-0.2.1.post1.dist-info/RECORD,,
```

