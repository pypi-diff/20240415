# Comparing `tmp/symbolica-0.3.0.tar.gz` & `tmp/symbolica-0.4.0.tar.gz`

## Comparing `symbolica-0.3.0.tar` & `symbolica-0.4.0.tar`

### file list

```diff
@@ -1,77 +1,83 @@
--rw-r--r--   0        0        0     1881 1970-01-01 00:00:00.000000 symbolica-0.3.0/Cargo.toml
--rw-r--r--   0     1000     1000       19 2023-06-16 10:52:31.000000 symbolica-0.3.0/.gitignore
--rw-r--r--   0     1000     1000    34783 2024-03-18 08:47:55.000000 symbolica-0.3.0/Cargo.lock
--rw-r--r--   0     1000     1000      812 2023-09-07 13:11:55.000000 symbolica-0.3.0/License.md
--rw-r--r--   0     1000     1000     3935 2024-03-18 08:47:41.000000 symbolica-0.3.0/Readme.md
--rw-r--r--   0     1000     1000      422 2024-01-25 12:49:23.000000 symbolica-0.3.0/build.rs
--rw-r--r--   0     1000     1000      383 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/builder.rs
--rw-r--r--   0     1000     1000      770 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/coefficient_ring.rs
--rw-r--r--   0     1000     1000     1083 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/collect.rs
--rw-r--r--   0     1000     1000      432 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/derivative.rs
--rw-r--r--   0     1000     1000     1193 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/evaluate.rs
--rw-r--r--   0     1000     1000      181 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/expansion.rs
--rw-r--r--   0     1000     1000     4556 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/factorization.rs
--rw-r--r--   0     1000     1000     1465 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/fibonacci.rs
--rw-r--r--   0     1000     1000     2539 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/fuel_backend.rs
--rw-r--r--   0     1000     1000     1297 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/groebner_basis.rs
--rw-r--r--   0     1000     1000     1362 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/numerical_integration.rs
--rw-r--r--   0     1000     1000   191552 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/optimize.rs
--rw-r--r--   0     1000     1000   191253 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/optimize_multiple.rs
--rw-r--r--   0     1000     1000     1443 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/partial_fraction.rs
--rw-r--r--   0     1000     1000      675 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/partition.rs
--rw-r--r--   0     1000     1000     1441 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/pattern_match.rs
--rw-r--r--   0     1000     1000     2834 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/pattern_restrictions.rs
--rw-r--r--   0     1000     1000     1625 2024-01-25 12:49:23.000000 symbolica-0.3.0/examples/polynomial.rs
--rw-r--r--   0     1000     1000     2491 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/polynomial_gcd.rs
--rw-r--r--   0     1000     1000      459 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/rational_polynomial.rs
--rw-r--r--   0     1000     1000      764 2024-01-25 12:49:23.000000 symbolica-0.3.0/examples/rational_reconstruction.rs
--rw-r--r--   0     1000     1000      326 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/replace_all.rs
--rw-r--r--   0     1000     1000      807 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/replace_once.rs
--rw-r--r--   0     1000     1000     2733 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/solve_linear_system.rs
--rw-r--r--   0     1000     1000      618 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/streaming.rs
--rw-r--r--   0     1000     1000      295 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/taylor_series.rs
--rw-r--r--   0     1000     1000     1351 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/tree_replace.rs
--rw-r--r--   0     1000     1000      316 2024-03-18 08:47:11.000000 symbolica-0.3.0/examples/tree_walk.rs
--rw-r--r--   0     1000     1000      691 2024-03-18 08:47:11.000000 symbolica-0.3.0/pyproject.toml
--rw-r--r--   0     1000     1000    14884 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/api/cpp.rs
--rw-r--r--   0     1000     1000     7487 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/api/mathematica.rs
--rw-r--r--   0     1000     1000   182824 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/api/python.rs
--rw-r--r--   0     1000     1000      117 2023-09-07 13:11:55.000000 symbolica-0.3.0/src/api.rs
--rw-r--r--   0     1000     1000    34058 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/coefficient.rs
--rw-r--r--   0     1000     1000     9518 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/collect.rs
--rw-r--r--   0     1000     1000     9629 2024-01-25 12:49:23.000000 symbolica-0.3.0/src/combinatorics.rs
--rw-r--r--   0     1000     1000    16599 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/derivative.rs
--rw-r--r--   0     1000     1000    35263 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/factorized_rational_polynomial.rs
--rw-r--r--   0     1000     1000    31863 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/finite_field.rs
--rw-r--r--   0     1000     1000    18572 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/float.rs
--rw-r--r--   0     1000     1000    47703 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/integer.rs
--rw-r--r--   0     1000     1000    15584 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/linear_system.rs
--rw-r--r--   0     1000     1000    26454 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/rational.rs
--rw-r--r--   0     1000     1000    24568 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains/rational_polynomial.rs
--rw-r--r--   0     1000     1000     3086 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/domains.rs
--rw-r--r--   0     1000     1000     5315 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/evaluate.rs
--rw-r--r--   0     1000     1000    10704 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/expand.rs
--rw-r--r--   0     1000     1000    82666 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/id.rs
--rw-r--r--   0     1000     1000    17178 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/lib.rs
--rw-r--r--   0     1000     1000    43723 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/normalize.rs
--rw-r--r--   0     1000     1000    38912 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/numerical_integration.rs
--rw-r--r--   0     1000     1000    44374 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/parser.rs
--rw-r--r--   0     1000     1000    66813 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/poly/evaluate.rs
--rw-r--r--   0     1000     1000   105828 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/poly/factor.rs
--rwxr-xr-x   0     1000     1000    98062 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/poly/gcd.rs
--rw-r--r--   0     1000     1000    31294 2024-01-25 12:49:23.000000 symbolica-0.3.0/src/poly/groebner.rs
--rwxr-xr-x   0     1000     1000   104317 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/poly/polynomial.rs
--rw-r--r--   0     1000     1000    75262 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/poly.rs
--rw-r--r--   0     1000     1000    39250 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/printer.rs
--rw-r--r--   0     1000     1000    15177 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/representations/coefficient.rs
--rw-r--r--   0     1000     1000    34721 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/representations/default.rs
--rw-r--r--   0     1000     1000    27267 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/representations.rs
--rw-r--r--   0     1000     1000     3717 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/solve.rs
--rw-r--r--   0     1000     1000    12014 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/state.rs
--rw-r--r--   0     1000     1000     4534 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/streaming.rs
--rw-r--r--   0     1000     1000    23339 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/tensors/matrix.rs
--rw-r--r--   0     1000     1000       16 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/tensors.rs
--rw-r--r--   0     1000     1000    18032 2024-03-18 08:47:11.000000 symbolica-0.3.0/src/transformer.rs
--rw-r--r--   0     1000     1000      796 2024-01-25 12:49:23.000000 symbolica-0.3.0/src/utils.rs
--rw-r--r--   0     1000     1000    82751 2024-03-18 08:47:11.000000 symbolica-0.3.0/symbolica.pyi
--rw-r--r--   0        0        0     4528 1970-01-01 00:00:00.000000 symbolica-0.3.0/PKG-INFO
+-rw-r--r--   0        0        0     1885 1970-01-01 00:00:00.000000 symbolica-0.4.0/Cargo.toml
+-rw-r--r--   0     1000     1000      747 2024-04-15 13:33:10.000000 symbolica-0.4.0/.github/workflows/coverage.yml
+-rw-r--r--   0     1000     1000     1118 2024-04-15 13:33:10.000000 symbolica-0.4.0/.github/workflows/publish_pypi.yml
+-rw-r--r--   0     1000     1000       19 2023-06-16 10:52:31.000000 symbolica-0.4.0/.gitignore
+-rw-r--r--   0     1000     1000    34783 2024-04-15 13:34:00.000000 symbolica-0.4.0/Cargo.lock
+-rw-r--r--   0     1000     1000      812 2023-09-07 13:11:55.000000 symbolica-0.4.0/License.md
+-rw-r--r--   0     1000     1000     4118 2024-04-15 13:33:47.000000 symbolica-0.4.0/Readme.md
+-rw-r--r--   0     1000     1000      422 2024-01-25 12:49:23.000000 symbolica-0.4.0/build.rs
+-rw-r--r--   0     1000     1000      351 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/builder.rs
+-rw-r--r--   0     1000     1000      730 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/coefficient_ring.rs
+-rw-r--r--   0     1000     1000     1049 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/collect.rs
+-rw-r--r--   0     1000     1000      414 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/derivative.rs
+-rw-r--r--   0     1000     1000     1161 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/evaluate.rs
+-rw-r--r--   0     1000     1000      170 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/expansion.rs
+-rw-r--r--   0     1000     1000     3945 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/factorization.rs
+-rw-r--r--   0     1000     1000     1447 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/fibonacci.rs
+-rw-r--r--   0     1000     1000     2368 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/fuel_backend.rs
+-rw-r--r--   0     1000     1000     1182 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/groebner_basis.rs
+-rw-r--r--   0     1000     1000     1362 2024-03-18 08:47:11.000000 symbolica-0.4.0/examples/numerical_integration.rs
+-rw-r--r--   0     1000     1000   191454 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/optimize.rs
+-rw-r--r--   0     1000     1000   191166 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/optimize_multiple.rs
+-rw-r--r--   0     1000     1000     1329 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/partial_fraction.rs
+-rw-r--r--   0     1000     1000      622 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/partition.rs
+-rw-r--r--   0     1000     1000     1332 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/pattern_match.rs
+-rw-r--r--   0     1000     1000     2795 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/pattern_restrictions.rs
+-rw-r--r--   0     1000     1000     1700 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/polynomial.rs
+-rw-r--r--   0     1000     1000     1180 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/polynomial_gcd.rs
+-rw-r--r--   0     1000     1000      306 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/rational_polynomial.rs
+-rw-r--r--   0     1000     1000      678 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/rational_reconstruction.rs
+-rw-r--r--   0     1000     1000      315 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/replace_all.rs
+-rw-r--r--   0     1000     1000      796 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/replace_once.rs
+-rw-r--r--   0     1000     1000     2402 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/solve_linear_system.rs
+-rw-r--r--   0     1000     1000      607 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/streaming.rs
+-rw-r--r--   0     1000     1000      267 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/taylor_series.rs
+-rw-r--r--   0     1000     1000     1340 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/tree_replace.rs
+-rw-r--r--   0     1000     1000      495 2024-04-15 13:33:10.000000 symbolica-0.4.0/examples/tree_walk.rs
+-rw-r--r--   0     1000     1000    21600 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/api/cpp.rs
+-rw-r--r--   0     1000     1000     7147 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/api/mathematica.rs
+-rw-r--r--   0     1000     1000   187916 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/api/python.rs
+-rw-r--r--   0     1000     1000      117 2023-09-07 13:11:55.000000 symbolica-0.4.0/src/api.rs
+-rw-r--r--   0     1000     1000    15177 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/atom/coefficient.rs
+-rw-r--r--   0     1000     1000    35254 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/atom/representation.rs
+-rw-r--r--   0     1000     1000    28974 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/atom.rs
+-rw-r--r--   0     1000     1000    34916 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/coefficient.rs
+-rw-r--r--   0     1000     1000    16302 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/collect.rs
+-rw-r--r--   0     1000     1000    10821 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/combinatorics.rs
+-rw-r--r--   0     1000     1000    17673 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/derivative.rs
+-rw-r--r--   0     1000     1000     8476 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/algebraic_number.rs
+-rw-r--r--   0     1000     1000    34619 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/factorized_rational_polynomial.rs
+-rw-r--r--   0     1000     1000    31997 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/finite_field.rs
+-rw-r--r--   0     1000     1000    20789 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/float.rs
+-rw-r--r--   0     1000     1000    48186 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/integer.rs
+-rw-r--r--   0     1000     1000    28850 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/rational.rs
+-rw-r--r--   0     1000     1000    45363 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains/rational_polynomial.rs
+-rw-r--r--   0     1000     1000     3134 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/domains.rs
+-rw-r--r--   0     1000     1000     6653 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/evaluate.rs
+-rw-r--r--   0     1000     1000    11394 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/expand.rs
+-rw-r--r--   0     1000     1000    90552 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/id.rs
+-rw-r--r--   0     1000     1000    17826 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/lib.rs
+-rw-r--r--   0     1000     1000    44215 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/normalize.rs
+-rw-r--r--   0     1000     1000    40419 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/numerical_integration.rs
+-rw-r--r--   0     1000     1000    46451 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/parser.rs
+-rw-r--r--   0     1000     1000    71732 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/evaluate.rs
+-rw-r--r--   0     1000     1000   111965 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/factor.rs
+-rwxr-xr-x   0     1000     1000   112076 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/gcd.rs
+-rw-r--r--   0     1000     1000    33344 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/groebner.rs
+-rwxr-xr-x   0     1000     1000   117561 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/polynomial.rs
+-rw-r--r--   0     1000     1000    19317 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/resultant.rs
+-rw-r--r--   0     1000     1000    30216 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly/univariate.rs
+-rw-r--r--   0     1000     1000    61378 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/poly.rs
+-rw-r--r--   0     1000     1000    45304 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/printer.rs
+-rw-r--r--   0     1000     1000     5986 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/solve.rs
+-rw-r--r--   0     1000     1000    14133 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/state.rs
+-rw-r--r--   0     1000     1000     5476 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/streaming.rs
+-rw-r--r--   0     1000     1000    26269 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/tensors/matrix.rs
+-rw-r--r--   0     1000     1000       16 2024-03-18 08:47:11.000000 symbolica-0.4.0/src/tensors.rs
+-rw-r--r--   0     1000     1000    23550 2024-04-15 13:33:10.000000 symbolica-0.4.0/src/transformer.rs
+-rw-r--r--   0     1000     1000      796 2024-01-25 12:49:23.000000 symbolica-0.4.0/src/utils.rs
+-rw-r--r--   0     1000     1000    88323 2024-04-15 13:33:10.000000 symbolica-0.4.0/symbolica.pyi
+-rw-r--r--   0     1000     1000     2298 2024-04-15 13:33:10.000000 symbolica-0.4.0/tests/pattern_matching.rs
+-rw-r--r--   0     1000     1000   418688 2024-04-15 13:33:10.000000 symbolica-0.4.0/tests/rational_polynomial.rs
+-rw-r--r--   0     1000     1000      755 2024-04-15 13:37:31.000000 symbolica-0.4.0/pyproject.toml
+-rw-r--r--   0        0        0     4711 1970-01-01 00:00:00.000000 symbolica-0.4.0/PKG-INFO
```

### Comparing `symbolica-0.3.0/Cargo.toml` & `symbolica-0.4.0/Cargo.toml`

 * *Files 1% similar despite different names*

```diff
@@ -4,17 +4,17 @@
 categories = ["science"]
 description = "A blazing fast computer algebra system"
 edition = "2021"
 keywords = ["algebra", "symbolic", "manipulation", "mathematics", "physics"]
 license-file = "License.md"
 name = "symbolica"
 readme = "Readme.md"
-repository = "https://github/benruijl/symbolica"
+repository = "https://github.com/benruijl/symbolica"
 rust-version = "1.73"
-version = "0.3.0"
+version = "0.4.0"
 
 [profile.release]
 codegen-units = 1
 lto = true
 
 [profile.dev-optim]
 inherits = "dev"
```

### Comparing `symbolica-0.3.0/Cargo.lock` & `symbolica-0.4.0/Cargo.lock`

 * *Files 0% similar despite different names*

```diff
@@ -794,15 +794,15 @@
 name = "static_assertions"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
 
 [[package]]
 name = "symbolica"
-version = "0.3.0"
+version = "0.4.0"
 dependencies = [
  "ahash",
  "append-only-vec",
  "bincode",
  "byteorder",
  "bytes",
  "colored",
```

### Comparing `symbolica-0.3.0/License.md` & `symbolica-0.4.0/License.md`

 * *Files identical despite different names*

### Comparing `symbolica-0.3.0/Readme.md` & `symbolica-0.4.0/Readme.md`

 * *Files 4% similar despite different names*

```diff
@@ -4,14 +4,15 @@
   <br>
 </h1>
 
 <p align="center">
 <a href="https://symbolica.io"><img alt="Symbolica website" src="https://img.shields.io/static/v1?label=symbolica&message=website&color=orange&style=flat-square"></a>
   <a href="https://reform.zulipchat.com"><img alt="Zulip Chat" src="https://img.shields.io/static/v1?label=zulip&message=discussions&color=blue&style=flat-square"></a>
     <a href="https://github.com/benruijl/symbolica"><img alt="Symbolica website" src="https://img.shields.io/static/v1?label=github&message=development&color=green&style=flat-square&logo=github"></a>
+    <a href="https://app.codecov.io/gh/benruijl/symbolica"><img alt="Codecov" src="https://img.shields.io/codecov/c/github/benruijl/symbolica?token=N43MATK5XJ&style=flat-square"></a>
 </p>
 
 # Symbolica
 
 Symbolica is a blazing fast and modern computer algebra system which aims to handle huge expressions. It can easily be incorporated into existing projects using its Python, Rust or C++ bindings.
 Check out the live [Jupyter Notebook demo](https://colab.research.google.com/drive/1VAtND2kddgBwNt1Tjsai8vnbVIbgg-7D?usp=sharing)!
 
@@ -45,15 +46,15 @@
 
 ## Rust
 
 If you want to use Symbolica as a library in Rust, simply include it in the `Cargo.toml`:
 
 ```toml
 [dependencies]
-symbolica = "0.3"
+symbolica = "0.4"
 ```
 
 # Examples
 
 Below we list some examples of the features of Symbolica. Check the [guide](https://symbolica.io/docs/) for a complete overview.
 
 ### Pattern matching
```

#### html2text {}

```diff
@@ -1,11 +1,11 @@
                                     ************
                                     [[llooggoo]]
                                      ************
-              _[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]_[_Z_u_l_i_p_ _C_h_a_t_]_[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]
+          _[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]_[_Z_u_l_i_p_ _C_h_a_t_]_[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]_[_C_o_d_e_c_o_v_]
 # Symbolica Symbolica is a blazing fast and modern computer algebra system
 which aims to handle huge expressions. It can easily be incorporated into
 existing projects using its Python, Rust or C++ bindings. Check out the live
 [Jupyter Notebook demo](https://colab.research.google.com/drive/
 1VAtND2kddgBwNt1Tjsai8vnbVIbgg-7D?usp=sharing)! For documentation and more, see
 [symbolica.io](https://symbolica.io). ## Quick Example Symbolica allows you to
 build and manipulate mathematical expressions through matching and replacing
@@ -14,15 +14,15 @@
 (probably) already know, by using Symbolica's bindings to Python, Rust and C++:
 [A demo of Symbolica]# Installation Visit the [Get Started](https://
 symbolica.io/docs/get_started.html) page for detailed installation
 instructions. ## Python Symbolica can be installed for Python >3.5 using `pip`:
 ```sh pip install symbolica ``` The installation may take some time on Mac OS
 and Windows, as it may have to compile Symbolica. ## Rust If you want to use
 Symbolica as a library in Rust, simply include it in the `Cargo.toml`: ```toml
-[dependencies] symbolica = "0.3" ``` # Examples Below we list some examples of
+[dependencies] symbolica = "0.4" ``` # Examples Below we list some examples of
 the features of Symbolica. Check the [guide](https://symbolica.io/docs/) for a
 complete overview. ### Pattern matching Variables ending with a `_` are
 wildcards that match to any subexpression. In the following example we try to
 match the pattern `f(w1_,w2_)`: ```python from symbolica import Expression x,
 y, w1_, w2_ = Expression.vars('x','y','w1_','w2_') f = Expression.fun('f') e =
 f(3,x)*y**2+5 r = e.replace_all(f(w1_,w2_), f(w1_ - 1, w2_**2)) print(r) ```
 which yields `y^2*f(2,x^2)+5`. ### Solving a linear system Solve a linear
```

### Comparing `symbolica-0.3.0/examples/coefficient_ring.rs` & `symbolica-0.4.0/examples/coefficient_ring.rs`

 * *Files 19% similar despite different names*

```diff
@@ -1,23 +1,22 @@
 use std::sync::Arc;
 
-use symbolica::{representations::Atom, state::State};
+use symbolica::{atom::Atom, state::State};
 
 fn main() {
     let expr = Atom::parse("x*z+x*(y+2)^-1*(y+z+1)").unwrap();
     println!("> In: {}", expr);
 
     let expr_yz = expr.set_coefficient_ring(&Arc::new(vec![
-        State::get_or_insert_var("y").into(),
-        State::get_or_insert_var("z").into(),
+        State::get_symbol("y").into(),
+        State::get_symbol("z").into(),
     ]));
     println!("> Coefficient ring y,z: {}", expr_yz);
 
     // the coefficient must downgrade from y,z to y
-    let expr_y =
-        expr_yz.set_coefficient_ring(&Arc::new(vec![State::get_or_insert_var("y").into()]));
+    let expr_y = expr_yz.set_coefficient_ring(&Arc::new(vec![State::get_symbol("y").into()]));
     println!("> Coefficient ring y: {}", expr_y);
 
     // the coefficient must downgrade from y,z to y
     let expr_exp = expr_y.expand();
     println!("> Coefficient ring y after expansion: {}", expr_exp);
 }
```

### Comparing `symbolica-0.3.0/examples/evaluate.rs` & `symbolica-0.4.0/examples/evaluate.rs`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 use ahash::HashMap;
 use symbolica::evaluate::EvaluationFn;
-use symbolica::{representations::Atom, state::State};
+use symbolica::{atom::Atom, state::State};
 
 fn main() {
-    let x = State::get_or_insert_var("x");
-    let f = State::get_or_insert_var("f");
-    let g = State::get_or_insert_var("g");
+    let x = State::get_symbol("x");
+    let f = State::get_symbol("f");
+    let g = State::get_symbol("g");
     let p0 = Atom::parse("p(0)").unwrap();
     let a = Atom::parse("x*cos(x) + f(x, 1)^2 + g(g(x)) + p(0)").unwrap();
 
     let mut const_map = HashMap::default();
     let mut fn_map: HashMap<_, EvaluationFn<_>> = HashMap::default();
     let mut cache = HashMap::default();
```

### Comparing `symbolica-0.3.0/examples/factorization.rs` & `symbolica-0.4.0/examples/factorization.rs`

 * *Files 17% similar despite different names*

```diff
@@ -1,156 +1,139 @@
 use std::sync::Arc;
 
 use symbolica::{
-    domains::{
-        finite_field::{FiniteField, FiniteFieldCore},
-        integer::IntegerRing,
-    },
+    atom::Atom,
+    domains::{finite_field::Zp, integer::Z},
     poly::{factor::Factorize, polynomial::MultivariatePolynomial, Variable},
-    representations::Atom,
     state::State,
 };
 
 fn factor_ff_univariate() {
     let exp = Atom::parse("x^100-1").unwrap().expand();
 
-    let field = FiniteField::<u32>::new(17);
-    let poly: MultivariatePolynomial<_, u8> = exp.as_view().to_polynomial(&field, None).unwrap();
+    let field = Zp::new(17);
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&field, None);
 
     let factors = poly.square_free_factorization();
 
     println!("Factorization of {}:", poly);
     for (f, pow) in factors {
         println!("\t({})^{}", f, pow);
     }
 }
 
 fn factor_ff_bivariate() {
     let order = Arc::new(vec![
-        Variable::Symbol(State::get_or_insert_var("x")),
-        Variable::Symbol(State::get_or_insert_var("y")),
+        Variable::Symbol(State::get_symbol("x")),
+        Variable::Symbol(State::get_symbol("y")),
     ]);
 
     let input = "((y+1)*x^2+x*y+1)*((y^2+2)*x^2+y+1)";
 
-    let exp = Atom::parse(input).unwrap().as_view().expand();
+    let exp = Atom::parse(input).unwrap().expand();
 
-    let field = FiniteField::<u32>::new(17);
-    let poly: MultivariatePolynomial<FiniteField<u32>, u8> =
-        exp.as_view().to_polynomial(&field, Some(&order)).unwrap();
+    let field = Zp::new(17);
+    let poly: MultivariatePolynomial<Zp, u8> = exp.to_polynomial(&field, Some(order));
 
     println!("Factorization of {}:", poly);
     for (f, pow) in poly.factor() {
         println!("\t({})^{}", f, pow);
     }
 }
 
 fn factor_ff_square_free() {
     let exp = Atom::parse("(1+x)*(1+x^2)^2*(x^4+1)^3").unwrap().expand();
 
-    let field = FiniteField::<u32>::new(3);
-    let poly: MultivariatePolynomial<_, u8> = exp.as_view().to_polynomial(&field, None).unwrap();
+    let field = Zp::new(3);
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&field, None);
 
     let factors = poly.square_free_factorization();
 
     println!("Square-free factorization of {}:", poly);
     for (f, pow) in factors {
         println!("\t({})^{}", f, pow);
     }
 }
 
 fn factor_square_free() {
     let exp = Atom::parse("3*(2*x^2+y)(x^3+y)^2(1+4*y)^2(1+x)")
         .unwrap()
         .expand();
 
-    let poly: MultivariatePolynomial<_, u8> = exp
-        .as_view()
-        .to_polynomial(&IntegerRing::new(), None)
-        .unwrap();
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&Z, None);
 
     let factors = poly.square_free_factorization();
 
     println!("Square-free factorization of {}:", poly);
     for (f, pow) in factors {
         println!("\t({})^{}", f, pow);
     }
 }
 
 fn factor_univariate_1() {
     let exp = Atom::parse("2*(4 + 3*x)*(3 + 2*x + 3*x^2)*(3 + 8*x^2)*(4 + x + x^16)")
         .unwrap()
         .expand();
 
-    let poly: MultivariatePolynomial<_, u8> = exp
-        .as_view()
-        .to_polynomial(&IntegerRing::new(), None)
-        .unwrap();
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&Z, None);
 
     let fs = poly.factor();
 
     println!("Factorization of {}:", poly);
     for (f, _p) in fs {
         println!("\t {}", f);
     }
 }
 
 fn factor_univariate_2() {
     let exp = Atom::parse("(x+1)(x+2)(x+3)^3(x+4)(x+5)(x^2+6)(x^3+7)(x+8)^2(x^4+9)(x^5+x+10)")
         .unwrap()
         .expand();
 
-    let poly: MultivariatePolynomial<_, u8> = exp
-        .as_view()
-        .to_polynomial(&IntegerRing::new(), None)
-        .unwrap();
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&Z, None);
 
     let fs = poly.factor();
 
     println!("Factorization of {}:", poly);
     for (f, p) in fs {
         println!("\t {} {}", f, p);
     }
 }
 
 fn factor_bivariate() {
     let order = Arc::new(vec![
-        Variable::Symbol(State::get_or_insert_var("x")),
-        Variable::Symbol(State::get_or_insert_var("y")),
+        Variable::Symbol(State::get_symbol("x")),
+        Variable::Symbol(State::get_symbol("y")),
     ]);
 
     let input = "(x^2+y+x+1)(3*x+y^2+4)*(6*x*(y+1)+y+5)*(7*x*y+4)";
 
-    let exp = Atom::parse(input).unwrap().as_view().expand();
+    let exp = Atom::parse(input).unwrap().expand();
 
-    let field = IntegerRing::new();
-    let poly: MultivariatePolynomial<_, u8> =
-        exp.as_view().to_polynomial(&field, Some(&order)).unwrap();
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&Z, Some(order));
 
     println!("Factorization of {}:", poly);
     for (f, pow) in poly.factor() {
         println!("\t({})^{}", f, pow);
     }
 }
 
 fn factor_multivariate() {
     let order = Arc::new(vec![
-        Variable::Symbol(State::get_or_insert_var("x")),
-        Variable::Symbol(State::get_or_insert_var("y")),
-        Variable::Symbol(State::get_or_insert_var("z")),
-        Variable::Symbol(State::get_or_insert_var("w")),
+        Variable::Symbol(State::get_symbol("x")),
+        Variable::Symbol(State::get_symbol("y")),
+        Variable::Symbol(State::get_symbol("z")),
+        Variable::Symbol(State::get_symbol("w")),
     ]);
 
     let input = "(x*(2+2*y+2*z)+1)*(x*(4+z^2)+y+3)*(x*(w+w^2+4+y)+w+5)";
 
-    let exp = Atom::parse(input).unwrap().as_view().expand();
+    let exp = Atom::parse(input).unwrap().expand();
 
-    let field = IntegerRing::new();
-    let poly: MultivariatePolynomial<_, u8> =
-        exp.as_view().to_polynomial(&field, Some(&order)).unwrap();
+    let poly: MultivariatePolynomial<_, u8> = exp.to_polynomial(&Z, Some(order));
 
     println!("Factorization of {}:", poly);
     for (f, p) in poly.factor() {
         println!("\t({})^{}", f, p);
     }
 }
```

### Comparing `symbolica-0.3.0/examples/fibonacci.rs` & `symbolica-0.4.0/examples/fibonacci.rs`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 use symbolica::{
+    atom::{Atom, AtomView},
     id::{Match, Pattern, PatternRestriction},
-    representations::{Atom, AtomView},
     state::{RecycledAtom, State},
 };
 
 fn main() {
     // prepare all patterns
     let pattern = Pattern::parse("f(x_)").unwrap();
     let rhs = Pattern::parse("f(x_ - 1) + f(x_ - 2)").unwrap();
     let lhs_zero_pat = Pattern::parse("f(0)").unwrap();
     let lhs_one_pat = Pattern::parse("f(1)").unwrap();
     let rhs_one = Atom::new_num(1).into_pattern();
 
     // prepare the pattern restriction `x_ > 1`
     let restrictions = (
-        State::get_or_insert_var("x_"),
+        State::get_symbol("x_"),
         PatternRestriction::Filter(Box::new(|v: &Match| match v {
             Match::Single(AtomView::Num(n)) => !n.is_one() && !n.is_zero(),
             _ => false,
         })),
     )
         .into();
```

### Comparing `symbolica-0.3.0/examples/fuel_backend.rs` & `symbolica-0.4.0/examples/fuel_backend.rs`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,15 @@
 use std::{
     io::{self, BufRead, Write},
     sync::Arc,
 };
 
 use smartstring::{LazyCompact, SmartString};
 use symbolica::{
-    domains::{
-        integer::IntegerRing, rational::RationalField, rational_polynomial::RationalPolynomial,
-    },
+    domains::{integer::Z, rational::Q, rational_polynomial::RationalPolynomial},
     parser::Token,
     printer::{PrintOptions, RationalPolynomialPrinter},
     state::State,
 };
 
 fn main() {
     let mut buffer = String::with_capacity(2048);
@@ -37,22 +35,22 @@
                 .into(),
         );
     }
 
     let vars: Arc<Vec<_>> = Arc::new(
         var_names
             .iter()
-            .map(|v| State::get_or_insert_var(v).into())
+            .map(|v| State::get_symbol(v).into())
             .collect(),
     );
 
     let print_opt = PrintOptions {
         terms_on_new_line: false,
         color_top_level_sum: false,
-        color_builtin_functions: false,
+        color_builtin_symbols: false,
         print_finite_field: false,
         symmetric_representation_for_finite_field: false,
         explicit_rational_polynomial: false,
         number_thousands_separator: None,
         multiplication_operator: '*',
         square_brackets_for_function: false,
         num_exp_as_superscript: false,
@@ -61,22 +59,17 @@
 
     buffer.clear();
     while let Ok(n) = stdin.read_line(&mut buffer) {
         if n == 0 || buffer.starts_with('\n') || buffer.starts_with("&q") {
             break;
         }
 
-        let r: RationalPolynomial<IntegerRing, u16> = Token::parse(&buffer)
+        let r: RationalPolynomial<_, u16> = Token::parse(&buffer)
             .unwrap()
-            .to_rational_polynomial(
-                &RationalField::new(),
-                &IntegerRing::new(),
-                &vars,
-                &var_names,
-            )
+            .to_rational_polynomial(&Q, &Z, &vars, &var_names)
             .unwrap();
 
         let out_str = format!(
             "{}",
             RationalPolynomialPrinter {
                 poly: &r,
                 opts: print_opt,
```

### Comparing `symbolica-0.3.0/examples/groebner_basis.rs` & `symbolica-0.4.0/examples/groebner_basis.rs`

 * *Files 8% similar despite different names*

```diff
@@ -1,34 +1,32 @@
 use symbolica::{
-    domains::finite_field::{FiniteField, FiniteFieldCore},
+    atom::Atom,
+    domains::finite_field::Zp,
     poly::{groebner::GroebnerBasis, polynomial::MultivariatePolynomial, GrevLexOrder},
-    representations::Atom,
     state::State,
 };
 
 fn main() {
     for x in 'a'..='z' {
-        State::get_or_insert_var(x.to_string());
+        State::get_symbol(x.to_string());
     }
 
     // cyclic-4
     let polys = [
         "a b c d - 1",
         "a b c + a b d + a c d + b c d",
         "a b + b c + a d + c d",
         "a + b + c + d",
     ];
 
     let ideal: Vec<MultivariatePolynomial<_, u16>> = polys
         .iter()
         .map(|x| {
             let a = Atom::parse(x).unwrap().expand();
-            a.as_view()
-                .to_polynomial(&FiniteField::<u32>::new(13), None)
-                .unwrap()
+            a.to_polynomial(&Zp::new(13), None)
         })
         .collect();
 
     // compute the Groebner basis with lex ordering
     let gb = GroebnerBasis::new(&ideal, true);
 
     println!("Lex order basis:");
```

### Comparing `symbolica-0.3.0/examples/numerical_integration.rs` & `symbolica-0.4.0/examples/numerical_integration.rs`

 * *Files identical despite different names*

### Comparing `symbolica-0.3.0/examples/optimize.rs` & `symbolica-0.4.0/examples/optimize.rs`

 * *Files 0% similar despite different names*

```diff
@@ -1,28 +1,24 @@
 use symbolica::{
-    domains::rational::RationalField,
+    atom::Atom,
+    domains::rational::Q,
     poly::evaluate::{BorrowedHornerScheme, InstructionSetPrinter},
-    representations::Atom,
 };
 
 use symbolica::poly::polynomial::MultivariatePolynomial;
 use wide::f64x4;
 
 // a large test polynomial
 const SIGMA: &str = "+32*amel2^3*zk^2*xcp3 +32*amel2^3*zk^2*xcp1 -48*amel2^3*zk^2*x1*xcp3 -48*amel2^3*zk^2*x1*xcp1 +32*amel2^4*x5^2*xcp3 +32*amel2^4*x5^2*xcp1 +64*amel2^4*x4*x5*xcp3 -128*amel2^4*x4*x5*xcp2 +64*amel2^4*x4*x5*xcp1 +64*amel2^4*x4^2*xcp3 -128*amel2^4*x4^2*xcp2 +64*amel2^4*x4^2*xcp1 -128*amel2^4*x3*x5*xcp2 +64*amel2^4*x3*x4*xcp3 -128*amel2^4*x3*x4*xcp2 +64*amel2^4*x3*x4*xcp1 +32*amel2^4*x3^2*xcp3 +32*amel2^4*x3^2*xcp1 -64*amel2^4*x1*xcp3 -64*amel2^4*x1*xcp1 +32*amel2^4*x1*x5*xcp3 +32*amel2^4*x1*x5*xcp1 -32*amel2^4*x1*x5^2*xcp3 -32*amel2^4*x1*x5^2*xcp1 +64*amel2^4*x1*x4*xcp3 -192*amel2^4*x1*x4*xcp2 +64*amel2^4*x1*x4*xcp1 -64*amel2^4*x1*x4*x5*xcp3 +128*amel2^4*x1*x4*x5*xcp2 -64*amel2^4*x1*x4*x5*xcp1 -64*amel2^4*x1*x4^2*xcp3 +128*amel2^4*x1*x4^2*xcp2 -64*amel2^4*x1*x4^2*xcp1 +96*amel2^4*x1*x3*xcp3 -192*amel2^4*x1*x3*xcp2 +96*amel2^4*x1*x3*xcp1 +128*amel2^4*x1*x3*x5*xcp2 -64*amel2^4*x1*x3*x4*xcp3 +128*amel2^4*x1*x3*x4*xcp2 -64*amel2^4*x1*x3*x4*xcp1 -32*amel2^4*x1*x3^2*xcp3 -32*amel2^4*x1*x3^2*xcp1 +64*amel2^4*x1^2*xcp3 +64*amel2^4*x1^2*xcp1 -64*amel2^4*x1^2*x5*xcp3 -64*amel2^4*x1^2*x5*xcp1 -64*amel2^4*x1^2*x4*xcp3 -64*amel2^4*x1^2*x4*xcp1 -64*amel2^4*x1^2*x3*xcp3 -64*amel2^4*x1^2*x3*xcp1 -32*amel2^4*x1^3*xcp3 -32*amel2^4*x1^3*xcp1 +48*e2e1*amel2^2*zk^2*xcp3 +32*e2e1*amel2^2*zk^2*xcp2 +48*e2e1*amel2^2*zk^2*xcp1 -48*e2e1*amel2^2*zk^2*x5*xcp3 +64*e2e1*amel2^2*zk^2*x5*xcp2 -48*e2e1*amel2^2*zk^2*x5*xcp1 -96*e2e1*amel2^2*zk^2*x4*xcp3 -96*e2e1*amel2^2*zk^2*x4*xcp1 -64*e2e1*amel2^2*zk^2*x3*xcp2 -48*e2e1*amel2^2*zk^2*x1*xcp3 -48*e2e1*amel2^2*zk^2*x1*xcp1 +256*e2e1*amel2^3*x5*xcp2 +32*e2e1*amel2^3*x5^2*xcp3 -128*e2e1*amel2^3*x5^2*xcp2 +32*e2e1*amel2^3*x5^2*xcp1 -32*e2e1*amel2^3*x5^3*xcp3 -32*e2e1*amel2^3*x5^3*xcp1 -64*e2e1*amel2^3*x4*xcp3 +256*e2e1*amel2^3*x4*xcp2 -64*e2e1*amel2^3*x4*xcp1 +128*e2e1*amel2^3*x4*x5*xcp3 -448*e2e1*amel2^3*x4*x5*xcp2 +128*e2e1*amel2^3*x4*x5*xcp1 -128*e2e1*amel2^3*x4*x5^2*xcp3 +64*e2e1*amel2^3*x4*x5^2*xcp2 -128*e2e1*amel2^3*x4*x5^2*xcp1 +192*e2e1*amel2^3*x4^2*xcp3 -384*e2e1*amel2^3*x4^2*xcp2 +192*e2e1*amel2^3*x4^2*xcp1 -192*e2e1*amel2^3*x4^2*x5*xcp3 +256*e2e1*amel2^3*x4^2*x5*xcp2 -192*e2e1*amel2^3*x4^2*x5*xcp1 -128*e2e1*amel2^3*x4^3*xcp3 +128*e2e1*amel2^3*x4^3*xcp2 -128*e2e1*amel2^3*x4^3*xcp1 +64*e2e1*amel2^3*x3*xcp3 +64*e2e1*amel2^3*x3*xcp1 -448*e2e1*amel2^3*x3*x5*xcp2 +64*e2e1*amel2^3*x3*x5^2*xcp2 +192*e2e1*amel2^3*x3*x4*xcp3 -576*e2e1*amel2^3*x3*x4*xcp2 +192*e2e1*amel2^3*x3*x4*xcp1 -64*e2e1*amel2^3*x3*x4*x5*xcp3 +384*e2e1*amel2^3*x3*x4*x5*xcp2 -64*e2e1*amel2^3*x3*x4*x5*xcp1 -128*e2e1*amel2^3*x3*x4^2*xcp3 +128*e2e1*amel2^3*x3*x4^2*xcp2 -128*e2e1*amel2^3*x3*x4^2*xcp1 +32*e2e1*amel2^3*x3^2*xcp3 -64*e2e1*amel2^3*x3^2*xcp2 +32*e2e1*amel2^3*x3^2*xcp1 -32*e2e1*amel2^3*x3^2*x5*xcp3 +128*e2e1*amel2^3*x3^2*x5*xcp2 -32*e2e1*amel2^3*x3^2*x5*xcp1 -64*e2e1*amel2^3*x3^2*x4*xcp3 -64*e2e1*amel2^3*x3^2*x4*xcp2 -64*e2e1*amel2^3*x3^2*x4*xcp1 -64*e2e1*amel2^3*x3^3*xcp2 -64*e2e1*amel2^3*x1*xcp3 +128*e2e1*amel2^3*x1*xcp2 -64*e2e1*amel2^3*x1*xcp1 +32*e2e1*amel2^3*x1*x5*xcp3 -448*e2e1*amel2^3*x1*x5*xcp2 +32*e2e1*amel2^3*x1*x5*xcp1 -96*e2e1*amel2^3*x1*x5^2*xcp3 +256*e2e1*amel2^3*x1*x5^2*xcp2 -96*e2e1*amel2^3*x1*x5^2*xcp1 +192*e2e1*amel2^3*x1*x4*xcp3 -768*e2e1*amel2^3*x1*x4*xcp2 +192*e2e1*amel2^3*x1*x4*xcp1 -320*e2e1*amel2^3*x1*x4*x5*xcp3 +768*e2e1*amel2^3*x1*x4*x5*xcp2 -320*e2e1*amel2^3*x1*x4*x5*xcp1 -256*e2e1*amel2^3*x1*x4^2*xcp3 +512*e2e1*amel2^3*x1*x4^2*xcp2 -256*e2e1*amel2^3*x1*x4^2*xcp1 +160*e2e1*amel2^3*x1*x3*xcp3 -448*e2e1*amel2^3*x1*x3*xcp2 +160*e2e1*amel2^3*x1*x3*xcp1 -64*e2e1*amel2^3*x1*x3*x5*xcp3 +512*e2e1*amel2^3*x1*x3*x5*xcp2 -64*e2e1*amel2^3*x1*x3*x5*xcp1 -256*e2e1*amel2^3*x1*x3*x4*xcp3 +512*e2e1*amel2^3*x1*x3*x4*xcp2 -256*e2e1*amel2^3*x1*x3*x4*xcp1 -32*e2e1*amel2^3*x1*x3^2*xcp3 -32*e2e1*amel2^3*x1*x3^2*xcp1 +128*e2e1*amel2^3*x1^2*xcp3 -64*e2e1*amel2^3*x1^2*xcp2 +128*e2e1*amel2^3*x1^2*xcp1 -96*e2e1*amel2^3*x1^2*x5*xcp3 +128*e2e1*amel2^3*x1^2*x5*xcp2 -96*e2e1*amel2^3*x1^2*x5*xcp1 -192*e2e1*amel2^3*x1^2*x4*xcp3 +64*e2e1*amel2^3*x1^2*x4*xcp2 -192*e2e1*amel2^3*x1^2*x4*xcp1 -128*e2e1*amel2^3*x1^2*x3*xcp3 -64*e2e1*amel2^3*x1^2*x3*xcp2 -128*e2e1*amel2^3*x1^2*x3*xcp1 -32*e2e1*amel2^3*x1^3*xcp3 -32*e2e1*amel2^3*x1^3*xcp1 +96*e2e1^2*amel2*zk^2*xcp2 -48*e2e1^2*amel2*zk^2*x5*xcp3 -32*e2e1^2*amel2*zk^2*x5*xcp2 -48*e2e1^2*amel2*zk^2*x5*xcp1 -96*e2e1^2*amel2*zk^2*x4*xcp3 -32*e2e1^2*amel2*zk^2*x4*xcp2 -96*e2e1^2*amel2*zk^2*x4*xcp1 -96*e2e1^2*amel2*zk^2*x3*xcp3 +32*e2e1^2*amel2*zk^2*x3*xcp2 -96*e2e1^2*amel2*zk^2*x3*xcp1 -96*e2e1^2*amel2*zk^2*x1*xcp2 +384*e2e1^2*amel2^2*x5*xcp2 +128*e2e1^2*amel2^2*x5^2*xcp2 -32*e2e1^2*amel2^2*x5^3*xcp3 -192*e2e1^2*amel2^2*x5^3*xcp2 -32*e2e1^2*amel2^2*x5^3*xcp1 -64*e2e1^2*amel2^2*x4*xcp3 +512*e2e1^2*amel2^2*x4*xcp2 -64*e2e1^2*amel2^2*x4*xcp1 +64*e2e1^2*amel2^2*x4*x5*xcp3 -256*e2e1^2*amel2^2*x4*x5*xcp2 +64*e2e1^2*amel2^2*x4*x5*xcp1 -192*e2e1^2*amel2^2*x4*x5^2*xcp3 -192*e2e1^2*amel2^2*x4*x5^2*xcp2 -192*e2e1^2*amel2^2*x4*x5^2*xcp1 +128*e2e1^2*amel2^2*x4^2*xcp3 -384*e2e1^2*amel2^2*x4^2*xcp2 +128*e2e1^2*amel2^2*x4^2*xcp1 -384*e2e1^2*amel2^2*x4^2*x5*xcp3 +256*e2e1^2*amel2^2*x4^2*x5*xcp2 -384*e2e1^2*amel2^2*x4^2*x5*xcp1 -256*e2e1^2*amel2^2*x4^3*xcp3 +256*e2e1^2*amel2^2*x4^3*xcp2 -256*e2e1^2*amel2^2*x4^3*xcp1 +64*e2e1^2*amel2^2*x3*xcp3 +128*e2e1^2*amel2^2*x3*xcp2 +64*e2e1^2*amel2^2*x3*xcp1 -64*e2e1^2*amel2^2*x3*x5*xcp3 -640*e2e1^2*amel2^2*x3*x5*xcp2 -64*e2e1^2*amel2^2*x3*x5*xcp1 -64*e2e1^2*amel2^2*x3*x5^2*xcp3 +64*e2e1^2*amel2^2*x3*x5^2*xcp2 -64*e2e1^2*amel2^2*x3*x5^2*xcp1 +64*e2e1^2*amel2^2*x3*x4*xcp3 -896*e2e1^2*amel2^2*x3*x4*xcp2 +64*e2e1^2*amel2^2*x3*x4*xcp1 -256*e2e1^2*amel2^2*x3*x4*x5*xcp3 +768*e2e1^2*amel2^2*x3*x4*x5*xcp2 -256*e2e1^2*amel2^2*x3*x4*x5*xcp1 -384*e2e1^2*amel2^2*x3*x4^2*xcp3 +640*e2e1^2*amel2^2*x3*x4^2*xcp2 -384*e2e1^2*amel2^2*x3*x4^2*xcp1 -256*e2e1^2*amel2^2*x3^2*xcp2 -32*e2e1^2*amel2^2*x3^2*x5*xcp3 +320*e2e1^2*amel2^2*x3^2*x5*xcp2 -32*e2e1^2*amel2^2*x3^2*x5*xcp1 -192*e2e1^2*amel2^2*x3^2*x4*xcp3 +320*e2e1^2*amel2^2*x3^2*x4*xcp2 -192*e2e1^2*amel2^2*x3^2*x4*xcp1 -64*e2e1^2*amel2^2*x3^3*xcp3 +64*e2e1^2*amel2^2*x3^3*xcp2 -64*e2e1^2*amel2^2*x3^3*xcp1 +64*e2e1^2*amel2^2*x1*xcp3 +256*e2e1^2*amel2^2*x1*xcp2 +64*e2e1^2*amel2^2*x1*xcp1 -32*e2e1^2*amel2^2*x1*x5*xcp3 -640*e2e1^2*amel2^2*x1*x5*xcp2 -32*e2e1^2*amel2^2*x1*x5*xcp1 -64*e2e1^2*amel2^2*x1*x5^2*xcp3 +320*e2e1^2*amel2^2*x1*x5^2*xcp2 -64*e2e1^2*amel2^2*x1*x5^2*xcp1 +192*e2e1^2*amel2^2*x1*x4*xcp3 -832*e2e1^2*amel2^2*x1*x4*xcp2 +192*e2e1^2*amel2^2*x1*x4*xcp1 -320*e2e1^2*amel2^2*x1*x4*x5*xcp3 +1024*e2e1^2*amel2^2*x1*x4*x5*xcp2 -320*e2e1^2*amel2^2*x1*x4*x5*xcp1 -320*e2e1^2*amel2^2*x1*x4^2*xcp3 +512*e2e1^2*amel2^2*x1*x4^2*xcp2 -320*e2e1^2*amel2^2*x1*x4^2*xcp1 +32*e2e1^2*amel2^2*x1*x3*xcp3 -576*e2e1^2*amel2^2*x1*x3*xcp2 +32*e2e1^2*amel2^2*x1*x3*xcp1 -256*e2e1^2*amel2^2*x1*x3*x5*xcp3 +896*e2e1^2*amel2^2*x1*x3*x5*xcp2 -256*e2e1^2*amel2^2*x1*x3*x5*xcp1 -448*e2e1^2*amel2^2*x1*x3*x4*xcp3 +768*e2e1^2*amel2^2*x1*x3*x4*xcp2 -448*e2e1^2*amel2^2*x1*x3*x4*xcp1 -128*e2e1^2*amel2^2*x1*x3^2*xcp3 +192*e2e1^2*amel2^2*x1*x3^2*xcp2 -128*e2e1^2*amel2^2*x1*x3^2*xcp1 +32*e2e1^2*amel2^2*x1^2*xcp3 +32*e2e1^2*amel2^2*x1^2*xcp1 -32*e2e1^2*amel2^2*x1^2*x5*xcp3 +64*e2e1^2*amel2^2*x1^2*x5*xcp2 -32*e2e1^2*amel2^2*x1^2*x5*xcp1 -128*e2e1^2*amel2^2*x1^2*x4*xcp3 +64*e2e1^2*amel2^2*x1^2*x4*xcp2 -128*e2e1^2*amel2^2*x1^2*x4*xcp1 -128*e2e1^2*amel2^2*x1^2*x3*xcp3 -64*e2e1^2*amel2^2*x1^2*x3*xcp2 -128*e2e1^2*amel2^2*x1^2*x3*xcp1 -64*e2e1^2*amel2^2*x1^3*xcp2 -32*e2e1^3*zk^2*xcp2 -32*e2e1^3*zk^2*x4*xcp2 +32*e2e1^3*zk^2*x3*xcp2 -64*e2e1^3*amel2*x5*xcp3 +128*e2e1^3*amel2*x5*xcp2 -64*e2e1^3*amel2*x5*xcp1 +32*e2e1^3*amel2*x5^2*xcp3 +320*e2e1^3*amel2*x5^2*xcp2 +32*e2e1^3*amel2*x5^2*xcp1 -256*e2e1^3*amel2*x5^3*xcp2 +384*e2e1^3*amel2*x4*xcp2 +192*e2e1^3*amel2*x4*x5*xcp2 -64*e2e1^3*amel2*x4*x5^2*xcp3 -512*e2e1^3*amel2*x4*x5^2*xcp2 -64*e2e1^3*amel2*x4*x5^2*xcp1 -256*e2e1^3*amel2*x4^2*xcp2 -192*e2e1^3*amel2*x4^2*x5*xcp3 -128*e2e1^3*amel2*x4^2*x5*xcp2 -192*e2e1^3*amel2*x4^2*x5*xcp1 -128*e2e1^3*amel2*x4^3*xcp3 +128*e2e1^3*amel2*x4^3*xcp2 -128*e2e1^3*amel2*x4^3*xcp1 +128*e2e1^3*amel2*x3*xcp2 -64*e2e1^3*amel2*x3*x5*xcp2 -256*e2e1^3*amel2*x3*x5^2*xcp2 -64*e2e1^3*amel2*x3*x4*xcp3 -704*e2e1^3*amel2*x3*x4*xcp2 -64*e2e1^3*amel2*x3*x4*xcp1 -192*e2e1^3*amel2*x3*x4*x5*xcp3 +256*e2e1^3*amel2*x3*x4*x5*xcp2 -192*e2e1^3*amel2*x3*x4*x5*xcp1 -256*e2e1^3*amel2*x3*x4^2*xcp3 +640*e2e1^3*amel2*x3*x4^2*xcp2 -256*e2e1^3*amel2*x3*x4^2*xcp1 -32*e2e1^3*amel2*x3^2*xcp3 -256*e2e1^3*amel2*x3^2*xcp2 -32*e2e1^3*amel2*x3^2*xcp1 +128*e2e1^3*amel2*x3^2*x5*xcp2 -128*e2e1^3*amel2*x3^2*x4*xcp3 +512*e2e1^3*amel2*x3^2*x4*xcp2 -128*e2e1^3*amel2*x3^2*x4*xcp1 +128*e2e1^3*amel2*x3^3*xcp2 +256*e2e1^3*amel2*x1*xcp2 +32*e2e1^3*amel2*x1*x5*xcp3 -576*e2e1^3*amel2*x1*x5*xcp2 +32*e2e1^3*amel2*x1*x5*xcp1 +256*e2e1^3*amel2*x1*x5^2*xcp2 +64*e2e1^3*amel2*x1*x4*xcp3 -256*e2e1^3*amel2*x1*x4*xcp2 +64*e2e1^3*amel2*x1*x4*xcp1 -64*e2e1^3*amel2*x1*x4*x5*xcp3 +384*e2e1^3*amel2*x1*x4*x5*xcp2 -64*e2e1^3*amel2*x1*x4*x5*xcp1 -128*e2e1^3*amel2*x1*x4^2*xcp3 +128*e2e1^3*amel2*x1*x4^2*xcp2 -128*e2e1^3*amel2*x1*x4^2*xcp1 +32*e2e1^3*amel2*x1*x3*xcp3 -320*e2e1^3*amel2*x1*x3*xcp2 +32*e2e1^3*amel2*x1*x3*xcp1 -64*e2e1^3*amel2*x1*x3*x5*xcp3 +512*e2e1^3*amel2*x1*x3*x5*xcp2 -64*e2e1^3*amel2*x1*x3*x5*xcp1 -256*e2e1^3*amel2*x1*x3*x4*xcp3 +384*e2e1^3*amel2*x1*x3*x4*xcp2 -256*e2e1^3*amel2*x1*x3*x4*xcp1 -128*e2e1^3*amel2*x1*x3^2*xcp3 +256*e2e1^3*amel2*x1*x3^2*xcp2 -128*e2e1^3*amel2*x1*x3^2*xcp1 -128*e2e1^3*amel2*x1^2*xcp2 +128*e2e1^3*amel2*x1^2*x5*xcp2 -128*e2e1^4*x5*xcp2 +256*e2e1^4*x5^2*xcp2 -128*e2e1^4*x5^3*xcp2 +128*e2e1^4*x4*xcp2 +128*e2e1^4*x4*x5*xcp2 -256*e2e1^4*x4*x5^2*xcp2 -128*e2e1^4*x4^2*xcp2 -128*e2e1^4*x4^2*x5*xcp2 +256*e2e1^4*x3*x5*xcp2 -256*e2e1^4*x3*x5^2*xcp2 -256*e2e1^4*x3*x4*xcp2 -128*e2e1^4*x3*x4*x5*xcp2 +128*e2e1^4*x3*x4^2*xcp2 -128*e2e1^4*x3^2*x5*xcp2 +128*e2e1^4*x3^2*x4*xcp2 -48*e3e2*amel2^2*zk^2*xcp3 -32*e3e2*amel2^2*zk^2*xcp2 -48*e3e2*amel2^2*zk^2*xcp1 +48*e3e2*amel2^2*zk^2*x5*xcp3 -64*e3e2*amel2^2*zk^2*x5*xcp2 +48*e3e2*amel2^2*zk^2*x5*xcp1 +96*e3e2*amel2^2*zk^2*x4*xcp3 +96*e3e2*amel2^2*zk^2*x4*xcp1 +64*e3e2*amel2^2*zk^2*x3*xcp2 +48*e3e2*amel2^2*zk^2*x1*xcp3 +48*e3e2*amel2^2*zk^2*x1*xcp1 -256*e3e2*amel2^3*x5*xcp2 -32*e3e2*amel2^3*x5^2*xcp3 +128*e3e2*amel2^3*x5^2*xcp2 -32*e3e2*amel2^3*x5^2*xcp1 +32*e3e2*amel2^3*x5^3*xcp3 +32*e3e2*amel2^3*x5^3*xcp1 +64*e3e2*amel2^3*x4*xcp3 -256*e3e2*amel2^3*x4*xcp2 +64*e3e2*amel2^3*x4*xcp1 -128*e3e2*amel2^3*x4*x5*xcp3 +448*e3e2*amel2^3*x4*x5*xcp2 -128*e3e2*amel2^3*x4*x5*xcp1 +128*e3e2*amel2^3*x4*x5^2*xcp3 -64*e3e2*amel2^3*x4*x5^2*xcp2 +128*e3e2*amel2^3*x4*x5^2*xcp1 -192*e3e2*amel2^3*x4^2*xcp3 +384*e3e2*amel2^3*x4^2*xcp2 -192*e3e2*amel2^3*x4^2*xcp1 +192*e3e2*amel2^3*x4^2*x5*xcp3 -256*e3e2*amel2^3*x4^2*x5*xcp2 +192*e3e2*amel2^3*x4^2*x5*xcp1 +128*e3e2*amel2^3*x4^3*xcp3 -128*e3e2*amel2^3*x4^3*xcp2 +128*e3e2*amel2^3*x4^3*xcp1 -64*e3e2*amel2^3*x3*xcp3 -64*e3e2*amel2^3*x3*xcp1 +448*e3e2*amel2^3*x3*x5*xcp2 -64*e3e2*amel2^3*x3*x5^2*xcp2 -192*e3e2*amel2^3*x3*x4*xcp3 +576*e3e2*amel2^3*x3*x4*xcp2 -192*e3e2*amel2^3*x3*x4*xcp1 +64*e3e2*amel2^3*x3*x4*x5*xcp3 -384*e3e2*amel2^3*x3*x4*x5*xcp2 +64*e3e2*amel2^3*x3*x4*x5*xcp1 +128*e3e2*amel2^3*x3*x4^2*xcp3 -128*e3e2*amel2^3*x3*x4^2*xcp2 +128*e3e2*amel2^3*x3*x4^2*xcp1 -32*e3e2*amel2^3*x3^2*xcp3 +64*e3e2*amel2^3*x3^2*xcp2 -32*e3e2*amel2^3*x3^2*xcp1 +32*e3e2*amel2^3*x3^2*x5*xcp3 -128*e3e2*amel2^3*x3^2*x5*xcp2 +32*e3e2*amel2^3*x3^2*x5*xcp1 +64*e3e2*amel2^3*x3^2*x4*xcp3 +64*e3e2*amel2^3*x3^2*x4*xcp2 +64*e3e2*amel2^3*x3^2*x4*xcp1 +64*e3e2*amel2^3*x3^3*xcp2 -128*e3e2*amel2^3*x1*xcp2 -32*e3e2*amel2^3*x1*x5*xcp3 +448*e3e2*amel2^3*x1*x5*xcp2 -32*e3e2*amel2^3*x1*x5*xcp1 +96*e3e2*amel2^3*x1*x5^2*xcp3 -256*e3e2*amel2^3*x1*x5^2*xcp2 +96*e3e2*amel2^3*x1*x5^2*xcp1 -128*e3e2*amel2^3*x1*x4*xcp3 +768*e3e2*amel2^3*x1*x4*xcp2 -128*e3e2*amel2^3*x1*x4*xcp1 +320*e3e2*amel2^3*x1*x4*x5*xcp3 -768*e3e2*amel2^3*x1*x4*x5*xcp2 +320*e3e2*amel2^3*x1*x4*x5*xcp1 +256*e3e2*amel2^3*x1*x4^2*xcp3 -512*e3e2*amel2^3*x1*x4^2*xcp2 +256*e3e2*amel2^3*x1*x4^2*xcp1 -96*e3e2*amel2^3*x1*x3*xcp3 +448*e3e2*amel2^3*x1*x3*xcp2 -96*e3e2*amel2^3*x1*x3*xcp1 +64*e3e2*amel2^3*x1*x3*x5*xcp3 -512*e3e2*amel2^3*x1*x3*x5*xcp2 +64*e3e2*amel2^3*x1*x3*x5*xcp1 +256*e3e2*amel2^3*x1*x3*x4*xcp3 -512*e3e2*amel2^3*x1*x3*x4*xcp2 +256*e3e2*amel2^3*x1*x3*x4*xcp1 +32*e3e2*amel2^3*x1*x3^2*xcp3 +32*e3e2*amel2^3*x1*x3^2*xcp1 -64*e3e2*amel2^3*x1^2*xcp3 +64*e3e2*amel2^3*x1^2*xcp2 -64*e3e2*amel2^3*x1^2*xcp1 +96*e3e2*amel2^3*x1^2*x5*xcp3 -128*e3e2*amel2^3*x1^2*x5*xcp2 +96*e3e2*amel2^3*x1^2*x5*xcp1 +128*e3e2*amel2^3*x1^2*x4*xcp3 -64*e3e2*amel2^3*x1^2*x4*xcp2 +128*e3e2*amel2^3*x1^2*x4*xcp1 +64*e3e2*amel2^3*x1^2*x3*xcp3 +64*e3e2*amel2^3*x1^2*x3*xcp2 +64*e3e2*amel2^3*x1^2*x3*xcp1 +32*e3e2*amel2^3*x1^3*xcp3 +32*e3e2*amel2^3*x1^3*xcp1 -16*e3e2*e2e1*amel2*zk^2*xcp3 -64*e3e2*e2e1*amel2*zk^2*xcp2 -16*e3e2*e2e1*amel2*zk^2*xcp1 +96*e3e2*e2e1*amel2*zk^2*x5*xcp3 +96*e3e2*e2e1*amel2*zk^2*x5*xcp1 +144*e3e2*e2e1*amel2*zk^2*x4*xcp3 +144*e3e2*e2e1*amel2*zk^2*x4*xcp1 +144*e3e2*e2e1*amel2*zk^2*x3*xcp3 -64*e3e2*e2e1*amel2*zk^2*x3*xcp2 +144*e3e2*e2e1*amel2*zk^2*x3*xcp1 +64*e3e2*e2e1*amel2*zk^2*x1*xcp2 -512*e3e2*e2e1*amel2^2*x5*xcp2 -128*e3e2*e2e1*amel2^2*x5^2*xcp2 +64*e3e2*e2e1*amel2^2*x5^3*xcp3 +256*e3e2*e2e1*amel2^2*x5^3*xcp2 +64*e3e2*e2e1*amel2^2*x5^3*xcp1 +64*e3e2*e2e1*amel2^2*x4*xcp3 -768*e3e2*e2e1*amel2^2*x4*xcp2 +64*e3e2*e2e1*amel2^2*x4*xcp1 -192*e3e2*e2e1*amel2^2*x4*x5*xcp3 +768*e3e2*e2e1*amel2^2*x4*x5*xcp2 -192*e3e2*e2e1*amel2^2*x4*x5*xcp1 +352*e3e2*e2e1*amel2^2*x4*x5^2*xcp3 +352*e3e2*e2e1*amel2^2*x4*x5^2*xcp1 -320*e3e2*e2e1*amel2^2*x4^2*xcp3 +896*e3e2*e2e1*amel2^2*x4^2*xcp2 -320*e3e2*e2e1*amel2^2*x4^2*xcp1 +704*e3e2*e2e1*amel2^2*x4^2*x5*xcp3 -768*e3e2*e2e1*amel2^2*x4^2*x5*xcp2 +704*e3e2*e2e1*amel2^2*x4^2*x5*xcp1 +448*e3e2*e2e1*amel2^2*x4^3*xcp3 -512*e3e2*e2e1*amel2^2*x4^3*xcp2 +448*e3e2*e2e1*amel2^2*x4^3*xcp1 -64*e3e2*e2e1*amel2^2*x3*xcp3 -256*e3e2*e2e1*amel2^2*x3*xcp2 -64*e3e2*e2e1*amel2^2*x3*xcp1 +64*e3e2*e2e1*amel2^2*x3*x5*xcp3 +1024*e3e2*e2e1*amel2^2*x3*x5*xcp2 +64*e3e2*e2e1*amel2^2*x3*x5*xcp1 +96*e3e2*e2e1*amel2^2*x3*x5^2*xcp3 -128*e3e2*e2e1*amel2^2*x3*x5^2*xcp2 +96*e3e2*e2e1*amel2^2*x3*x5^2*xcp1 -192*e3e2*e2e1*amel2^2*x3*x4*xcp3 +1536*e3e2*e2e1*amel2^2*x3*x4*xcp2 -192*e3e2*e2e1*amel2^2*x3*x4*xcp1 +448*e3e2*e2e1*amel2^2*x3*x4*x5*xcp3 -1280*e3e2*e2e1*amel2^2*x3*x4*x5*xcp2 +448*e3e2*e2e1*amel2^2*x3*x4*x5*xcp1 +640*e3e2*e2e1*amel2^2*x3*x4^2*xcp3 -1024*e3e2*e2e1*amel2^2*x3*x4^2*xcp2 +640*e3e2*e2e1*amel2^2*x3*x4^2*xcp1 +512*e3e2*e2e1*amel2^2*x3^2*xcp2 +64*e3e2*e2e1*amel2^2*x3^2*x5*xcp3 -512*e3e2*e2e1*amel2^2*x3^2*x5*xcp2 +64*e3e2*e2e1*amel2^2*x3^2*x5*xcp1 +288*e3e2*e2e1*amel2^2*x3^2*x4*xcp3 -512*e3e2*e2e1*amel2^2*x3^2*x4*xcp2 +288*e3e2*e2e1*amel2^2*x3^2*x4*xcp1 +96*e3e2*e2e1*amel2^2*x3^3*xcp3 -128*e3e2*e2e1*amel2^2*x3^3*xcp2 +96*e3e2*e2e1*amel2^2*x3^3*xcp1 -128*e3e2*e2e1*amel2^2*x1*xcp3 -384*e3e2*e2e1*amel2^2*x1*xcp2 -128*e3e2*e2e1*amel2^2*x1*xcp1 +32*e3e2*e2e1*amel2^2*x1*x5*xcp3 +1216*e3e2*e2e1*amel2^2*x1*x5*xcp2 +32*e3e2*e2e1*amel2^2*x1*x5*xcp1 +128*e3e2*e2e1*amel2^2*x1*x5^2*xcp3 -576*e3e2*e2e1*amel2^2*x1*x5^2*xcp2 +128*e3e2*e2e1*amel2^2*x1*x5^2*xcp1 -192*e3e2*e2e1*amel2^2*x1*x4*xcp3 +1856*e3e2*e2e1*amel2^2*x1*x4*xcp2 -192*e3e2*e2e1*amel2^2*x1*x4*xcp1 +512*e3e2*e2e1*amel2^2*x1*x4*x5*xcp3 -1920*e3e2*e2e1*amel2^2*x1*x4*x5*xcp2 +512*e3e2*e2e1*amel2^2*x1*x4*x5*xcp1 +448*e3e2*e2e1*amel2^2*x1*x4^2*xcp3 -1152*e3e2*e2e1*amel2^2*x1*x4^2*xcp2 +448*e3e2*e2e1*amel2^2*x1*x4^2*xcp1 -32*e3e2*e2e1*amel2^2*x1*x3*xcp3 +1280*e3e2*e2e1*amel2^2*x1*x3*xcp2 -32*e3e2*e2e1*amel2^2*x1*x3*xcp1 +384*e3e2*e2e1*amel2^2*x1*x3*x5*xcp3 -1536*e3e2*e2e1*amel2^2*x1*x3*x5*xcp2 +384*e3e2*e2e1*amel2^2*x1*x3*x5*xcp1 +640*e3e2*e2e1*amel2^2*x1*x3*x4*xcp3 -1664*e3e2*e2e1*amel2^2*x1*x3*x4*xcp2 +640*e3e2*e2e1*amel2^2*x1*x3*x4*xcp1 +192*e3e2*e2e1*amel2^2*x1*x3^2*xcp3 -576*e3e2*e2e1*amel2^2*x1*x3^2*xcp2 +192*e3e2*e2e1*amel2^2*x1*x3^2*xcp1 -32*e3e2*e2e1*amel2^2*x1^2*xcp3 +64*e3e2*e2e1*amel2^2*x1^2*xcp2 -32*e3e2*e2e1*amel2^2*x1^2*xcp1 +64*e3e2*e2e1*amel2^2*x1^2*x5*xcp3 -128*e3e2*e2e1*amel2^2*x1^2*x5*xcp2 +64*e3e2*e2e1*amel2^2*x1^2*x5*xcp1 +160*e3e2*e2e1*amel2^2*x1^2*x4*xcp3 -128*e3e2*e2e1*amel2^2*x1^2*x4*xcp2 +160*e3e2*e2e1*amel2^2*x1^2*x4*xcp1 +160*e3e2*e2e1*amel2^2*x1^2*x3*xcp3 +160*e3e2*e2e1*amel2^2*x1^2*x3*xcp1 +64*e3e2*e2e1*amel2^2*x1^3*xcp2 +64*e3e2*e2e1^2*zk^2*xcp2 +64*e3e2*e2e1^2*zk^2*x4*xcp2 -64*e3e2*e2e1^2*zk^2*x3*xcp2 +128*e3e2*e2e1^2*amel2*x5*xcp3 -256*e3e2*e2e1^2*amel2*x5*xcp2 +128*e3e2*e2e1^2*amel2*x5*xcp1 -64*e3e2*e2e1^2*amel2*x5^2*xcp3 -640*e3e2*e2e1^2*amel2*x5^2*xcp2 -64*e3e2*e2e1^2*amel2*x5^2*xcp1 +512*e3e2*e2e1^2*amel2*x5^3*xcp2 -896*e3e2*e2e1^2*amel2*x4*xcp2 -64*e3e2*e2e1^2*amel2*x4*x5*xcp3 -128*e3e2*e2e1^2*amel2*x4*x5*xcp2 -64*e3e2*e2e1^2*amel2*x4*x5*xcp1 +192*e3e2*e2e1^2*amel2*x4*x5^2*xcp3 +896*e3e2*e2e1^2*amel2*x4*x5^2*xcp2 +192*e3e2*e2e1^2*amel2*x4*x5^2*xcp1 -64*e3e2*e2e1^2*amel2*x4^2*xcp3 +768*e3e2*e2e1^2*amel2*x4^2*xcp2 -64*e3e2*e2e1^2*amel2*x4^2*xcp1 +512*e3e2*e2e1^2*amel2*x4^2*x5*xcp3 +512*e3e2*e2e1^2*amel2*x4^2*x5*xcp1 +320*e3e2*e2e1^2*amel2*x4^3*xcp3 -384*e3e2*e2e1^2*amel2*x4^3*xcp2 +320*e3e2*e2e1^2*amel2*x4^3*xcp1 -256*e3e2*e2e1^2*amel2*x3*xcp2 +128*e3e2*e2e1^2*amel2*x3*x5*xcp2 +512*e3e2*e2e1^2*amel2*x3*x5^2*xcp2 +64*e3e2*e2e1^2*amel2*x3*x4*xcp3 +1664*e3e2*e2e1^2*amel2*x3*x4*xcp2 +64*e3e2*e2e1^2*amel2*x3*x4*xcp1 +512*e3e2*e2e1^2*amel2*x3*x4*x5*xcp3 -768*e3e2*e2e1^2*amel2*x3*x4*x5*xcp2 +512*e3e2*e2e1^2*amel2*x3*x4*x5*xcp1 +640*e3e2*e2e1^2*amel2*x3*x4^2*xcp3 -1536*e3e2*e2e1^2*amel2*x3*x4^2*xcp2 +640*e3e2*e2e1^2*amel2*x3*x4^2*xcp1 +64*e3e2*e2e1^2*amel2*x3^2*xcp3 +512*e3e2*e2e1^2*amel2*x3^2*xcp2 +64*e3e2*e2e1^2*amel2*x3^2*xcp1 -256*e3e2*e2e1^2*amel2*x3^2*x5*xcp2 +320*e3e2*e2e1^2*amel2*x3^2*x4*xcp3 -1152*e3e2*e2e1^2*amel2*x3^2*x4*xcp2 +320*e3e2*e2e1^2*amel2*x3^2*x4*xcp1 -256*e3e2*e2e1^2*amel2*x3^3*xcp2 -640*e3e2*e2e1^2*amel2*x1*xcp2 -64*e3e2*e2e1^2*amel2*x1*x5*xcp3 +1408*e3e2*e2e1^2*amel2*x1*x5*xcp2 -64*e3e2*e2e1^2*amel2*x1*x5*xcp1 -640*e3e2*e2e1^2*amel2*x1*x5^2*xcp2 -128*e3e2*e2e1^2*amel2*x1*x4*xcp3 +1152*e3e2*e2e1^2*amel2*x1*x4*xcp2 -128*e3e2*e2e1^2*amel2*x1*x4*xcp1 +128*e3e2*e2e1^2*amel2*x1*x4*x5*xcp3 -1152*e3e2*e2e1^2*amel2*x1*x4*x5*xcp2 +128*e3e2*e2e1^2*amel2*x1*x4*x5*xcp1 +192*e3e2*e2e1^2*amel2*x1*x4^2*xcp3 -512*e3e2*e2e1^2*amel2*x1*x4^2*xcp2 +192*e3e2*e2e1^2*amel2*x1*x4^2*xcp1 -64*e3e2*e2e1^2*amel2*x1*x3*xcp3 +1152*e3e2*e2e1^2*amel2*x1*x3*xcp2 -64*e3e2*e2e1^2*amel2*x1*x3*xcp1 +128*e3e2*e2e1^2*amel2*x1*x3*x5*xcp3 -1280*e3e2*e2e1^2*amel2*x1*x3*x5*xcp2 +128*e3e2*e2e1^2*amel2*x1*x3*x5*xcp1 +384*e3e2*e2e1^2*amel2*x1*x3*x4*xcp3 -1152*e3e2*e2e1^2*amel2*x1*x3*x4*xcp2 +384*e3e2*e2e1^2*amel2*x1*x3*x4*xcp1 +192*e3e2*e2e1^2*amel2*x1*x3^2*xcp3 -640*e3e2*e2e1^2*amel2*x1*x3^2*xcp2 +192*e3e2*e2e1^2*amel2*x1*x3^2*xcp1 +256*e3e2*e2e1^2*amel2*x1^2*xcp2 -256*e3e2*e2e1^2*amel2*x1^2*x5*xcp2 -128*e3e2*e2e1^2*amel2*x1^2*x4*xcp2 -128*e3e2*e2e1^2*amel2*x1^2*x3*xcp2 +384*e3e2*e2e1^3*x5*xcp2 -768*e3e2*e2e1^3*x5^2*xcp2 +384*e3e2*e2e1^3*x5^3*xcp2 -384*e3e2*e2e1^3*x4*xcp2 -384*e3e2*e2e1^3*x4*x5*xcp2 +768*e3e2*e2e1^3*x4*x5^2*xcp2 +384*e3e2*e2e1^3*x4^2*xcp2 +384*e3e2*e2e1^3*x4^2*x5*xcp2 -768*e3e2*e2e1^3*x3*x5*xcp2 +768*e3e2*e2e1^3*x3*x5^2*xcp2 +768*e3e2*e2e1^3*x3*x4*xcp2 +384*e3e2*e2e1^3*x3*x4*x5*xcp2 -384*e3e2*e2e1^3*x3*x4^2*xcp2 +384*e3e2*e2e1^3*x3^2*x5*xcp2 -384*e3e2*e2e1^3*x3^2*x4*xcp2 +16*e3e2^2*amel2*zk^2*xcp3 -32*e3e2^2*amel2*zk^2*xcp2 +16*e3e2^2*amel2*zk^2*xcp1 -48*e3e2^2*amel2*zk^2*x5*xcp3 +32*e3e2^2*amel2*zk^2*x5*xcp2 -48*e3e2^2*amel2*zk^2*x5*xcp1 -48*e3e2^2*amel2*zk^2*x4*xcp3 +32*e3e2^2*amel2*zk^2*x4*xcp2 -48*e3e2^2*amel2*zk^2*x4*xcp1 -48*e3e2^2*amel2*zk^2*x3*xcp3 +32*e3e2^2*amel2*zk^2*x3*xcp2 -48*e3e2^2*amel2*zk^2*x3*xcp1 +32*e3e2^2*amel2*zk^2*x1*xcp2 +128*e3e2^2*amel2^2*x5*xcp2 -32*e3e2^2*amel2^2*x5^3*xcp3 -64*e3e2^2*amel2^2*x5^3*xcp2 -32*e3e2^2*amel2^2*x5^3*xcp1 +256*e3e2^2*amel2^2*x4*xcp2 +128*e3e2^2*amel2^2*x4*x5*xcp3 -512*e3e2^2*amel2^2*x4*x5*xcp2 +128*e3e2^2*amel2^2*x4*x5*xcp1 -160*e3e2^2*amel2^2*x4*x5^2*xcp3 +192*e3e2^2*amel2^2*x4*x5^2*xcp2 -160*e3e2^2*amel2^2*x4*x5^2*xcp1 +192*e3e2^2*amel2^2*x4^2*xcp3 -512*e3e2^2*amel2^2*x4^2*xcp2 +192*e3e2^2*amel2^2*x4^2*xcp1 -320*e3e2^2*amel2^2*x4^2*x5*xcp3 +512*e3e2^2*amel2^2*x4^2*x5*xcp2 -320*e3e2^2*amel2^2*x4^2*x5*xcp1 -192*e3e2^2*amel2^2*x4^3*xcp3 +256*e3e2^2*amel2^2*x4^3*xcp2 -192*e3e2^2*amel2^2*x4^3*xcp1 +128*e3e2^2*amel2^2*x3*xcp2 -384*e3e2^2*amel2^2*x3*x5*xcp2 -32*e3e2^2*amel2^2*x3*x5^2*xcp3 +64*e3e2^2*amel2^2*x3*x5^2*xcp2 -32*e3e2^2*amel2^2*x3*x5^2*xcp1 +128*e3e2^2*amel2^2*x3*x4*xcp3 -640*e3e2^2*amel2^2*x3*x4*xcp2 +128*e3e2^2*amel2^2*x3*x4*xcp1 -192*e3e2^2*amel2^2*x3*x4*x5*xcp3 +512*e3e2^2*amel2^2*x3*x4*x5*xcp2 -192*e3e2^2*amel2^2*x3*x4*x5*xcp1 -256*e3e2^2*amel2^2*x3*x4^2*xcp3 +384*e3e2^2*amel2^2*x3*x4^2*xcp2 -256*e3e2^2*amel2^2*x3*x4^2*xcp1 -256*e3e2^2*amel2^2*x3^2*xcp2 -32*e3e2^2*amel2^2*x3^2*x5*xcp3 +192*e3e2^2*amel2^2*x3^2*x5*xcp2 -32*e3e2^2*amel2^2*x3^2*x5*xcp1 -96*e3e2^2*amel2^2*x3^2*x4*xcp3 +192*e3e2^2*amel2^2*x3^2*x4*xcp2 -96*e3e2^2*amel2^2*x3^2*x4*xcp1 -32*e3e2^2*amel2^2*x3^3*xcp3 +64*e3e2^2*amel2^2*x3^3*xcp2 -32*e3e2^2*amel2^2*x3^3*xcp1 +64*e3e2^2*amel2^2*x1*xcp3 +128*e3e2^2*amel2^2*x1*xcp2 +64*e3e2^2*amel2^2*x1*xcp1 -576*e3e2^2*amel2^2*x1*x5*xcp2 -64*e3e2^2*amel2^2*x1*x5^2*xcp3 +256*e3e2^2*amel2^2*x1*x5^2*xcp2 -64*e3e2^2*amel2^2*x1*x5^2*xcp1 -1024*e3e2^2*amel2^2*x1*x4*xcp2 -192*e3e2^2*amel2^2*x1*x4*x5*xcp3 +896*e3e2^2*amel2^2*x1*x4*x5*xcp2 -192*e3e2^2*amel2^2*x1*x4*x5*xcp1 -128*e3e2^2*amel2^2*x1*x4^2*xcp3 +640*e3e2^2*amel2^2*x1*x4^2*xcp2 -128*e3e2^2*amel2^2*x1*x4^2*xcp1 -704*e3e2^2*amel2^2*x1*x3*xcp2 -128*e3e2^2*amel2^2*x1*x3*x5*xcp3 +640*e3e2^2*amel2^2*x1*x3*x5*xcp2 -128*e3e2^2*amel2^2*x1*x3*x5*xcp1 -192*e3e2^2*amel2^2*x1*x3*x4*xcp3 +896*e3e2^2*amel2^2*x1*x3*x4*xcp2 -192*e3e2^2*amel2^2*x1*x3*x4*xcp1 -64*e3e2^2*amel2^2*x1*x3^2*xcp3 +384*e3e2^2*amel2^2*x1*x3^2*xcp2 -64*e3e2^2*amel2^2*x1*x3^2*xcp1 -64*e3e2^2*amel2^2*x1^2*xcp2 -32*e3e2^2*amel2^2*x1^2*x5*xcp3 +64*e3e2^2*amel2^2*x1^2*x5*xcp2 -32*e3e2^2*amel2^2*x1^2*x5*xcp1 -32*e3e2^2*amel2^2*x1^2*x4*xcp3 +64*e3e2^2*amel2^2*x1^2*x4*xcp2 -32*e3e2^2*amel2^2*x1^2*x4*xcp1 -32*e3e2^2*amel2^2*x1^2*x3*xcp3 +64*e3e2^2*amel2^2*x1^2*x3*xcp2 -32*e3e2^2*amel2^2*x1^2*x3*xcp1 -32*e3e2^2*e2e1*zk^2*xcp2 -32*e3e2^2*e2e1*zk^2*x4*xcp2 +32*e3e2^2*e2e1*zk^2*x3*xcp2 -64*e3e2^2*e2e1*amel2*x5*xcp3 +128*e3e2^2*e2e1*amel2*x5*xcp2 -64*e3e2^2*e2e1*amel2*x5*xcp1 +32*e3e2^2*e2e1*amel2*x5^2*xcp3 +320*e3e2^2*e2e1*amel2*x5^2*xcp2 +32*e3e2^2*e2e1*amel2*x5^2*xcp1 -256*e3e2^2*e2e1*amel2*x5^3*xcp2 +640*e3e2^2*e2e1*amel2*x4*xcp2 +128*e3e2^2*e2e1*amel2*x4*x5*xcp3 -320*e3e2^2*e2e1*amel2*x4*x5*xcp2 +128*e3e2^2*e2e1*amel2*x4*x5*xcp1 -192*e3e2^2*e2e1*amel2*x4*x5^2*xcp3 -256*e3e2^2*e2e1*amel2*x4*x5^2*xcp2 -192*e3e2^2*e2e1*amel2*x4*x5^2*xcp1 +128*e3e2^2*e2e1*amel2*x4^2*xcp3 -768*e3e2^2*e2e1*amel2*x4^2*xcp2 +128*e3e2^2*e2e1*amel2*x4^2*xcp1 -448*e3e2^2*e2e1*amel2*x4^2*x5*xcp3 +384*e3e2^2*e2e1*amel2*x4^2*x5*xcp2 -448*e3e2^2*e2e1*amel2*x4^2*x5*xcp1 -256*e3e2^2*e2e1*amel2*x4^3*xcp3 +384*e3e2^2*e2e1*amel2*x4^3*xcp2 -256*e3e2^2*e2e1*amel2*x4^3*xcp1 +128*e3e2^2*e2e1*amel2*x3*xcp2 -64*e3e2^2*e2e1*amel2*x3*x5*xcp2 -256*e3e2^2*e2e1*amel2*x3*x5^2*xcp2 +64*e3e2^2*e2e1*amel2*x3*x4*xcp3 -1216*e3e2^2*e2e1*amel2*x3*x4*xcp2 +64*e3e2^2*e2e1*amel2*x3*x4*xcp1 -448*e3e2^2*e2e1*amel2*x3*x4*x5*xcp3 +768*e3e2^2*e2e1*amel2*x3*x4*x5*xcp2 -448*e3e2^2*e2e1*amel2*x3*x4*x5*xcp1 -512*e3e2^2*e2e1*amel2*x3*x4^2*xcp3 +1152*e3e2^2*e2e1*amel2*x3*x4^2*xcp2 -512*e3e2^2*e2e1*amel2*x3*x4^2*xcp1 -32*e3e2^2*e2e1*amel2*x3^2*xcp3 -256*e3e2^2*e2e1*amel2*x3^2*xcp2 -32*e3e2^2*e2e1*amel2*x3^2*xcp1 +128*e3e2^2*e2e1*amel2*x3^2*x5*xcp2 -256*e3e2^2*e2e1*amel2*x3^2*x4*xcp3 +768*e3e2^2*e2e1*amel2*x3^2*x4*xcp2 -256*e3e2^2*e2e1*amel2*x3^2*x4*xcp1 +128*e3e2^2*e2e1*amel2*x3^3*xcp2 +512*e3e2^2*e2e1*amel2*x1*xcp2 +32*e3e2^2*e2e1*amel2*x1*x5*xcp3 -1088*e3e2^2*e2e1*amel2*x1*x5*xcp2 +32*e3e2^2*e2e1*amel2*x1*x5*xcp1 +512*e3e2^2*e2e1*amel2*x1*x5^2*xcp2 +64*e3e2^2*e2e1*amel2*x1*x4*xcp3 -1280*e3e2^2*e2e1*amel2*x1*x4*xcp2 +64*e3e2^2*e2e1*amel2*x1*x4*xcp1 -64*e3e2^2*e2e1*amel2*x1*x4*x5*xcp3 +1152*e3e2^2*e2e1*amel2*x1*x4*x5*xcp2 -64*e3e2^2*e2e1*amel2*x1*x4*x5*xcp1 -64*e3e2^2*e2e1*amel2*x1*x4^2*xcp3 +640*e3e2^2*e2e1*amel2*x1*x4^2*xcp2 -64*e3e2^2*e2e1*amel2*x1*x4^2*xcp1 +32*e3e2^2*e2e1*amel2*x1*x3*xcp3 -1088*e3e2^2*e2e1*amel2*x1*x3*xcp2 +32*e3e2^2*e2e1*amel2*x1*x3*xcp1 -64*e3e2^2*e2e1*amel2*x1*x3*x5*xcp3 +1024*e3e2^2*e2e1*amel2*x1*x3*x5*xcp2 -64*e3e2^2*e2e1*amel2*x1*x3*x5*xcp1 -128*e3e2^2*e2e1*amel2*x1*x3*x4*xcp3 +1152*e3e2^2*e2e1*amel2*x1*x3*x4*xcp2 -128*e3e2^2*e2e1*amel2*x1*x3*x4*xcp1 -64*e3e2^2*e2e1*amel2*x1*x3^2*xcp3 +512*e3e2^2*e2e1*amel2*x1*x3^2*xcp2 -64*e3e2^2*e2e1*amel2*x1*x3^2*xcp1 -128*e3e2^2*e2e1*amel2*x1^2*xcp2 +128*e3e2^2*e2e1*amel2*x1^2*x5*xcp2 +128*e3e2^2*e2e1*amel2*x1^2*x4*xcp2 +128*e3e2^2*e2e1*amel2*x1^2*x3*xcp2 -384*e3e2^2*e2e1^2*x5*xcp2 +768*e3e2^2*e2e1^2*x5^2*xcp2 -384*e3e2^2*e2e1^2*x5^3*xcp2 +384*e3e2^2*e2e1^2*x4*xcp2 +384*e3e2^2*e2e1^2*x4*x5*xcp2 -768*e3e2^2*e2e1^2*x4*x5^2*xcp2 -384*e3e2^2*e2e1^2*x4^2*xcp2 -384*e3e2^2*e2e1^2*x4^2*x5*xcp2 +768*e3e2^2*e2e1^2*x3*x5*xcp2 -768*e3e2^2*e2e1^2*x3*x5^2*xcp2 -768*e3e2^2*e2e1^2*x3*x4*xcp2 -384*e3e2^2*e2e1^2*x3*x4*x5*xcp2 +384*e3e2^2*e2e1^2*x3*x4^2*xcp2 -384*e3e2^2*e2e1^2*x3^2*x5*xcp2 +384*e3e2^2*e2e1^2*x3^2*x4*xcp2 -128*e3e2^3*amel2*x4*xcp2 -64*e3e2^3*amel2*x4*x5*xcp3 +256*e3e2^3*amel2*x4*x5*xcp2 -64*e3e2^3*amel2*x4*x5*xcp1 +64*e3e2^3*amel2*x4*x5^2*xcp3 -128*e3e2^3*amel2*x4*x5^2*xcp2 +64*e3e2^3*amel2*x4*x5^2*xcp1 -64*e3e2^3*amel2*x4^2*xcp3 +256*e3e2^3*amel2*x4^2*xcp2 -64*e3e2^3*amel2*x4^2*xcp1 +128*e3e2^3*amel2*x4^2*x5*xcp3 -256*e3e2^3*amel2*x4^2*x5*xcp2 +128*e3e2^3*amel2*x4^2*x5*xcp1 +64*e3e2^3*amel2*x4^3*xcp3 -128*e3e2^3*amel2*x4^3*xcp2 +64*e3e2^3*amel2*x4^3*xcp1 -64*e3e2^3*amel2*x3*x4*xcp3 +256*e3e2^3*amel2*x3*x4*xcp2 -64*e3e2^3*amel2*x3*x4*xcp1 +128*e3e2^3*amel2*x3*x4*x5*xcp3 -256*e3e2^3*amel2*x3*x4*x5*xcp2 +128*e3e2^3*amel2*x3*x4*x5*xcp1 +128*e3e2^3*amel2*x3*x4^2*xcp3 -256*e3e2^3*amel2*x3*x4^2*xcp2 +128*e3e2^3*amel2*x3*x4^2*xcp1 +64*e3e2^3*amel2*x3^2*x4*xcp3 -128*e3e2^3*amel2*x3^2*x4*xcp2 +64*e3e2^3*amel2*x3^2*x4*xcp1 -128*e3e2^3*amel2*x1*xcp2 +256*e3e2^3*amel2*x1*x5*xcp2 -128*e3e2^3*amel2*x1*x5^2*xcp2 +384*e3e2^3*amel2*x1*x4*xcp2 -384*e3e2^3*amel2*x1*x4*x5*xcp2 -256*e3e2^3*amel2*x1*x4^2*xcp2 +256*e3e2^3*amel2*x1*x3*xcp2 -256*e3e2^3*amel2*x1*x3*x5*xcp2 -384*e3e2^3*amel2*x1*x3*x4*xcp2 -128*e3e2^3*amel2*x1*x3^2*xcp2 +128*e3e2^3*e2e1*x5*xcp2 -256*e3e2^3*e2e1*x5^2*xcp2 +128*e3e2^3*e2e1*x5^3*xcp2 -128*e3e2^3*e2e1*x4*xcp2 -128*e3e2^3*e2e1*x4*x5*xcp2 +256*e3e2^3*e2e1*x4*x5^2*xcp2 +128*e3e2^3*e2e1*x4^2*xcp2 +128*e3e2^3*e2e1*x4^2*x5*xcp2 -256*e3e2^3*e2e1*x3*x5*xcp2 +256*e3e2^3*e2e1*x3*x5^2*xcp2 +256*e3e2^3*e2e1*x3*x4*xcp2 +128*e3e2^3*e2e1*x3*x4*x5*xcp2 -128*e3e2^3*e2e1*x3*x4^2*xcp2 +128*e3e2^3*e2e1*x3^2*x5*xcp2 -128*e3e2^3*e2e1*x3^2*x4*xcp2 -112*e3e1*amel2^2*zk^2*xcp3 -112*e3e1*amel2^2*zk^2*xcp1 +48*e3e1*amel2^2*zk^2*x5*xcp3 +48*e3e1*amel2^2*zk^2*x5*xcp1 +48*e3e1*amel2^2*zk^2*x4*xcp3 -32*e3e1*amel2^2*zk^2*x4*xcp2 +48*e3e1*amel2^2*zk^2*x4*xcp1 -32*e3e1*amel2^2*zk^2*x3*xcp2 +96*e3e1*amel2^2*zk^2*x1*xcp3 +96*e3e1*amel2^2*zk^2*x1*xcp1 +96*e3e1*amel2^3*x5*xcp3 +96*e3e1*amel2^3*x5*xcp1 -160*e3e1*amel2^3*x5^2*xcp3 -160*e3e1*amel2^3*x5^2*xcp1 +32*e3e1*amel2^3*x5^3*xcp3 +32*e3e1*amel2^3*x5^3*xcp1 +96*e3e1*amel2^3*x4*xcp3 -128*e3e1*amel2^3*x4*xcp2 +96*e3e1*amel2^3*x4*xcp1 -352*e3e1*amel2^3*x4*x5*xcp3 +576*e3e1*amel2^3*x4*x5*xcp2 -352*e3e1*amel2^3*x4*x5*xcp1 +96*e3e1*amel2^3*x4*x5^2*xcp3 -128*e3e1*amel2^3*x4*x5^2*xcp2 +96*e3e1*amel2^3*x4*x5^2*xcp1 -320*e3e1*amel2^3*x4^2*xcp3 +576*e3e1*amel2^3*x4^2*xcp2 -320*e3e1*amel2^3*x4^2*xcp1 +128*e3e1*amel2^3*x4^2*x5*xcp3 -256*e3e1*amel2^3*x4^2*x5*xcp2 +128*e3e1*amel2^3*x4^2*x5*xcp1 +64*e3e1*amel2^3*x4^3*xcp3 -128*e3e1*amel2^3*x4^3*xcp2 +64*e3e1*amel2^3*x4^3*xcp1 -128*e3e1*amel2^3*x3*xcp2 -96*e3e1*amel2^3*x3*x5*xcp3 +576*e3e1*amel2^3*x3*x5*xcp2 -96*e3e1*amel2^3*x3*x5*xcp1 -128*e3e1*amel2^3*x3*x5^2*xcp2 -352*e3e1*amel2^3*x3*x4*xcp3 +704*e3e1*amel2^3*x3*x4*xcp2 -352*e3e1*amel2^3*x3*x4*xcp1 +64*e3e1*amel2^3*x3*x4*x5*xcp3 -256*e3e1*amel2^3*x3*x4*x5*xcp2 +64*e3e1*amel2^3*x3*x4*x5*xcp1 +64*e3e1*amel2^3*x3*x4^2*xcp3 -128*e3e1*amel2^3*x3*x4^2*xcp2 +64*e3e1*amel2^3*x3*x4^2*xcp1 -128*e3e1*amel2^3*x3^2*xcp3 +128*e3e1*amel2^3*x3^2*xcp2 -128*e3e1*amel2^3*x3^2*xcp1 +32*e3e1*amel2^3*x3^2*x5*xcp3 +32*e3e1*amel2^3*x3^2*x5*xcp1 +32*e3e1*amel2^3*x3^2*x4*xcp3 +32*e3e1*amel2^3*x3^2*x4*xcp1 +256*e3e1*amel2^3*x1*xcp3 +256*e3e1*amel2^3*x1*xcp1 -256*e3e1*amel2^3*x1*x5*xcp3 -256*e3e1*amel2^3*x1*x5*xcp1 +192*e3e1*amel2^3*x1*x5^2*xcp3 +192*e3e1*amel2^3*x1*x5^2*xcp1 -352*e3e1*amel2^3*x1*x4*xcp3 +448*e3e1*amel2^3*x1*x4*xcp2 -352*e3e1*amel2^3*x1*x4*xcp1 +384*e3e1*amel2^3*x1*x4*x5*xcp3 -384*e3e1*amel2^3*x1*x4*x5*xcp2 +384*e3e1*amel2^3*x1*x4*x5*xcp1 +256*e3e1*amel2^3*x1*x4^2*xcp3 -384*e3e1*amel2^3*x1*x4^2*xcp2 +256*e3e1*amel2^3*x1*x4^2*xcp1 -352*e3e1*amel2^3*x1*x3*xcp3 +448*e3e1*amel2^3*x1*x3*xcp2 -352*e3e1*amel2^3*x1*x3*xcp1 +128*e3e1*amel2^3*x1*x3*x5*xcp3 -384*e3e1*amel2^3*x1*x3*x5*xcp2 +128*e3e1*amel2^3*x1*x3*x5*xcp1 +256*e3e1*amel2^3*x1*x3*x4*xcp3 -512*e3e1*amel2^3*x1*x3*x4*xcp2 +256*e3e1*amel2^3*x1*x3*x4*xcp1 +64*e3e1*amel2^3*x1*x3^2*xcp3 -128*e3e1*amel2^3*x1*x3^2*xcp2 +64*e3e1*amel2^3*x1*x3^2*xcp1 -224*e3e1*amel2^3*x1^2*xcp3 -224*e3e1*amel2^3*x1^2*xcp1 +224*e3e1*amel2^3*x1^2*x5*xcp3 +224*e3e1*amel2^3*x1^2*x5*xcp1 +224*e3e1*amel2^3*x1^2*x4*xcp3 +224*e3e1*amel2^3*x1^2*x4*xcp1 +192*e3e1*amel2^3*x1^2*x3*xcp3 +192*e3e1*amel2^3*x1^2*x3*xcp1 +64*e3e1*amel2^3*x1^3*xcp3 +64*e3e1*amel2^3*x1^3*xcp1 -16*e3e1*e2e1*amel2*zk^2*xcp3 +96*e3e1*e2e1*amel2*zk^2*xcp2 -16*e3e1*e2e1*amel2*zk^2*xcp1 +48*e3e1*e2e1*amel2*zk^2*x5*xcp3 -192*e3e1*e2e1*amel2*zk^2*x5*xcp2 +48*e3e1*e2e1*amel2*zk^2*x5*xcp1 +96*e3e1*e2e1*amel2*zk^2*x4*xcp3 -224*e3e1*e2e1*amel2*zk^2*x4*xcp2 +96*e3e1*e2e1*amel2*zk^2*x4*xcp1 +48*e3e1*e2e1*amel2*zk^2*x3*xcp3 -160*e3e1*e2e1*amel2*zk^2*x3*xcp2 +48*e3e1*e2e1*amel2*zk^2*x3*xcp1 +64*e3e1*e2e1*amel2^2*xcp3 +256*e3e1*e2e1*amel2^2*xcp2 +64*e3e1*e2e1*amel2^2*xcp1 -32*e3e1*e2e1*amel2^2*x5*xcp3 -1152*e3e1*e2e1*amel2^2*x5*xcp2 -32*e3e1*e2e1*amel2^2*x5*xcp1 -96*e3e1*e2e1*amel2^2*x5^2*xcp3 +896*e3e1*e2e1*amel2^2*x5^2*xcp2 -96*e3e1*e2e1*amel2^2*x5^2*xcp1 +96*e3e1*e2e1*amel2^2*x5^3*xcp3 -256*e3e1*e2e1*amel2^2*x5^3*xcp2 +96*e3e1*e2e1*amel2^2*x5^3*xcp1 +128*e3e1*e2e1*amel2^2*x4*xcp3 -1408*e3e1*e2e1*amel2^2*x4*xcp2 +128*e3e1*e2e1*amel2^2*x4*xcp1 -448*e3e1*e2e1*amel2^2*x4*x5*xcp3 +2496*e3e1*e2e1*amel2^2*x4*x5*xcp2 -448*e3e1*e2e1*amel2^2*x4*x5*xcp1 +448*e3e1*e2e1*amel2^2*x4*x5^2*xcp3 -1024*e3e1*e2e1*amel2^2*x4*x5^2*xcp2 +448*e3e1*e2e1*amel2^2*x4*x5^2*xcp1 -448*e3e1*e2e1*amel2^2*x4^2*xcp3 +1792*e3e1*e2e1*amel2^2*x4^2*xcp2 -448*e3e1*e2e1*amel2^2*x4^2*xcp1 +640*e3e1*e2e1*amel2^2*x4^2*x5*xcp3 -1536*e3e1*e2e1*amel2^2*x4^2*x5*xcp2 +640*e3e1*e2e1*amel2^2*x4^2*x5*xcp1 +320*e3e1*e2e1*amel2^2*x4^3*xcp3 -768*e3e1*e2e1*amel2^2*x4^3*xcp2 +320*e3e1*e2e1*amel2^2*x4^3*xcp1 -160*e3e1*e2e1*amel2^2*x3*xcp3 -768*e3e1*e2e1*amel2^2*x3*xcp2 -160*e3e1*e2e1*amel2^2*x3*xcp1 -64*e3e1*e2e1*amel2^2*x3*x5*xcp3 +1856*e3e1*e2e1*amel2^2*x3*x5*xcp2 -64*e3e1*e2e1*amel2^2*x3*x5*xcp1 +96*e3e1*e2e1*amel2^2*x3*x5^2*xcp3 -512*e3e1*e2e1*amel2^2*x3*x5^2*xcp2 +96*e3e1*e2e1*amel2^2*x3*x5^2*xcp1 -384*e3e1*e2e1*amel2^2*x3*x4*xcp3 +2496*e3e1*e2e1*amel2^2*x3*x4*xcp2 -384*e3e1*e2e1*amel2^2*x3*x4*xcp1 +384*e3e1*e2e1*amel2^2*x3*x4*x5*xcp3 -1664*e3e1*e2e1*amel2^2*x3*x4*x5*xcp2 +384*e3e1*e2e1*amel2^2*x3*x4*x5*xcp1 +384*e3e1*e2e1*amel2^2*x3*x4^2*xcp3 -1280*e3e1*e2e1*amel2^2*x3*x4^2*xcp2 +384*e3e1*e2e1*amel2^2*x3*x4^2*xcp1 -32*e3e1*e2e1*amel2^2*x3^2*xcp3 +704*e3e1*e2e1*amel2^2*x3^2*xcp2 -32*e3e1*e2e1*amel2^2*x3^2*xcp1 +32*e3e1*e2e1*amel2^2*x3^2*x5*xcp3 -384*e3e1*e2e1*amel2^2*x3^2*x5*xcp2 +32*e3e1*e2e1*amel2^2*x3^2*x5*xcp1 +128*e3e1*e2e1*amel2^2*x3^2*x4*xcp3 -640*e3e1*e2e1*amel2^2*x3^2*x4*xcp2 +128*e3e1*e2e1*amel2^2*x3^2*x4*xcp1 +32*e3e1*e2e1*amel2^2*x3^3*xcp3 -128*e3e1*e2e1*amel2^2*x3^3*xcp2 +32*e3e1*e2e1*amel2^2*x3^3*xcp1 +96*e3e1*e2e1*amel2^2*x1*xcp3 -640*e3e1*e2e1*amel2^2*x1*xcp2 +96*e3e1*e2e1*amel2^2*x1*xcp1 -160*e3e1*e2e1*amel2^2*x1*x5*xcp3 +1472*e3e1*e2e1*amel2^2*x1*x5*xcp2 -160*e3e1*e2e1*amel2^2*x1*x5*xcp1 +192*e3e1*e2e1*amel2^2*x1*x5^2*xcp3 -768*e3e1*e2e1*amel2^2*x1*x5^2*xcp2 +192*e3e1*e2e1*amel2^2*x1*x5^2*xcp1 -576*e3e1*e2e1*amel2^2*x1*x4*xcp3 +1920*e3e1*e2e1*amel2^2*x1*x4*xcp2 -576*e3e1*e2e1*amel2^2*x1*x4*xcp1 +704*e3e1*e2e1*amel2^2*x1*x4*x5*xcp3 -1920*e3e1*e2e1*amel2^2*x1*x4*x5*xcp2 +704*e3e1*e2e1*amel2^2*x1*x4*x5*xcp1 +512*e3e1*e2e1*amel2^2*x1*x4^2*xcp3 -1152*e3e1*e2e1*amel2^2*x1*x4^2*xcp2 +512*e3e1*e2e1*amel2^2*x1*x4^2*xcp1 -288*e3e1*e2e1*amel2^2*x1*x3*xcp3 +1344*e3e1*e2e1*amel2^2*x1*x3*xcp2 -288*e3e1*e2e1*amel2^2*x1*x3*xcp1 +320*e3e1*e2e1*amel2^2*x1*x3*x5*xcp3 -1408*e3e1*e2e1*amel2^2*x1*x3*x5*xcp2 +320*e3e1*e2e1*amel2^2*x1*x3*x5*xcp1 +576*e3e1*e2e1*amel2^2*x1*x3*x4*xcp3 -1792*e3e1*e2e1*amel2^2*x1*x3*x4*xcp2 +576*e3e1*e2e1*amel2^2*x1*x3*x4*xcp1 +64*e3e1*e2e1*amel2^2*x1*x3^2*xcp3 -640*e3e1*e2e1*amel2^2*x1*x3^2*xcp2 +64*e3e1*e2e1*amel2^2*x1*x3^2*xcp1 -192*e3e1*e2e1*amel2^2*x1^2*xcp3 +192*e3e1*e2e1*amel2^2*x1^2*xcp2 -192*e3e1*e2e1*amel2^2*x1^2*xcp1 +96*e3e1*e2e1*amel2^2*x1^2*x5*xcp3 -256*e3e1*e2e1*amel2^2*x1^2*x5*xcp2 +96*e3e1*e2e1*amel2^2*x1^2*x5*xcp1 +256*e3e1*e2e1*amel2^2*x1^2*x4*xcp3 -256*e3e1*e2e1*amel2^2*x1^2*x4*xcp2 +256*e3e1*e2e1*amel2^2*x1^2*x4*xcp1 +224*e3e1*e2e1*amel2^2*x1^2*x3*xcp3 -128*e3e1*e2e1*amel2^2*x1^2*x3*xcp2 +224*e3e1*e2e1*amel2^2*x1^2*x3*xcp1 +128*e3e1*e2e1^2*zk^2*xcp2 -64*e3e1*e2e1^2*zk^2*x5*xcp2 -32*e3e1*e2e1^2*zk^2*x4*xcp2 -160*e3e1*e2e1^2*zk^2*x3*xcp2 +32*e3e1*e2e1^2*zk^2*x1*xcp2 +64*e3e1*e2e1^2*amel2*xcp3 +512*e3e1*e2e1^2*amel2*xcp2 +64*e3e1*e2e1^2*amel2*xcp1 -64*e3e1*e2e1^2*amel2*x5*xcp3 -1536*e3e1*e2e1^2*amel2*x5*xcp2 -64*e3e1*e2e1^2*amel2*x5*xcp1 +640*e3e1*e2e1^2*amel2*x5^2*xcp2 +64*e3e1*e2e1^2*amel2*x5^3*xcp3 +64*e3e1*e2e1^2*amel2*x5^3*xcp1 -32*e3e1*e2e1^2*amel2*x4*xcp3 -2048*e3e1*e2e1^2*amel2*x4*xcp2 -32*e3e1*e2e1^2*amel2*x4*xcp1 -32*e3e1*e2e1^2*amel2*x4*x5*xcp3 +2240*e3e1*e2e1^2*amel2*x4*x5*xcp2 -32*e3e1*e2e1^2*amel2*x4*x5*xcp1 +320*e3e1*e2e1^2*amel2*x4*x5^2*xcp3 -512*e3e1*e2e1^2*amel2*x4*x5^2*xcp2 +320*e3e1*e2e1^2*amel2*x4*x5^2*xcp1 -64*e3e1*e2e1^2*amel2*x4^2*xcp3 +1856*e3e1*e2e1^2*amel2*x4^2*xcp2 -64*e3e1*e2e1^2*amel2*x4^2*xcp1 +512*e3e1*e2e1^2*amel2*x4^2*x5*xcp3 -1280*e3e1*e2e1^2*amel2*x4^2*x5*xcp2 +512*e3e1*e2e1^2*amel2*x4^2*x5*xcp1 +256*e3e1*e2e1^2*amel2*x4^3*xcp3 -768*e3e1*e2e1^2*amel2*x4^3*xcp2 +256*e3e1*e2e1^2*amel2*x4^3*xcp1 -96*e3e1*e2e1^2*amel2*x3*xcp3 -1280*e3e1*e2e1^2*amel2*x3*xcp2 -96*e3e1*e2e1^2*amel2*x3*xcp1 +32*e3e1*e2e1^2*amel2*x3*x5*xcp3 +1856*e3e1*e2e1^2*amel2*x3*x5*xcp2 +32*e3e1*e2e1^2*amel2*x3*x5*xcp1 +192*e3e1*e2e1^2*amel2*x3*x5^2*xcp3 -384*e3e1*e2e1^2*amel2*x3*x5^2*xcp2 +192*e3e1*e2e1^2*amel2*x3*x5^2*xcp1 +96*e3e1*e2e1^2*amel2*x3*x4*xcp3 +3136*e3e1*e2e1^2*amel2*x3*x4*xcp2 +96*e3e1*e2e1^2*amel2*x3*x4*xcp1 +576*e3e1*e2e1^2*amel2*x3*x4*x5*xcp3 -2176*e3e1*e2e1^2*amel2*x3*x4*x5*xcp2 +576*e3e1*e2e1^2*amel2*x3*x4*x5*xcp1 +448*e3e1*e2e1^2*amel2*x3*x4^2*xcp3 -2048*e3e1*e2e1^2*amel2*x3*x4^2*xcp2 +448*e3e1*e2e1^2*amel2*x3*x4^2*xcp1 +32*e3e1*e2e1^2*amel2*x3^2*xcp3 +1024*e3e1*e2e1^2*amel2*x3^2*xcp2 +32*e3e1*e2e1^2*amel2*x3^2*xcp1 +128*e3e1*e2e1^2*amel2*x3^2*x5*xcp3 -512*e3e1*e2e1^2*amel2*x3^2*x5*xcp2 +128*e3e1*e2e1^2*amel2*x3^2*x5*xcp1 +192*e3e1*e2e1^2*amel2*x3^2*x4*xcp3 -1280*e3e1*e2e1^2*amel2*x3^2*x4*xcp2 +192*e3e1*e2e1^2*amel2*x3^2*x4*xcp1 -256*e3e1*e2e1^2*amel2*x3^3*xcp2 -32*e3e1*e2e1^2*amel2*x1*xcp3 -1024*e3e1*e2e1^2*amel2*x1*xcp2 -32*e3e1*e2e1^2*amel2*x1*xcp1 -32*e3e1*e2e1^2*amel2*x1*x5*xcp3 +1600*e3e1*e2e1^2*amel2*x1*x5*xcp2 -32*e3e1*e2e1^2*amel2*x1*x5*xcp1 +64*e3e1*e2e1^2*amel2*x1*x5^2*xcp3 -640*e3e1*e2e1^2*amel2*x1*x5^2*xcp2 +64*e3e1*e2e1^2*amel2*x1*x5^2*xcp1 -224*e3e1*e2e1^2*amel2*x1*x4*xcp3 +1536*e3e1*e2e1^2*amel2*x1*x4*xcp2 -224*e3e1*e2e1^2*amel2*x1*x4*xcp1 +256*e3e1*e2e1^2*amel2*x1*x4*x5*xcp3 -1408*e3e1*e2e1^2*amel2*x1*x4*x5*xcp2 +256*e3e1*e2e1^2*amel2*x1*x4*x5*xcp1 +256*e3e1*e2e1^2*amel2*x1*x4^2*xcp3 -768*e3e1*e2e1^2*amel2*x1*x4^2*xcp2 +256*e3e1*e2e1^2*amel2*x1*x4^2*xcp1 -64*e3e1*e2e1^2*amel2*x1*x3*xcp3 +1600*e3e1*e2e1^2*amel2*x1*x3*xcp2 -64*e3e1*e2e1^2*amel2*x1*x3*xcp1 +256*e3e1*e2e1^2*amel2*x1*x3*x5*xcp3 -1536*e3e1*e2e1^2*amel2*x1*x3*x5*xcp2 +256*e3e1*e2e1^2*amel2*x1*x3*x5*xcp1 +448*e3e1*e2e1^2*amel2*x1*x3*x4*xcp3 -1664*e3e1*e2e1^2*amel2*x1*x3*x4*xcp2 +448*e3e1*e2e1^2*amel2*x1*x3*x4*xcp1 +192*e3e1*e2e1^2*amel2*x1*x3^2*xcp3 -768*e3e1*e2e1^2*amel2*x1*x3^2*xcp2 +192*e3e1*e2e1^2*amel2*x1*x3^2*xcp1 -32*e3e1*e2e1^2*amel2*x1^2*xcp3 +192*e3e1*e2e1^2*amel2*x1^2*xcp2 -32*e3e1*e2e1^2*amel2*x1^2*xcp1 -128*e3e1*e2e1^2*amel2*x1^2*x5*xcp2 -128*e3e1*e2e1^2*amel2*x1^2*x4*xcp2 -128*e3e1*e2e1^2*amel2*x1^2*x3*xcp2 +256*e3e1*e2e1^3*xcp2 -384*e3e1*e2e1^3*x5*xcp2 +128*e3e1*e2e1^3*x5^3*xcp2 -896*e3e1*e2e1^3*x4*xcp2 +768*e3e1*e2e1^3*x4*x5*xcp2 +128*e3e1*e2e1^3*x4*x5^2*xcp2 +768*e3e1*e2e1^3*x4^2*xcp2 -128*e3e1*e2e1^3*x4^2*x5*xcp2 -128*e3e1*e2e1^3*x4^3*xcp2 -512*e3e1*e2e1^3*x3*xcp2 +384*e3e1*e2e1^3*x3*x5*xcp2 +128*e3e1*e2e1^3*x3*x5^2*xcp2 +1408*e3e1*e2e1^3*x3*x4*xcp2 -512*e3e1*e2e1^3*x3*x4*x5*xcp2 -640*e3e1*e2e1^3*x3*x4^2*xcp2 +256*e3e1*e2e1^3*x3^2*xcp2 -512*e3e1*e2e1^3*x3^2*x4*xcp2 -256*e3e1*e2e1^3*x1*xcp2 +384*e3e1*e2e1^3*x1*x5*xcp2 -128*e3e1*e2e1^3*x1*x5^2*xcp2 +384*e3e1*e2e1^3*x1*x4*xcp2 -256*e3e1*e2e1^3*x1*x4*x5*xcp2 -128*e3e1*e2e1^3*x1*x4^2*xcp2 +512*e3e1*e2e1^3*x1*x3*xcp2 -384*e3e1*e2e1^3*x1*x3*x5*xcp2 -384*e3e1*e2e1^3*x1*x3*x4*xcp2 -256*e3e1*e2e1^3*x1*x3^2*xcp2 +16*e3e1*e3e2*amel2*zk^2*xcp3 -128*e3e1*e3e2*amel2*zk^2*xcp2 +16*e3e1*e3e2*amel2*zk^2*xcp1 -48*e3e1*e3e2*amel2*zk^2*x5*xcp3 +192*e3e1*e3e2*amel2*zk^2*x5*xcp2 -48*e3e1*e3e2*amel2*zk^2*x5*xcp1 -96*e3e1*e3e2*amel2*zk^2*x4*xcp3 +224*e3e1*e3e2*amel2*zk^2*x4*xcp2 -96*e3e1*e3e2*amel2*zk^2*x4*xcp1 -48*e3e1*e3e2*amel2*zk^2*x3*xcp3 +160*e3e1*e3e2*amel2*zk^2*x3*xcp2 -48*e3e1*e3e2*amel2*zk^2*x3*xcp1 +32*e3e1*e3e2*amel2*zk^2*x1*xcp2 -64*e3e1*e3e2*amel2^2*xcp3 -256*e3e1*e3e2*amel2^2*xcp2 -64*e3e1*e3e2*amel2^2*xcp1 +96*e3e1*e3e2*amel2^2*x5*xcp3 +1152*e3e1*e3e2*amel2^2*x5*xcp2 +96*e3e1*e3e2*amel2^2*x5*xcp1 +96*e3e1*e3e2*amel2^2*x5^2*xcp3 -1024*e3e1*e3e2*amel2^2*x5^2*xcp2 +96*e3e1*e3e2*amel2^2*x5^2*xcp1 -96*e3e1*e3e2*amel2^2*x5^3*xcp3 +256*e3e1*e3e2*amel2^2*x5^3*xcp2 -96*e3e1*e3e2*amel2^2*x5^3*xcp1 -64*e3e1*e3e2*amel2^2*x4*xcp3 +1408*e3e1*e3e2*amel2^2*x4*xcp2 -64*e3e1*e3e2*amel2^2*x4*xcp1 +448*e3e1*e3e2*amel2^2*x4*x5*xcp3 -2752*e3e1*e3e2*amel2^2*x4*x5*xcp2 +448*e3e1*e3e2*amel2^2*x4*x5*xcp1 -448*e3e1*e3e2*amel2^2*x4*x5^2*xcp3 +1024*e3e1*e3e2*amel2^2*x4*x5^2*xcp2 -448*e3e1*e3e2*amel2^2*x4*x5^2*xcp1 +448*e3e1*e3e2*amel2^2*x4^2*xcp3 -1920*e3e1*e3e2*amel2^2*x4^2*xcp2 +448*e3e1*e3e2*amel2^2*x4^2*xcp1 -640*e3e1*e3e2*amel2^2*x4^2*x5*xcp3 +1536*e3e1*e3e2*amel2^2*x4^2*x5*xcp2 -640*e3e1*e3e2*amel2^2*x4^2*x5*xcp1 -320*e3e1*e3e2*amel2^2*x4^3*xcp3 +768*e3e1*e3e2*amel2^2*x4^3*xcp2 -320*e3e1*e3e2*amel2^2*x4^3*xcp1 +160*e3e1*e3e2*amel2^2*x3*xcp3 +768*e3e1*e3e2*amel2^2*x3*xcp2 +160*e3e1*e3e2*amel2^2*x3*xcp1 +64*e3e1*e3e2*amel2^2*x3*x5*xcp3 -1856*e3e1*e3e2*amel2^2*x3*x5*xcp2 +64*e3e1*e3e2*amel2^2*x3*x5*xcp1 -96*e3e1*e3e2*amel2^2*x3*x5^2*xcp3 +512*e3e1*e3e2*amel2^2*x3*x5^2*xcp2 -96*e3e1*e3e2*amel2^2*x3*x5^2*xcp1 +384*e3e1*e3e2*amel2^2*x3*x4*xcp3 -2496*e3e1*e3e2*amel2^2*x3*x4*xcp2 +384*e3e1*e3e2*amel2^2*x3*x4*xcp1 -384*e3e1*e3e2*amel2^2*x3*x4*x5*xcp3 +1664*e3e1*e3e2*amel2^2*x3*x4*x5*xcp2 -384*e3e1*e3e2*amel2^2*x3*x4*x5*xcp1 -384*e3e1*e3e2*amel2^2*x3*x4^2*xcp3 +1280*e3e1*e3e2*amel2^2*x3*x4^2*xcp2 -384*e3e1*e3e2*amel2^2*x3*x4^2*xcp1 +32*e3e1*e3e2*amel2^2*x3^2*xcp3 -704*e3e1*e3e2*amel2^2*x3^2*xcp2 +32*e3e1*e3e2*amel2^2*x3^2*xcp1 -32*e3e1*e3e2*amel2^2*x3^2*x5*xcp3 +384*e3e1*e3e2*amel2^2*x3^2*x5*xcp2 -32*e3e1*e3e2*amel2^2*x3^2*x5*xcp1 -128*e3e1*e3e2*amel2^2*x3^2*x4*xcp3 +640*e3e1*e3e2*amel2^2*x3^2*x4*xcp2 -128*e3e1*e3e2*amel2^2*x3^2*x4*xcp1 -32*e3e1*e3e2*amel2^2*x3^3*xcp3 +128*e3e1*e3e2*amel2^2*x3^3*xcp2 -32*e3e1*e3e2*amel2^2*x3^3*xcp1 +96*e3e1*e3e2*amel2^2*x1*xcp3 +640*e3e1*e3e2*amel2^2*x1*xcp2 +96*e3e1*e3e2*amel2^2*x1*xcp1 +64*e3e1*e3e2*amel2^2*x1*x5*xcp3 -1664*e3e1*e3e2*amel2^2*x1*x5*xcp2 +64*e3e1*e3e2*amel2^2*x1*x5*xcp1 -192*e3e1*e3e2*amel2^2*x1*x5^2*xcp3 +896*e3e1*e3e2*amel2^2*x1*x5^2*xcp2 -192*e3e1*e3e2*amel2^2*x1*x5^2*xcp1 +256*e3e1*e3e2*amel2^2*x1*x4*xcp3 -2112*e3e1*e3e2*amel2^2*x1*x4*xcp2 +256*e3e1*e3e2*amel2^2*x1*x4*xcp1 -640*e3e1*e3e2*amel2^2*x1*x4*x5*xcp3 +2176*e3e1*e3e2*amel2^2*x1*x4*x5*xcp2 -640*e3e1*e3e2*amel2^2*x1*x4*x5*xcp1 -448*e3e1*e3e2*amel2^2*x1*x4^2*xcp3 +1280*e3e1*e3e2*amel2^2*x1*x4^2*xcp2 -448*e3e1*e3e2*amel2^2*x1*x4^2*xcp1 +64*e3e1*e3e2*amel2^2*x1*x3*xcp3 -1344*e3e1*e3e2*amel2^2*x1*x3*xcp2 +64*e3e1*e3e2*amel2^2*x1*x3*xcp1 -256*e3e1*e3e2*amel2^2*x1*x3*x5*xcp3 +1408*e3e1*e3e2*amel2^2*x1*x3*x5*xcp2 -256*e3e1*e3e2*amel2^2*x1*x3*x5*xcp1 -512*e3e1*e3e2*amel2^2*x1*x3*x4*xcp3 +1792*e3e1*e3e2*amel2^2*x1*x3*x4*xcp2 -512*e3e1*e3e2*amel2^2*x1*x3*x4*xcp1 -64*e3e1*e3e2*amel2^2*x1*x3^2*xcp3 +640*e3e1*e3e2*amel2^2*x1*x3^2*xcp2 -64*e3e1*e3e2*amel2^2*x1*x3^2*xcp1 +32*e3e1*e3e2*amel2^2*x1^2*xcp3 -256*e3e1*e3e2*amel2^2*x1^2*xcp2 +32*e3e1*e3e2*amel2^2*x1^2*xcp1 -96*e3e1*e3e2*amel2^2*x1^2*x5*xcp3 +256*e3e1*e3e2*amel2^2*x1^2*x5*xcp2 -96*e3e1*e3e2*amel2^2*x1^2*x5*xcp1 -128*e3e1*e3e2*amel2^2*x1^2*x4*xcp3 +256*e3e1*e3e2*amel2^2*x1^2*x4*xcp2 -128*e3e1*e3e2*amel2^2*x1^2*x4*xcp1 -96*e3e1*e3e2*amel2^2*x1^2*x3*xcp3 +128*e3e1*e3e2*amel2^2*x1^2*x3*xcp2 -96*e3e1*e3e2*amel2^2*x1^2*x3*xcp1 -256*e3e1*e3e2*e2e1*zk^2*xcp2 +192*e3e1*e3e2*e2e1*zk^2*x5*xcp2 +160*e3e1*e3e2*e2e1*zk^2*x4*xcp2 +288*e3e1*e3e2*e2e1*zk^2*x3*xcp2 -32*e3e1*e3e2*e2e1*zk^2*x1*xcp2 -64*e3e1*e3e2*e2e1*amel2*xcp3 -768*e3e1*e3e2*e2e1*amel2*xcp2 -64*e3e1*e3e2*e2e1*amel2*xcp1 +64*e3e1*e3e2*e2e1*amel2*x5*xcp3 +2304*e3e1*e3e2*e2e1*amel2*x5*xcp2 +64*e3e1*e3e2*e2e1*amel2*x5*xcp1 +64*e3e1*e3e2*e2e1*amel2*x5^2*xcp3 -1280*e3e1*e3e2*e2e1*amel2*x5^2*xcp2 +64*e3e1*e3e2*e2e1*amel2*x5^2*xcp1 -128*e3e1*e3e2*e2e1*amel2*x5^3*xcp3 +128*e3e1*e3e2*e2e1*amel2*x5^3*xcp2 -128*e3e1*e3e2*e2e1*amel2*x5^3*xcp1 +96*e3e1*e3e2*e2e1*amel2*x4*xcp3 +3328*e3e1*e3e2*e2e1*amel2*x4*xcp2 +96*e3e1*e3e2*e2e1*amel2*x4*xcp1 +160*e3e1*e3e2*e2e1*amel2*x4*x5*xcp3 -4672*e3e1*e3e2*e2e1*amel2*x4*x5*xcp2 +160*e3e1*e3e2*e2e1*amel2*x4*x5*xcp1 -576*e3e1*e3e2*e2e1*amel2*x4*x5^2*xcp3 +1536*e3e1*e3e2*e2e1*amel2*x4*x5^2*xcp2 -576*e3e1*e3e2*e2e1*amel2*x4*x5^2*xcp1 +192*e3e1*e3e2*e2e1*amel2*x4^2*xcp3 -3776*e3e1*e3e2*e2e1*amel2*x4^2*xcp2 +192*e3e1*e3e2*e2e1*amel2*x4^2*xcp1 -896*e3e1*e3e2*e2e1*amel2*x4^2*x5*xcp3 +3072*e3e1*e3e2*e2e1*amel2*x4^2*x5*xcp2 -896*e3e1*e3e2*e2e1*amel2*x4^2*x5*xcp1 -448*e3e1*e3e2*e2e1*amel2*x4^3*xcp3 +1664*e3e1*e3e2*e2e1*amel2*x4^3*xcp2 -448*e3e1*e3e2*e2e1*amel2*x4^3*xcp1 +96*e3e1*e3e2*e2e1*amel2*x3*xcp3 +2048*e3e1*e3e2*e2e1*amel2*x3*xcp2 +96*e3e1*e3e2*e2e1*amel2*x3*xcp1 +32*e3e1*e3e2*e2e1*amel2*x3*x5*xcp3 -3136*e3e1*e3e2*e2e1*amel2*x3*x5*xcp2 +32*e3e1*e3e2*e2e1*amel2*x3*x5*xcp1 -320*e3e1*e3e2*e2e1*amel2*x3*x5^2*xcp3 +768*e3e1*e3e2*e2e1*amel2*x3*x5^2*xcp2 -320*e3e1*e3e2*e2e1*amel2*x3*x5^2*xcp1 -32*e3e1*e3e2*e2e1*amel2*x3*x4*xcp3 -5440*e3e1*e3e2*e2e1*amel2*x3*x4*xcp2 -32*e3e1*e3e2*e2e1*amel2*x3*x4*xcp1 -960*e3e1*e3e2*e2e1*amel2*x3*x4*x5*xcp3 +4096*e3e1*e3e2*e2e1*amel2*x3*x4*x5*xcp2 -960*e3e1*e3e2*e2e1*amel2*x3*x4*x5*xcp1 -768*e3e1*e3e2*e2e1*amel2*x3*x4^2*xcp3 +3712*e3e1*e3e2*e2e1*amel2*x3*x4^2*xcp2 -768*e3e1*e3e2*e2e1*amel2*x3*x4^2*xcp1 -32*e3e1*e3e2*e2e1*amel2*x3^2*xcp3 -1664*e3e1*e3e2*e2e1*amel2*x3^2*xcp2 -32*e3e1*e3e2*e2e1*amel2*x3^2*xcp1 -192*e3e1*e3e2*e2e1*amel2*x3^2*x5*xcp3 +896*e3e1*e3e2*e2e1*amel2*x3^2*x5*xcp2 -192*e3e1*e3e2*e2e1*amel2*x3^2*x5*xcp1 -320*e3e1*e3e2*e2e1*amel2*x3^2*x4*xcp3 +2176*e3e1*e3e2*e2e1*amel2*x3^2*x4*xcp2 -320*e3e1*e3e2*e2e1*amel2*x3^2*x4*xcp1 +384*e3e1*e3e2*e2e1*amel2*x3^3*xcp2 +32*e3e1*e3e2*e2e1*amel2*x1*xcp3 +1664*e3e1*e3e2*e2e1*amel2*x1*xcp2 +32*e3e1*e3e2*e2e1*amel2*x1*xcp1 +96*e3e1*e3e2*e2e1*amel2*x1*x5*xcp3 -2880*e3e1*e3e2*e2e1*amel2*x1*x5*xcp2 +96*e3e1*e3e2*e2e1*amel2*x1*x5*xcp1 -128*e3e1*e3e2*e2e1*amel2*x1*x5^2*xcp3 +1280*e3e1*e3e2*e2e1*amel2*x1*x5^2*xcp2 -128*e3e1*e3e2*e2e1*amel2*x1*x5^2*xcp1 +288*e3e1*e3e2*e2e1*amel2*x1*x4*xcp3 -2944*e3e1*e3e2*e2e1*amel2*x1*x4*xcp2 +288*e3e1*e3e2*e2e1*amel2*x1*x4*xcp1 -384*e3e1*e3e2*e2e1*amel2*x1*x4*x5*xcp3 +2816*e3e1*e3e2*e2e1*amel2*x1*x4*x5*xcp2 -384*e3e1*e3e2*e2e1*amel2*x1*x4*x5*xcp1 -320*e3e1*e3e2*e2e1*amel2*x1*x4^2*xcp3 +1536*e3e1*e3e2*e2e1*amel2*x1*x4^2*xcp2 -320*e3e1*e3e2*e2e1*amel2*x1*x4^2*xcp1 +128*e3e1*e3e2*e2e1*amel2*x1*x3*xcp3 -2752*e3e1*e3e2*e2e1*amel2*x1*x3*xcp2 +128*e3e1*e3e2*e2e1*amel2*x1*x3*xcp1 -384*e3e1*e3e2*e2e1*amel2*x1*x3*x5*xcp3 +2688*e3e1*e3e2*e2e1*amel2*x1*x3*x5*xcp2 -384*e3e1*e3e2*e2e1*amel2*x1*x3*x5*xcp1 -576*e3e1*e3e2*e2e1*amel2*x1*x3*x4*xcp3 +2944*e3e1*e3e2*e2e1*amel2*x1*x3*x4*xcp2 -576*e3e1*e3e2*e2e1*amel2*x1*x3*x4*xcp1 -256*e3e1*e3e2*e2e1*amel2*x1*x3^2*xcp3 +1280*e3e1*e3e2*e2e1*amel2*x1*x3^2*xcp2 -256*e3e1*e3e2*e2e1*amel2*x1*x3^2*xcp1 +32*e3e1*e3e2*e2e1*amel2*x1^2*xcp3 -320*e3e1*e3e2*e2e1*amel2*x1^2*xcp2 +32*e3e1*e3e2*e2e1*amel2*x1^2*xcp1 +256*e3e1*e3e2*e2e1*amel2*x1^2*x5*xcp2 +256*e3e1*e3e2*e2e1*amel2*x1^2*x4*xcp2 +256*e3e1*e3e2*e2e1*amel2*x1^2*x3*xcp2 -512*e3e1*e3e2*e2e1^2*xcp2 +768*e3e1*e3e2*e2e1^2*x5*xcp2 -256*e3e1*e3e2*e2e1^2*x5^3*xcp2 +2048*e3e1*e3e2*e2e1^2*x4*xcp2 -2048*e3e1*e3e2*e2e1^2*x4*x5*xcp2 -2048*e3e1*e3e2*e2e1^2*x4^2*xcp2 +768*e3e1*e3e2*e2e1^2*x4^2*x5*xcp2 +512*e3e1*e3e2*e2e1^2*x4^3*xcp2 +1024*e3e1*e3e2*e2e1^2*x3*xcp2 -768*e3e1*e3e2*e2e1^2*x3*x5*xcp2 -256*e3e1*e3e2*e2e1^2*x3*x5^2*xcp2 -3328*e3e1*e3e2*e2e1^2*x3*x4*xcp2 +1536*e3e1*e3e2*e2e1^2*x3*x4*x5*xcp2 +1792*e3e1*e3e2*e2e1^2*x3*x4^2*xcp2 -512*e3e1*e3e2*e2e1^2*x3^2*xcp2 +1280*e3e1*e3e2*e2e1^2*x3^2*x4*xcp2 +512*e3e1*e3e2*e2e1^2*x1*xcp2 -768*e3e1*e3e2*e2e1^2*x1*x5*xcp2 +256*e3e1*e3e2*e2e1^2*x1*x5^2*xcp2 -768*e3e1*e3e2*e2e1^2*x1*x4*xcp2 +512*e3e1*e3e2*e2e1^2*x1*x4*x5*xcp2 +256*e3e1*e3e2*e2e1^2*x1*x4^2*xcp2 -1024*e3e1*e3e2*e2e1^2*x1*x3*xcp2 +768*e3e1*e3e2*e2e1^2*x1*x3*x5*xcp2 +768*e3e1*e3e2*e2e1^2*x1*x3*x4*xcp2 +512*e3e1*e3e2*e2e1^2*x1*x3^2*xcp2 +128*e3e1*e3e2^2*zk^2*xcp2 -128*e3e1*e3e2^2*zk^2*x5*xcp2 -128*e3e1*e3e2^2*zk^2*x4*xcp2 -128*e3e1*e3e2^2*zk^2*x3*xcp2 +256*e3e1*e3e2^2*amel2*xcp2 -768*e3e1*e3e2^2*amel2*x5*xcp2 -64*e3e1*e3e2^2*amel2*x5^2*xcp3 +640*e3e1*e3e2^2*amel2*x5^2*xcp2 -64*e3e1*e3e2^2*amel2*x5^2*xcp1 +64*e3e1*e3e2^2*amel2*x5^3*xcp3 -128*e3e1*e3e2^2*amel2*x5^3*xcp2 +64*e3e1*e3e2^2*amel2*x5^3*xcp1 -64*e3e1*e3e2^2*amel2*x4*xcp3 -1280*e3e1*e3e2^2*amel2*x4*xcp2 -64*e3e1*e3e2^2*amel2*x4*xcp1 -128*e3e1*e3e2^2*amel2*x4*x5*xcp3 +2432*e3e1*e3e2^2*amel2*x4*x5*xcp2 -128*e3e1*e3e2^2*amel2*x4*x5*xcp1 +256*e3e1*e3e2^2*amel2*x4*x5^2*xcp3 -1024*e3e1*e3e2^2*amel2*x4*x5^2*xcp2 +256*e3e1*e3e2^2*amel2*x4*x5^2*xcp1 -128*e3e1*e3e2^2*amel2*x4^2*xcp3 +1920*e3e1*e3e2^2*amel2*x4^2*xcp2 -128*e3e1*e3e2^2*amel2*x4^2*xcp1 +384*e3e1*e3e2^2*amel2*x4^2*x5*xcp3 -1792*e3e1*e3e2^2*amel2*x4^2*x5*xcp2 +384*e3e1*e3e2^2*amel2*x4^2*x5*xcp1 +192*e3e1*e3e2^2*amel2*x4^3*xcp3 -896*e3e1*e3e2^2*amel2*x4^3*xcp2 +192*e3e1*e3e2^2*amel2*x4^3*xcp1 -768*e3e1*e3e2^2*amel2*x3*xcp2 -64*e3e1*e3e2^2*amel2*x3*x5*xcp3 +1280*e3e1*e3e2^2*amel2*x3*x5*xcp2 -64*e3e1*e3e2^2*amel2*x3*x5*xcp1 +128*e3e1*e3e2^2*amel2*x3*x5^2*xcp3 -384*e3e1*e3e2^2*amel2*x3*x5^2*xcp2 +128*e3e1*e3e2^2*amel2*x3*x5^2*xcp1 -64*e3e1*e3e2^2*amel2*x3*x4*xcp3 +2304*e3e1*e3e2^2*amel2*x3*x4*xcp2 -64*e3e1*e3e2^2*amel2*x3*x4*xcp1 +384*e3e1*e3e2^2*amel2*x3*x4*x5*xcp3 -1920*e3e1*e3e2^2*amel2*x3*x4*x5*xcp2 +384*e3e1*e3e2^2*amel2*x3*x4*x5*xcp1 +320*e3e1*e3e2^2*amel2*x3*x4^2*xcp3 -1664*e3e1*e3e2^2*amel2*x3*x4^2*xcp2 +320*e3e1*e3e2^2*amel2*x3*x4^2*xcp1 +640*e3e1*e3e2^2*amel2*x3^2*xcp2 +64*e3e1*e3e2^2*amel2*x3^2*x5*xcp3 -384*e3e1*e3e2^2*amel2*x3^2*x5*xcp2 +64*e3e1*e3e2^2*amel2*x3^2*x5*xcp1 +128*e3e1*e3e2^2*amel2*x3^2*x4*xcp3 -896*e3e1*e3e2^2*amel2*x3^2*x4*xcp2 +128*e3e1*e3e2^2*amel2*x3^2*x4*xcp1 -128*e3e1*e3e2^2*amel2*x3^3*xcp2 -640*e3e1*e3e2^2*amel2*x1*xcp2 -64*e3e1*e3e2^2*amel2*x1*x5*xcp3 +1280*e3e1*e3e2^2*amel2*x1*x5*xcp2 -64*e3e1*e3e2^2*amel2*x1*x5*xcp1 +64*e3e1*e3e2^2*amel2*x1*x5^2*xcp3 -640*e3e1*e3e2^2*amel2*x1*x5^2*xcp2 +64*e3e1*e3e2^2*amel2*x1*x5^2*xcp1 -64*e3e1*e3e2^2*amel2*x1*x4*xcp3 +1408*e3e1*e3e2^2*amel2*x1*x4*xcp2 -64*e3e1*e3e2^2*amel2*x1*x4*xcp1 +128*e3e1*e3e2^2*amel2*x1*x4*x5*xcp3 -1408*e3e1*e3e2^2*amel2*x1*x4*x5*xcp2 +128*e3e1*e3e2^2*amel2*x1*x4*x5*xcp1 +64*e3e1*e3e2^2*amel2*x1*x4^2*xcp3 -768*e3e1*e3e2^2*amel2*x1*x4^2*xcp2 +64*e3e1*e3e2^2*amel2*x1*x4^2*xcp1 -64*e3e1*e3e2^2*amel2*x1*x3*xcp3 +1152*e3e1*e3e2^2*amel2*x1*x3*xcp2 -64*e3e1*e3e2^2*amel2*x1*x3*xcp1 +128*e3e1*e3e2^2*amel2*x1*x3*x5*xcp3 -1152*e3e1*e3e2^2*amel2*x1*x3*x5*xcp2 +128*e3e1*e3e2^2*amel2*x1*x3*x5*xcp1 +128*e3e1*e3e2^2*amel2*x1*x3*x4*xcp3 -1280*e3e1*e3e2^2*amel2*x1*x3*x4*xcp2 +128*e3e1*e3e2^2*amel2*x1*x3*x4*xcp1 +64*e3e1*e3e2^2*amel2*x1*x3^2*xcp3 -512*e3e1*e3e2^2*amel2*x1*x3^2*xcp2 +64*e3e1*e3e2^2*amel2*x1*x3^2*xcp1 +128*e3e1*e3e2^2*amel2*x1^2*xcp2 -128*e3e1*e3e2^2*amel2*x1^2*x5*xcp2 -128*e3e1*e3e2^2*amel2*x1^2*x4*xcp2 -128*e3e1*e3e2^2*amel2*x1^2*x3*xcp2 +256*e3e1*e3e2^2*e2e1*xcp2 -384*e3e1*e3e2^2*e2e1*x5*xcp2 +128*e3e1*e3e2^2*e2e1*x5^3*xcp2 -1408*e3e1*e3e2^2*e2e1*x4*xcp2 +1792*e3e1*e3e2^2*e2e1*x4*x5*xcp2 -384*e3e1*e3e2^2*e2e1*x4*x5^2*xcp2 +1792*e3e1*e3e2^2*e2e1*x4^2*xcp2 -1152*e3e1*e3e2^2*e2e1*x4^2*x5*xcp2 -640*e3e1*e3e2^2*e2e1*x4^3*xcp2 -512*e3e1*e3e2^2*e2e1*x3*xcp2 +384*e3e1*e3e2^2*e2e1*x3*x5*xcp2 +128*e3e1*e3e2^2*e2e1*x3*x5^2*xcp2 +2432*e3e1*e3e2^2*e2e1*x3*x4*xcp2 -1536*e3e1*e3e2^2*e2e1*x3*x4*x5*xcp2 -1664*e3e1*e3e2^2*e2e1*x3*x4^2*xcp2 +256*e3e1*e3e2^2*e2e1*x3^2*xcp2 -1024*e3e1*e3e2^2*e2e1*x3^2*x4*xcp2 -256*e3e1*e3e2^2*e2e1*x1*xcp2 +384*e3e1*e3e2^2*e2e1*x1*x5*xcp2 -128*e3e1*e3e2^2*e2e1*x1*x5^2*xcp2 +384*e3e1*e3e2^2*e2e1*x1*x4*xcp2 -256*e3e1*e3e2^2*e2e1*x1*x4*x5*xcp2 -128*e3e1*e3e2^2*e2e1*x1*x4^2*xcp2 +512*e3e1*e3e2^2*e2e1*x1*x3*xcp2 -384*e3e1*e3e2^2*e2e1*x1*x3*x5*xcp2 -384*e3e1*e3e2^2*e2e1*x1*x3*x4*xcp2 -256*e3e1*e3e2^2*e2e1*x1*x3^2*xcp2 +256*e3e1*e3e2^3*x4*xcp2 -512*e3e1*e3e2^3*x4*x5*xcp2 +256*e3e1*e3e2^3*x4*x5^2*xcp2 -512*e3e1*e3e2^3*x4^2*xcp2 +512*e3e1*e3e2^3*x4^2*x5*xcp2 +256*e3e1*e3e2^3*x4^3*xcp2 -512*e3e1*e3e2^3*x3*x4*xcp2 +512*e3e1*e3e2^3*x3*x4*x5*xcp2 +512*e3e1*e3e2^3*x3*x4^2*xcp2 +256*e3e1*e3e2^3*x3^2*x4*xcp2 +80*e3e1^2*amel2*zk^2*xcp3 +80*e3e1^2*amel2*zk^2*xcp1 -48*e3e1^2*amel2*zk^2*x5*xcp3 -48*e3e1^2*amel2*zk^2*x5*xcp1 -48*e3e1^2*amel2*zk^2*x4*xcp3 +32*e3e1^2*amel2*zk^2*x4*xcp2 -48*e3e1^2*amel2*zk^2*x4*xcp1 +32*e3e1^2*amel2*zk^2*x3*xcp2 -48*e3e1^2*amel2*zk^2*x1*xcp3 -48*e3e1^2*amel2*zk^2*x1*xcp1 +64*e3e1^2*amel2^2*xcp3 +64*e3e1^2*amel2^2*xcp1 -288*e3e1^2*amel2^2*x5*xcp3 -288*e3e1^2*amel2^2*x5*xcp1 +288*e3e1^2*amel2^2*x5^2*xcp3 +288*e3e1^2*amel2^2*x5^2*xcp1 -96*e3e1^2*amel2^2*x5^3*xcp3 -96*e3e1^2*amel2^2*x5^3*xcp1 -320*e3e1^2*amel2^2*x4*xcp3 +256*e3e1^2*amel2^2*x4*xcp2 -320*e3e1^2*amel2^2*x4*xcp1 +640*e3e1^2*amel2^2*x4*x5*xcp3 -640*e3e1^2*amel2^2*x4*x5*xcp2 +640*e3e1^2*amel2^2*x4*x5*xcp1 -288*e3e1^2*amel2^2*x4*x5^2*xcp3 +256*e3e1^2*amel2^2*x4*x5^2*xcp2 -288*e3e1^2*amel2^2*x4*x5^2*xcp1 +448*e3e1^2*amel2^2*x4^2*xcp3 -640*e3e1^2*amel2^2*x4^2*xcp2 +448*e3e1^2*amel2^2*x4^2*xcp1 -320*e3e1^2*amel2^2*x4^2*x5*xcp3 +512*e3e1^2*amel2^2*x4^2*x5*xcp2 -320*e3e1^2*amel2^2*x4^2*x5*xcp1 -128*e3e1^2*amel2^2*x4^3*xcp3 +256*e3e1^2*amel2^2*x4^3*xcp2 -128*e3e1^2*amel2^2*x4^3*xcp1 -96*e3e1^2*amel2^2*x3*xcp3 +256*e3e1^2*amel2^2*x3*xcp2 -96*e3e1^2*amel2^2*x3*xcp1 +256*e3e1^2*amel2^2*x3*x5*xcp3 -640*e3e1^2*amel2^2*x3*x5*xcp2 +256*e3e1^2*amel2^2*x3*x5*xcp1 -64*e3e1^2*amel2^2*x3*x5^2*xcp3 +256*e3e1^2*amel2^2*x3*x5^2*xcp2 -64*e3e1^2*amel2^2*x3*x5^2*xcp1 +448*e3e1^2*amel2^2*x3*x4*xcp3 -896*e3e1^2*amel2^2*x3*x4*xcp2 +448*e3e1^2*amel2^2*x3*x4*xcp1 -192*e3e1^2*amel2^2*x3*x4*x5*xcp3 +640*e3e1^2*amel2^2*x3*x4*x5*xcp2 -192*e3e1^2*amel2^2*x3*x4*x5*xcp1 -128*e3e1^2*amel2^2*x3*x4^2*xcp3 +384*e3e1^2*amel2^2*x3*x4^2*xcp2 -128*e3e1^2*amel2^2*x3*x4^2*xcp1 +96*e3e1^2*amel2^2*x3^2*xcp3 -256*e3e1^2*amel2^2*x3^2*xcp2 +96*e3e1^2*amel2^2*x3^2*xcp1 -32*e3e1^2*amel2^2*x3^2*x5*xcp3 +128*e3e1^2*amel2^2*x3^2*x5*xcp2 -32*e3e1^2*amel2^2*x3^2*x5*xcp1 -32*e3e1^2*amel2^2*x3^2*x4*xcp3 +128*e3e1^2*amel2^2*x3^2*x4*xcp2 -32*e3e1^2*amel2^2*x3^2*x4*xcp1 -352*e3e1^2*amel2^2*x1*xcp3 -352*e3e1^2*amel2^2*x1*xcp1 +448*e3e1^2*amel2^2*x1*x5*xcp3 +448*e3e1^2*amel2^2*x1*x5*xcp1 -288*e3e1^2*amel2^2*x1*x5^2*xcp3 -288*e3e1^2*amel2^2*x1*x5^2*xcp1 +512*e3e1^2*amel2^2*x1*x4*xcp3 -384*e3e1^2*amel2^2*x1*x4*xcp2 +512*e3e1^2*amel2^2*x1*x4*xcp1 -576*e3e1^2*amel2^2*x1*x4*x5*xcp3 +384*e3e1^2*amel2^2*x1*x4*x5*xcp2 -576*e3e1^2*amel2^2*x1*x4*x5*xcp1 -320*e3e1^2*amel2^2*x1*x4^2*xcp3 +384*e3e1^2*amel2^2*x1*x4^2*xcp2 -320*e3e1^2*amel2^2*x1*x4^2*xcp1 +384*e3e1^2*amel2^2*x1*x3*xcp3 -384*e3e1^2*amel2^2*x1*x3*xcp2 +384*e3e1^2*amel2^2*x1*x3*xcp1 -256*e3e1^2*amel2^2*x1*x3*x5*xcp3 +384*e3e1^2*amel2^2*x1*x3*x5*xcp2 -256*e3e1^2*amel2^2*x1*x3*x5*xcp1 -320*e3e1^2*amel2^2*x1*x3*x4*xcp3 +640*e3e1^2*amel2^2*x1*x3*x4*xcp2 -320*e3e1^2*amel2^2*x1*x3*x4*xcp1 -32*e3e1^2*amel2^2*x1*x3^2*xcp3 +256*e3e1^2*amel2^2*x1*x3^2*xcp2 -32*e3e1^2*amel2^2*x1*x3^2*xcp1 +224*e3e1^2*amel2^2*x1^2*xcp3 +224*e3e1^2*amel2^2*x1^2*xcp1 -224*e3e1^2*amel2^2*x1^2*x5*xcp3 -224*e3e1^2*amel2^2*x1^2*x5*xcp1 -224*e3e1^2*amel2^2*x1^2*x4*xcp3 -224*e3e1^2*amel2^2*x1^2*x4*xcp1 -192*e3e1^2*amel2^2*x1^2*x3*xcp3 -192*e3e1^2*amel2^2*x1^2*x3*xcp1 -32*e3e1^2*amel2^2*x1^3*xcp3 -32*e3e1^2*amel2^2*x1^3*xcp1 -96*e3e1^2*e2e1*zk^2*xcp2 +64*e3e1^2*e2e1*zk^2*x5*xcp2 +64*e3e1^2*e2e1*zk^2*x4*xcp2 +128*e3e1^2*e2e1*zk^2*x3*xcp2 -32*e3e1^2*e2e1*zk^2*x1*xcp2 -512*e3e1^2*e2e1*amel2*xcp2 +1536*e3e1^2*e2e1*amel2*x5*xcp2 +32*e3e1^2*e2e1*amel2*x5^2*xcp3 -1216*e3e1^2*e2e1*amel2*x5^2*xcp2 +32*e3e1^2*e2e1*amel2*x5^2*xcp1 -64*e3e1^2*e2e1*amel2*x5^3*xcp3 +384*e3e1^2*e2e1*amel2*x5^3*xcp2 -64*e3e1^2*e2e1*amel2*x5^3*xcp1 -160*e3e1^2*e2e1*amel2*x4*xcp3 +1792*e3e1^2*e2e1*amel2*x4*xcp2 -160*e3e1^2*e2e1*amel2*x4*xcp1 +288*e3e1^2*e2e1*amel2*x4*x5*xcp3 -2944*e3e1^2*e2e1*amel2*x4*x5*xcp2 +288*e3e1^2*e2e1*amel2*x4*x5*xcp1 -320*e3e1^2*e2e1*amel2*x4*x5^2*xcp3 +1408*e3e1^2*e2e1*amel2*x4*x5^2*xcp2 -320*e3e1^2*e2e1*amel2*x4*x5^2*xcp1 +256*e3e1^2*e2e1*amel2*x4^2*xcp3 -1856*e3e1^2*e2e1*amel2*x4^2*xcp2 +256*e3e1^2*e2e1*amel2*x4^2*xcp1 -448*e3e1^2*e2e1*amel2*x4^2*x5*xcp3 +1792*e3e1^2*e2e1*amel2*x4^2*x5*xcp2 -448*e3e1^2*e2e1*amel2*x4^2*x5*xcp1 -192*e3e1^2*e2e1*amel2*x4^3*xcp3 +768*e3e1^2*e2e1*amel2*x4^3*xcp2 -192*e3e1^2*e2e1*amel2*x4^3*xcp1 +32*e3e1^2*e2e1*amel2*x3*xcp3 +1280*e3e1^2*e2e1*amel2*x3*xcp2 +32*e3e1^2*e2e1*amel2*x3*xcp1 -32*e3e1^2*e2e1*amel2*x3*x5*xcp3 -2304*e3e1^2*e2e1*amel2*x3*x5*xcp2 -32*e3e1^2*e2e1*amel2*x3*x5*xcp1 -128*e3e1^2*e2e1*amel2*x3*x5^2*xcp3 +1024*e3e1^2*e2e1*amel2*x3*x5^2*xcp2 -128*e3e1^2*e2e1*amel2*x3*x5^2*xcp1 +96*e3e1^2*e2e1*amel2*x3*x4*xcp3 -2816*e3e1^2*e2e1*amel2*x3*x4*xcp2 +96*e3e1^2*e2e1*amel2*x3*x4*xcp1 -384*e3e1^2*e2e1*amel2*x3*x4*x5*xcp3 +2560*e3e1^2*e2e1*amel2*x3*x4*x5*xcp2 -384*e3e1^2*e2e1*amel2*x3*x4*x5*xcp1 -256*e3e1^2*e2e1*amel2*x3*x4^2*xcp3 +1664*e3e1^2*e2e1*amel2*x3*x4^2*xcp2 -256*e3e1^2*e2e1*amel2*x3*x4^2*xcp1 -896*e3e1^2*e2e1*amel2*x3^2*xcp2 -64*e3e1^2*e2e1*amel2*x3^2*x5*xcp3 +640*e3e1^2*e2e1*amel2*x3^2*x5*xcp2 -64*e3e1^2*e2e1*amel2*x3^2*x5*xcp1 -64*e3e1^2*e2e1*amel2*x3^2*x4*xcp3 +896*e3e1^2*e2e1*amel2*x3^2*x4*xcp2 -64*e3e1^2*e2e1*amel2*x3^2*x4*xcp1 +128*e3e1^2*e2e1*amel2*x3^3*xcp2 -96*e3e1^2*e2e1*amel2*x1*xcp3 +768*e3e1^2*e2e1*amel2*x1*xcp2 -96*e3e1^2*e2e1*amel2*x1*xcp1 +128*e3e1^2*e2e1*amel2*x1*x5*xcp3 -1280*e3e1^2*e2e1*amel2*x1*x5*xcp2 +128*e3e1^2*e2e1*amel2*x1*x5*xcp1 -64*e3e1^2*e2e1*amel2*x1*x5^2*xcp3 +640*e3e1^2*e2e1*amel2*x1*x5^2*xcp2 -64*e3e1^2*e2e1*amel2*x1*x5^2*xcp1 +416*e3e1^2*e2e1*amel2*x1*x4*xcp3 -1408*e3e1^2*e2e1*amel2*x1*x4*xcp2 +416*e3e1^2*e2e1*amel2*x1*x4*xcp1 -320*e3e1^2*e2e1*amel2*x1*x4*x5*xcp3 +1408*e3e1^2*e2e1*amel2*x1*x4*x5*xcp2 -320*e3e1^2*e2e1*amel2*x1*x4*x5*xcp1 -256*e3e1^2*e2e1*amel2*x1*x4^2*xcp3 +768*e3e1^2*e2e1*amel2*x1*x4^2*xcp2 -256*e3e1^2*e2e1*amel2*x1*x4^2*xcp1 +160*e3e1^2*e2e1*amel2*x1*x3*xcp3 -1408*e3e1^2*e2e1*amel2*x1*x3*xcp2 +160*e3e1^2*e2e1*amel2*x1*x3*xcp1 -192*e3e1^2*e2e1*amel2*x1*x3*x5*xcp3 +1408*e3e1^2*e2e1*amel2*x1*x3*x5*xcp2 -192*e3e1^2*e2e1*amel2*x1*x3*x5*xcp1 -320*e3e1^2*e2e1*amel2*x1*x3*x4*xcp3 +1536*e3e1^2*e2e1*amel2*x1*x3*x4*xcp2 -320*e3e1^2*e2e1*amel2*x1*x3*x4*xcp1 -64*e3e1^2*e2e1*amel2*x1*x3^2*xcp3 +640*e3e1^2*e2e1*amel2*x1*x3^2*xcp2 -64*e3e1^2*e2e1*amel2*x1*x3^2*xcp1 +96*e3e1^2*e2e1*amel2*x1^2*xcp3 -64*e3e1^2*e2e1*amel2*x1^2*xcp2 +96*e3e1^2*e2e1*amel2*x1^2*xcp1 +128*e3e1^2*e2e1*amel2*x1^2*x5*xcp2 -64*e3e1^2*e2e1*amel2*x1^2*x4*xcp3 +128*e3e1^2*e2e1*amel2*x1^2*x4*xcp2 -64*e3e1^2*e2e1*amel2*x1^2*x4*xcp1 -64*e3e1^2*e2e1*amel2*x1^2*x3*xcp3 +128*e3e1^2*e2e1*amel2*x1^2*x3*xcp2 -64*e3e1^2*e2e1*amel2*x1^2*x3*xcp1 -512*e3e1^2*e2e1^2*xcp2 +1152*e3e1^2*e2e1^2*x5*xcp2 -768*e3e1^2*e2e1^2*x5^2*xcp2 +128*e3e1^2*e2e1^2*x5^3*xcp2 +1408*e3e1^2*e2e1^2*x4*xcp2 -1920*e3e1^2*e2e1^2*x4*x5*xcp2 +512*e3e1^2*e2e1^2*x4*x5^2*xcp2 -1152*e3e1^2*e2e1^2*x4^2*xcp2 +640*e3e1^2*e2e1^2*x4^2*x5*xcp2 +256*e3e1^2*e2e1^2*x4^3*xcp2 +1024*e3e1^2*e2e1^2*x3*xcp2 -1536*e3e1^2*e2e1^2*x3*x5*xcp2 +512*e3e1^2*e2e1^2*x3*x5^2*xcp2 -2048*e3e1^2*e2e1^2*x3*x4*xcp2 +1408*e3e1^2*e2e1^2*x3*x4*x5*xcp2 +896*e3e1^2*e2e1^2*x3*x4^2*xcp2 -512*e3e1^2*e2e1^2*x3^2*xcp2 +384*e3e1^2*e2e1^2*x3^2*x5*xcp2 +640*e3e1^2*e2e1^2*x3^2*x4*xcp2 +512*e3e1^2*e2e1^2*x1*xcp2 -768*e3e1^2*e2e1^2*x1*x5*xcp2 +256*e3e1^2*e2e1^2*x1*x5^2*xcp2 -768*e3e1^2*e2e1^2*x1*x4*xcp2 +512*e3e1^2*e2e1^2*x1*x4*x5*xcp2 +256*e3e1^2*e2e1^2*x1*x4^2*xcp2 -1024*e3e1^2*e2e1^2*x1*x3*xcp2 +768*e3e1^2*e2e1^2*x1*x3*x5*xcp2 +768*e3e1^2*e2e1^2*x1*x3*x4*xcp2 +512*e3e1^2*e2e1^2*x1*x3^2*xcp2 +128*e3e1^2*e3e2*zk^2*xcp2 -128*e3e1^2*e3e2*zk^2*x5*xcp2 -128*e3e1^2*e3e2*zk^2*x4*xcp2 -128*e3e1^2*e3e2*zk^2*x3*xcp2 +64*e3e1^2*e3e2*amel2*xcp3 +512*e3e1^2*e3e2*amel2*xcp2 +64*e3e1^2*e3e2*amel2*xcp1 -128*e3e1^2*e3e2*amel2*x5*xcp3 -1664*e3e1^2*e3e2*amel2*x5*xcp2 -128*e3e1^2*e3e2*amel2*x5*xcp1 +1664*e3e1^2*e3e2*amel2*x5^2*xcp2 +64*e3e1^2*e3e2*amel2*x5^3*xcp3 -512*e3e1^2*e3e2*amel2*x5^3*xcp2 +64*e3e1^2*e3e2*amel2*x5^3*xcp1 -1920*e3e1^2*e3e2*amel2*x4*xcp2 -256*e3e1^2*e3e2*amel2*x4*x5*xcp3 +3840*e3e1^2*e3e2*amel2*x4*x5*xcp2 -256*e3e1^2*e3e2*amel2*x4*x5*xcp1 +320*e3e1^2*e3e2*amel2*x4*x5^2*xcp3 -1792*e3e1^2*e3e2*amel2*x4*x5^2*xcp2 +320*e3e1^2*e3e2*amel2*x4*x5^2*xcp1 -256*e3e1^2*e3e2*amel2*x4^2*xcp3 +2304*e3e1^2*e3e2*amel2*x4^2*xcp2 -256*e3e1^2*e3e2*amel2*x4^2*xcp1 +448*e3e1^2*e3e2*amel2*x4^2*x5*xcp3 -2176*e3e1^2*e3e2*amel2*x4^2*x5*xcp2 +448*e3e1^2*e3e2*amel2*x4^2*x5*xcp1 +192*e3e1^2*e3e2*amel2*x4^3*xcp3 -896*e3e1^2*e3e2*amel2*x4^3*xcp2 +192*e3e1^2*e3e2*amel2*x4^3*xcp1 -64*e3e1^2*e3e2*amel2*x3*xcp3 -1280*e3e1^2*e3e2*amel2*x3*xcp2 -64*e3e1^2*e3e2*amel2*x3*xcp1 +2432*e3e1^2*e3e2*amel2*x3*x5*xcp2 +128*e3e1^2*e3e2*amel2*x3*x5^2*xcp3 -1024*e3e1^2*e3e2*amel2*x3*x5^2*xcp2 +128*e3e1^2*e3e2*amel2*x3*x5^2*xcp1 -128*e3e1^2*e3e2*amel2*x3*x4*xcp3 +2944*e3e1^2*e3e2*amel2*x3*x4*xcp2 -128*e3e1^2*e3e2*amel2*x3*x4*xcp1 +384*e3e1^2*e3e2*amel2*x3*x4*x5*xcp3 -2560*e3e1^2*e3e2*amel2*x3*x4*x5*xcp2 +384*e3e1^2*e3e2*amel2*x3*x4*x5*xcp1 +256*e3e1^2*e3e2*amel2*x3*x4^2*xcp3 -1664*e3e1^2*e3e2*amel2*x3*x4^2*xcp2 +256*e3e1^2*e3e2*amel2*x3*x4^2*xcp1 +896*e3e1^2*e3e2*amel2*x3^2*xcp2 +64*e3e1^2*e3e2*amel2*x3^2*x5*xcp3 -640*e3e1^2*e3e2*amel2*x3^2*x5*xcp2 +64*e3e1^2*e3e2*amel2*x3^2*x5*xcp1 +64*e3e1^2*e3e2*amel2*x3^2*x4*xcp3 -896*e3e1^2*e3e2*amel2*x3^2*x4*xcp2 +64*e3e1^2*e3e2*amel2*x3^2*x4*xcp1 -128*e3e1^2*e3e2*amel2*x3^3*xcp2 -64*e3e1^2*e3e2*amel2*x1*xcp3 -768*e3e1^2*e3e2*amel2*x1*xcp2 -64*e3e1^2*e3e2*amel2*x1*xcp1 +1664*e3e1^2*e3e2*amel2*x1*x5*xcp2 +64*e3e1^2*e3e2*amel2*x1*x5^2*xcp3 -896*e3e1^2*e3e2*amel2*x1*x5^2*xcp2 +64*e3e1^2*e3e2*amel2*x1*x5^2*xcp1 -128*e3e1^2*e3e2*amel2*x1*x4*xcp3 +1792*e3e1^2*e3e2*amel2*x1*x4*xcp2 -128*e3e1^2*e3e2*amel2*x1*x4*xcp1 +256*e3e1^2*e3e2*amel2*x1*x4*x5*xcp3 -1920*e3e1^2*e3e2*amel2*x1*x4*x5*xcp2 +256*e3e1^2*e3e2*amel2*x1*x4*x5*xcp1 +192*e3e1^2*e3e2*amel2*x1*x4^2*xcp3 -1024*e3e1^2*e3e2*amel2*x1*x4^2*xcp2 +192*e3e1^2*e3e2*amel2*x1*x4^2*xcp1 +1408*e3e1^2*e3e2*amel2*x1*x3*xcp2 +128*e3e1^2*e3e2*amel2*x1*x3*x5*xcp3 -1536*e3e1^2*e3e2*amel2*x1*x3*x5*xcp2 +128*e3e1^2*e3e2*amel2*x1*x3*x5*xcp1 +256*e3e1^2*e3e2*amel2*x1*x3*x4*xcp3 -1664*e3e1^2*e3e2*amel2*x1*x3*x4*xcp2 +256*e3e1^2*e3e2*amel2*x1*x3*x4*xcp1 +64*e3e1^2*e3e2*amel2*x1*x3^2*xcp3 -640*e3e1^2*e3e2*amel2*x1*x3^2*xcp2 +64*e3e1^2*e3e2*amel2*x1*x3^2*xcp1 +128*e3e1^2*e3e2*amel2*x1^2*xcp2 -128*e3e1^2*e3e2*amel2*x1^2*x5*xcp2 -128*e3e1^2*e3e2*amel2*x1^2*x4*xcp2 -128*e3e1^2*e3e2*amel2*x1^2*x3*xcp2 +768*e3e1^2*e3e2*e2e1*xcp2 -1920*e3e1^2*e3e2*e2e1*x5*xcp2 +1536*e3e1^2*e3e2*e2e1*x5^2*xcp2 -384*e3e1^2*e3e2*e2e1*x5^3*xcp2 -2432*e3e1^2*e3e2*e2e1*x4*xcp2 +3968*e3e1^2*e3e2*e2e1*x4*x5*xcp2 -1536*e3e1^2*e3e2*e2e1*x4*x5^2*xcp2 +2432*e3e1^2*e3e2*e2e1*x4^2*xcp2 -1920*e3e1^2*e3e2*e2e1*x4^2*x5*xcp2 -768*e3e1^2*e3e2*e2e1*x4^3*xcp2 -1536*e3e1^2*e3e2*e2e1*x3*xcp2 +2560*e3e1^2*e3e2*e2e1*x3*x5*xcp2 -1024*e3e1^2*e3e2*e2e1*x3*x5^2*xcp2 +3584*e3e1^2*e3e2*e2e1*x3*x4*xcp2 -2944*e3e1^2*e3e2*e2e1*x3*x4*x5*xcp2 -1920*e3e1^2*e3e2*e2e1*x3*x4^2*xcp2 +768*e3e1^2*e3e2*e2e1*x3^2*xcp2 -640*e3e1^2*e3e2*e2e1*x3^2*x5*xcp2 -1152*e3e1^2*e3e2*e2e1*x3^2*x4*xcp2 -768*e3e1^2*e3e2*e2e1*x1*xcp2 +1280*e3e1^2*e3e2*e2e1*x1*x5*xcp2 -512*e3e1^2*e3e2*e2e1*x1*x5^2*xcp2 +1280*e3e1^2*e3e2*e2e1*x1*x4*xcp2 -1024*e3e1^2*e3e2*e2e1*x1*x4*x5*xcp2 -512*e3e1^2*e3e2*e2e1*x1*x4^2*xcp2 +1536*e3e1^2*e3e2*e2e1*x1*x3*xcp2 -1280*e3e1^2*e3e2*e2e1*x1*x3*x5*xcp2 -1280*e3e1^2*e3e2*e2e1*x1*x3*x4*xcp2 -768*e3e1^2*e3e2*e2e1*x1*x3^2*xcp2 -256*e3e1^2*e3e2^2*xcp2 +768*e3e1^2*e3e2^2*x5*xcp2 -768*e3e1^2*e3e2^2*x5^2*xcp2 +256*e3e1^2*e3e2^2*x5^3*xcp2 +1024*e3e1^2*e3e2^2*x4*xcp2 -2048*e3e1^2*e3e2^2*x4*x5*xcp2 +1024*e3e1^2*e3e2^2*x4*x5^2*xcp2 -1280*e3e1^2*e3e2^2*x4^2*xcp2 +1280*e3e1^2*e3e2^2*x4^2*x5*xcp2 +512*e3e1^2*e3e2^2*x4^3*xcp2 +512*e3e1^2*e3e2^2*x3*xcp2 -1024*e3e1^2*e3e2^2*x3*x5*xcp2 +512*e3e1^2*e3e2^2*x3*x5^2*xcp2 -1536*e3e1^2*e3e2^2*x3*x4*xcp2 +1536*e3e1^2*e3e2^2*x3*x4*x5*xcp2 +1024*e3e1^2*e3e2^2*x3*x4^2*xcp2 -256*e3e1^2*e3e2^2*x3^2*xcp2 +256*e3e1^2*e3e2^2*x3^2*x5*xcp2 +512*e3e1^2*e3e2^2*x3^2*x4*xcp2 +256*e3e1^2*e3e2^2*x1*xcp2 -512*e3e1^2*e3e2^2*x1*x5*xcp2 +256*e3e1^2*e3e2^2*x1*x5^2*xcp2 -512*e3e1^2*e3e2^2*x1*x4*xcp2 +512*e3e1^2*e3e2^2*x1*x4*x5*xcp2 +256*e3e1^2*e3e2^2*x1*x4^2*xcp2 -512*e3e1^2*e3e2^2*x1*x3*xcp2 +512*e3e1^2*e3e2^2*x1*x3*x5*xcp2 +512*e3e1^2*e3e2^2*x1*x3*x4*xcp2 +256*e3e1^2*e3e2^2*x1*x3^2*xcp2 -64*e3e1^3*amel2*xcp3 -64*e3e1^3*amel2*xcp1 +192*e3e1^3*amel2*x5*xcp3 +192*e3e1^3*amel2*x5*xcp1 -192*e3e1^3*amel2*x5^2*xcp3 -192*e3e1^3*amel2*x5^2*xcp1 +64*e3e1^3*amel2*x5^3*xcp3 +64*e3e1^3*amel2*x5^3*xcp1 +192*e3e1^3*amel2*x4*xcp3 -128*e3e1^3*amel2*x4*xcp2 +192*e3e1^3*amel2*x4*xcp1 -384*e3e1^3*amel2*x4*x5*xcp3 +256*e3e1^3*amel2*x4*x5*xcp2 -384*e3e1^3*amel2*x4*x5*xcp1 +192*e3e1^3*amel2*x4*x5^2*xcp3 -128*e3e1^3*amel2*x4*x5^2*xcp2 +192*e3e1^3*amel2*x4*x5^2*xcp1 -192*e3e1^3*amel2*x4^2*xcp3 +256*e3e1^3*amel2*x4^2*xcp2 -192*e3e1^3*amel2*x4^2*xcp1 +192*e3e1^3*amel2*x4^2*x5*xcp3 -256*e3e1^3*amel2*x4^2*x5*xcp2 +192*e3e1^3*amel2*x4^2*x5*xcp1 +64*e3e1^3*amel2*x4^3*xcp3 -128*e3e1^3*amel2*x4^3*xcp2 +64*e3e1^3*amel2*x4^3*xcp1 +64*e3e1^3*amel2*x3*xcp3 -128*e3e1^3*amel2*x3*xcp2 +64*e3e1^3*amel2*x3*xcp1 -128*e3e1^3*amel2*x3*x5*xcp3 +256*e3e1^3*amel2*x3*x5*xcp2 -128*e3e1^3*amel2*x3*x5*xcp1 +64*e3e1^3*amel2*x3*x5^2*xcp3 -128*e3e1^3*amel2*x3*x5^2*xcp2 +64*e3e1^3*amel2*x3*x5^2*xcp1 -128*e3e1^3*amel2*x3*x4*xcp3 +384*e3e1^3*amel2*x3*x4*xcp2 -128*e3e1^3*amel2*x3*x4*xcp1 +128*e3e1^3*amel2*x3*x4*x5*xcp3 -384*e3e1^3*amel2*x3*x4*x5*xcp2 +128*e3e1^3*amel2*x3*x4*x5*xcp1 +64*e3e1^3*amel2*x3*x4^2*xcp3 -256*e3e1^3*amel2*x3*x4^2*xcp2 +64*e3e1^3*amel2*x3*x4^2*xcp1 +128*e3e1^3*amel2*x3^2*xcp2 -128*e3e1^3*amel2*x3^2*x5*xcp2 -128*e3e1^3*amel2*x3^2*x4*xcp2 +128*e3e1^3*amel2*x1*xcp3 +128*e3e1^3*amel2*x1*xcp1 -256*e3e1^3*amel2*x1*x5*xcp3 -256*e3e1^3*amel2*x1*x5*xcp1 +128*e3e1^3*amel2*x1*x5^2*xcp3 +128*e3e1^3*amel2*x1*x5^2*xcp1 -256*e3e1^3*amel2*x1*x4*xcp3 +128*e3e1^3*amel2*x1*x4*xcp2 -256*e3e1^3*amel2*x1*x4*xcp1 +256*e3e1^3*amel2*x1*x4*x5*xcp3 -128*e3e1^3*amel2*x1*x4*x5*xcp2 +256*e3e1^3*amel2*x1*x4*x5*xcp1 +128*e3e1^3*amel2*x1*x4^2*xcp3 -128*e3e1^3*amel2*x1*x4^2*xcp2 +128*e3e1^3*amel2*x1*x4^2*xcp1 -128*e3e1^3*amel2*x1*x3*xcp3 +128*e3e1^3*amel2*x1*x3*xcp2 -128*e3e1^3*amel2*x1*x3*xcp1 +128*e3e1^3*amel2*x1*x3*x5*xcp3 -128*e3e1^3*amel2*x1*x3*x5*xcp2 +128*e3e1^3*amel2*x1*x3*x5*xcp1 +128*e3e1^3*amel2*x1*x3*x4*xcp3 -256*e3e1^3*amel2*x1*x3*x4*xcp2 +128*e3e1^3*amel2*x1*x3*x4*xcp1 -128*e3e1^3*amel2*x1*x3^2*xcp2 -64*e3e1^3*amel2*x1^2*xcp3 -64*e3e1^3*amel2*x1^2*xcp1 +64*e3e1^3*amel2*x1^2*x5*xcp3 +64*e3e1^3*amel2*x1^2*x5*xcp1 +64*e3e1^3*amel2*x1^2*x4*xcp3 +64*e3e1^3*amel2*x1^2*x4*xcp1 +64*e3e1^3*amel2*x1^2*x3*xcp3 +64*e3e1^3*amel2*x1^2*x3*xcp1 +256*e3e1^3*e2e1*xcp2 -640*e3e1^3*e2e1*x5*xcp2 +512*e3e1^3*e2e1*x5^2*xcp2 -128*e3e1^3*e2e1*x5^3*xcp2 -640*e3e1^3*e2e1*x4*xcp2 +1024*e3e1^3*e2e1*x4*x5*xcp2 -384*e3e1^3*e2e1*x4*x5^2*xcp2 +512*e3e1^3*e2e1*x4^2*xcp2 -384*e3e1^3*e2e1*x4^2*x5*xcp2 -128*e3e1^3*e2e1*x4^3*xcp2 -512*e3e1^3*e2e1*x3*xcp2 +896*e3e1^3*e2e1*x3*x5*xcp2 -384*e3e1^3*e2e1*x3*x5^2*xcp2 +896*e3e1^3*e2e1*x3*x4*xcp2 -768*e3e1^3*e2e1*x3*x4*x5*xcp2 -384*e3e1^3*e2e1*x3*x4^2*xcp2 +256*e3e1^3*e2e1*x3^2*xcp2 -256*e3e1^3*e2e1*x3^2*x5*xcp2 -256*e3e1^3*e2e1*x3^2*x4*xcp2 -256*e3e1^3*e2e1*x1*xcp2 +384*e3e1^3*e2e1*x1*x5*xcp2 -128*e3e1^3*e2e1*x1*x5^2*xcp2 +384*e3e1^3*e2e1*x1*x4*xcp2 -256*e3e1^3*e2e1*x1*x4*x5*xcp2 -128*e3e1^3*e2e1*x1*x4^2*xcp2 +512*e3e1^3*e2e1*x1*x3*xcp2 -384*e3e1^3*e2e1*x1*x3*x5*xcp2 -384*e3e1^3*e2e1*x1*x3*x4*xcp2 -256*e3e1^3*e2e1*x1*x3^2*xcp2 -256*e3e1^3*e3e2*xcp2 +768*e3e1^3*e3e2*x5*xcp2 -768*e3e1^3*e3e2*x5^2*xcp2 +256*e3e1^3*e3e2*x5^3*xcp2 +768*e3e1^3*e3e2*x4*xcp2 -1536*e3e1^3*e3e2*x4*x5*xcp2 +768*e3e1^3*e3e2*x4*x5^2*xcp2 -768*e3e1^3*e3e2*x4^2*xcp2 +768*e3e1^3*e3e2*x4^2*x5*xcp2 +256*e3e1^3*e3e2*x4^3*xcp2 +512*e3e1^3*e3e2*x3*xcp2 -1024*e3e1^3*e3e2*x3*x5*xcp2 +512*e3e1^3*e3e2*x3*x5^2*xcp2 -1024*e3e1^3*e3e2*x3*x4*xcp2 +1024*e3e1^3*e3e2*x3*x4*x5*xcp2 +512*e3e1^3*e3e2*x3*x4^2*xcp2 -256*e3e1^3*e3e2*x3^2*xcp2 +256*e3e1^3*e3e2*x3^2*x5*xcp2 +256*e3e1^3*e3e2*x3^2*x4*xcp2 +256*e3e1^3*e3e2*x1*xcp2 -512*e3e1^3*e3e2*x1*x5*xcp2 +256*e3e1^3*e3e2*x1*x5^2*xcp2 -512*e3e1^3*e3e2*x1*x4*xcp2 +512*e3e1^3*e3e2*x1*x4*x5*xcp2 +256*e3e1^3*e3e2*x1*x4^2*xcp2 -512*e3e1^3*e3e2*x1*x3*xcp2 +512*e3e1^3*e3e2*x1*x3*x5*xcp2 +512*e3e1^3*e3e2*x1*x3*x4*xcp2 +256*e3e1^3*e3e2*x1*x3^2*xcp2 -48*e4e2*amel2^2*zk^2*xcp3 -64*e4e2*amel2^2*zk^2*xcp2 -48*e4e2*amel2^2*zk^2*xcp1 +48*e4e2*amel2^2*zk^2*x5*xcp3 -64*e4e2*amel2^2*zk^2*x5*xcp2 +48*e4e2*amel2^2*zk^2*x5*xcp1 +96*e4e2*amel2^2*zk^2*x4*xcp3 +96*e4e2*amel2^2*zk^2*x4*xcp1 +64*e4e2*amel2^2*zk^2*x3*xcp2 +48*e4e2*amel2^2*zk^2*x1*xcp3 +32*e4e2*amel2^2*zk^2*x1*xcp2 +48*e4e2*amel2^2*zk^2*x1*xcp1 -256*e4e2*amel2^3*x5*xcp2 -32*e4e2*amel2^3*x5^2*xcp3 -32*e4e2*amel2^3*x5^2*xcp1 +32*e4e2*amel2^3*x5^3*xcp3 +32*e4e2*amel2^3*x5^3*xcp1 +64*e4e2*amel2^3*x4*xcp3 -256*e4e2*amel2^3*x4*xcp2 +64*e4e2*amel2^3*x4*xcp1 -64*e4e2*amel2^3*x4*x5*xcp3 +192*e4e2*amel2^3*x4*x5*xcp2 -64*e4e2*amel2^3*x4*x5*xcp1 +128*e4e2*amel2^3*x4*x5^2*xcp3 -64*e4e2*amel2^3*x4*x5^2*xcp2 +128*e4e2*amel2^3*x4*x5^2*xcp1 -128*e4e2*amel2^3*x4^2*xcp3 +128*e4e2*amel2^3*x4^2*xcp2 -128*e4e2*amel2^3*x4^2*xcp1 +192*e4e2*amel2^3*x4^2*x5*xcp3 -256*e4e2*amel2^3*x4^2*x5*xcp2 +192*e4e2*amel2^3*x4^2*x5*xcp1 +128*e4e2*amel2^3*x4^3*xcp3 -128*e4e2*amel2^3*x4^3*xcp2 +128*e4e2*amel2^3*x4^3*xcp1 -64*e4e2*amel2^3*x3*xcp3 -64*e4e2*amel2^3*x3*xcp1 +64*e4e2*amel2^3*x3*x5*xcp3 +448*e4e2*amel2^3*x3*x5*xcp2 +64*e4e2*amel2^3*x3*x5*xcp1 -64*e4e2*amel2^3*x3*x5^2*xcp2 -128*e4e2*amel2^3*x3*x4*xcp3 +320*e4e2*amel2^3*x3*x4*xcp2 -128*e4e2*amel2^3*x3*x4*xcp1 +64*e4e2*amel2^3*x3*x4*x5*xcp3 -384*e4e2*amel2^3*x3*x4*x5*xcp2 +64*e4e2*amel2^3*x3*x4*x5*xcp1 +128*e4e2*amel2^3*x3*x4^2*xcp3 -128*e4e2*amel2^3*x3*x4^2*xcp2 +128*e4e2*amel2^3*x3*x4^2*xcp1 -32*e4e2*amel2^3*x3^2*xcp3 -64*e4e2*amel2^3*x3^2*xcp2 -32*e4e2*amel2^3*x3^2*xcp1 +32*e4e2*amel2^3*x3^2*x5*xcp3 -128*e4e2*amel2^3*x3^2*x5*xcp2 +32*e4e2*amel2^3*x3^2*x5*xcp1 +64*e4e2*amel2^3*x3^2*x4*xcp3 +64*e4e2*amel2^3*x3^2*x4*xcp2 +64*e4e2*amel2^3*x3^2*x4*xcp1 +64*e4e2*amel2^3*x3^3*xcp2 -128*e4e2*amel2^3*x1*xcp2 +256*e4e2*amel2^3*x1*x5*xcp2 +96*e4e2*amel2^3*x1*x5^2*xcp3 -128*e4e2*amel2^3*x1*x5^2*xcp2 +96*e4e2*amel2^3*x1*x5^2*xcp1 -128*e4e2*amel2^3*x1*x4*xcp3 +576*e4e2*amel2^3*x1*x4*xcp2 -128*e4e2*amel2^3*x1*x4*xcp1 +256*e4e2*amel2^3*x1*x4*x5*xcp3 -512*e4e2*amel2^3*x1*x4*x5*xcp2 +256*e4e2*amel2^3*x1*x4*x5*xcp1 +192*e4e2*amel2^3*x1*x4^2*xcp3 -256*e4e2*amel2^3*x1*x4^2*xcp2 +192*e4e2*amel2^3*x1*x4^2*xcp1 -128*e4e2*amel2^3*x1*x3*xcp3 +448*e4e2*amel2^3*x1*x3*xcp2 -128*e4e2*amel2^3*x1*x3*xcp1 -512*e4e2*amel2^3*x1*x3*x5*xcp2 +192*e4e2*amel2^3*x1*x3*x4*xcp3 -256*e4e2*amel2^3*x1*x3*x4*xcp2 +192*e4e2*amel2^3*x1*x3*x4*xcp1 +32*e4e2*amel2^3*x1*x3^2*xcp3 +128*e4e2*amel2^3*x1*x3^2*xcp2 +32*e4e2*amel2^3*x1*x3^2*xcp1 -96*e4e2*amel2^3*x1^2*xcp3 -96*e4e2*amel2^3*x1^2*xcp1 +96*e4e2*amel2^3*x1^2*x5*xcp3 -128*e4e2*amel2^3*x1^2*x5*xcp2 +96*e4e2*amel2^3*x1^2*x5*xcp1 +128*e4e2*amel2^3*x1^2*x4*xcp3 -64*e4e2*amel2^3*x1^2*x4*xcp2 +128*e4e2*amel2^3*x1^2*x4*xcp1 +64*e4e2*amel2^3*x1^2*x3*xcp3 +64*e4e2*amel2^3*x1^2*x3*xcp2 +64*e4e2*amel2^3*x1^2*x3*xcp1 +32*e4e2*amel2^3*x1^3*xcp3 +32*e4e2*amel2^3*x1^3*xcp1 -16*e4e2*e2e1*amel2*zk^2*xcp3 -160*e4e2*e2e1*amel2*zk^2*xcp2 -16*e4e2*e2e1*amel2*zk^2*xcp1 +96*e4e2*e2e1*amel2*zk^2*x5*xcp3 -32*e4e2*e2e1*amel2*zk^2*x5*xcp2 +96*e4e2*e2e1*amel2*zk^2*x5*xcp1 +96*e4e2*e2e1*amel2*zk^2*x4*xcp3 +64*e4e2*e2e1*amel2*zk^2*x4*xcp2 +96*e4e2*e2e1*amel2*zk^2*x4*xcp1 +96*e4e2*e2e1*amel2*zk^2*x3*xcp3 +32*e4e2*e2e1*amel2*zk^2*x3*xcp2 +96*e4e2*e2e1*amel2*zk^2*x3*xcp1 +128*e4e2*e2e1*amel2*zk^2*x1*xcp2 -512*e4e2*e2e1*amel2^2*x5*xcp2 -448*e4e2*e2e1*amel2^2*x5^2*xcp2 +64*e4e2*e2e1*amel2^2*x5^3*xcp3 +320*e4e2*e2e1*amel2^2*x5^3*xcp2 +64*e4e2*e2e1*amel2^2*x5^3*xcp1 -512*e4e2*e2e1*amel2^2*x4*xcp2 -64*e4e2*e2e1*amel2^2*x4*x5*xcp3 -64*e4e2*e2e1*amel2^2*x4*x5*xcp2 -64*e4e2*e2e1*amel2^2*x4*x5*xcp1 +256*e4e2*e2e1*amel2^2*x4*x5^2*xcp3 +320*e4e2*e2e1*amel2^2*x4*x5^2*xcp2 +256*e4e2*e2e1*amel2^2*x4*x5^2*xcp1 -192*e4e2*e2e1*amel2^2*x4^2*xcp3 +256*e4e2*e2e1*amel2^2*x4^2*xcp2 -192*e4e2*e2e1*amel2^2*x4^2*xcp1 +448*e4e2*e2e1*amel2^2*x4^2*x5*xcp3 -384*e4e2*e2e1*amel2^2*x4^2*x5*xcp2 +448*e4e2*e2e1*amel2^2*x4^2*x5*xcp1 +256*e4e2*e2e1*amel2^2*x4^3*xcp3 -256*e4e2*e2e1*amel2^2*x4^3*xcp2 +256*e4e2*e2e1*amel2^2*x4^3*xcp1 -128*e4e2*e2e1*amel2^2*x3*xcp3 -128*e4e2*e2e1*amel2^2*x3*xcp1 +128*e4e2*e2e1*amel2^2*x3*x5*xcp3 +832*e4e2*e2e1*amel2^2*x3*x5*xcp2 +128*e4e2*e2e1*amel2^2*x3*x5*xcp1 -128*e4e2*e2e1*amel2^2*x3*x4*xcp3 +832*e4e2*e2e1*amel2^2*x3*x4*xcp2 -128*e4e2*e2e1*amel2^2*x3*x4*xcp1 +192*e4e2*e2e1*amel2^2*x3*x4*x5*xcp3 -1152*e4e2*e2e1*amel2^2*x3*x4*x5*xcp2 +192*e4e2*e2e1*amel2^2*x3*x4*x5*xcp1 +384*e4e2*e2e1*amel2^2*x3*x4^2*xcp3 -640*e4e2*e2e1*amel2^2*x3*x4^2*xcp2 +384*e4e2*e2e1*amel2^2*x3*x4^2*xcp1 +128*e4e2*e2e1*amel2^2*x3^2*xcp2 +64*e4e2*e2e1*amel2^2*x3^2*x5*xcp3 -576*e4e2*e2e1*amel2^2*x3^2*x5*xcp2 +64*e4e2*e2e1*amel2^2*x3^2*x5*xcp1 +192*e4e2*e2e1*amel2^2*x3^2*x4*xcp3 -192*e4e2*e2e1*amel2^2*x3^2*x4*xcp2 +192*e4e2*e2e1*amel2^2*x3^2*x4*xcp1 +64*e4e2*e2e1*amel2^2*x3^3*xcp3 +64*e4e2*e2e1*amel2^2*x3^3*xcp1 -128*e4e2*e2e1*amel2^2*x1*xcp3 -384*e4e2*e2e1*amel2^2*x1*xcp2 -128*e4e2*e2e1*amel2^2*x1*xcp1 +64*e4e2*e2e1*amel2^2*x1*x5*xcp3 +768*e4e2*e2e1*amel2^2*x1*x5*xcp2 +64*e4e2*e2e1*amel2^2*x1*x5*xcp1 +128*e4e2*e2e1*amel2^2*x1*x5^2*xcp3 -320*e4e2*e2e1*amel2^2*x1*x5^2*xcp2 +128*e4e2*e2e1*amel2^2*x1*x5^2*xcp1 -256*e4e2*e2e1*amel2^2*x1*x4*xcp3 +960*e4e2*e2e1*amel2^2*x1*x4*xcp2 -256*e4e2*e2e1*amel2^2*x1*x4*xcp1 +384*e4e2*e2e1*amel2^2*x1*x4*x5*xcp3 -1152*e4e2*e2e1*amel2^2*x1*x4*x5*xcp2 +384*e4e2*e2e1*amel2^2*x1*x4*x5*xcp1 +320*e4e2*e2e1*amel2^2*x1*x4^2*xcp3 -384*e4e2*e2e1*amel2^2*x1*x4^2*xcp2 +320*e4e2*e2e1*amel2^2*x1*x4^2*xcp1 -64*e4e2*e2e1*amel2^2*x1*x3*xcp3 +832*e4e2*e2e1*amel2^2*x1*x3*xcp2 -64*e4e2*e2e1*amel2^2*x1*x3*xcp1 +256*e4e2*e2e1*amel2^2*x1*x3*x5*xcp3 -1280*e4e2*e2e1*amel2^2*x1*x3*x5*xcp2 +256*e4e2*e2e1*amel2^2*x1*x3*x5*xcp1 +448*e4e2*e2e1*amel2^2*x1*x3*x4*xcp3 -640*e4e2*e2e1*amel2^2*x1*x3*x4*xcp2 +448*e4e2*e2e1*amel2^2*x1*x3*x4*xcp1 +128*e4e2*e2e1*amel2^2*x1*x3^2*xcp3 -64*e4e2*e2e1*amel2^2*x1*x3^2*xcp2 +128*e4e2*e2e1*amel2^2*x1*x3^2*xcp1 -64*e4e2*e2e1*amel2^2*x1^2*xcp3 -64*e4e2*e2e1*amel2^2*x1^2*xcp2 -64*e4e2*e2e1*amel2^2*x1^2*xcp1 +64*e4e2*e2e1*amel2^2*x1^2*x5*xcp3 -192*e4e2*e2e1*amel2^2*x1^2*x5*xcp2 +64*e4e2*e2e1*amel2^2*x1^2*x5*xcp1 +128*e4e2*e2e1*amel2^2*x1^2*x4*xcp3 -64*e4e2*e2e1*amel2^2*x1^2*x4*xcp2 +128*e4e2*e2e1*amel2^2*x1^2*x4*xcp1 +128*e4e2*e2e1*amel2^2*x1^2*x3*xcp3 +128*e4e2*e2e1*amel2^2*x1^2*x3*xcp2 +128*e4e2*e2e1*amel2^2*x1^2*x3*xcp1 +64*e4e2*e2e1*amel2^2*x1^3*xcp2 +64*e4e2*e2e1^2*zk^2*xcp2 +64*e4e2*e2e1^2*zk^2*x4*xcp2 -64*e4e2*e2e1^2*zk^2*x3*xcp2 +128*e4e2*e2e1^2*amel2*x5*xcp3 -256*e4e2*e2e1^2*amel2*x5*xcp2 +128*e4e2*e2e1^2*amel2*x5*xcp1 -64*e4e2*e2e1^2*amel2*x5^2*xcp3 -896*e4e2*e2e1^2*amel2*x5^2*xcp2 -64*e4e2*e2e1^2*amel2*x5^2*xcp1 +640*e4e2*e2e1^2*amel2*x5^3*xcp2 -64*e4e2*e2e1^2*amel2*x4*xcp3 -640*e4e2*e2e1^2*amel2*x4*xcp2 -64*e4e2*e2e1^2*amel2*x4*xcp1 -512*e4e2*e2e1^2*amel2*x4*x5*xcp2 +128*e4e2*e2e1^2*amel2*x4*x5^2*xcp3 +1024*e4e2*e2e1^2*amel2*x4*x5^2*xcp2 +128*e4e2*e2e1^2*amel2*x4*x5^2*xcp1 -64*e4e2*e2e1^2*amel2*x4^2*xcp3 +384*e4e2*e2e1^2*amel2*x4^2*xcp2 -64*e4e2*e2e1^2*amel2*x4^2*xcp1 +256*e4e2*e2e1^2*amel2*x4^2*x5*xcp3 +128*e4e2*e2e1^2*amel2*x4^2*x5*xcp2 +256*e4e2*e2e1^2*amel2*x4^2*x5*xcp1 +128*e4e2*e2e1^2*amel2*x4^3*xcp3 -128*e4e2*e2e1^2*amel2*x4^3*xcp2 +128*e4e2*e2e1^2*amel2*x4^3*xcp1 -64*e4e2*e2e1^2*amel2*x3*xcp3 -64*e4e2*e2e1^2*amel2*x3*xcp1 +128*e4e2*e2e1^2*amel2*x3*x5*xcp2 -64*e4e2*e2e1^2*amel2*x3*x5^2*xcp3 +512*e4e2*e2e1^2*amel2*x3*x5^2*xcp2 -64*e4e2*e2e1^2*amel2*x3*x5^2*xcp1 +1152*e4e2*e2e1^2*amel2*x3*x4*xcp2 +128*e4e2*e2e1^2*amel2*x3*x4*x5*xcp3 -640*e4e2*e2e1^2*amel2*x3*x4*x5*xcp2 +128*e4e2*e2e1^2*amel2*x3*x4*x5*xcp1 +256*e4e2*e2e1^2*amel2*x3*x4^2*xcp3 -768*e4e2*e2e1^2*amel2*x3*x4^2*xcp2 +256*e4e2*e2e1^2*amel2*x3*x4^2*xcp1 +256*e4e2*e2e1^2*amel2*x3^2*xcp2 -128*e4e2*e2e1^2*amel2*x3^2*x5*xcp3 -256*e4e2*e2e1^2*amel2*x3^2*x5*xcp2 -128*e4e2*e2e1^2*amel2*x3^2*x5*xcp1 +128*e4e2*e2e1^2*amel2*x3^2*x4*xcp3 -512*e4e2*e2e1^2*amel2*x3^2*x4*xcp2 +128*e4e2*e2e1^2*amel2*x3^2*x4*xcp1 -128*e4e2*e2e1^2*amel2*x3^3*xcp2 -640*e4e2*e2e1^2*amel2*x1*xcp2 -64*e4e2*e2e1^2*amel2*x1*x5*xcp3 +1152*e4e2*e2e1^2*amel2*x1*x5*xcp2 -64*e4e2*e2e1^2*amel2*x1*x5*xcp1 -384*e4e2*e2e1^2*amel2*x1*x5^2*xcp2 -128*e4e2*e2e1^2*amel2*x1*x4*xcp3 +384*e4e2*e2e1^2*amel2*x1*x4*xcp2 -128*e4e2*e2e1^2*amel2*x1*x4*xcp1 +128*e4e2*e2e1^2*amel2*x1*x4*x5*xcp3 -640*e4e2*e2e1^2*amel2*x1*x4*x5*xcp2 +128*e4e2*e2e1^2*amel2*x1*x4*x5*xcp1 +128*e4e2*e2e1^2*amel2*x1*x4^2*xcp3 -128*e4e2*e2e1^2*amel2*x1*x4^2*xcp2 +128*e4e2*e2e1^2*amel2*x1*x4^2*xcp1 -64*e4e2*e2e1^2*amel2*x1*x3*xcp3 +640*e4e2*e2e1^2*amel2*x1*x3*xcp2 -64*e4e2*e2e1^2*amel2*x1*x3*xcp1 +128*e4e2*e2e1^2*amel2*x1*x3*x5*xcp3 -1024*e4e2*e2e1^2*amel2*x1*x3*x5*xcp2 +128*e4e2*e2e1^2*amel2*x1*x3*x5*xcp1 +256*e4e2*e2e1^2*amel2*x1*x3*x4*xcp3 -384*e4e2*e2e1^2*amel2*x1*x3*x4*xcp2 +256*e4e2*e2e1^2*amel2*x1*x3*x4*xcp1 +128*e4e2*e2e1^2*amel2*x1*x3^2*xcp3 -256*e4e2*e2e1^2*amel2*x1*x3^2*xcp2 +128*e4e2*e2e1^2*amel2*x1*x3^2*xcp1 +256*e4e2*e2e1^2*amel2*x1^2*xcp2 -256*e4e2*e2e1^2*amel2*x1^2*x5*xcp2 +384*e4e2*e2e1^3*x5*xcp2 -768*e4e2*e2e1^3*x5^2*xcp2 +384*e4e2*e2e1^3*x5^3*xcp2 -384*e4e2*e2e1^3*x4*xcp2 -256*e4e2*e2e1^3*x4*x5*xcp2 +640*e4e2*e2e1^3*x4*x5^2*xcp2 +256*e4e2*e2e1^3*x4^2*xcp2 +256*e4e2*e2e1^3*x4^2*x5*xcp2 -640*e4e2*e2e1^3*x3*x5*xcp2 +640*e4e2*e2e1^3*x3*x5^2*xcp2 +640*e4e2*e2e1^3*x3*x4*xcp2 +128*e4e2*e2e1^3*x3*x4*x5*xcp2 -256*e4e2*e2e1^3*x3*x4^2*xcp2 +256*e4e2*e2e1^3*x3^2*x5*xcp2 -256*e4e2*e2e1^3*x3^2*x4*xcp2 +32*e4e2*e3e2*amel2*zk^2*xcp3 +32*e4e2*e3e2*amel2*zk^2*xcp2 +32*e4e2*e3e2*amel2*zk^2*xcp1 -96*e4e2*e3e2*amel2*zk^2*x5*xcp3 +96*e4e2*e3e2*amel2*zk^2*x5*xcp2 -96*e4e2*e3e2*amel2*zk^2*x5*xcp1 -48*e4e2*e3e2*amel2*zk^2*x4*xcp3 -48*e4e2*e3e2*amel2*zk^2*x4*xcp1 -48*e4e2*e3e2*amel2*zk^2*x3*xcp3 -32*e4e2*e3e2*amel2*zk^2*x3*xcp2 -48*e4e2*e3e2*amel2*zk^2*x3*xcp1 +256*e4e2*e3e2*amel2^2*x5*xcp2 +320*e4e2*e3e2*amel2^2*x5^2*xcp2 -64*e4e2*e3e2*amel2^2*x5^3*xcp3 -192*e4e2*e3e2*amel2^2*x5^3*xcp2 -64*e4e2*e3e2*amel2^2*x5^3*xcp1 +64*e4e2*e3e2*amel2^2*x4*xcp3 +256*e4e2*e3e2*amel2^2*x4*xcp2 +64*e4e2*e3e2*amel2^2*x4*xcp1 +128*e4e2*e3e2*amel2^2*x4*x5*xcp3 -192*e4e2*e3e2*amel2^2*x4*x5*xcp2 +128*e4e2*e3e2*amel2^2*x4*x5*xcp1 -224*e4e2*e3e2*amel2^2*x4*x5^2*xcp3 +64*e4e2*e3e2*amel2^2*x4*x5^2*xcp2 -224*e4e2*e3e2*amel2^2*x4*x5^2*xcp1 +256*e4e2*e3e2*amel2^2*x4^2*xcp3 -384*e4e2*e3e2*amel2^2*x4^2*xcp2 +256*e4e2*e3e2*amel2^2*x4^2*xcp1 -384*e4e2*e3e2*amel2^2*x4^2*x5*xcp3 +640*e4e2*e3e2*amel2^2*x4^2*x5*xcp2 -384*e4e2*e3e2*amel2^2*x4^2*x5*xcp1 -192*e4e2*e3e2*amel2^2*x4^3*xcp3 +256*e4e2*e3e2*amel2^2*x4^3*xcp2 -192*e4e2*e3e2*amel2^2*x4^3*xcp1 +64*e4e2*e3e2*amel2^2*x3*xcp3 +64*e4e2*e3e2*amel2^2*x3*xcp1 -64*e4e2*e3e2*amel2^2*x3*x5*xcp3 -576*e4e2*e3e2*amel2^2*x3*x5*xcp2 -64*e4e2*e3e2*amel2^2*x3*x5*xcp1 +32*e4e2*e3e2*amel2^2*x3*x5^2*xcp3 +32*e4e2*e3e2*amel2^2*x3*x5^2*xcp1 +192*e4e2*e3e2*amel2^2*x3*x4*xcp3 -576*e4e2*e3e2*amel2^2*x3*x4*xcp2 +192*e4e2*e3e2*amel2^2*x3*x4*xcp1 -128*e4e2*e3e2*amel2^2*x3*x4*x5*xcp3 +896*e4e2*e3e2*amel2^2*x3*x4*x5*xcp2 -128*e4e2*e3e2*amel2^2*x3*x4*x5*xcp1 -256*e4e2*e3e2*amel2^2*x3*x4^2*xcp3 +384*e4e2*e3e2*amel2^2*x3*x4^2*xcp2 -256*e4e2*e3e2*amel2^2*x3*x4^2*xcp1 -128*e4e2*e3e2*amel2^2*x3^2*xcp2 -64*e4e2*e3e2*amel2^2*x3^2*x5*xcp3 +448*e4e2*e3e2*amel2^2*x3^2*x5*xcp2 -64*e4e2*e3e2*amel2^2*x3^2*x5*xcp1 -96*e4e2*e3e2*amel2^2*x3^2*x4*xcp3 +64*e4e2*e3e2*amel2^2*x3^2*x4*xcp2 -96*e4e2*e3e2*amel2^2*x3^2*x4*xcp1 -32*e4e2*e3e2*amel2^2*x3^3*xcp3 -32*e4e2*e3e2*amel2^2*x3^3*xcp1 +128*e4e2*e3e2*amel2^2*x1*xcp3 +256*e4e2*e3e2*amel2^2*x1*xcp2 +128*e4e2*e3e2*amel2^2*x1*xcp1 -32*e4e2*e3e2*amel2^2*x1*x5*xcp3 -704*e4e2*e3e2*amel2^2*x1*x5*xcp2 -32*e4e2*e3e2*amel2^2*x1*x5*xcp1 -128*e4e2*e3e2*amel2^2*x1*x5^2*xcp3 +256*e4e2*e3e2*amel2^2*x1*x5^2*xcp2 -128*e4e2*e3e2*amel2^2*x1*x5^2*xcp1 +64*e4e2*e3e2*amel2^2*x1*x4*xcp3 -1152*e4e2*e3e2*amel2^2*x1*x4*xcp2 +64*e4e2*e3e2*amel2^2*x1*x4*xcp1 -256*e4e2*e3e2*amel2^2*x1*x4*x5*xcp3 +1024*e4e2*e3e2*amel2^2*x1*x4*x5*xcp2 -256*e4e2*e3e2*amel2^2*x1*x4*x5*xcp1 -128*e4e2*e3e2*amel2^2*x1*x4^2*xcp3 +512*e4e2*e3e2*amel2^2*x1*x4^2*xcp2 -128*e4e2*e3e2*amel2^2*x1*x4^2*xcp1 +32*e4e2*e3e2*amel2^2*x1*x3*xcp3 -960*e4e2*e3e2*amel2^2*x1*x3*xcp2 +32*e4e2*e3e2*amel2^2*x1*x3*xcp1 -128*e4e2*e3e2*amel2^2*x1*x3*x5*xcp3 +1024*e4e2*e3e2*amel2^2*x1*x3*x5*xcp2 -128*e4e2*e3e2*amel2^2*x1*x3*x5*xcp1 -192*e4e2*e3e2*amel2^2*x1*x3*x4*xcp3 +768*e4e2*e3e2*amel2^2*x1*x3*x4*xcp2 -192*e4e2*e3e2*amel2^2*x1*x3*x4*xcp1 -64*e4e2*e3e2*amel2^2*x1*x3^2*xcp3 +256*e4e2*e3e2*amel2^2*x1*x3^2*xcp2 -64*e4e2*e3e2*amel2^2*x1*x3^2*xcp1 +32*e4e2*e3e2*amel2^2*x1^2*xcp3 +32*e4e2*e3e2*amel2^2*x1^2*xcp1 -64*e4e2*e3e2*amel2^2*x1^2*x5*xcp3 +192*e4e2*e3e2*amel2^2*x1^2*x5*xcp2 -64*e4e2*e3e2*amel2^2*x1^2*x5*xcp1 -32*e4e2*e3e2*amel2^2*x1^2*x4*xcp3 +64*e4e2*e3e2*amel2^2*x1^2*x4*xcp2 -32*e4e2*e3e2*amel2^2*x1^2*x4*xcp1 -32*e4e2*e3e2*amel2^2*x1^2*x3*xcp3 -32*e4e2*e3e2*amel2^2*x1^2*x3*xcp1 -64*e4e2*e3e2*e2e1*zk^2*xcp2 -64*e4e2*e3e2*e2e1*zk^2*x4*xcp2 +64*e4e2*e3e2*e2e1*zk^2*x3*xcp2 -128*e4e2*e3e2*e2e1*amel2*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x5*xcp2 -128*e4e2*e3e2*e2e1*amel2*x5*xcp1 +64*e4e2*e3e2*e2e1*amel2*x5^2*xcp3 +1152*e4e2*e3e2*e2e1*amel2*x5^2*xcp2 +64*e4e2*e3e2*e2e1*amel2*x5^2*xcp1 -768*e4e2*e3e2*e2e1*amel2*x5^3*xcp2 +64*e4e2*e3e2*e2e1*amel2*x4*xcp3 +1024*e4e2*e3e2*e2e1*amel2*x4*xcp2 +64*e4e2*e3e2*e2e1*amel2*x4*xcp1 +128*e4e2*e3e2*e2e1*amel2*x4*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x4*x5*xcp2 +128*e4e2*e3e2*e2e1*amel2*x4*x5*xcp1 -256*e4e2*e3e2*e2e1*amel2*x4*x5^2*xcp3 -896*e4e2*e3e2*e2e1*amel2*x4*x5^2*xcp2 -256*e4e2*e3e2*e2e1*amel2*x4*x5^2*xcp1 +192*e4e2*e3e2*e2e1*amel2*x4^2*xcp3 -640*e4e2*e3e2*e2e1*amel2*x4^2*xcp2 +192*e4e2*e3e2*e2e1*amel2*x4^2*xcp1 -448*e4e2*e3e2*e2e1*amel2*x4^2*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x4^2*x5*xcp2 -448*e4e2*e3e2*e2e1*amel2*x4^2*x5*xcp1 -192*e4e2*e3e2*e2e1*amel2*x4^3*xcp3 +256*e4e2*e3e2*e2e1*amel2*x4^3*xcp2 -192*e4e2*e3e2*e2e1*amel2*x4^3*xcp1 +64*e4e2*e3e2*e2e1*amel2*x3*xcp3 +64*e4e2*e3e2*e2e1*amel2*x3*xcp1 +128*e4e2*e3e2*e2e1*amel2*x3*x5^2*xcp3 -640*e4e2*e3e2*e2e1*amel2*x3*x5^2*xcp2 +128*e4e2*e3e2*e2e1*amel2*x3*x5^2*xcp1 +128*e4e2*e3e2*e2e1*amel2*x3*x4*xcp3 -1536*e4e2*e3e2*e2e1*amel2*x3*x4*xcp2 +128*e4e2*e3e2*e2e1*amel2*x3*x4*xcp1 -256*e4e2*e3e2*e2e1*amel2*x3*x4*x5*xcp3 +1024*e4e2*e3e2*e2e1*amel2*x3*x4*x5*xcp2 -256*e4e2*e3e2*e2e1*amel2*x3*x4*x5*xcp1 -384*e4e2*e3e2*e2e1*amel2*x3*x4^2*xcp3 +1024*e4e2*e3e2*e2e1*amel2*x3*x4^2*xcp2 -384*e4e2*e3e2*e2e1*amel2*x3*x4^2*xcp1 -256*e4e2*e3e2*e2e1*amel2*x3^2*xcp2 +192*e4e2*e3e2*e2e1*amel2*x3^2*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x3^2*x5*xcp2 +192*e4e2*e3e2*e2e1*amel2*x3^2*x5*xcp1 -192*e4e2*e3e2*e2e1*amel2*x3^2*x4*xcp3 +640*e4e2*e3e2*e2e1*amel2*x3^2*x4*xcp2 -192*e4e2*e3e2*e2e1*amel2*x3^2*x4*xcp1 +128*e4e2*e3e2*e2e1*amel2*x3^3*xcp2 +1024*e4e2*e3e2*e2e1*amel2*x1*xcp2 +64*e4e2*e3e2*e2e1*amel2*x1*x5*xcp3 -1664*e4e2*e3e2*e2e1*amel2*x1*x5*xcp2 +64*e4e2*e3e2*e2e1*amel2*x1*x5*xcp1 +512*e4e2*e3e2*e2e1*amel2*x1*x5^2*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1*x4*xcp3 -1408*e4e2*e3e2*e2e1*amel2*x1*x4*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1*x4*xcp1 -128*e4e2*e3e2*e2e1*amel2*x1*x4*x5*xcp3 +1152*e4e2*e3e2*e2e1*amel2*x1*x4*x5*xcp2 -128*e4e2*e3e2*e2e1*amel2*x1*x4*x5*xcp1 -64*e4e2*e3e2*e2e1*amel2*x1*x4^2*xcp3 +384*e4e2*e3e2*e2e1*amel2*x1*x4^2*xcp2 -64*e4e2*e3e2*e2e1*amel2*x1*x4^2*xcp1 +64*e4e2*e3e2*e2e1*amel2*x1*x3*xcp3 -1536*e4e2*e3e2*e2e1*amel2*x1*x3*xcp2 +64*e4e2*e3e2*e2e1*amel2*x1*x3*xcp1 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x5*xcp3 +1408*e4e2*e3e2*e2e1*amel2*x1*x3*x5*xcp2 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x5*xcp1 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x4*xcp3 +896*e4e2*e3e2*e2e1*amel2*x1*x3*x4*xcp2 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x4*xcp1 -64*e4e2*e3e2*e2e1*amel2*x1*x3^2*xcp3 +512*e4e2*e3e2*e2e1*amel2*x1*x3^2*xcp2 -64*e4e2*e3e2*e2e1*amel2*x1*x3^2*xcp1 -256*e4e2*e3e2*e2e1*amel2*x1^2*xcp2 +256*e4e2*e3e2*e2e1*amel2*x1^2*x5*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1^2*x4*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1^2*x3*xcp2 -768*e4e2*e3e2*e2e1^2*x5*xcp2 +1536*e4e2*e3e2*e2e1^2*x5^2*xcp2 -768*e4e2*e3e2*e2e1^2*x5^3*xcp2 +768*e4e2*e3e2*e2e1^2*x4*xcp2 +512*e4e2*e3e2*e2e1^2*x4*x5*xcp2 -1280*e4e2*e3e2*e2e1^2*x4*x5^2*xcp2 -512*e4e2*e3e2*e2e1^2*x4^2*xcp2 -512*e4e2*e3e2*e2e1^2*x4^2*x5*xcp2 +1280*e4e2*e3e2*e2e1^2*x3*x5*xcp2 -1280*e4e2*e3e2*e2e1^2*x3*x5^2*xcp2 -1280*e4e2*e3e2*e2e1^2*x3*x4*xcp2 -256*e4e2*e3e2*e2e1^2*x3*x4*x5*xcp2 +512*e4e2*e3e2*e2e1^2*x3*x4^2*xcp2 -512*e4e2*e3e2*e2e1^2*x3^2*x5*xcp2 +512*e4e2*e3e2*e2e1^2*x3^2*x4*xcp2 -256*e4e2*e3e2^2*amel2*x5^2*xcp2 +128*e4e2*e3e2^2*amel2*x5^3*xcp2 -384*e4e2*e3e2^2*amel2*x4*xcp2 -128*e4e2*e3e2^2*amel2*x4*x5*xcp3 +256*e4e2*e3e2^2*amel2*x4*x5*xcp2 -128*e4e2*e3e2^2*amel2*x4*x5*xcp1 +128*e4e2*e3e2^2*amel2*x4*x5^2*xcp3 -128*e4e2*e3e2^2*amel2*x4*x5^2*xcp2 +128*e4e2*e3e2^2*amel2*x4*x5^2*xcp1 -128*e4e2*e3e2^2*amel2*x4^2*xcp3 +256*e4e2*e3e2^2*amel2*x4^2*xcp2 -128*e4e2*e3e2^2*amel2*x4^2*xcp1 +192*e4e2*e3e2^2*amel2*x4^2*x5*xcp3 -384*e4e2*e3e2^2*amel2*x4^2*x5*xcp2 +192*e4e2*e3e2^2*amel2*x4^2*x5*xcp1 +64*e4e2*e3e2^2*amel2*x4^3*xcp3 -128*e4e2*e3e2^2*amel2*x4^3*xcp2 +64*e4e2*e3e2^2*amel2*x4^3*xcp1 -128*e4e2*e3e2^2*amel2*x3*x5*xcp2 -64*e4e2*e3e2^2*amel2*x3*x5^2*xcp3 +128*e4e2*e3e2^2*amel2*x3*x5^2*xcp2 -64*e4e2*e3e2^2*amel2*x3*x5^2*xcp1 -128*e4e2*e3e2^2*amel2*x3*x4*xcp3 +384*e4e2*e3e2^2*amel2*x3*x4*xcp2 -128*e4e2*e3e2^2*amel2*x3*x4*xcp1 +128*e4e2*e3e2^2*amel2*x3*x4*x5*xcp3 -384*e4e2*e3e2^2*amel2*x3*x4*x5*xcp2 +128*e4e2*e3e2^2*amel2*x3*x4*x5*xcp1 +128*e4e2*e3e2^2*amel2*x3*x4^2*xcp3 -256*e4e2*e3e2^2*amel2*x3*x4^2*xcp2 +128*e4e2*e3e2^2*amel2*x3*x4^2*xcp1 -64*e4e2*e3e2^2*amel2*x3^2*x5*xcp3 -64*e4e2*e3e2^2*amel2*x3^2*x5*xcp1 +64*e4e2*e3e2^2*amel2*x3^2*x4*xcp3 -128*e4e2*e3e2^2*amel2*x3^2*x4*xcp2 +64*e4e2*e3e2^2*amel2*x3^2*x4*xcp1 -384*e4e2*e3e2^2*amel2*x1*xcp2 +512*e4e2*e3e2^2*amel2*x1*x5*xcp2 -128*e4e2*e3e2^2*amel2*x1*x5^2*xcp2 +768*e4e2*e3e2^2*amel2*x1*x4*xcp2 -512*e4e2*e3e2^2*amel2*x1*x4*x5*xcp2 -256*e4e2*e3e2^2*amel2*x1*x4^2*xcp2 +640*e4e2*e3e2^2*amel2*x1*x3*xcp2 -384*e4e2*e3e2^2*amel2*x1*x3*x5*xcp2 -512*e4e2*e3e2^2*amel2*x1*x3*x4*xcp2 -256*e4e2*e3e2^2*amel2*x1*x3^2*xcp2 +384*e4e2*e3e2^2*e2e1*x5*xcp2 -768*e4e2*e3e2^2*e2e1*x5^2*xcp2 +384*e4e2*e3e2^2*e2e1*x5^3*xcp2 -384*e4e2*e3e2^2*e2e1*x4*xcp2 -256*e4e2*e3e2^2*e2e1*x4*x5*xcp2 +640*e4e2*e3e2^2*e2e1*x4*x5^2*xcp2 +256*e4e2*e3e2^2*e2e1*x4^2*xcp2 +256*e4e2*e3e2^2*e2e1*x4^2*x5*xcp2 -640*e4e2*e3e2^2*e2e1*x3*x5*xcp2 +640*e4e2*e3e2^2*e2e1*x3*x5^2*xcp2 +640*e4e2*e3e2^2*e2e1*x3*x4*xcp2 +128*e4e2*e3e2^2*e2e1*x3*x4*x5*xcp2 -256*e4e2*e3e2^2*e2e1*x3*x4^2*xcp2 +256*e4e2*e3e2^2*e2e1*x3^2*x5*xcp2 -256*e4e2*e3e2^2*e2e1*x3^2*x4*xcp2 +16*e4e2*e3e1*amel2*zk^2*xcp3 -64*e4e2*e3e1*amel2*zk^2*xcp2 +16*e4e2*e3e1*amel2*zk^2*xcp1 -48*e4e2*e3e1*amel2*zk^2*x5*xcp3 +128*e4e2*e3e1*amel2*zk^2*x5*xcp2 -48*e4e2*e3e1*amel2*zk^2*x5*xcp1 -96*e4e2*e3e1*amel2*zk^2*x4*xcp3 +160*e4e2*e3e1*amel2*zk^2*x4*xcp2 -96*e4e2*e3e1*amel2*zk^2*x4*xcp1 -48*e4e2*e3e1*amel2*zk^2*x3*xcp3 +160*e4e2*e3e1*amel2*zk^2*x3*xcp2 -48*e4e2*e3e1*amel2*zk^2*x3*xcp1 -32*e4e2*e3e1*amel2*zk^2*x1*xcp2 -64*e4e2*e3e1*amel2^2*xcp3 -256*e4e2*e3e1*amel2^2*xcp2 -64*e4e2*e3e1*amel2^2*xcp1 +96*e4e2*e3e1*amel2^2*x5*xcp3 +1024*e4e2*e3e1*amel2^2*x5*xcp2 +96*e4e2*e3e1*amel2^2*x5*xcp1 +64*e4e2*e3e1*amel2^2*x5^2*xcp3 -448*e4e2*e3e1*amel2^2*x5^2*xcp2 +64*e4e2*e3e1*amel2^2*x5^2*xcp1 -96*e4e2*e3e1*amel2^2*x5^3*xcp3 +128*e4e2*e3e1*amel2^2*x5^3*xcp2 -96*e4e2*e3e1*amel2^2*x5^3*xcp1 -32*e4e2*e3e1*amel2^2*x4*xcp3 +1280*e4e2*e3e1*amel2^2*x4*xcp2 -32*e4e2*e3e1*amel2^2*x4*xcp1 +160*e4e2*e3e1*amel2^2*x4*x5*xcp3 -1600*e4e2*e3e1*amel2^2*x4*x5*xcp2 +160*e4e2*e3e1*amel2^2*x4*x5*xcp1 -384*e4e2*e3e1*amel2^2*x4*x5^2*xcp3 +640*e4e2*e3e1*amel2^2*x4*x5^2*xcp2 -384*e4e2*e3e1*amel2^2*x4*x5^2*xcp1 +192*e4e2*e3e1*amel2^2*x4^2*xcp3 -1088*e4e2*e3e1*amel2^2*x4^2*xcp2 +192*e4e2*e3e1*amel2^2*x4^2*xcp1 -512*e4e2*e3e1*amel2^2*x4^2*x5*xcp3 +1024*e4e2*e3e1*amel2^2*x4^2*x5*xcp2 -512*e4e2*e3e1*amel2^2*x4^2*x5*xcp1 -256*e4e2*e3e1*amel2^2*x4^3*xcp3 +512*e4e2*e3e1*amel2^2*x4^3*xcp2 -256*e4e2*e3e1*amel2^2*x4^3*xcp1 +192*e4e2*e3e1*amel2^2*x3*xcp3 +768*e4e2*e3e1*amel2^2*x3*xcp2 +192*e4e2*e3e1*amel2^2*x3*xcp1 -160*e4e2*e3e1*amel2^2*x3*x5*xcp3 -1728*e4e2*e3e1*amel2^2*x3*x5*xcp2 -160*e4e2*e3e1*amel2^2*x3*x5*xcp1 -32*e4e2*e3e1*amel2^2*x3*x5^2*xcp3 +512*e4e2*e3e1*amel2^2*x3*x5^2*xcp2 -32*e4e2*e3e1*amel2^2*x3*x5^2*xcp1 +160*e4e2*e3e1*amel2^2*x3*x4*xcp3 -1856*e4e2*e3e1*amel2^2*x3*x4*xcp2 +160*e4e2*e3e1*amel2^2*x3*x4*xcp1 -256*e4e2*e3e1*amel2^2*x3*x4*x5*xcp3 +1408*e4e2*e3e1*amel2^2*x3*x4*x5*xcp2 -256*e4e2*e3e1*amel2^2*x3*x4*x5*xcp1 -320*e4e2*e3e1*amel2^2*x3*x4^2*xcp3 +1024*e4e2*e3e1*amel2^2*x3*x4^2*xcp2 -320*e4e2*e3e1*amel2^2*x3*x4^2*xcp1 +32*e4e2*e3e1*amel2^2*x3^2*xcp3 -448*e4e2*e3e1*amel2^2*x3^2*xcp2 +32*e4e2*e3e1*amel2^2*x3^2*xcp1 -32*e4e2*e3e1*amel2^2*x3^2*x5*xcp3 +256*e4e2*e3e1*amel2^2*x3^2*x5*xcp2 -32*e4e2*e3e1*amel2^2*x3^2*x5*xcp1 -128*e4e2*e3e1*amel2^2*x3^2*x4*xcp3 +512*e4e2*e3e1*amel2^2*x3^2*x4*xcp2 -128*e4e2*e3e1*amel2^2*x3^2*x4*xcp1 -32*e4e2*e3e1*amel2^2*x3^3*xcp3 +128*e4e2*e3e1*amel2^2*x3^3*xcp2 -32*e4e2*e3e1*amel2^2*x3^3*xcp1 +64*e4e2*e3e1*amel2^2*x1*xcp3 +640*e4e2*e3e1*amel2^2*x1*xcp2 +64*e4e2*e3e1*amel2^2*x1*xcp1 +32*e4e2*e3e1*amel2^2*x1*x5*xcp3 -1088*e4e2*e3e1*amel2^2*x1*x5*xcp2 +32*e4e2*e3e1*amel2^2*x1*x5*xcp1 -192*e4e2*e3e1*amel2^2*x1*x5^2*xcp3 +512*e4e2*e3e1*amel2^2*x1*x5^2*xcp2 -192*e4e2*e3e1*amel2^2*x1*x5^2*xcp1 +288*e4e2*e3e1*amel2^2*x1*x4*xcp3 -1536*e4e2*e3e1*amel2^2*x1*x4*xcp2 +288*e4e2*e3e1*amel2^2*x1*x4*xcp1 -512*e4e2*e3e1*amel2^2*x1*x4*x5*xcp3 +1408*e4e2*e3e1*amel2^2*x1*x4*x5*xcp2 -512*e4e2*e3e1*amel2^2*x1*x4*x5*xcp1 -320*e4e2*e3e1*amel2^2*x1*x4^2*xcp3 +640*e4e2*e3e1*amel2^2*x1*x4^2*xcp2 -320*e4e2*e3e1*amel2^2*x1*x4^2*xcp1 +128*e4e2*e3e1*amel2^2*x1*x3*xcp3 -1344*e4e2*e3e1*amel2^2*x1*x3*xcp2 +128*e4e2*e3e1*amel2^2*x1*x3*xcp1 -128*e4e2*e3e1*amel2^2*x1*x3*x5*xcp3 +1280*e4e2*e3e1*amel2^2*x1*x3*x5*xcp2 -128*e4e2*e3e1*amel2^2*x1*x3*x5*xcp1 -384*e4e2*e3e1*amel2^2*x1*x3*x4*xcp3 +1152*e4e2*e3e1*amel2^2*x1*x3*x4*xcp2 -384*e4e2*e3e1*amel2^2*x1*x3*x4*xcp1 -64*e4e2*e3e1*amel2^2*x1*x3^2*xcp3 +384*e4e2*e3e1*amel2^2*x1*x3^2*xcp2 -64*e4e2*e3e1*amel2^2*x1*x3^2*xcp1 +96*e4e2*e3e1*amel2^2*x1^2*xcp3 -128*e4e2*e3e1*amel2^2*x1^2*xcp2 +96*e4e2*e3e1*amel2^2*x1^2*xcp1 -96*e4e2*e3e1*amel2^2*x1^2*x5*xcp3 +256*e4e2*e3e1*amel2^2*x1^2*x5*xcp2 -96*e4e2*e3e1*amel2^2*x1^2*x5*xcp1 -128*e4e2*e3e1*amel2^2*x1^2*x4*xcp3 +256*e4e2*e3e1*amel2^2*x1^2*x4*xcp2 -128*e4e2*e3e1*amel2^2*x1^2*x4*xcp1 -96*e4e2*e3e1*amel2^2*x1^2*x3*xcp3 +128*e4e2*e3e1*amel2^2*x1^2*x3*xcp2 -96*e4e2*e3e1*amel2^2*x1^2*x3*xcp1 -224*e4e2*e3e1*e2e1*zk^2*xcp2 +128*e4e2*e3e1*e2e1*zk^2*x5*xcp2 +192*e4e2*e3e1*e2e1*zk^2*x3*xcp2 -32*e4e2*e3e1*e2e1*zk^2*x1*xcp2 -64*e4e2*e3e1*e2e1*amel2*xcp3 -768*e4e2*e3e1*e2e1*amel2*xcp2 -64*e4e2*e3e1*e2e1*amel2*xcp1 +64*e4e2*e3e1*e2e1*amel2*x5*xcp3 +2048*e4e2*e3e1*e2e1*amel2*x5*xcp2 +64*e4e2*e3e1*e2e1*amel2*x5*xcp1 +32*e4e2*e3e1*e2e1*amel2*x5^2*xcp3 -448*e4e2*e3e1*e2e1*amel2*x5^2*xcp2 +32*e4e2*e3e1*e2e1*amel2*x5^2*xcp1 -128*e4e2*e3e1*e2e1*amel2*x5^3*xcp3 -128*e4e2*e3e1*e2e1*amel2*x5^3*xcp2 -128*e4e2*e3e1*e2e1*amel2*x5^3*xcp1 +96*e4e2*e3e1*e2e1*amel2*x4*xcp3 +2560*e4e2*e3e1*e2e1*amel2*x4*xcp2 +96*e4e2*e3e1*e2e1*amel2*x4*xcp1 +32*e4e2*e3e1*e2e1*amel2*x4*x5*xcp3 -2176*e4e2*e3e1*e2e1*amel2*x4*x5*xcp2 +32*e4e2*e3e1*e2e1*amel2*x4*x5*xcp1 -448*e4e2*e3e1*e2e1*amel2*x4*x5^2*xcp3 +256*e4e2*e3e1*e2e1*amel2*x4*x5^2*xcp2 -448*e4e2*e3e1*e2e1*amel2*x4*x5^2*xcp1 +128*e4e2*e3e1*e2e1*amel2*x4^2*xcp3 -1984*e4e2*e3e1*e2e1*amel2*x4^2*xcp2 +128*e4e2*e3e1*e2e1*amel2*x4^2*xcp1 -576*e4e2*e3e1*e2e1*amel2*x4^2*x5*xcp3 +1152*e4e2*e3e1*e2e1*amel2*x4^2*x5*xcp2 -576*e4e2*e3e1*e2e1*amel2*x4^2*x5*xcp1 -256*e4e2*e3e1*e2e1*amel2*x4^3*xcp3 +640*e4e2*e3e1*e2e1*amel2*x4^3*xcp2 -256*e4e2*e3e1*e2e1*amel2*x4^3*xcp1 +160*e4e2*e3e1*e2e1*amel2*x3*xcp3 +1536*e4e2*e3e1*e2e1*amel2*x3*xcp2 +160*e4e2*e3e1*e2e1*amel2*x3*xcp1 -32*e4e2*e3e1*e2e1*amel2*x3*x5*xcp3 -2048*e4e2*e3e1*e2e1*amel2*x3*x5*xcp2 -32*e4e2*e3e1*e2e1*amel2*x3*x5*xcp1 -192*e4e2*e3e1*e2e1*amel2*x3*x5^2*xcp3 +128*e4e2*e3e1*e2e1*amel2*x3*x5^2*xcp2 -192*e4e2*e3e1*e2e1*amel2*x3*x5^2*xcp1 -32*e4e2*e3e1*e2e1*amel2*x3*x4*xcp3 -3584*e4e2*e3e1*e2e1*amel2*x3*x4*xcp2 -32*e4e2*e3e1*e2e1*amel2*x3*x4*xcp1 -512*e4e2*e3e1*e2e1*amel2*x3*x4*x5*xcp3 +2176*e4e2*e3e1*e2e1*amel2*x3*x4*x5*xcp2 -512*e4e2*e3e1*e2e1*amel2*x3*x4*x5*xcp1 -448*e4e2*e3e1*e2e1*amel2*x3*x4^2*xcp3 +2048*e4e2*e3e1*e2e1*amel2*x3*x4^2*xcp2 -448*e4e2*e3e1*e2e1*amel2*x3*x4^2*xcp1 -1024*e4e2*e3e1*e2e1*amel2*x3^2*xcp2 -64*e4e2*e3e1*e2e1*amel2*x3^2*x5*xcp3 +384*e4e2*e3e1*e2e1*amel2*x3^2*x5*xcp2 -64*e4e2*e3e1*e2e1*amel2*x3^2*x5*xcp1 -192*e4e2*e3e1*e2e1*amel2*x3^2*x4*xcp3 +1280*e4e2*e3e1*e2e1*amel2*x3^2*x4*xcp2 -192*e4e2*e3e1*e2e1*amel2*x3^2*x4*xcp1 +256*e4e2*e3e1*e2e1*amel2*x3^3*xcp2 +32*e4e2*e3e1*e2e1*amel2*x1*xcp3 +1664*e4e2*e3e1*e2e1*amel2*x1*xcp2 +32*e4e2*e3e1*e2e1*amel2*x1*xcp1 +64*e4e2*e3e1*e2e1*amel2*x1*x5*xcp3 -2304*e4e2*e3e1*e2e1*amel2*x1*x5*xcp2 +64*e4e2*e3e1*e2e1*amel2*x1*x5*xcp1 -128*e4e2*e3e1*e2e1*amel2*x1*x5^2*xcp3 +896*e4e2*e3e1*e2e1*amel2*x1*x5^2*xcp2 -128*e4e2*e3e1*e2e1*amel2*x1*x5^2*xcp1 +288*e4e2*e3e1*e2e1*amel2*x1*x4*xcp3 -1664*e4e2*e3e1*e2e1*amel2*x1*x4*xcp2 +288*e4e2*e3e1*e2e1*amel2*x1*x4*xcp1 -320*e4e2*e3e1*e2e1*amel2*x1*x4*x5*xcp3 +1536*e4e2*e3e1*e2e1*amel2*x1*x4*x5*xcp2 -320*e4e2*e3e1*e2e1*amel2*x1*x4*x5*xcp1 -256*e4e2*e3e1*e2e1*amel2*x1*x4^2*xcp3 +640*e4e2*e3e1*e2e1*amel2*x1*x4^2*xcp2 -256*e4e2*e3e1*e2e1*amel2*x1*x4^2*xcp1 +96*e4e2*e3e1*e2e1*amel2*x1*x3*xcp3 -2048*e4e2*e3e1*e2e1*amel2*x1*x3*xcp2 +96*e4e2*e3e1*e2e1*amel2*x1*x3*xcp1 -320*e4e2*e3e1*e2e1*amel2*x1*x3*x5*xcp3 +1792*e4e2*e3e1*e2e1*amel2*x1*x3*x5*xcp2 -320*e4e2*e3e1*e2e1*amel2*x1*x3*x5*xcp1 -448*e4e2*e3e1*e2e1*amel2*x1*x3*x4*xcp3 +1536*e4e2*e3e1*e2e1*amel2*x1*x3*x4*xcp2 -448*e4e2*e3e1*e2e1*amel2*x1*x3*x4*xcp1 -192*e4e2*e3e1*e2e1*amel2*x1*x3^2*xcp3 +768*e4e2*e3e1*e2e1*amel2*x1*x3^2*xcp2 -192*e4e2*e3e1*e2e1*amel2*x1*x3^2*xcp1 +32*e4e2*e3e1*e2e1*amel2*x1^2*xcp3 -320*e4e2*e3e1*e2e1*amel2*x1^2*xcp2 +32*e4e2*e3e1*e2e1*amel2*x1^2*xcp1 +256*e4e2*e3e1*e2e1*amel2*x1^2*x5*xcp2 +128*e4e2*e3e1*e2e1*amel2*x1^2*x4*xcp2 +128*e4e2*e3e1*e2e1*amel2*x1^2*x3*xcp2 -512*e4e2*e3e1*e2e1^2*xcp2 +640*e4e2*e3e1*e2e1^2*x5*xcp2 +256*e4e2*e3e1*e2e1^2*x5^2*xcp2 -384*e4e2*e3e1*e2e1^2*x5^3*xcp2 +1664*e4e2*e3e1*e2e1^2*x4*xcp2 -1152*e4e2*e3e1*e2e1^2*x4*x5*xcp2 -512*e4e2*e3e1*e2e1^2*x4*x5^2*xcp2 -1152*e4e2*e3e1*e2e1^2*x4^2*xcp2 +128*e4e2*e3e1*e2e1^2*x4^3*xcp2 +768*e4e2*e3e1*e2e1^2*x3*xcp2 -256*e4e2*e3e1*e2e1^2*x3*x5*xcp2 -512*e4e2*e3e1*e2e1^2*x3*x5^2*xcp2 -2304*e4e2*e3e1*e2e1^2*x3*x4*xcp2 +640*e4e2*e3e1*e2e1^2*x3*x4*x5*xcp2 +896*e4e2*e3e1*e2e1^2*x3*x4^2*xcp2 -256*e4e2*e3e1*e2e1^2*x3^2*xcp2 -256*e4e2*e3e1*e2e1^2*x3^2*x5*xcp2 +768*e4e2*e3e1*e2e1^2*x3^2*x4*xcp2 +512*e4e2*e3e1*e2e1^2*x1*xcp2 -768*e4e2*e3e1*e2e1^2*x1*x5*xcp2 +256*e4e2*e3e1*e2e1^2*x1*x5^2*xcp2 -512*e4e2*e3e1*e2e1^2*x1*x4*xcp2 +384*e4e2*e3e1*e2e1^2*x1*x4*x5*xcp2 +128*e4e2*e3e1*e2e1^2*x1*x4^2*xcp2 -768*e4e2*e3e1*e2e1^2*x1*x3*xcp2 +640*e4e2*e3e1*e2e1^2*x1*x3*x5*xcp2 +384*e4e2*e3e1*e2e1^2*x1*x3*x4*xcp2 +256*e4e2*e3e1*e2e1^2*x1*x3^2*xcp2 +224*e4e2*e3e1*e3e2*zk^2*xcp2 -192*e4e2*e3e1*e3e2*zk^2*x5*xcp2 -96*e4e2*e3e1*e3e2*zk^2*x4*xcp2 -160*e4e2*e3e1*e3e2*zk^2*x3*xcp2 +512*e4e2*e3e1*e3e2*amel2*xcp2 -1280*e4e2*e3e1*e3e2*amel2*x5*xcp2 -96*e4e2*e3e1*e3e2*amel2*x5^2*xcp3 +448*e4e2*e3e1*e3e2*amel2*x5^2*xcp2 -96*e4e2*e3e1*e3e2*amel2*x5^2*xcp1 +128*e4e2*e3e1*e3e2*amel2*x5^3*xcp3 +128*e4e2*e3e1*e3e2*amel2*x5^3*xcp1 -128*e4e2*e3e1*e3e2*amel2*x4*xcp3 -1792*e4e2*e3e1*e3e2*amel2*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x4*xcp1 -128*e4e2*e3e1*e3e2*amel2*x4*x5*xcp3 +2240*e4e2*e3e1*e3e2*amel2*x4*x5*xcp2 -128*e4e2*e3e1*e3e2*amel2*x4*x5*xcp1 +384*e4e2*e3e1*e3e2*amel2*x4*x5^2*xcp3 -768*e4e2*e3e1*e3e2*amel2*x4*x5^2*xcp2 +384*e4e2*e3e1*e3e2*amel2*x4*x5^2*xcp1 -192*e4e2*e3e1*e3e2*amel2*x4^2*xcp3 +1920*e4e2*e3e1*e3e2*amel2*x4^2*xcp2 -192*e4e2*e3e1*e3e2*amel2*x4^2*xcp1 +448*e4e2*e3e1*e3e2*amel2*x4^2*x5*xcp3 -1664*e4e2*e3e1*e3e2*amel2*x4^2*x5*xcp2 +448*e4e2*e3e1*e3e2*amel2*x4^2*x5*xcp1 +192*e4e2*e3e1*e3e2*amel2*x4^3*xcp3 -768*e4e2*e3e1*e3e2*amel2*x4^3*xcp2 +192*e4e2*e3e1*e3e2*amel2*x4^3*xcp1 -64*e4e2*e3e1*e3e2*amel2*x3*xcp3 -1024*e4e2*e3e1*e3e2*amel2*x3*xcp2 -64*e4e2*e3e1*e3e2*amel2*x3*xcp1 -64*e4e2*e3e1*e3e2*amel2*x3*x5*xcp3 +1344*e4e2*e3e1*e3e2*amel2*x3*x5*xcp2 -64*e4e2*e3e1*e3e2*amel2*x3*x5*xcp1 +128*e4e2*e3e1*e3e2*amel2*x3*x5^2*xcp3 -128*e4e2*e3e1*e3e2*amel2*x3*x5^2*xcp2 +128*e4e2*e3e1*e3e2*amel2*x3*x5^2*xcp1 -128*e4e2*e3e1*e3e2*amel2*x3*x4*xcp3 +2624*e4e2*e3e1*e3e2*amel2*x3*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x3*x4*xcp1 +320*e4e2*e3e1*e3e2*amel2*x3*x4*x5*xcp3 -1920*e4e2*e3e1*e3e2*amel2*x3*x4*x5*xcp2 +320*e4e2*e3e1*e3e2*amel2*x3*x4*x5*xcp1 +320*e4e2*e3e1*e3e2*amel2*x3*x4^2*xcp3 -1664*e4e2*e3e1*e3e2*amel2*x3*x4^2*xcp2 +320*e4e2*e3e1*e3e2*amel2*x3*x4^2*xcp1 -32*e4e2*e3e1*e3e2*amel2*x3^2*xcp3 +640*e4e2*e3e1*e3e2*amel2*x3^2*xcp2 -32*e4e2*e3e1*e3e2*amel2*x3^2*xcp1 -256*e4e2*e3e1*e3e2*amel2*x3^2*x5*xcp2 +128*e4e2*e3e1*e3e2*amel2*x3^2*x4*xcp3 -896*e4e2*e3e1*e3e2*amel2*x3^2*x4*xcp2 +128*e4e2*e3e1*e3e2*amel2*x3^2*x4*xcp1 -128*e4e2*e3e1*e3e2*amel2*x3^3*xcp2 -1280*e4e2*e3e1*e3e2*amel2*x1*xcp2 -96*e4e2*e3e1*e3e2*amel2*x1*x5*xcp3 +1984*e4e2*e3e1*e3e2*amel2*x1*x5*xcp2 -96*e4e2*e3e1*e3e2*amel2*x1*x5*xcp1 +128*e4e2*e3e1*e3e2*amel2*x1*x5^2*xcp3 -896*e4e2*e3e1*e3e2*amel2*x1*x5^2*xcp2 +128*e4e2*e3e1*e3e2*amel2*x1*x5^2*xcp1 -128*e4e2*e3e1*e3e2*amel2*x1*x4*xcp3 +1536*e4e2*e3e1*e3e2*amel2*x1*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x1*x4*xcp1 +192*e4e2*e3e1*e3e2*amel2*x1*x4*x5*xcp3 -1408*e4e2*e3e1*e3e2*amel2*x1*x4*x5*xcp2 +192*e4e2*e3e1*e3e2*amel2*x1*x4*x5*xcp1 +64*e4e2*e3e1*e3e2*amel2*x1*x4^2*xcp3 -512*e4e2*e3e1*e3e2*amel2*x1*x4^2*xcp2 +64*e4e2*e3e1*e3e2*amel2*x1*x4^2*xcp1 -96*e4e2*e3e1*e3e2*amel2*x1*x3*xcp3 +1600*e4e2*e3e1*e3e2*amel2*x1*x3*xcp2 -96*e4e2*e3e1*e3e2*amel2*x1*x3*xcp1 +192*e4e2*e3e1*e3e2*amel2*x1*x3*x5*xcp3 -1280*e4e2*e3e1*e3e2*amel2*x1*x3*x5*xcp2 +192*e4e2*e3e1*e3e2*amel2*x1*x3*x5*xcp1 +128*e4e2*e3e1*e3e2*amel2*x1*x3*x4*xcp3 -1024*e4e2*e3e1*e3e2*amel2*x1*x3*x4*xcp2 +128*e4e2*e3e1*e3e2*amel2*x1*x3*x4*xcp1 +64*e4e2*e3e1*e3e2*amel2*x1*x3^2*xcp3 -512*e4e2*e3e1*e3e2*amel2*x1*x3^2*xcp2 +64*e4e2*e3e1*e3e2*amel2*x1*x3^2*xcp1 +256*e4e2*e3e1*e3e2*amel2*x1^2*xcp2 -256*e4e2*e3e1*e3e2*amel2*x1^2*x5*xcp2 -128*e4e2*e3e1*e3e2*amel2*x1^2*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x1^2*x3*xcp2 +512*e4e2*e3e1*e3e2*e2e1*xcp2 -512*e4e2*e3e1*e3e2*e2e1*x5*xcp2 -512*e4e2*e3e1*e3e2*e2e1*x5^2*xcp2 +512*e4e2*e3e1*e3e2*e2e1*x5^3*xcp2 -2304*e4e2*e3e1*e3e2*e2e1*x4*xcp2 +2048*e4e2*e3e1*e3e2*e2e1*x4*x5*xcp2 +256*e4e2*e3e1*e3e2*e2e1*x4*x5^2*xcp2 +2048*e4e2*e3e1*e3e2*e2e1*x4^2*xcp2 -640*e4e2*e3e1*e3e2*e2e1*x4^2*x5*xcp2 -384*e4e2*e3e1*e3e2*e2e1*x4^3*xcp2 -768*e4e2*e3e1*e3e2*e2e1*x3*xcp2 +768*e4e2*e3e1*e3e2*e2e1*x3*x5^2*xcp2 +3328*e4e2*e3e1*e3e2*e2e1*x3*x4*xcp2 -1280*e4e2*e3e1*e3e2*e2e1*x3*x4*x5*xcp2 -1536*e4e2*e3e1*e3e2*e2e1*x3*x4^2*xcp2 +256*e4e2*e3e1*e3e2*e2e1*x3^2*xcp2 +384*e4e2*e3e1*e3e2*e2e1*x3^2*x5*xcp2 -1152*e4e2*e3e1*e3e2*e2e1*x3^2*x4*xcp2 -512*e4e2*e3e1*e3e2*e2e1*x1*xcp2 +768*e4e2*e3e1*e3e2*e2e1*x1*x5*xcp2 -256*e4e2*e3e1*e3e2*e2e1*x1*x5^2*xcp2 +512*e4e2*e3e1*e3e2*e2e1*x1*x4*xcp2 -384*e4e2*e3e1*e3e2*e2e1*x1*x4*x5*xcp2 -128*e4e2*e3e1*e3e2*e2e1*x1*x4^2*xcp2 +768*e4e2*e3e1*e3e2*e2e1*x1*x3*xcp2 -640*e4e2*e3e1*e3e2*e2e1*x1*x3*x5*xcp2 -384*e4e2*e3e1*e3e2*e2e1*x1*x3*x4*xcp2 -256*e4e2*e3e1*e3e2*e2e1*x1*x3^2*xcp2 -128*e4e2*e3e1*e3e2^2*x5*xcp2 +256*e4e2*e3e1*e3e2^2*x5^2*xcp2 -128*e4e2*e3e1*e3e2^2*x5^3*xcp2 +640*e4e2*e3e1*e3e2^2*x4*xcp2 -896*e4e2*e3e1*e3e2^2*x4*x5*xcp2 +256*e4e2*e3e1*e3e2^2*x4*x5^2*xcp2 -896*e4e2*e3e1*e3e2^2*x4^2*xcp2 +640*e4e2*e3e1*e3e2^2*x4^2*x5*xcp2 +256*e4e2*e3e1*e3e2^2*x4^3*xcp2 +256*e4e2*e3e1*e3e2^2*x3*x5*xcp2 -256*e4e2*e3e1*e3e2^2*x3*x5^2*xcp2 -1024*e4e2*e3e1*e3e2^2*x3*x4*xcp2 +640*e4e2*e3e1*e3e2^2*x3*x4*x5*xcp2 +640*e4e2*e3e1*e3e2^2*x3*x4^2*xcp2 -128*e4e2*e3e1*e3e2^2*x3^2*x5*xcp2 +384*e4e2*e3e1*e3e2^2*x3^2*x4*xcp2 +96*e4e2*e3e1^2*zk^2*xcp2 -64*e4e2*e3e1^2*zk^2*x5*xcp2 -64*e4e2*e3e1^2*zk^2*x4*xcp2 -128*e4e2*e3e1^2*zk^2*x3*xcp2 +32*e4e2*e3e1^2*zk^2*x1*xcp2 +64*e4e2*e3e1^2*amel2*xcp3 +512*e4e2*e3e1^2*amel2*xcp2 +64*e4e2*e3e1^2*amel2*xcp1 -128*e4e2*e3e1^2*amel2*x5*xcp3 -1408*e4e2*e3e1^2*amel2*x5*xcp2 -128*e4e2*e3e1^2*amel2*x5*xcp1 +32*e4e2*e3e1^2*amel2*x5^2*xcp3 +960*e4e2*e3e1^2*amel2*x5^2*xcp2 +32*e4e2*e3e1^2*amel2*x5^2*xcp1 +64*e4e2*e3e1^2*amel2*x5^3*xcp3 -256*e4e2*e3e1^2*amel2*x5^3*xcp2 +64*e4e2*e3e1^2*amel2*x5^3*xcp1 -32*e4e2*e3e1^2*amel2*x4*xcp3 -1664*e4e2*e3e1^2*amel2*x4*xcp2 -32*e4e2*e3e1^2*amel2*x4*xcp1 -32*e4e2*e3e1^2*amel2*x4*x5*xcp3 +2432*e4e2*e3e1^2*amel2*x4*x5*xcp2 -32*e4e2*e3e1^2*amel2*x4*x5*xcp1 +256*e4e2*e3e1^2*amel2*x4*x5^2*xcp3 -1024*e4e2*e3e1^2*amel2*x4*x5^2*xcp2 +256*e4e2*e3e1^2*amel2*x4*x5^2*xcp1 -64*e4e2*e3e1^2*amel2*x4^2*xcp3 +1472*e4e2*e3e1^2*amel2*x4^2*xcp2 -64*e4e2*e3e1^2*amel2*x4^2*xcp1 +320*e4e2*e3e1^2*amel2*x4^2*x5*xcp3 -1280*e4e2*e3e1^2*amel2*x4^2*x5*xcp2 +320*e4e2*e3e1^2*amel2*x4^2*x5*xcp1 +128*e4e2*e3e1^2*amel2*x4^3*xcp3 -512*e4e2*e3e1^2*amel2*x4^3*xcp2 +128*e4e2*e3e1^2*amel2*x4^3*xcp1 -96*e4e2*e3e1^2*amel2*x3*xcp3 -1280*e4e2*e3e1^2*amel2*x3*xcp2 -96*e4e2*e3e1^2*amel2*x3*xcp1 +160*e4e2*e3e1^2*amel2*x3*x5*xcp3 +2176*e4e2*e3e1^2*amel2*x3*x5*xcp2 +160*e4e2*e3e1^2*amel2*x3*x5*xcp1 +64*e4e2*e3e1^2*amel2*x3*x5^2*xcp3 -896*e4e2*e3e1^2*amel2*x3*x5^2*xcp2 +64*e4e2*e3e1^2*amel2*x3*x5^2*xcp1 +32*e4e2*e3e1^2*amel2*x3*x4*xcp3 +2432*e4e2*e3e1^2*amel2*x3*x4*xcp2 +32*e4e2*e3e1^2*amel2*x3*x4*xcp1 +256*e4e2*e3e1^2*amel2*x3*x4*x5*xcp3 -2048*e4e2*e3e1^2*amel2*x3*x4*x5*xcp2 +256*e4e2*e3e1^2*amel2*x3*x4*x5*xcp1 +192*e4e2*e3e1^2*amel2*x3*x4^2*xcp3 -1280*e4e2*e3e1^2*amel2*x3*x4^2*xcp2 +192*e4e2*e3e1^2*amel2*x3*x4^2*xcp1 +768*e4e2*e3e1^2*amel2*x3^2*xcp2 +64*e4e2*e3e1^2*amel2*x3^2*x5*xcp3 -512*e4e2*e3e1^2*amel2*x3^2*x5*xcp2 +64*e4e2*e3e1^2*amel2*x3^2*x5*xcp1 +64*e4e2*e3e1^2*amel2*x3^2*x4*xcp3 -768*e4e2*e3e1^2*amel2*x3^2*x4*xcp2 +64*e4e2*e3e1^2*amel2*x3^2*x4*xcp1 -128*e4e2*e3e1^2*amel2*x3^3*xcp2 -32*e4e2*e3e1^2*amel2*x1*xcp3 -768*e4e2*e3e1^2*amel2*x1*xcp2 -32*e4e2*e3e1^2*amel2*x1*xcp1 +1152*e4e2*e3e1^2*amel2*x1*x5*xcp2 +64*e4e2*e3e1^2*amel2*x1*x5^2*xcp3 -512*e4e2*e3e1^2*amel2*x1*x5^2*xcp2 +64*e4e2*e3e1^2*amel2*x1*x5^2*xcp1 -160*e4e2*e3e1^2*amel2*x1*x4*xcp3 +1280*e4e2*e3e1^2*amel2*x1*x4*xcp2 -160*e4e2*e3e1^2*amel2*x1*x4*xcp1 +192*e4e2*e3e1^2*amel2*x1*x4*x5*xcp3 -1152*e4e2*e3e1^2*amel2*x1*x4*x5*xcp2 +192*e4e2*e3e1^2*amel2*x1*x4*x5*xcp1 +128*e4e2*e3e1^2*amel2*x1*x4^2*xcp3 -512*e4e2*e3e1^2*amel2*x1*x4^2*xcp2 +128*e4e2*e3e1^2*amel2*x1*x4^2*xcp1 -32*e4e2*e3e1^2*amel2*x1*x3*xcp3 +1408*e4e2*e3e1^2*amel2*x1*x3*xcp2 -32*e4e2*e3e1^2*amel2*x1*x3*xcp1 +64*e4e2*e3e1^2*amel2*x1*x3*x5*xcp3 -1280*e4e2*e3e1^2*amel2*x1*x3*x5*xcp2 +64*e4e2*e3e1^2*amel2*x1*x3*x5*xcp1 +192*e4e2*e3e1^2*amel2*x1*x3*x4*xcp3 -1152*e4e2*e3e1^2*amel2*x1*x3*x4*xcp2 +192*e4e2*e3e1^2*amel2*x1*x3*x4*xcp1 +64*e4e2*e3e1^2*amel2*x1*x3^2*xcp3 -512*e4e2*e3e1^2*amel2*x1*x3^2*xcp2 +64*e4e2*e3e1^2*amel2*x1*x3^2*xcp1 -32*e4e2*e3e1^2*amel2*x1^2*xcp3 +64*e4e2*e3e1^2*amel2*x1^2*xcp2 -32*e4e2*e3e1^2*amel2*x1^2*xcp1 -128*e4e2*e3e1^2*amel2*x1^2*x5*xcp2 -128*e4e2*e3e1^2*amel2*x1^2*x4*xcp2 -128*e4e2*e3e1^2*amel2*x1^2*x3*xcp2 +768*e4e2*e3e1^2*e2e1*xcp2 -1664*e4e2*e3e1^2*e2e1*x5*xcp2 +1024*e4e2*e3e1^2*e2e1*x5^2*xcp2 -128*e4e2*e3e1^2*e2e1*x5^3*xcp2 -1920*e4e2*e3e1^2*e2e1*x4*xcp2 +2432*e4e2*e3e1^2*e2e1*x4*x5*xcp2 -512*e4e2*e3e1^2*e2e1*x4*x5^2*xcp2 +1408*e4e2*e3e1^2*e2e1*x4^2*xcp2 -640*e4e2*e3e1^2*e2e1*x4^2*x5*xcp2 -256*e4e2*e3e1^2*e2e1*x4^3*xcp2 -1280*e4e2*e3e1^2*e2e1*x3*xcp2 +1792*e4e2*e3e1^2*e2e1*x3*x5*xcp2 -512*e4e2*e3e1^2*e2e1*x3*x5^2*xcp2 +2560*e4e2*e3e1^2*e2e1*x3*x4*xcp2 -1536*e4e2*e3e1^2*e2e1*x3*x4*x5*xcp2 -1024*e4e2*e3e1^2*e2e1*x3*x4^2*xcp2 +512*e4e2*e3e1^2*e2e1*x3^2*xcp2 -256*e4e2*e3e1^2*e2e1*x3^2*x5*xcp2 -768*e4e2*e3e1^2*e2e1*x3^2*x4*xcp2 -768*e4e2*e3e1^2*e2e1*x1*xcp2 +1152*e4e2*e3e1^2*e2e1*x1*x5*xcp2 -384*e4e2*e3e1^2*e2e1*x1*x5^2*xcp2 +896*e4e2*e3e1^2*e2e1*x1*x4*xcp2 -640*e4e2*e3e1^2*e2e1*x1*x4*x5*xcp2 -256*e4e2*e3e1^2*e2e1*x1*x4^2*xcp2 +1280*e4e2*e3e1^2*e2e1*x1*x3*xcp2 -1024*e4e2*e3e1^2*e2e1*x1*x3*x5*xcp2 -768*e4e2*e3e1^2*e2e1*x1*x3*x4*xcp2 -512*e4e2*e3e1^2*e2e1*x1*x3^2*xcp2 -512*e4e2*e3e1^2*e3e2*xcp2 +1280*e4e2*e3e1^2*e3e2*x5*xcp2 -1024*e4e2*e3e1^2*e3e2*x5^2*xcp2 +256*e4e2*e3e1^2*e3e2*x5^3*xcp2 +1536*e4e2*e3e1^2*e3e2*x4*xcp2 -2432*e4e2*e3e1^2*e3e2*x4*x5*xcp2 +896*e4e2*e3e1^2*e3e2*x4*x5^2*xcp2 -1408*e4e2*e3e1^2*e3e2*x4^2*xcp2 +1024*e4e2*e3e1^2*e3e2*x4^2*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x4^3*xcp2 +768*e4e2*e3e1^2*e3e2*x3*xcp2 -1152*e4e2*e3e1^2*e3e2*x3*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x3*x5^2*xcp2 -1920*e4e2*e3e1^2*e3e2*x3*x4*xcp2 +1408*e4e2*e3e1^2*e3e2*x3*x4*x5*xcp2 +1024*e4e2*e3e1^2*e3e2*x3*x4^2*xcp2 -256*e4e2*e3e1^2*e3e2*x3^2*xcp2 +128*e4e2*e3e1^2*e3e2*x3^2*x5*xcp2 +640*e4e2*e3e1^2*e3e2*x3^2*x4*xcp2 +512*e4e2*e3e1^2*e3e2*x1*xcp2 -896*e4e2*e3e1^2*e3e2*x1*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x1*x5^2*xcp2 -640*e4e2*e3e1^2*e3e2*x1*x4*xcp2 +512*e4e2*e3e1^2*e3e2*x1*x4*x5*xcp2 +128*e4e2*e3e1^2*e3e2*x1*x4^2*xcp2 -768*e4e2*e3e1^2*e3e2*x1*x3*xcp2 +640*e4e2*e3e1^2*e3e2*x1*x3*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x1*x3*x4*xcp2 +256*e4e2*e3e1^2*e3e2*x1*x3^2*xcp2 -256*e4e2*e3e1^3*xcp2 +640*e4e2*e3e1^3*x5*xcp2 -512*e4e2*e3e1^3*x5^2*xcp2 +128*e4e2*e3e1^3*x5^3*xcp2 +640*e4e2*e3e1^3*x4*xcp2 -1024*e4e2*e3e1^3*x4*x5*xcp2 +384*e4e2*e3e1^3*x4*x5^2*xcp2 -512*e4e2*e3e1^3*x4^2*xcp2 +384*e4e2*e3e1^3*x4^2*x5*xcp2 +128*e4e2*e3e1^3*x4^3*xcp2 +512*e4e2*e3e1^3*x3*xcp2 -896*e4e2*e3e1^3*x3*x5*xcp2 +384*e4e2*e3e1^3*x3*x5^2*xcp2 -896*e4e2*e3e1^3*x3*x4*xcp2 +768*e4e2*e3e1^3*x3*x4*x5*xcp2 +384*e4e2*e3e1^3*x3*x4^2*xcp2 -256*e4e2*e3e1^3*x3^2*xcp2 +256*e4e2*e3e1^3*x3^2*x5*xcp2 +256*e4e2*e3e1^3*x3^2*x4*xcp2 +256*e4e2*e3e1^3*x1*xcp2 -384*e4e2*e3e1^3*x1*x5*xcp2 +128*e4e2*e3e1^3*x1*x5^2*xcp2 -384*e4e2*e3e1^3*x1*x4*xcp2 +256*e4e2*e3e1^3*x1*x4*x5*xcp2 +128*e4e2*e3e1^3*x1*x4^2*xcp2 -512*e4e2*e3e1^3*x1*x3*xcp2 +384*e4e2*e3e1^3*x1*x3*x5*xcp2 +384*e4e2*e3e1^3*x1*x3*x4*xcp2 +256*e4e2*e3e1^3*x1*x3^2*xcp2 +16*e4e2^2*amel2*zk^2*xcp3 +64*e4e2^2*amel2*zk^2*xcp2 +16*e4e2^2*amel2*zk^2*xcp1 -48*e4e2^2*amel2*zk^2*x5*xcp3 +64*e4e2^2*amel2*zk^2*x5*xcp2 -48*e4e2^2*amel2*zk^2*x5*xcp1 -32*e4e2^2*amel2*zk^2*x4*xcp2 -64*e4e2^2*amel2*zk^2*x3*xcp2 -32*e4e2^2*amel2*zk^2*x1*xcp2 +128*e4e2^2*amel2^2*x5*xcp2 +320*e4e2^2*amel2^2*x5^2*xcp2 -32*e4e2^2*amel2^2*x5^3*xcp3 -128*e4e2^2*amel2^2*x5^3*xcp2 -32*e4e2^2*amel2^2*x5^3*xcp1 +64*e4e2^2*amel2^2*x4*xcp3 +64*e4e2^2*amel2^2*x4*xcp1 +192*e4e2^2*amel2^2*x4*x5*xcp2 -64*e4e2^2*amel2^2*x4*x5^2*xcp3 -128*e4e2^2*amel2^2*x4*x5^2*xcp2 -64*e4e2^2*amel2^2*x4*x5^2*xcp1 +64*e4e2^2*amel2^2*x4^2*xcp3 +64*e4e2^2*amel2^2*x4^2*xcp1 -64*e4e2^2*amel2^2*x4^2*x5*xcp3 +128*e4e2^2*amel2^2*x4^2*x5*xcp2 -64*e4e2^2*amel2^2*x4^2*x5*xcp1 +64*e4e2^2*amel2^2*x3*xcp3 -128*e4e2^2*amel2^2*x3*xcp2 +64*e4e2^2*amel2^2*x3*xcp1 -64*e4e2^2*amel2^2*x3*x5*xcp3 -320*e4e2^2*amel2^2*x3*x5*xcp2 -64*e4e2^2*amel2^2*x3*x5*xcp1 +64*e4e2^2*amel2^2*x3*x5^2*xcp3 -64*e4e2^2*amel2^2*x3*x5^2*xcp2 +64*e4e2^2*amel2^2*x3*x5^2*xcp1 +64*e4e2^2*amel2^2*x3*x4*xcp3 -64*e4e2^2*amel2^2*x3*x4*xcp2 +64*e4e2^2*amel2^2*x3*x4*xcp1 +64*e4e2^2*amel2^2*x3*x4*x5*xcp3 +384*e4e2^2*amel2^2*x3*x4*x5*xcp2 +64*e4e2^2*amel2^2*x3*x4*x5*xcp1 +128*e4e2^2*amel2^2*x3^2*xcp2 -32*e4e2^2*amel2^2*x3^2*x5*xcp3 +256*e4e2^2*amel2^2*x3^2*x5*xcp2 -32*e4e2^2*amel2^2*x3^2*x5*xcp1 -128*e4e2^2*amel2^2*x3^2*x4*xcp2 -64*e4e2^2*amel2^2*x3^3*xcp2 +64*e4e2^2*amel2^2*x1*xcp3 +128*e4e2^2*amel2^2*x1*xcp2 +64*e4e2^2*amel2^2*x1*xcp1 -32*e4e2^2*amel2^2*x1*x5*xcp3 -128*e4e2^2*amel2^2*x1*x5*xcp2 -32*e4e2^2*amel2^2*x1*x5*xcp1 -64*e4e2^2*amel2^2*x1*x5^2*xcp3 -64*e4e2^2*amel2^2*x1*x5^2*xcp1 +64*e4e2^2*amel2^2*x1*x4*xcp3 -128*e4e2^2*amel2^2*x1*x4*xcp2 +64*e4e2^2*amel2^2*x1*x4*xcp1 -64*e4e2^2*amel2^2*x1*x4*x5*xcp3 +256*e4e2^2*amel2^2*x1*x4*x5*xcp2 -64*e4e2^2*amel2^2*x1*x4*x5*xcp1 +32*e4e2^2*amel2^2*x1*x3*xcp3 -256*e4e2^2*amel2^2*x1*x3*xcp2 +32*e4e2^2*amel2^2*x1*x3*xcp1 +512*e4e2^2*amel2^2*x1*x3*x5*xcp2 -128*e4e2^2*amel2^2*x1*x3^2*xcp2 +32*e4e2^2*amel2^2*x1^2*xcp3 +64*e4e2^2*amel2^2*x1^2*xcp2 +32*e4e2^2*amel2^2*x1^2*xcp1 -32*e4e2^2*amel2^2*x1^2*x5*xcp3 +128*e4e2^2*amel2^2*x1^2*x5*xcp2 -32*e4e2^2*amel2^2*x1^2*x5*xcp1 -64*e4e2^2*amel2^2*x1^2*x3*xcp2 -32*e4e2^2*e2e1*zk^2*xcp2 -32*e4e2^2*e2e1*zk^2*x4*xcp2 +32*e4e2^2*e2e1*zk^2*x3*xcp2 -64*e4e2^2*e2e1*amel2*x5*xcp3 +128*e4e2^2*e2e1*amel2*x5*xcp2 -64*e4e2^2*e2e1*amel2*x5*xcp1 +32*e4e2^2*e2e1*amel2*x5^2*xcp3 +832*e4e2^2*e2e1*amel2*x5^2*xcp2 +32*e4e2^2*e2e1*amel2*x5^2*xcp1 -512*e4e2^2*e2e1*amel2*x5^3*xcp2 +64*e4e2^2*e2e1*amel2*x4*xcp3 +384*e4e2^2*e2e1*amel2*x4*xcp2 +64*e4e2^2*e2e1*amel2*x4*xcp1 +320*e4e2^2*e2e1*amel2*x4*x5*xcp2 -64*e4e2^2*e2e1*amel2*x4*x5^2*xcp3 -640*e4e2^2*e2e1*amel2*x4*x5^2*xcp2 -64*e4e2^2*e2e1*amel2*x4*x5^2*xcp1 +64*e4e2^2*e2e1*amel2*x4^2*xcp3 -128*e4e2^2*e2e1*amel2*x4^2*xcp2 +64*e4e2^2*e2e1*amel2*x4^2*xcp1 -64*e4e2^2*e2e1*amel2*x4^2*x5*xcp3 -64*e4e2^2*e2e1*amel2*x4^2*x5*xcp1 +64*e4e2^2*e2e1*amel2*x3*xcp3 -128*e4e2^2*e2e1*amel2*x3*xcp2 +64*e4e2^2*e2e1*amel2*x3*xcp1 -192*e4e2^2*e2e1*amel2*x3*x5*xcp2 +128*e4e2^2*e2e1*amel2*x3*x5^2*xcp3 -384*e4e2^2*e2e1*amel2*x3*x5^2*xcp2 +128*e4e2^2*e2e1*amel2*x3*x5^2*xcp1 +64*e4e2^2*e2e1*amel2*x3*x4*xcp3 -576*e4e2^2*e2e1*amel2*x3*x4*xcp2 +64*e4e2^2*e2e1*amel2*x3*x4*xcp1 +64*e4e2^2*e2e1*amel2*x3*x4*x5*xcp3 +512*e4e2^2*e2e1*amel2*x3*x4*x5*xcp2 +64*e4e2^2*e2e1*amel2*x3*x4*x5*xcp1 +128*e4e2^2*e2e1*amel2*x3*x4^2*xcp2 +32*e4e2^2*e2e1*amel2*x3^2*xcp3 +32*e4e2^2*e2e1*amel2*x3^2*xcp1 +128*e4e2^2*e2e1*amel2*x3^2*x5*xcp3 +256*e4e2^2*e2e1*amel2*x3^2*x5*xcp2 +128*e4e2^2*e2e1*amel2*x3^2*x5*xcp1 +512*e4e2^2*e2e1*amel2*x1*xcp2 +32*e4e2^2*e2e1*amel2*x1*x5*xcp3 -576*e4e2^2*e2e1*amel2*x1*x5*xcp2 +32*e4e2^2*e2e1*amel2*x1*x5*xcp1 +64*e4e2^2*e2e1*amel2*x1*x4*xcp3 -128*e4e2^2*e2e1*amel2*x1*x4*xcp2 +64*e4e2^2*e2e1*amel2*x1*x4*xcp1 -64*e4e2^2*e2e1*amel2*x1*x4*x5*xcp3 +256*e4e2^2*e2e1*amel2*x1*x4*x5*xcp2 -64*e4e2^2*e2e1*amel2*x1*x4*x5*xcp1 +32*e4e2^2*e2e1*amel2*x1*x3*xcp3 -448*e4e2^2*e2e1*amel2*x1*x3*xcp2 +32*e4e2^2*e2e1*amel2*x1*x3*xcp1 -64*e4e2^2*e2e1*amel2*x1*x3*x5*xcp3 +640*e4e2^2*e2e1*amel2*x1*x3*x5*xcp2 -64*e4e2^2*e2e1*amel2*x1*x3*x5*xcp1 -128*e4e2^2*e2e1*amel2*x1^2*xcp2 +128*e4e2^2*e2e1*amel2*x1^2*x5*xcp2 -384*e4e2^2*e2e1^2*x5*xcp2 +768*e4e2^2*e2e1^2*x5^2*xcp2 -384*e4e2^2*e2e1^2*x5^3*xcp2 +384*e4e2^2*e2e1^2*x4*xcp2 +128*e4e2^2*e2e1^2*x4*x5*xcp2 -512*e4e2^2*e2e1^2*x4*x5^2*xcp2 -128*e4e2^2*e2e1^2*x4^2*xcp2 -128*e4e2^2*e2e1^2*x4^2*x5*xcp2 +512*e4e2^2*e2e1^2*x3*x5*xcp2 -512*e4e2^2*e2e1^2*x3*x5^2*xcp2 -512*e4e2^2*e2e1^2*x3*x4*xcp2 +128*e4e2^2*e2e1^2*x3*x4*x5*xcp2 +128*e4e2^2*e2e1^2*x3*x4^2*xcp2 -128*e4e2^2*e2e1^2*x3^2*x5*xcp2 +128*e4e2^2*e2e1^2*x3^2*x4*xcp2 -512*e4e2^2*e3e2*amel2*x5^2*xcp2 +256*e4e2^2*e3e2*amel2*x5^3*xcp2 -384*e4e2^2*e3e2*amel2*x4*xcp2 -64*e4e2^2*e3e2*amel2*x4*x5*xcp3 -64*e4e2^2*e3e2*amel2*x4*x5*xcp1 +64*e4e2^2*e3e2*amel2*x4*x5^2*xcp3 +128*e4e2^2*e3e2*amel2*x4*x5^2*xcp2 +64*e4e2^2*e3e2*amel2*x4*x5^2*xcp1 -64*e4e2^2*e3e2*amel2*x4^2*xcp3 -64*e4e2^2*e3e2*amel2*x4^2*xcp1 +64*e4e2^2*e3e2*amel2*x4^2*x5*xcp3 -128*e4e2^2*e3e2*amel2*x4^2*x5*xcp2 +64*e4e2^2*e3e2*amel2*x4^2*x5*xcp1 -128*e4e2^2*e3e2*amel2*x3*x5^2*xcp3 +256*e4e2^2*e3e2*amel2*x3*x5^2*xcp2 -128*e4e2^2*e3e2*amel2*x3*x5^2*xcp1 -64*e4e2^2*e3e2*amel2*x3*x4*xcp3 +256*e4e2^2*e3e2*amel2*x3*x4*xcp2 -64*e4e2^2*e3e2*amel2*x3*x4*xcp1 -256*e4e2^2*e3e2*amel2*x3*x4*x5*xcp2 -64*e4e2^2*e3e2*amel2*x3^2*x5*xcp3 -128*e4e2^2*e3e2*amel2*x3^2*x5*xcp2 -64*e4e2^2*e3e2*amel2*x3^2*x5*xcp1 -384*e4e2^2*e3e2*amel2*x1*xcp2 +256*e4e2^2*e3e2*amel2*x1*x5*xcp2 +128*e4e2^2*e3e2*amel2*x1*x5^2*xcp2 +384*e4e2^2*e3e2*amel2*x1*x4*xcp2 -128*e4e2^2*e3e2*amel2*x1*x4*x5*xcp2 +512*e4e2^2*e3e2*amel2*x1*x3*xcp2 -256*e4e2^2*e3e2*amel2*x1*x3*x5*xcp2 -128*e4e2^2*e3e2*amel2*x1*x3*x4*xcp2 -128*e4e2^2*e3e2*amel2*x1*x3^2*xcp2 +384*e4e2^2*e3e2*e2e1*x5*xcp2 -768*e4e2^2*e3e2*e2e1*x5^2*xcp2 +384*e4e2^2*e3e2*e2e1*x5^3*xcp2 -384*e4e2^2*e3e2*e2e1*x4*xcp2 -128*e4e2^2*e3e2*e2e1*x4*x5*xcp2 +512*e4e2^2*e3e2*e2e1*x4*x5^2*xcp2 +128*e4e2^2*e3e2*e2e1*x4^2*xcp2 +128*e4e2^2*e3e2*e2e1*x4^2*x5*xcp2 -512*e4e2^2*e3e2*e2e1*x3*x5*xcp2 +512*e4e2^2*e3e2*e2e1*x3*x5^2*xcp2 +512*e4e2^2*e3e2*e2e1*x3*x4*xcp2 -128*e4e2^2*e3e2*e2e1*x3*x4*x5*xcp2 -128*e4e2^2*e3e2*e2e1*x3*x4^2*xcp2 +128*e4e2^2*e3e2*e2e1*x3^2*x5*xcp2 -128*e4e2^2*e3e2*e2e1*x3^2*x4*xcp2 +96*e4e2^2*e3e1*zk^2*xcp2 -64*e4e2^2*e3e1*zk^2*x5*xcp2 +32*e4e2^2*e3e1*zk^2*x4*xcp2 -32*e4e2^2*e3e1*zk^2*x3*xcp2 +256*e4e2^2*e3e1*amel2*xcp2 -512*e4e2^2*e3e1*amel2*x5*xcp2 -32*e4e2^2*e3e1*amel2*x5^2*xcp3 -192*e4e2^2*e3e1*amel2*x5^2*xcp2 -32*e4e2^2*e3e1*amel2*x5^2*xcp1 +64*e4e2^2*e3e1*amel2*x5^3*xcp3 +128*e4e2^2*e3e1*amel2*x5^3*xcp2 +64*e4e2^2*e3e1*amel2*x5^3*xcp1 -64*e4e2^2*e3e1*amel2*x4*xcp3 -512*e4e2^2*e3e1*amel2*x4*xcp2 -64*e4e2^2*e3e1*amel2*x4*xcp1 +64*e4e2^2*e3e1*amel2*x4*x5*xcp2 +128*e4e2^2*e3e1*amel2*x4*x5^2*xcp3 +128*e4e2^2*e3e1*amel2*x4*x5^2*xcp2 +128*e4e2^2*e3e1*amel2*x4*x5^2*xcp1 -64*e4e2^2*e3e1*amel2*x4^2*xcp3 +256*e4e2^2*e3e1*amel2*x4^2*xcp2 -64*e4e2^2*e3e1*amel2*x4^2*xcp1 +64*e4e2^2*e3e1*amel2*x4^2*x5*xcp3 -128*e4e2^2*e3e1*amel2*x4^2*x5*xcp2 +64*e4e2^2*e3e1*amel2*x4^2*x5*xcp1 -64*e4e2^2*e3e1*amel2*x3*xcp3 -256*e4e2^2*e3e1*amel2*x3*xcp2 -64*e4e2^2*e3e1*amel2*x3*xcp1 +320*e4e2^2*e3e1*amel2*x3*x5*xcp2 +128*e4e2^2*e3e1*amel2*x3*x5^2*xcp2 -64*e4e2^2*e3e1*amel2*x3*x4*xcp3 +576*e4e2^2*e3e1*amel2*x3*x4*xcp2 -64*e4e2^2*e3e1*amel2*x3*x4*xcp1 -64*e4e2^2*e3e1*amel2*x3*x4*x5*xcp3 -256*e4e2^2*e3e1*amel2*x3*x4*x5*xcp2 -64*e4e2^2*e3e1*amel2*x3*x4*x5*xcp1 -128*e4e2^2*e3e1*amel2*x3*x4^2*xcp2 -32*e4e2^2*e3e1*amel2*x3^2*xcp3 -32*e4e2^2*e3e1*amel2*x3^2*xcp1 -64*e4e2^2*e3e1*amel2*x3^2*x5*xcp3 +128*e4e2^2*e3e1*amel2*x3^2*x5*xcp2 -64*e4e2^2*e3e1*amel2*x3^2*x5*xcp1 -640*e4e2^2*e3e1*amel2*x1*xcp2 -32*e4e2^2*e3e1*amel2*x1*x5*xcp3 +704*e4e2^2*e3e1*amel2*x1*x5*xcp2 -32*e4e2^2*e3e1*amel2*x1*x5*xcp1 +64*e4e2^2*e3e1*amel2*x1*x5^2*xcp3 -256*e4e2^2*e3e1*amel2*x1*x5^2*xcp2 +64*e4e2^2*e3e1*amel2*x1*x5^2*xcp1 -64*e4e2^2*e3e1*amel2*x1*x4*xcp3 +128*e4e2^2*e3e1*amel2*x1*x4*xcp2 -64*e4e2^2*e3e1*amel2*x1*x4*xcp1 +64*e4e2^2*e3e1*amel2*x1*x4*x5*xcp3 -256*e4e2^2*e3e1*amel2*x1*x4*x5*xcp2 +64*e4e2^2*e3e1*amel2*x1*x4*x5*xcp1 -32*e4e2^2*e3e1*amel2*x1*x3*xcp3 +448*e4e2^2*e3e1*amel2*x1*x3*xcp2 -32*e4e2^2*e3e1*amel2*x1*x3*xcp1 +64*e4e2^2*e3e1*amel2*x1*x3*x5*xcp3 -384*e4e2^2*e3e1*amel2*x1*x3*x5*xcp2 +64*e4e2^2*e3e1*amel2*x1*x3*x5*xcp1 +128*e4e2^2*e3e1*amel2*x1^2*xcp2 -128*e4e2^2*e3e1*amel2*x1^2*x5*xcp2 +256*e4e2^2*e3e1*e2e1*xcp2 -128*e4e2^2*e3e1*e2e1*x5*xcp2 -512*e4e2^2*e3e1*e2e1*x5^2*xcp2 +384*e4e2^2*e3e1*e2e1*x5^3*xcp2 -896*e4e2^2*e3e1*e2e1*x4*xcp2 +384*e4e2^2*e3e1*e2e1*x4*x5*xcp2 +512*e4e2^2*e3e1*e2e1*x4*x5^2*xcp2 +384*e4e2^2*e3e1*e2e1*x4^2*xcp2 +128*e4e2^2*e3e1*e2e1*x4^2*x5*xcp2 -256*e4e2^2*e3e1*e2e1*x3*xcp2 -256*e4e2^2*e3e1*e2e1*x3*x5*xcp2 +512*e4e2^2*e3e1*e2e1*x3*x5^2*xcp2 +1024*e4e2^2*e3e1*e2e1*x3*x4*xcp2 -256*e4e2^2*e3e1*e2e1*x3*x4*x5*xcp2 -256*e4e2^2*e3e1*e2e1*x3*x4^2*xcp2 +256*e4e2^2*e3e1*e2e1*x3^2*x5*xcp2 -256*e4e2^2*e3e1*e2e1*x3^2*x4*xcp2 -256*e4e2^2*e3e1*e2e1*x1*xcp2 +384*e4e2^2*e3e1*e2e1*x1*x5*xcp2 -128*e4e2^2*e3e1*e2e1*x1*x5^2*xcp2 +128*e4e2^2*e3e1*e2e1*x1*x4*xcp2 -128*e4e2^2*e3e1*e2e1*x1*x4*x5*xcp2 +256*e4e2^2*e3e1*e2e1*x1*x3*xcp2 -256*e4e2^2*e3e1*e2e1*x1*x3*x5*xcp2 -256*e4e2^2*e3e1*e3e2*x5*xcp2 +512*e4e2^2*e3e1*e3e2*x5^2*xcp2 -256*e4e2^2*e3e1*e3e2*x5^3*xcp2 +512*e4e2^2*e3e1*e3e2*x4*xcp2 -384*e4e2^2*e3e1*e3e2*x4*x5*xcp2 -128*e4e2^2*e3e1*e3e2*x4*x5^2*xcp2 -384*e4e2^2*e3e1*e3e2*x4^2*xcp2 +128*e4e2^2*e3e1*e3e2*x4^2*x5*xcp2 +384*e4e2^2*e3e1*e3e2*x3*x5*xcp2 -384*e4e2^2*e3e1*e3e2*x3*x5^2*xcp2 -640*e4e2^2*e3e1*e3e2*x3*x4*xcp2 +256*e4e2^2*e3e1*e3e2*x3*x4*x5*xcp2 +128*e4e2^2*e3e1*e3e2*x3*x4^2*xcp2 -128*e4e2^2*e3e1*e3e2*x3^2*x5*xcp2 +128*e4e2^2*e3e1*e3e2*x3^2*x4*xcp2 -256*e4e2^2*e3e1^2*xcp2 +512*e4e2^2*e3e1^2*x5*xcp2 -256*e4e2^2*e3e1^2*x5^2*xcp2 +512*e4e2^2*e3e1^2*x4*xcp2 -512*e4e2^2*e3e1^2*x4*x5*xcp2 -256*e4e2^2*e3e1^2*x4^2*xcp2 +256*e4e2^2*e3e1^2*x3*xcp2 -256*e4e2^2*e3e1^2*x3*x5*xcp2 -512*e4e2^2*e3e1^2*x3*x4*xcp2 +128*e4e2^2*e3e1^2*x3*x4*x5*xcp2 +128*e4e2^2*e3e1^2*x3*x4^2*xcp2 -128*e4e2^2*e3e1^2*x3^2*x5*xcp2 +128*e4e2^2*e3e1^2*x3^2*x4*xcp2 +256*e4e2^2*e3e1^2*x1*xcp2 -384*e4e2^2*e3e1^2*x1*x5*xcp2 +128*e4e2^2*e3e1^2*x1*x5^2*xcp2 -128*e4e2^2*e3e1^2*x1*x4*xcp2 +128*e4e2^2*e3e1^2*x1*x4*x5*xcp2 -256*e4e2^2*e3e1^2*x1*x3*xcp2 +256*e4e2^2*e3e1^2*x1*x3*x5*xcp2 -256*e4e2^3*amel2*x5^2*xcp2 +128*e4e2^3*amel2*x5^3*xcp2 -128*e4e2^3*amel2*x4*xcp2 +128*e4e2^3*amel2*x4*x5^2*xcp2 +128*e4e2^3*amel2*x3*x5*xcp2 -64*e4e2^3*amel2*x3*x5^2*xcp3 +128*e4e2^3*amel2*x3*x5^2*xcp2 -64*e4e2^3*amel2*x3*x5^2*xcp1 +128*e4e2^3*amel2*x3*x4*xcp2 -128*e4e2^3*amel2*x3*x4*x5*xcp2 -128*e4e2^3*amel2*x3^2*x5*xcp2 -128*e4e2^3*amel2*x1*xcp2 +128*e4e2^3*amel2*x1*x5^2*xcp2 +128*e4e2^3*amel2*x1*x3*xcp2 -128*e4e2^3*amel2*x1*x3*x5*xcp2 +128*e4e2^3*e2e1*x5*xcp2 -256*e4e2^3*e2e1*x5^2*xcp2 +128*e4e2^3*e2e1*x5^3*xcp2 -128*e4e2^3*e2e1*x4*xcp2 +128*e4e2^3*e2e1*x4*x5^2*xcp2 -128*e4e2^3*e2e1*x3*x5*xcp2 +128*e4e2^3*e2e1*x3*x5^2*xcp2 +128*e4e2^3*e2e1*x3*x4*xcp2 -128*e4e2^3*e2e1*x3*x4*x5*xcp2 -128*e4e2^3*e3e1*x5*xcp2 +256*e4e2^3*e3e1*x5^2*xcp2 -128*e4e2^3*e3e1*x5^3*xcp2 +128*e4e2^3*e3e1*x4*xcp2 -128*e4e2^3*e3e1*x4*x5^2*xcp2 +128*e4e2^3*e3e1*x3*x5*xcp2 -128*e4e2^3*e3e1*x3*x5^2*xcp2 -128*e4e2^3*e3e1*x3*x4*xcp2 +128*e4e2^3*e3e1*x3*x4*x5*xcp2 -64*e4e1*amel2^2*zk^2*xcp3 -64*e4e1*amel2^2*zk^2*xcp1 +96*e4e1*amel2^2*zk^2*x1*xcp3 +96*e4e1*amel2^2*zk^2*x1*xcp1 -64*e4e1*amel2^3*x5^2*xcp3 -64*e4e1*amel2^3*x5^2*xcp1 -128*e4e1*amel2^3*x4*x5*xcp3 +256*e4e1*amel2^3*x4*x5*xcp2 -128*e4e1*amel2^3*x4*x5*xcp1 -128*e4e1*amel2^3*x4^2*xcp3 +256*e4e1*amel2^3*x4^2*xcp2 -128*e4e1*amel2^3*x4^2*xcp1 +256*e4e1*amel2^3*x3*x5*xcp2 -128*e4e1*amel2^3*x3*x4*xcp3 +256*e4e1*amel2^3*x3*x4*xcp2 -128*e4e1*amel2^3*x3*x4*xcp1 -64*e4e1*amel2^3*x3^2*xcp3 -64*e4e1*amel2^3*x3^2*xcp1 +192*e4e1*amel2^3*x1*xcp3 +192*e4e1*amel2^3*x1*xcp1 -64*e4e1*amel2^3*x1*x5*xcp3 -64*e4e1*amel2^3*x1*x5*xcp1 +64*e4e1*amel2^3*x1*x5^2*xcp3 +64*e4e1*amel2^3*x1*x5^2*xcp1 -128*e4e1*amel2^3*x1*x4*xcp3 +256*e4e1*amel2^3*x1*x4*xcp2 -128*e4e1*amel2^3*x1*x4*xcp1 +128*e4e1*amel2^3*x1*x4*x5*xcp3 -256*e4e1*amel2^3*x1*x4*x5*xcp2 +128*e4e1*amel2^3*x1*x4*x5*xcp1 +128*e4e1*amel2^3*x1*x4^2*xcp3 -256*e4e1*amel2^3*x1*x4^2*xcp2 +128*e4e1*amel2^3*x1*x4^2*xcp1 -256*e4e1*amel2^3*x1*x3*xcp3 +256*e4e1*amel2^3*x1*x3*xcp2 -256*e4e1*amel2^3*x1*x3*xcp1 -256*e4e1*amel2^3*x1*x3*x5*xcp2 +128*e4e1*amel2^3*x1*x3*x4*xcp3 -256*e4e1*amel2^3*x1*x3*x4*xcp2 +128*e4e1*amel2^3*x1*x3*x4*xcp1 +64*e4e1*amel2^3*x1*x3^2*xcp3 +64*e4e1*amel2^3*x1*x3^2*xcp1 -192*e4e1*amel2^3*x1^2*xcp3 -192*e4e1*amel2^3*x1^2*xcp1 +128*e4e1*amel2^3*x1^2*x5*xcp3 +128*e4e1*amel2^3*x1^2*x5*xcp1 +128*e4e1*amel2^3*x1^2*x4*xcp3 +128*e4e1*amel2^3*x1^2*x4*xcp2 +128*e4e1*amel2^3*x1^2*x4*xcp1 +192*e4e1*amel2^3*x1^2*x3*xcp3 +128*e4e1*amel2^3*x1^2*x3*xcp2 +192*e4e1*amel2^3*x1^2*x3*xcp1 +64*e4e1*amel2^3*x1^3*xcp3 +64*e4e1*amel2^3*x1^3*xcp1 +64*e4e1*e2e1*amel2*zk^2*xcp3 -64*e4e1*e2e1*amel2*zk^2*xcp2 +64*e4e1*e2e1*amel2*zk^2*xcp1 -48*e4e1*e2e1*amel2*zk^2*x5*xcp3 -64*e4e1*e2e1*amel2*zk^2*x5*xcp2 -48*e4e1*e2e1*amel2*zk^2*x5*xcp1 -32*e4e1*e2e1*amel2*zk^2*x4*xcp2 +32*e4e1*e2e1*amel2*zk^2*x3*xcp2 -48*e4e1*e2e1*amel2*zk^2*x1*xcp3 +96*e4e1*e2e1*amel2*zk^2*x1*xcp2 -48*e4e1*e2e1*amel2*zk^2*x1*xcp1 +128*e4e1*e2e1*amel2^2*xcp3 +128*e4e1*e2e1*amel2^2*xcp1 -128*e4e1*e2e1*amel2^2*x5*xcp3 -512*e4e1*e2e1*amel2^2*x5*xcp2 -128*e4e1*e2e1*amel2^2*x5*xcp1 +32*e4e1*e2e1*amel2^2*x5^2*xcp3 +256*e4e1*e2e1*amel2^2*x5^2*xcp2 +32*e4e1*e2e1*amel2^2*x5^2*xcp1 -32*e4e1*e2e1*amel2^2*x5^3*xcp3 -32*e4e1*e2e1*amel2^2*x5^3*xcp1 -64*e4e1*e2e1*amel2^2*x4*xcp3 -640*e4e1*e2e1*amel2^2*x4*xcp2 -64*e4e1*e2e1*amel2^2*x4*xcp1 +704*e4e1*e2e1*amel2^2*x4*x5*xcp2 -64*e4e1*e2e1*amel2^2*x4*x5^2*xcp3 +128*e4e1*e2e1*amel2^2*x4*x5^2*xcp2 -64*e4e1*e2e1*amel2^2*x4*x5^2*xcp1 +512*e4e1*e2e1*amel2^2*x4^2*xcp2 -64*e4e1*e2e1*amel2^2*x4^2*x5*xcp3 +128*e4e1*e2e1*amel2^2*x4^2*x5*xcp2 -64*e4e1*e2e1*amel2^2*x4^2*x5*xcp1 -256*e4e1*e2e1*amel2^2*x3*xcp3 -128*e4e1*e2e1*amel2^2*x3*xcp2 -256*e4e1*e2e1*amel2^2*x3*xcp1 +64*e4e1*e2e1*amel2^2*x3*x5*xcp3 +704*e4e1*e2e1*amel2^2*x3*x5*xcp2 +64*e4e1*e2e1*amel2^2*x3*x5*xcp1 +128*e4e1*e2e1*amel2^2*x3*x5^2*xcp2 +64*e4e1*e2e1*amel2^2*x3*x4*xcp3 +960*e4e1*e2e1*amel2^2*x3*x4*xcp2 +64*e4e1*e2e1*amel2^2*x3*x4*xcp1 -64*e4e1*e2e1*amel2^2*x3*x4*x5*xcp3 -64*e4e1*e2e1*amel2^2*x3*x4*x5*xcp1 -128*e4e1*e2e1*amel2^2*x3*x4^2*xcp2 +96*e4e1*e2e1*amel2^2*x3^2*xcp3 +192*e4e1*e2e1*amel2^2*x3^2*xcp2 +96*e4e1*e2e1*amel2^2*x3^2*xcp1 -32*e4e1*e2e1*amel2^2*x3^2*x5*xcp3 -128*e4e1*e2e1*amel2^2*x3^2*x5*xcp2 -32*e4e1*e2e1*amel2^2*x3^2*x5*xcp1 -128*e4e1*e2e1*amel2^2*x3^2*x4*xcp2 -64*e4e1*e2e1*amel2^2*x1*xcp3 -64*e4e1*e2e1*amel2^2*x1*xcp1 +192*e4e1*e2e1*amel2^2*x1*x5*xcp3 +640*e4e1*e2e1*amel2^2*x1*x5*xcp2 +192*e4e1*e2e1*amel2^2*x1*x5*xcp1 -96*e4e1*e2e1*amel2^2*x1*x5^2*xcp3 -384*e4e1*e2e1*amel2^2*x1*x5^2*xcp2 -96*e4e1*e2e1*amel2^2*x1*x5^2*xcp1 -64*e4e1*e2e1*amel2^2*x1*x4*xcp3 +832*e4e1*e2e1*amel2^2*x1*x4*xcp2 -64*e4e1*e2e1*amel2^2*x1*x4*xcp1 -896*e4e1*e2e1*amel2^2*x1*x4*x5*xcp2 +64*e4e1*e2e1*amel2^2*x1*x4^2*xcp3 -384*e4e1*e2e1*amel2^2*x1*x4^2*xcp2 +64*e4e1*e2e1*amel2^2*x1*x4^2*xcp1 +192*e4e1*e2e1*amel2^2*x1*x3*xcp2 -640*e4e1*e2e1*amel2^2*x1*x3*x5*xcp2 +192*e4e1*e2e1*amel2^2*x1*x3*x4*xcp3 -512*e4e1*e2e1*amel2^2*x1*x3*x4*xcp2 +192*e4e1*e2e1*amel2^2*x1*x3*x4*xcp1 -32*e4e1*e2e1*amel2^2*x1*x3^2*xcp3 -32*e4e1*e2e1*amel2^2*x1*x3^2*xcp1 -96*e4e1*e2e1*amel2^2*x1^2*xcp3 -256*e4e1*e2e1*amel2^2*x1^2*xcp2 -96*e4e1*e2e1*amel2^2*x1^2*xcp1 -96*e4e1*e2e1*amel2^2*x1^2*x5*xcp3 +128*e4e1*e2e1*amel2^2*x1^2*x5*xcp2 -96*e4e1*e2e1*amel2^2*x1^2*x5*xcp1 +64*e4e1*e2e1*amel2^2*x1^2*x4*xcp3 +384*e4e1*e2e1*amel2^2*x1^2*x4*xcp2 +64*e4e1*e2e1*amel2^2*x1^2*x4*xcp1 +128*e4e1*e2e1*amel2^2*x1^2*x3*xcp3 +512*e4e1*e2e1*amel2^2*x1^2*x3*xcp2 +128*e4e1*e2e1*amel2^2*x1^2*x3*xcp1 -32*e4e1*e2e1*amel2^2*x1^3*xcp3 +128*e4e1*e2e1*amel2^2*x1^3*xcp2 -32*e4e1*e2e1*amel2^2*x1^3*xcp1 +64*e4e1*e2e1^2*zk^2*xcp2 -64*e4e1*e2e1^2*zk^2*x5*xcp2 -32*e4e1*e2e1^2*zk^2*x4*xcp2 -96*e4e1*e2e1^2*zk^2*x3*xcp2 +32*e4e1*e2e1^2*zk^2*x1*xcp2 +128*e4e1*e2e1^2*amel2*xcp3 +256*e4e1*e2e1^2*amel2*xcp2 +128*e4e1*e2e1^2*amel2*xcp1 -896*e4e1*e2e1^2*amel2*x5*xcp2 -32*e4e1*e2e1^2*amel2*x5^2*xcp3 +192*e4e1*e2e1^2*amel2*x5^2*xcp2 -32*e4e1*e2e1^2*amel2*x5^2*xcp1 +128*e4e1*e2e1^2*amel2*x5^3*xcp2 -64*e4e1*e2e1^2*amel2*x4*xcp3 -1152*e4e1*e2e1^2*amel2*x4*xcp2 -64*e4e1*e2e1^2*amel2*x4*xcp1 +128*e4e1*e2e1^2*amel2*x4*x5*xcp3 +576*e4e1*e2e1^2*amel2*x4*x5*xcp2 +128*e4e1*e2e1^2*amel2*x4*x5*xcp1 -64*e4e1*e2e1^2*amel2*x4*x5^2*xcp3 +384*e4e1*e2e1^2*amel2*x4*x5^2*xcp2 -64*e4e1*e2e1^2*amel2*x4*x5^2*xcp1 +128*e4e1*e2e1^2*amel2*x4^2*xcp3 +512*e4e1*e2e1^2*amel2*x4^2*xcp2 +128*e4e1*e2e1^2*amel2*x4^2*xcp1 -64*e4e1*e2e1^2*amel2*x4^2*x5*xcp3 +256*e4e1*e2e1^2*amel2*x4^2*x5*xcp2 -64*e4e1*e2e1^2*amel2*x4^2*x5*xcp1 -128*e4e1*e2e1^2*amel2*x3*xcp3 -768*e4e1*e2e1^2*amel2*x3*xcp2 -128*e4e1*e2e1^2*amel2*x3*xcp1 +832*e4e1*e2e1^2*amel2*x3*x5*xcp2 +256*e4e1*e2e1^2*amel2*x3*x5^2*xcp2 +192*e4e1*e2e1^2*amel2*x3*x4*xcp3 +1344*e4e1*e2e1^2*amel2*x3*x4*xcp2 +192*e4e1*e2e1^2*amel2*x3*x4*xcp1 -64*e4e1*e2e1^2*amel2*x3*x4*x5*xcp3 +128*e4e1*e2e1^2*amel2*x3*x4*x5*xcp2 -64*e4e1*e2e1^2*amel2*x3*x4*x5*xcp1 -256*e4e1*e2e1^2*amel2*x3*x4^2*xcp2 +32*e4e1*e2e1^2*amel2*x3^2*xcp3 +640*e4e1*e2e1^2*amel2*x3^2*xcp2 +32*e4e1*e2e1^2*amel2*x3^2*xcp1 -256*e4e1*e2e1^2*amel2*x3^2*x4*xcp2 -128*e4e1*e2e1^2*amel2*x3^3*xcp2 -128*e4e1*e2e1^2*amel2*x1*xcp3 -384*e4e1*e2e1^2*amel2*x1*xcp2 -128*e4e1*e2e1^2*amel2*x1*xcp1 +64*e4e1*e2e1^2*amel2*x1*x5*xcp3 +1280*e4e1*e2e1^2*amel2*x1*x5*xcp2 +64*e4e1*e2e1^2*amel2*x1*x5*xcp1 -640*e4e1*e2e1^2*amel2*x1*x5^2*xcp2 +64*e4e1*e2e1^2*amel2*x1*x4*xcp3 +832*e4e1*e2e1^2*amel2*x1*x4*xcp2 +64*e4e1*e2e1^2*amel2*x1*x4*xcp1 -128*e4e1*e2e1^2*amel2*x1*x4*x5*xcp3 -1024*e4e1*e2e1^2*amel2*x1*x4*x5*xcp2 -128*e4e1*e2e1^2*amel2*x1*x4*x5*xcp1 -64*e4e1*e2e1^2*amel2*x1*x4^2*xcp3 -256*e4e1*e2e1^2*amel2*x1*x4^2*xcp2 -64*e4e1*e2e1^2*amel2*x1*x4^2*xcp1 +128*e4e1*e2e1^2*amel2*x1*x3*xcp3 +576*e4e1*e2e1^2*amel2*x1*x3*xcp2 +128*e4e1*e2e1^2*amel2*x1*x3*xcp1 -1024*e4e1*e2e1^2*amel2*x1*x3*x5*xcp2 +64*e4e1*e2e1^2*amel2*x1*x3*x4*xcp3 -512*e4e1*e2e1^2*amel2*x1*x3*x4*xcp2 +64*e4e1*e2e1^2*amel2*x1*x3*x4*xcp1 +128*e4e1*e2e1^2*amel2*x1*x3^2*xcp3 -256*e4e1*e2e1^2*amel2*x1*x3^2*xcp2 +128*e4e1*e2e1^2*amel2*x1*x3^2*xcp1 +32*e4e1*e2e1^2*amel2*x1^2*xcp3 -192*e4e1*e2e1^2*amel2*x1^2*xcp2 +32*e4e1*e2e1^2*amel2*x1^2*xcp1 +128*e4e1*e2e1^2*amel2*x1^2*x5*xcp2 -64*e4e1*e2e1^2*amel2*x1^2*x4*xcp3 +256*e4e1*e2e1^2*amel2*x1^2*x4*xcp2 -64*e4e1*e2e1^2*amel2*x1^2*x4*xcp1 -64*e4e1*e2e1^2*amel2*x1^2*x3*xcp3 +384*e4e1*e2e1^2*amel2*x1^2*x3*xcp2 -64*e4e1*e2e1^2*amel2*x1^2*x3*xcp1 +128*e4e1*e2e1^2*amel2*x1^3*xcp2 +256*e4e1*e2e1^3*xcp2 -256*e4e1*e2e1^3*x5*xcp2 -128*e4e1*e2e1^3*x5^2*xcp2 +128*e4e1*e2e1^3*x5^3*xcp2 -512*e4e1*e2e1^3*x4*xcp2 +128*e4e1*e2e1^3*x4*x5*xcp2 +256*e4e1*e2e1^3*x4*x5^2*xcp2 +256*e4e1*e2e1^3*x4^2*xcp2 +128*e4e1*e2e1^3*x4^2*x5*xcp2 -512*e4e1*e2e1^3*x3*xcp2 +128*e4e1*e2e1^3*x3*x5*xcp2 +256*e4e1*e2e1^3*x3*x5^2*xcp2 +640*e4e1*e2e1^3*x3*x4*xcp2 +128*e4e1*e2e1^3*x3*x4*x5*xcp2 -128*e4e1*e2e1^3*x3*x4^2*xcp2 +256*e4e1*e2e1^3*x3^2*xcp2 +128*e4e1*e2e1^3*x3^2*x5*xcp2 -128*e4e1*e2e1^3*x3^2*x4*xcp2 -256*e4e1*e2e1^3*x1*xcp2 +512*e4e1*e2e1^3*x1*x5*xcp2 -256*e4e1*e2e1^3*x1*x5^2*xcp2 +256*e4e1*e2e1^3*x1*x4*xcp2 -384*e4e1*e2e1^3*x1*x4*x5*xcp2 -128*e4e1*e2e1^3*x1*x4^2*xcp2 +512*e4e1*e2e1^3*x1*x3*xcp2 -512*e4e1*e2e1^3*x1*x3*x5*xcp2 -256*e4e1*e2e1^3*x1*x3*x4*xcp2 -256*e4e1*e2e1^3*x1*x3^2*xcp2 -64*e4e1*e3e2*amel2*zk^2*xcp3 +64*e4e1*e3e2*amel2*zk^2*xcp2 -64*e4e1*e3e2*amel2*zk^2*xcp1 +48*e4e1*e3e2*amel2*zk^2*x5*xcp3 +64*e4e1*e3e2*amel2*zk^2*x5*xcp2 +48*e4e1*e3e2*amel2*zk^2*x5*xcp1 +32*e4e1*e3e2*amel2*zk^2*x4*xcp2 -32*e4e1*e3e2*amel2*zk^2*x3*xcp2 +48*e4e1*e3e2*amel2*zk^2*x1*xcp3 -96*e4e1*e3e2*amel2*zk^2*x1*xcp2 +48*e4e1*e3e2*amel2*zk^2*x1*xcp1 -128*e4e1*e3e2*amel2^2*xcp3 -128*e4e1*e3e2*amel2^2*xcp1 +128*e4e1*e3e2*amel2^2*x5*xcp3 +512*e4e1*e3e2*amel2^2*x5*xcp2 +128*e4e1*e3e2*amel2^2*x5*xcp1 -32*e4e1*e3e2*amel2^2*x5^2*xcp3 -256*e4e1*e3e2*amel2^2*x5^2*xcp2 -32*e4e1*e3e2*amel2^2*x5^2*xcp1 +32*e4e1*e3e2*amel2^2*x5^3*xcp3 +32*e4e1*e3e2*amel2^2*x5^3*xcp1 +64*e4e1*e3e2*amel2^2*x4*xcp3 +640*e4e1*e3e2*amel2^2*x4*xcp2 +64*e4e1*e3e2*amel2^2*x4*xcp1 -704*e4e1*e3e2*amel2^2*x4*x5*xcp2 +64*e4e1*e3e2*amel2^2*x4*x5^2*xcp3 -128*e4e1*e3e2*amel2^2*x4*x5^2*xcp2 +64*e4e1*e3e2*amel2^2*x4*x5^2*xcp1 -512*e4e1*e3e2*amel2^2*x4^2*xcp2 +64*e4e1*e3e2*amel2^2*x4^2*x5*xcp3 -128*e4e1*e3e2*amel2^2*x4^2*x5*xcp2 +64*e4e1*e3e2*amel2^2*x4^2*x5*xcp1 +256*e4e1*e3e2*amel2^2*x3*xcp3 +128*e4e1*e3e2*amel2^2*x3*xcp2 +256*e4e1*e3e2*amel2^2*x3*xcp1 -64*e4e1*e3e2*amel2^2*x3*x5*xcp3 -704*e4e1*e3e2*amel2^2*x3*x5*xcp2 -64*e4e1*e3e2*amel2^2*x3*x5*xcp1 -128*e4e1*e3e2*amel2^2*x3*x5^2*xcp2 -64*e4e1*e3e2*amel2^2*x3*x4*xcp3 -960*e4e1*e3e2*amel2^2*x3*x4*xcp2 -64*e4e1*e3e2*amel2^2*x3*x4*xcp1 +64*e4e1*e3e2*amel2^2*x3*x4*x5*xcp3 +64*e4e1*e3e2*amel2^2*x3*x4*x5*xcp1 +128*e4e1*e3e2*amel2^2*x3*x4^2*xcp2 -96*e4e1*e3e2*amel2^2*x3^2*xcp3 -192*e4e1*e3e2*amel2^2*x3^2*xcp2 -96*e4e1*e3e2*amel2^2*x3^2*xcp1 +32*e4e1*e3e2*amel2^2*x3^2*x5*xcp3 +128*e4e1*e3e2*amel2^2*x3^2*x5*xcp2 +32*e4e1*e3e2*amel2^2*x3^2*x5*xcp1 +128*e4e1*e3e2*amel2^2*x3^2*x4*xcp2 +192*e4e1*e3e2*amel2^2*x1*xcp3 +192*e4e1*e3e2*amel2^2*x1*xcp1 -192*e4e1*e3e2*amel2^2*x1*x5*xcp3 -640*e4e1*e3e2*amel2^2*x1*x5*xcp2 -192*e4e1*e3e2*amel2^2*x1*x5*xcp1 +96*e4e1*e3e2*amel2^2*x1*x5^2*xcp3 +384*e4e1*e3e2*amel2^2*x1*x5^2*xcp2 +96*e4e1*e3e2*amel2^2*x1*x5^2*xcp1 -64*e4e1*e3e2*amel2^2*x1*x4*xcp3 -832*e4e1*e3e2*amel2^2*x1*x4*xcp2 -64*e4e1*e3e2*amel2^2*x1*x4*xcp1 +896*e4e1*e3e2*amel2^2*x1*x4*x5*xcp2 -64*e4e1*e3e2*amel2^2*x1*x4^2*xcp3 +384*e4e1*e3e2*amel2^2*x1*x4^2*xcp2 -64*e4e1*e3e2*amel2^2*x1*x4^2*xcp1 -128*e4e1*e3e2*amel2^2*x1*x3*xcp3 -192*e4e1*e3e2*amel2^2*x1*x3*xcp2 -128*e4e1*e3e2*amel2^2*x1*x3*xcp1 +640*e4e1*e3e2*amel2^2*x1*x3*x5*xcp2 -192*e4e1*e3e2*amel2^2*x1*x3*x4*xcp3 +512*e4e1*e3e2*amel2^2*x1*x3*x4*xcp2 -192*e4e1*e3e2*amel2^2*x1*x3*x4*xcp1 +32*e4e1*e3e2*amel2^2*x1*x3^2*xcp3 +32*e4e1*e3e2*amel2^2*x1*x3^2*xcp1 -32*e4e1*e3e2*amel2^2*x1^2*xcp3 +256*e4e1*e3e2*amel2^2*x1^2*xcp2 -32*e4e1*e3e2*amel2^2*x1^2*xcp1 +96*e4e1*e3e2*amel2^2*x1^2*x5*xcp3 -128*e4e1*e3e2*amel2^2*x1^2*x5*xcp2 +96*e4e1*e3e2*amel2^2*x1^2*x5*xcp1 +64*e4e1*e3e2*amel2^2*x1^2*x4*xcp3 -384*e4e1*e3e2*amel2^2*x1^2*x4*xcp2 +64*e4e1*e3e2*amel2^2*x1^2*x4*xcp1 -512*e4e1*e3e2*amel2^2*x1^2*x3*xcp2 +32*e4e1*e3e2*amel2^2*x1^3*xcp3 -128*e4e1*e3e2*amel2^2*x1^3*xcp2 +32*e4e1*e3e2*amel2^2*x1^3*xcp1 -160*e4e1*e3e2*e2e1*zk^2*xcp2 +128*e4e1*e3e2*e2e1*zk^2*x5*xcp2 +64*e4e1*e3e2*e2e1*zk^2*x4*xcp2 +192*e4e1*e3e2*e2e1*zk^2*x3*xcp2 -32*e4e1*e3e2*e2e1*zk^2*x1*xcp2 -128*e4e1*e3e2*e2e1*amel2*xcp3 -512*e4e1*e3e2*e2e1*amel2*xcp2 -128*e4e1*e3e2*e2e1*amel2*xcp1 -64*e4e1*e3e2*e2e1*amel2*x5*xcp3 +1536*e4e1*e3e2*e2e1*amel2*x5*xcp2 -64*e4e1*e3e2*e2e1*amel2*x5*xcp1 +64*e4e1*e3e2*e2e1*amel2*x5^2*xcp3 -256*e4e1*e3e2*e2e1*amel2*x5^2*xcp2 +64*e4e1*e3e2*e2e1*amel2*x5^2*xcp1 -256*e4e1*e3e2*e2e1*amel2*x5^3*xcp2 +64*e4e1*e3e2*e2e1*amel2*x4*xcp3 +2048*e4e1*e3e2*e2e1*amel2*x4*xcp2 +64*e4e1*e3e2*e2e1*amel2*x4*xcp1 -256*e4e1*e3e2*e2e1*amel2*x4*x5*xcp3 -896*e4e1*e3e2*e2e1*amel2*x4*x5*xcp2 -256*e4e1*e3e2*e2e1*amel2*x4*x5*xcp1 +128*e4e1*e3e2*e2e1*amel2*x4*x5^2*xcp3 -768*e4e1*e3e2*e2e1*amel2*x4*x5^2*xcp2 +128*e4e1*e3e2*e2e1*amel2*x4*x5^2*xcp1 -256*e4e1*e3e2*e2e1*amel2*x4^2*xcp3 -896*e4e1*e3e2*e2e1*amel2*x4^2*xcp2 -256*e4e1*e3e2*e2e1*amel2*x4^2*xcp1 +128*e4e1*e3e2*e2e1*amel2*x4^2*x5*xcp3 -512*e4e1*e3e2*e2e1*amel2*x4^2*x5*xcp2 +128*e4e1*e3e2*e2e1*amel2*x4^2*x5*xcp1 +128*e4e1*e3e2*e2e1*amel2*x3*xcp3 +1536*e4e1*e3e2*e2e1*amel2*x3*xcp2 +128*e4e1*e3e2*e2e1*amel2*x3*xcp1 -1408*e4e1*e3e2*e2e1*amel2*x3*x5*xcp2 -512*e4e1*e3e2*e2e1*amel2*x3*x5^2*xcp2 -384*e4e1*e3e2*e2e1*amel2*x3*x4*xcp3 -2432*e4e1*e3e2*e2e1*amel2*x3*x4*xcp2 -384*e4e1*e3e2*e2e1*amel2*x3*x4*xcp1 +128*e4e1*e3e2*e2e1*amel2*x3*x4*x5*xcp3 -256*e4e1*e3e2*e2e1*amel2*x3*x4*x5*xcp2 +128*e4e1*e3e2*e2e1*amel2*x3*x4*x5*xcp1 +512*e4e1*e3e2*e2e1*amel2*x3*x4^2*xcp2 -64*e4e1*e3e2*e2e1*amel2*x3^2*xcp3 -1280*e4e1*e3e2*e2e1*amel2*x3^2*xcp2 -64*e4e1*e3e2*e2e1*amel2*x3^2*xcp1 +512*e4e1*e3e2*e2e1*amel2*x3^2*x4*xcp2 +256*e4e1*e3e2*e2e1*amel2*x3^3*xcp2 +128*e4e1*e3e2*e2e1*amel2*x1*xcp3 +896*e4e1*e3e2*e2e1*amel2*x1*xcp2 +128*e4e1*e3e2*e2e1*amel2*x1*xcp1 -32*e4e1*e3e2*e2e1*amel2*x1*x5*xcp3 -2240*e4e1*e3e2*e2e1*amel2*x1*x5*xcp2 -32*e4e1*e3e2*e2e1*amel2*x1*x5*xcp1 +1024*e4e1*e3e2*e2e1*amel2*x1*x5^2*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x4*xcp3 -1600*e4e1*e3e2*e2e1*amel2*x1*x4*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x4*xcp1 +192*e4e1*e3e2*e2e1*amel2*x1*x4*x5*xcp3 +1536*e4e1*e3e2*e2e1*amel2*x1*x4*x5*xcp2 +192*e4e1*e3e2*e2e1*amel2*x1*x4*x5*xcp1 +128*e4e1*e3e2*e2e1*amel2*x1*x4^2*xcp3 +384*e4e1*e3e2*e2e1*amel2*x1*x4^2*xcp2 +128*e4e1*e3e2*e2e1*amel2*x1*x4^2*xcp1 -96*e4e1*e3e2*e2e1*amel2*x1*x3*xcp3 -1536*e4e1*e3e2*e2e1*amel2*x1*x3*xcp2 -96*e4e1*e3e2*e2e1*amel2*x1*x3*xcp1 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x5*xcp3 +1792*e4e1*e3e2*e2e1*amel2*x1*x3*x5*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x5*xcp1 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x4*xcp3 +1024*e4e1*e3e2*e2e1*amel2*x1*x3*x4*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x4*xcp1 -192*e4e1*e3e2*e2e1*amel2*x1*x3^2*xcp3 +640*e4e1*e3e2*e2e1*amel2*x1*x3^2*xcp2 -192*e4e1*e3e2*e2e1*amel2*x1*x3^2*xcp1 -32*e4e1*e3e2*e2e1*amel2*x1^2*xcp3 +192*e4e1*e3e2*e2e1*amel2*x1^2*xcp2 -32*e4e1*e3e2*e2e1*amel2*x1^2*xcp1 -128*e4e1*e3e2*e2e1*amel2*x1^2*x5*xcp2 +64*e4e1*e3e2*e2e1*amel2*x1^2*x4*xcp3 -384*e4e1*e3e2*e2e1*amel2*x1^2*x4*xcp2 +64*e4e1*e3e2*e2e1*amel2*x1^2*x4*xcp1 +64*e4e1*e3e2*e2e1*amel2*x1^2*x3*xcp3 -384*e4e1*e3e2*e2e1*amel2*x1^2*x3*xcp2 +64*e4e1*e3e2*e2e1*amel2*x1^2*x3*xcp1 -128*e4e1*e3e2*e2e1*amel2*x1^3*xcp2 -512*e4e1*e3e2*e2e1^2*xcp2 +384*e4e1*e3e2*e2e1^2*x5*xcp2 +512*e4e1*e3e2*e2e1^2*x5^2*xcp2 -384*e4e1*e3e2*e2e1^2*x5^3*xcp2 +1152*e4e1*e3e2*e2e1^2*x4*xcp2 -128*e4e1*e3e2*e2e1^2*x4*x5*xcp2 -768*e4e1*e3e2*e2e1^2*x4*x5^2*xcp2 -640*e4e1*e3e2*e2e1^2*x4^2*xcp2 -384*e4e1*e3e2*e2e1^2*x4^2*x5*xcp2 +1024*e4e1*e3e2*e2e1^2*x3*xcp2 -768*e4e1*e3e2*e2e1^2*x3*x5^2*xcp2 -1536*e4e1*e3e2*e2e1^2*x3*x4*xcp2 -384*e4e1*e3e2*e2e1^2*x3*x4*x5*xcp2 +384*e4e1*e3e2*e2e1^2*x3*x4^2*xcp2 -512*e4e1*e3e2*e2e1^2*x3^2*xcp2 -384*e4e1*e3e2*e2e1^2*x3^2*x5*xcp2 +384*e4e1*e3e2*e2e1^2*x3^2*x4*xcp2 +512*e4e1*e3e2*e2e1^2*x1*xcp2 -1024*e4e1*e3e2*e2e1^2*x1*x5*xcp2 +512*e4e1*e3e2*e2e1^2*x1*x5^2*xcp2 -512*e4e1*e3e2*e2e1^2*x1*x4*xcp2 +768*e4e1*e3e2*e2e1^2*x1*x4*x5*xcp2 +256*e4e1*e3e2*e2e1^2*x1*x4^2*xcp2 -1024*e4e1*e3e2*e2e1^2*x1*x3*xcp2 +1024*e4e1*e3e2*e2e1^2*x1*x3*x5*xcp2 +512*e4e1*e3e2*e2e1^2*x1*x3*x4*xcp2 +512*e4e1*e3e2*e2e1^2*x1*x3^2*xcp2 +96*e4e1*e3e2^2*zk^2*xcp2 -64*e4e1*e3e2^2*zk^2*x5*xcp2 -32*e4e1*e3e2^2*zk^2*x4*xcp2 -96*e4e1*e3e2^2*zk^2*x3*xcp2 +256*e4e1*e3e2^2*amel2*xcp2 +64*e4e1*e3e2^2*amel2*x5*xcp3 -640*e4e1*e3e2^2*amel2*x5*xcp2 +64*e4e1*e3e2^2*amel2*x5*xcp1 -32*e4e1*e3e2^2*amel2*x5^2*xcp3 +64*e4e1*e3e2^2*amel2*x5^2*xcp2 -32*e4e1*e3e2^2*amel2*x5^2*xcp1 +128*e4e1*e3e2^2*amel2*x5^3*xcp2 -896*e4e1*e3e2^2*amel2*x4*xcp2 +128*e4e1*e3e2^2*amel2*x4*x5*xcp3 +320*e4e1*e3e2^2*amel2*x4*x5*xcp2 +128*e4e1*e3e2^2*amel2*x4*x5*xcp1 -64*e4e1*e3e2^2*amel2*x4*x5^2*xcp3 +384*e4e1*e3e2^2*amel2*x4*x5^2*xcp2 -64*e4e1*e3e2^2*amel2*x4*x5^2*xcp1 +128*e4e1*e3e2^2*amel2*x4^2*xcp3 +384*e4e1*e3e2^2*amel2*x4^2*xcp2 +128*e4e1*e3e2^2*amel2*x4^2*xcp1 -64*e4e1*e3e2^2*amel2*x4^2*x5*xcp3 +256*e4e1*e3e2^2*amel2*x4^2*x5*xcp2 -64*e4e1*e3e2^2*amel2*x4^2*x5*xcp1 -768*e4e1*e3e2^2*amel2*x3*xcp2 +576*e4e1*e3e2^2*amel2*x3*x5*xcp2 +256*e4e1*e3e2^2*amel2*x3*x5^2*xcp2 +192*e4e1*e3e2^2*amel2*x3*x4*xcp3 +1088*e4e1*e3e2^2*amel2*x3*x4*xcp2 +192*e4e1*e3e2^2*amel2*x3*x4*xcp1 -64*e4e1*e3e2^2*amel2*x3*x4*x5*xcp3 +128*e4e1*e3e2^2*amel2*x3*x4*x5*xcp2 -64*e4e1*e3e2^2*amel2*x3*x4*x5*xcp1 -256*e4e1*e3e2^2*amel2*x3*x4^2*xcp2 +32*e4e1*e3e2^2*amel2*x3^2*xcp3 +640*e4e1*e3e2^2*amel2*x3^2*xcp2 +32*e4e1*e3e2^2*amel2*x3^2*xcp1 -256*e4e1*e3e2^2*amel2*x3^2*x4*xcp2 -128*e4e1*e3e2^2*amel2*x3^3*xcp2 -512*e4e1*e3e2^2*amel2*x1*xcp2 -32*e4e1*e3e2^2*amel2*x1*x5*xcp3 +960*e4e1*e3e2^2*amel2*x1*x5*xcp2 -32*e4e1*e3e2^2*amel2*x1*x5*xcp1 -384*e4e1*e3e2^2*amel2*x1*x5^2*xcp2 +768*e4e1*e3e2^2*amel2*x1*x4*xcp2 -64*e4e1*e3e2^2*amel2*x1*x4*x5*xcp3 -512*e4e1*e3e2^2*amel2*x1*x4*x5*xcp2 -64*e4e1*e3e2^2*amel2*x1*x4*x5*xcp1 -64*e4e1*e3e2^2*amel2*x1*x4^2*xcp3 -128*e4e1*e3e2^2*amel2*x1*x4^2*xcp2 -64*e4e1*e3e2^2*amel2*x1*x4^2*xcp1 -32*e4e1*e3e2^2*amel2*x1*x3*xcp3 +960*e4e1*e3e2^2*amel2*x1*x3*xcp2 -32*e4e1*e3e2^2*amel2*x1*x3*xcp1 +64*e4e1*e3e2^2*amel2*x1*x3*x5*xcp3 -768*e4e1*e3e2^2*amel2*x1*x3*x5*xcp2 +64*e4e1*e3e2^2*amel2*x1*x3*x5*xcp1 -512*e4e1*e3e2^2*amel2*x1*x3*x4*xcp2 +64*e4e1*e3e2^2*amel2*x1*x3^2*xcp3 -384*e4e1*e3e2^2*amel2*x1*x3^2*xcp2 +64*e4e1*e3e2^2*amel2*x1*x3^2*xcp1 +128*e4e1*e3e2^2*amel2*x1^2*x4*xcp2 +256*e4e1*e3e2^2*e2e1*xcp2 -640*e4e1*e3e2^2*e2e1*x5^2*xcp2 +384*e4e1*e3e2^2*e2e1*x5^3*xcp2 -768*e4e1*e3e2^2*e2e1*x4*xcp2 -128*e4e1*e3e2^2*e2e1*x4*x5*xcp2 +768*e4e1*e3e2^2*e2e1*x4*x5^2*xcp2 +512*e4e1*e3e2^2*e2e1*x4^2*xcp2 +384*e4e1*e3e2^2*e2e1*x4^2*x5*xcp2 -512*e4e1*e3e2^2*e2e1*x3*xcp2 -384*e4e1*e3e2^2*e2e1*x3*x5*xcp2 +768*e4e1*e3e2^2*e2e1*x3*x5^2*xcp2 +1152*e4e1*e3e2^2*e2e1*x3*x4*xcp2 +384*e4e1*e3e2^2*e2e1*x3*x4*x5*xcp2 -384*e4e1*e3e2^2*e2e1*x3*x4^2*xcp2 +256*e4e1*e3e2^2*e2e1*x3^2*xcp2 +384*e4e1*e3e2^2*e2e1*x3^2*x5*xcp2 -384*e4e1*e3e2^2*e2e1*x3^2*x4*xcp2 -256*e4e1*e3e2^2*e2e1*x1*xcp2 +512*e4e1*e3e2^2*e2e1*x1*x5*xcp2 -256*e4e1*e3e2^2*e2e1*x1*x5^2*xcp2 +256*e4e1*e3e2^2*e2e1*x1*x4*xcp2 -384*e4e1*e3e2^2*e2e1*x1*x4*x5*xcp2 -128*e4e1*e3e2^2*e2e1*x1*x4^2*xcp2 +512*e4e1*e3e2^2*e2e1*x1*x3*xcp2 -512*e4e1*e3e2^2*e2e1*x1*x3*x5*xcp2 -256*e4e1*e3e2^2*e2e1*x1*x3*x4*xcp2 -256*e4e1*e3e2^2*e2e1*x1*x3^2*xcp2 -128*e4e1*e3e2^3*x5*xcp2 +256*e4e1*e3e2^3*x5^2*xcp2 -128*e4e1*e3e2^3*x5^3*xcp2 +128*e4e1*e3e2^3*x4*xcp2 +128*e4e1*e3e2^3*x4*x5*xcp2 -256*e4e1*e3e2^3*x4*x5^2*xcp2 -128*e4e1*e3e2^3*x4^2*xcp2 -128*e4e1*e3e2^3*x4^2*x5*xcp2 +256*e4e1*e3e2^3*x3*x5*xcp2 -256*e4e1*e3e2^3*x3*x5^2*xcp2 -256*e4e1*e3e2^3*x3*x4*xcp2 -128*e4e1*e3e2^3*x3*x4*x5*xcp2 +128*e4e1*e3e2^3*x3*x4^2*xcp2 -128*e4e1*e3e2^3*x3^2*x5*xcp2 +128*e4e1*e3e2^3*x3^2*x4*xcp2 +112*e4e1*e3e1*amel2*zk^2*xcp3 +112*e4e1*e3e1*amel2*zk^2*xcp1 -48*e4e1*e3e1*amel2*zk^2*x5*xcp3 -48*e4e1*e3e1*amel2*zk^2*x5*xcp1 -48*e4e1*e3e1*amel2*zk^2*x4*xcp3 +32*e4e1*e3e1*amel2*zk^2*x4*xcp2 -48*e4e1*e3e1*amel2*zk^2*x4*xcp1 +32*e4e1*e3e1*amel2*zk^2*x3*xcp2 -96*e4e1*e3e1*amel2*zk^2*x1*xcp3 -96*e4e1*e3e1*amel2*zk^2*x1*xcp1 -160*e4e1*e3e1*amel2^2*x5*xcp3 -160*e4e1*e3e1*amel2^2*x5*xcp1 +224*e4e1*e3e1*amel2^2*x5^2*xcp3 +224*e4e1*e3e1*amel2^2*x5^2*xcp1 -32*e4e1*e3e1*amel2^2*x5^3*xcp3 -32*e4e1*e3e1*amel2^2*x5^3*xcp1 -160*e4e1*e3e1*amel2^2*x4*xcp3 +256*e4e1*e3e1*amel2^2*x4*xcp2 -160*e4e1*e3e1*amel2^2*x4*xcp1 +480*e4e1*e3e1*amel2^2*x4*x5*xcp3 -704*e4e1*e3e1*amel2^2*x4*x5*xcp2 +480*e4e1*e3e1*amel2^2*x4*x5*xcp1 -96*e4e1*e3e1*amel2^2*x4*x5^2*xcp3 +128*e4e1*e3e1*amel2^2*x4*x5^2*xcp2 -96*e4e1*e3e1*amel2^2*x4*x5^2*xcp1 +384*e4e1*e3e1*amel2^2*x4^2*xcp3 -704*e4e1*e3e1*amel2^2*x4^2*xcp2 +384*e4e1*e3e1*amel2^2*x4^2*xcp1 -128*e4e1*e3e1*amel2^2*x4^2*x5*xcp3 +256*e4e1*e3e1*amel2^2*x4^2*x5*xcp2 -128*e4e1*e3e1*amel2^2*x4^2*x5*xcp1 -64*e4e1*e3e1*amel2^2*x4^3*xcp3 +128*e4e1*e3e1*amel2^2*x4^3*xcp2 -64*e4e1*e3e1*amel2^2*x4^3*xcp1 +256*e4e1*e3e1*amel2^2*x3*xcp2 +160*e4e1*e3e1*amel2^2*x3*x5*xcp3 -704*e4e1*e3e1*amel2^2*x3*x5*xcp2 +160*e4e1*e3e1*amel2^2*x3*x5*xcp1 +128*e4e1*e3e1*amel2^2*x3*x5^2*xcp2 +416*e4e1*e3e1*amel2^2*x3*x4*xcp3 -960*e4e1*e3e1*amel2^2*x3*x4*xcp2 +416*e4e1*e3e1*amel2^2*x3*x4*xcp1 -64*e4e1*e3e1*amel2^2*x3*x4*x5*xcp3 +256*e4e1*e3e1*amel2^2*x3*x4*x5*xcp2 -64*e4e1*e3e1*amel2^2*x3*x4*x5*xcp1 -64*e4e1*e3e1*amel2^2*x3*x4^2*xcp3 +128*e4e1*e3e1*amel2^2*x3*x4^2*xcp2 -64*e4e1*e3e1*amel2^2*x3*x4^2*xcp1 +128*e4e1*e3e1*amel2^2*x3^2*xcp3 -256*e4e1*e3e1*amel2^2*x3^2*xcp2 +128*e4e1*e3e1*amel2^2*x3^2*xcp1 -32*e4e1*e3e1*amel2^2*x3^2*x5*xcp3 -32*e4e1*e3e1*amel2^2*x3^2*x5*xcp1 -32*e4e1*e3e1*amel2^2*x3^2*x4*xcp3 -32*e4e1*e3e1*amel2^2*x3^2*x4*xcp1 -512*e4e1*e3e1*amel2^2*x1*xcp3 -512*e4e1*e3e1*amel2^2*x1*xcp1 +384*e4e1*e3e1*amel2^2*x1*x5*xcp3 +384*e4e1*e3e1*amel2^2*x1*x5*xcp1 -256*e4e1*e3e1*amel2^2*x1*x5^2*xcp3 -256*e4e1*e3e1*amel2^2*x1*x5^2*xcp1 +480*e4e1*e3e1*amel2^2*x1*x4*xcp3 -320*e4e1*e3e1*amel2^2*x1*x4*xcp2 +480*e4e1*e3e1*amel2^2*x1*x4*xcp1 -512*e4e1*e3e1*amel2^2*x1*x4*x5*xcp3 +384*e4e1*e3e1*amel2^2*x1*x4*x5*xcp2 -512*e4e1*e3e1*amel2^2*x1*x4*x5*xcp1 -320*e4e1*e3e1*amel2^2*x1*x4^2*xcp3 +384*e4e1*e3e1*amel2^2*x1*x4^2*xcp2 -320*e4e1*e3e1*amel2^2*x1*x4^2*xcp1 +608*e4e1*e3e1*amel2^2*x1*x3*xcp3 -320*e4e1*e3e1*amel2^2*x1*x3*xcp2 +608*e4e1*e3e1*amel2^2*x1*x3*xcp1 -256*e4e1*e3e1*amel2^2*x1*x3*x5*xcp3 +384*e4e1*e3e1*amel2^2*x1*x3*x5*xcp2 -256*e4e1*e3e1*amel2^2*x1*x3*x5*xcp1 -384*e4e1*e3e1*amel2^2*x1*x3*x4*xcp3 +640*e4e1*e3e1*amel2^2*x1*x3*x4*xcp2 -384*e4e1*e3e1*amel2^2*x1*x3*x4*xcp1 -64*e4e1*e3e1*amel2^2*x1*x3^2*xcp3 +256*e4e1*e3e1*amel2^2*x1*x3^2*xcp2 -64*e4e1*e3e1*amel2^2*x1*x3^2*xcp1 +416*e4e1*e3e1*amel2^2*x1^2*xcp3 +416*e4e1*e3e1*amel2^2*x1^2*xcp1 -288*e4e1*e3e1*amel2^2*x1^2*x5*xcp3 -288*e4e1*e3e1*amel2^2*x1^2*x5*xcp1 -288*e4e1*e3e1*amel2^2*x1^2*x4*xcp3 -256*e4e1*e3e1*amel2^2*x1^2*x4*xcp2 -288*e4e1*e3e1*amel2^2*x1^2*x4*xcp1 -384*e4e1*e3e1*amel2^2*x1^2*x3*xcp3 -256*e4e1*e3e1*amel2^2*x1^2*x3*xcp2 -384*e4e1*e3e1*amel2^2*x1^2*x3*xcp1 -64*e4e1*e3e1*amel2^2*x1^3*xcp3 -64*e4e1*e3e1*amel2^2*x1^3*xcp1 -64*e4e1*e3e1*e2e1*zk^2*xcp2 +64*e4e1*e3e1*e2e1*zk^2*x5*xcp2 +64*e4e1*e3e1*e2e1*zk^2*x4*xcp2 +128*e4e1*e3e1*e2e1*zk^2*x3*xcp2 -128*e4e1*e3e1*e2e1*zk^2*x1*xcp2 -192*e4e1*e3e1*e2e1*amel2*xcp3 -512*e4e1*e3e1*e2e1*amel2*xcp2 -192*e4e1*e3e1*e2e1*amel2*xcp1 +192*e4e1*e3e1*e2e1*amel2*x5*xcp3 +1536*e4e1*e3e1*e2e1*amel2*x5*xcp2 +192*e4e1*e3e1*e2e1*amel2*x5*xcp1 -160*e4e1*e3e1*e2e1*amel2*x5^2*xcp3 -832*e4e1*e3e1*e2e1*amel2*x5^2*xcp2 -160*e4e1*e3e1*e2e1*amel2*x5^2*xcp1 +64*e4e1*e3e1*e2e1*amel2*x5^3*xcp3 +128*e4e1*e3e1*e2e1*amel2*x5^3*xcp2 +64*e4e1*e3e1*e2e1*amel2*x5^3*xcp1 -32*e4e1*e3e1*e2e1*amel2*x4*xcp3 +1920*e4e1*e3e1*e2e1*amel2*x4*xcp2 -32*e4e1*e3e1*e2e1*amel2*x4*xcp1 -32*e4e1*e3e1*e2e1*amel2*x4*x5*xcp3 -2048*e4e1*e3e1*e2e1*amel2*x4*x5*xcp2 -32*e4e1*e3e1*e2e1*amel2*x4*x5*xcp1 +64*e4e1*e3e1*e2e1*amel2*x4*x5^2*xcp3 +384*e4e1*e3e1*e2e1*amel2*x4*x5^2*xcp2 +64*e4e1*e3e1*e2e1*amel2*x4*x5^2*xcp1 +128*e4e1*e3e1*e2e1*amel2*x4^2*xcp3 -1344*e4e1*e3e1*e2e1*amel2*x4^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x4^2*xcp1 -64*e4e1*e3e1*e2e1*amel2*x4^2*x5*xcp3 +512*e4e1*e3e1*e2e1*amel2*x4^2*x5*xcp2 -64*e4e1*e3e1*e2e1*amel2*x4^2*x5*xcp1 -64*e4e1*e3e1*e2e1*amel2*x4^3*xcp3 +256*e4e1*e3e1*e2e1*amel2*x4^3*xcp2 -64*e4e1*e3e1*e2e1*amel2*x4^3*xcp1 +224*e4e1*e3e1*e2e1*amel2*x3*xcp3 +1408*e4e1*e3e1*e2e1*amel2*x3*xcp2 +224*e4e1*e3e1*e2e1*amel2*x3*xcp1 -160*e4e1*e3e1*e2e1*amel2*x3*x5*xcp3 -1920*e4e1*e3e1*e2e1*amel2*x3*x5*xcp2 -160*e4e1*e3e1*e2e1*amel2*x3*x5*xcp1 +64*e4e1*e3e1*e2e1*amel2*x3*x5^2*xcp3 +256*e4e1*e3e1*e2e1*amel2*x3*x5^2*xcp2 +64*e4e1*e3e1*e2e1*amel2*x3*x5^2*xcp1 +32*e4e1*e3e1*e2e1*amel2*x3*x4*xcp3 -2560*e4e1*e3e1*e2e1*amel2*x3*x4*xcp2 +32*e4e1*e3e1*e2e1*amel2*x3*x4*xcp1 +768*e4e1*e3e1*e2e1*amel2*x3*x4*x5*xcp2 -64*e4e1*e3e1*e2e1*amel2*x3*x4^2*xcp3 +640*e4e1*e3e1*e2e1*amel2*x3*x4^2*xcp2 -64*e4e1*e3e1*e2e1*amel2*x3*x4^2*xcp1 -1024*e4e1*e3e1*e2e1*amel2*x3^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x3^2*x5*xcp2 +384*e4e1*e3e1*e2e1*amel2*x3^2*x4*xcp2 +128*e4e1*e3e1*e2e1*amel2*x3^3*xcp2 -32*e4e1*e3e1*e2e1*amel2*x1*xcp3 +384*e4e1*e3e1*e2e1*amel2*x1*xcp2 -32*e4e1*e3e1*e2e1*amel2*x1*xcp1 -160*e4e1*e3e1*e2e1*amel2*x1*x5*xcp3 -960*e4e1*e3e1*e2e1*amel2*x1*x5*xcp2 -160*e4e1*e3e1*e2e1*amel2*x1*x5*xcp1 +128*e4e1*e3e1*e2e1*amel2*x1*x5^2*xcp3 +384*e4e1*e3e1*e2e1*amel2*x1*x5^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x1*x5^2*xcp1 +288*e4e1*e3e1*e2e1*amel2*x1*x4*xcp3 -1088*e4e1*e3e1*e2e1*amel2*x1*x4*xcp2 +288*e4e1*e3e1*e2e1*amel2*x1*x4*xcp1 +896*e4e1*e3e1*e2e1*amel2*x1*x4*x5*xcp2 -128*e4e1*e3e1*e2e1*amel2*x1*x4^2*xcp3 +384*e4e1*e3e1*e2e1*amel2*x1*x4^2*xcp2 -128*e4e1*e3e1*e2e1*amel2*x1*x4^2*xcp1 +64*e4e1*e3e1*e2e1*amel2*x1*x3*xcp3 -1024*e4e1*e3e1*e2e1*amel2*x1*x3*xcp2 +64*e4e1*e3e1*e2e1*amel2*x1*x3*xcp1 +1280*e4e1*e3e1*e2e1*amel2*x1*x3*x5*xcp2 -256*e4e1*e3e1*e2e1*amel2*x1*x3*x4*xcp3 +1280*e4e1*e3e1*e2e1*amel2*x1*x3*x4*xcp2 -256*e4e1*e3e1*e2e1*amel2*x1*x3*x4*xcp1 -64*e4e1*e3e1*e2e1*amel2*x1*x3^2*xcp3 +640*e4e1*e3e1*e2e1*amel2*x1*x3^2*xcp2 -64*e4e1*e3e1*e2e1*amel2*x1*x3^2*xcp1 +128*e4e1*e3e1*e2e1*amel2*x1^2*xcp3 +512*e4e1*e3e1*e2e1*amel2*x1^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x1^2*xcp1 +64*e4e1*e3e1*e2e1*amel2*x1^2*x5*xcp3 -384*e4e1*e3e1*e2e1*amel2*x1^2*x5*xcp2 +64*e4e1*e3e1*e2e1*amel2*x1^2*x5*xcp1 -64*e4e1*e3e1*e2e1*amel2*x1^2*x4*xcp3 -384*e4e1*e3e1*e2e1*amel2*x1^2*x4*xcp2 -64*e4e1*e3e1*e2e1*amel2*x1^2*x4*xcp1 -64*e4e1*e3e1*e2e1*amel2*x1^2*x3*xcp3 -384*e4e1*e3e1*e2e1*amel2*x1^2*x3*xcp2 -64*e4e1*e3e1*e2e1*amel2*x1^2*x3*xcp1 -128*e4e1*e3e1*e2e1*amel2*x1^3*xcp2 -768*e4e1*e3e1*e2e1^2*xcp2 +1280*e4e1*e3e1*e2e1^2*x5*xcp2 -512*e4e1*e3e1*e2e1^2*x5^2*xcp2 +1536*e4e1*e3e1*e2e1^2*x4*xcp2 -1408*e4e1*e3e1*e2e1^2*x4*x5*xcp2 +128*e4e1*e3e1*e2e1^2*x4*x5^2*xcp2 -896*e4e1*e3e1*e2e1^2*x4^2*xcp2 +256*e4e1*e3e1*e2e1^2*x4^2*x5*xcp2 +128*e4e1*e3e1*e2e1^2*x4^3*xcp2 +1536*e4e1*e3e1*e2e1^2*x3*xcp2 -1408*e4e1*e3e1*e2e1^2*x3*x5*xcp2 +128*e4e1*e3e1*e2e1^2*x3*x5^2*xcp2 -1920*e4e1*e3e1*e2e1^2*x3*x4*xcp2 +640*e4e1*e3e1*e2e1^2*x3*x4*x5*xcp2 +512*e4e1*e3e1*e2e1^2*x3*x4^2*xcp2 -768*e4e1*e3e1*e2e1^2*x3^2*xcp2 +128*e4e1*e3e1*e2e1^2*x3^2*x5*xcp2 +384*e4e1*e3e1*e2e1^2*x3^2*x4*xcp2 +512*e4e1*e3e1*e2e1^2*x1*xcp2 -896*e4e1*e3e1*e2e1^2*x1*x5*xcp2 +384*e4e1*e3e1*e2e1^2*x1*x5^2*xcp2 -640*e4e1*e3e1*e2e1^2*x1*x4*xcp2 +640*e4e1*e3e1*e2e1^2*x1*x4*x5*xcp2 +256*e4e1*e3e1*e2e1^2*x1*x4^2*xcp2 -1280*e4e1*e3e1*e2e1^2*x1*x3*xcp2 +1024*e4e1*e3e1*e2e1^2*x1*x3*x5*xcp2 +768*e4e1*e3e1*e2e1^2*x1*x3*x4*xcp2 +768*e4e1*e3e1*e2e1^2*x1*x3^2*xcp2 +256*e4e1*e3e1*e2e1^2*x1^2*xcp2 -128*e4e1*e3e1*e2e1^2*x1^2*x5*xcp2 -128*e4e1*e3e1*e2e1^2*x1^2*x4*xcp2 -256*e4e1*e3e1*e2e1^2*x1^2*x3*xcp2 +96*e4e1*e3e1*e3e2*zk^2*xcp2 -64*e4e1*e3e1*e3e2*zk^2*x5*xcp2 -64*e4e1*e3e1*e3e2*zk^2*x4*xcp2 -128*e4e1*e3e1*e3e2*zk^2*x3*xcp2 +96*e4e1*e3e1*e3e2*zk^2*x1*xcp2 +192*e4e1*e3e1*e3e2*amel2*xcp3 +512*e4e1*e3e1*e3e2*amel2*xcp2 +192*e4e1*e3e1*e3e2*amel2*xcp1 -256*e4e1*e3e1*e3e2*amel2*x5*xcp3 -1536*e4e1*e3e1*e3e2*amel2*x5*xcp2 -256*e4e1*e3e1*e3e2*amel2*x5*xcp1 +160*e4e1*e3e1*e3e2*amel2*x5^2*xcp3 +960*e4e1*e3e1*e3e2*amel2*x5^2*xcp2 +160*e4e1*e3e1*e3e2*amel2*x5^2*xcp1 -64*e4e1*e3e1*e3e2*amel2*x5^3*xcp3 -128*e4e1*e3e1*e3e2*amel2*x5^3*xcp2 -64*e4e1*e3e1*e3e2*amel2*x5^3*xcp1 -32*e4e1*e3e1*e3e2*amel2*x4*xcp3 -1920*e4e1*e3e1*e3e2*amel2*x4*xcp2 -32*e4e1*e3e1*e3e2*amel2*x4*xcp1 +32*e4e1*e3e1*e3e2*amel2*x4*x5*xcp3 +2304*e4e1*e3e1*e3e2*amel2*x4*x5*xcp2 +32*e4e1*e3e1*e3e2*amel2*x4*x5*xcp1 -64*e4e1*e3e1*e3e2*amel2*x4*x5^2*xcp3 -384*e4e1*e3e1*e3e2*amel2*x4*x5^2*xcp2 -64*e4e1*e3e1*e3e2*amel2*x4*x5^2*xcp1 -128*e4e1*e3e1*e3e2*amel2*x4^2*xcp3 +1472*e4e1*e3e1*e3e2*amel2*x4^2*xcp2 -128*e4e1*e3e1*e3e2*amel2*x4^2*xcp1 +64*e4e1*e3e1*e3e2*amel2*x4^2*x5*xcp3 -512*e4e1*e3e1*e3e2*amel2*x4^2*x5*xcp2 +64*e4e1*e3e1*e3e2*amel2*x4^2*x5*xcp1 +64*e4e1*e3e1*e3e2*amel2*x4^3*xcp3 -256*e4e1*e3e1*e3e2*amel2*x4^3*xcp2 +64*e4e1*e3e1*e3e2*amel2*x4^3*xcp1 -224*e4e1*e3e1*e3e2*amel2*x3*xcp3 -1408*e4e1*e3e1*e3e2*amel2*x3*xcp2 -224*e4e1*e3e1*e3e2*amel2*x3*xcp1 +160*e4e1*e3e1*e3e2*amel2*x3*x5*xcp3 +1920*e4e1*e3e1*e3e2*amel2*x3*x5*xcp2 +160*e4e1*e3e1*e3e2*amel2*x3*x5*xcp1 -64*e4e1*e3e1*e3e2*amel2*x3*x5^2*xcp3 -256*e4e1*e3e1*e3e2*amel2*x3*x5^2*xcp2 -64*e4e1*e3e1*e3e2*amel2*x3*x5^2*xcp1 -32*e4e1*e3e1*e3e2*amel2*x3*x4*xcp3 +2560*e4e1*e3e1*e3e2*amel2*x3*x4*xcp2 -32*e4e1*e3e1*e3e2*amel2*x3*x4*xcp1 -768*e4e1*e3e1*e3e2*amel2*x3*x4*x5*xcp2 +64*e4e1*e3e1*e3e2*amel2*x3*x4^2*xcp3 -640*e4e1*e3e1*e3e2*amel2*x3*x4^2*xcp2 +64*e4e1*e3e1*e3e2*amel2*x3*x4^2*xcp1 +1024*e4e1*e3e1*e3e2*amel2*x3^2*xcp2 -128*e4e1*e3e1*e3e2*amel2*x3^2*x5*xcp2 -384*e4e1*e3e1*e3e2*amel2*x3^2*x4*xcp2 -128*e4e1*e3e1*e3e2*amel2*x3^3*xcp2 -160*e4e1*e3e1*e3e2*amel2*x1*xcp3 -384*e4e1*e3e1*e3e2*amel2*x1*xcp2 -160*e4e1*e3e1*e3e2*amel2*x1*xcp1 +256*e4e1*e3e1*e3e2*amel2*x1*x5*xcp3 +1024*e4e1*e3e1*e3e2*amel2*x1*x5*xcp2 +256*e4e1*e3e1*e3e2*amel2*x1*x5*xcp1 -128*e4e1*e3e1*e3e2*amel2*x1*x5^2*xcp3 -512*e4e1*e3e1*e3e2*amel2*x1*x5^2*xcp2 -128*e4e1*e3e1*e3e2*amel2*x1*x5^2*xcp1 +32*e4e1*e3e1*e3e2*amel2*x1*x4*xcp3 +1152*e4e1*e3e1*e3e2*amel2*x1*x4*xcp2 +32*e4e1*e3e1*e3e2*amel2*x1*x4*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1*x4*x5*xcp3 -1152*e4e1*e3e1*e3e2*amel2*x1*x4*x5*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1*x4*x5*xcp1 +64*e4e1*e3e1*e3e2*amel2*x1*x4^2*xcp3 -512*e4e1*e3e1*e3e2*amel2*x1*x4^2*xcp2 +64*e4e1*e3e1*e3e2*amel2*x1*x4^2*xcp1 +160*e4e1*e3e1*e3e2*amel2*x1*x3*xcp3 +1024*e4e1*e3e1*e3e2*amel2*x1*x3*xcp2 +160*e4e1*e3e1*e3e2*amel2*x1*x3*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1*x3*x5*xcp3 -1280*e4e1*e3e1*e3e2*amel2*x1*x3*x5*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1*x3*x5*xcp1 +192*e4e1*e3e1*e3e2*amel2*x1*x3*x4*xcp3 -1280*e4e1*e3e1*e3e2*amel2*x1*x3*x4*xcp2 +192*e4e1*e3e1*e3e2*amel2*x1*x3*x4*xcp1 +64*e4e1*e3e1*e3e2*amel2*x1*x3^2*xcp3 -640*e4e1*e3e1*e3e2*amel2*x1*x3^2*xcp2 +64*e4e1*e3e1*e3e2*amel2*x1*x3^2*xcp1 +32*e4e1*e3e1*e3e2*amel2*x1^2*xcp3 -448*e4e1*e3e1*e3e2*amel2*x1^2*xcp2 +32*e4e1*e3e1*e3e2*amel2*x1^2*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1^2*x5*xcp3 +512*e4e1*e3e1*e3e2*amel2*x1^2*x5*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1^2*x5*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1^2*x4*xcp3 +512*e4e1*e3e1*e3e2*amel2*x1^2*x4*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1^2*x4*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1^2*x3*xcp3 +384*e4e1*e3e1*e3e2*amel2*x1^2*x3*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1^2*x3*xcp1 +128*e4e1*e3e1*e3e2*amel2*x1^3*xcp2 +1280*e4e1*e3e1*e3e2*e2e1*xcp2 -2304*e4e1*e3e1*e3e2*e2e1*x5*xcp2 +1024*e4e1*e3e1*e3e2*e2e1*x5^2*xcp2 -2816*e4e1*e3e1*e3e2*e2e1*x4*xcp2 +2816*e4e1*e3e1*e3e2*e2e1*x4*x5*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x4*x5^2*xcp2 +1792*e4e1*e3e1*e3e2*e2e1*x4^2*xcp2 -512*e4e1*e3e1*e3e2*e2e1*x4^2*x5*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x4^3*xcp2 -2560*e4e1*e3e1*e3e2*e2e1*x3*xcp2 +2560*e4e1*e3e1*e3e2*e2e1*x3*x5*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x3*x5^2*xcp2 +3584*e4e1*e3e1*e3e2*e2e1*x3*x4*xcp2 -1280*e4e1*e3e1*e3e2*e2e1*x3*x4*x5*xcp2 -1024*e4e1*e3e1*e3e2*e2e1*x3*x4^2*xcp2 +1280*e4e1*e3e1*e3e2*e2e1*x3^2*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x3^2*x5*xcp2 -768*e4e1*e3e1*e3e2*e2e1*x3^2*x4*xcp2 -1024*e4e1*e3e1*e3e2*e2e1*x1*xcp2 +1792*e4e1*e3e1*e3e2*e2e1*x1*x5*xcp2 -768*e4e1*e3e1*e3e2*e2e1*x1*x5^2*xcp2 +1280*e4e1*e3e1*e3e2*e2e1*x1*x4*xcp2 -1152*e4e1*e3e1*e3e2*e2e1*x1*x4*x5*xcp2 -384*e4e1*e3e1*e3e2*e2e1*x1*x4^2*xcp2 +2304*e4e1*e3e1*e3e2*e2e1*x1*x3*xcp2 -1920*e4e1*e3e1*e3e2*e2e1*x1*x3*x5*xcp2 -1408*e4e1*e3e1*e3e2*e2e1*x1*x3*x4*xcp2 -1280*e4e1*e3e1*e3e2*e2e1*x1*x3^2*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x1^2*xcp2 +128*e4e1*e3e1*e3e2*e2e1*x1^2*x5*xcp2 +128*e4e1*e3e1*e3e2*e2e1*x1^2*x4*xcp2 +256*e4e1*e3e1*e3e2*e2e1*x1^2*x3*xcp2 -512*e4e1*e3e1*e3e2^2*xcp2 +1024*e4e1*e3e1*e3e2^2*x5*xcp2 -512*e4e1*e3e1*e3e2^2*x5^2*xcp2 +1280*e4e1*e3e1*e3e2^2*x4*xcp2 -1408*e4e1*e3e1*e3e2^2*x4*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x4*x5^2*xcp2 -896*e4e1*e3e1*e3e2^2*x4^2*xcp2 +256*e4e1*e3e1*e3e2^2*x4^2*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x4^3*xcp2 +1024*e4e1*e3e1*e3e2^2*x3*xcp2 -1152*e4e1*e3e1*e3e2^2*x3*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x3*x5^2*xcp2 -1664*e4e1*e3e1*e3e2^2*x3*x4*xcp2 +640*e4e1*e3e1*e3e2^2*x3*x4*x5*xcp2 +512*e4e1*e3e1*e3e2^2*x3*x4^2*xcp2 -512*e4e1*e3e1*e3e2^2*x3^2*xcp2 +128*e4e1*e3e1*e3e2^2*x3^2*x5*xcp2 +384*e4e1*e3e1*e3e2^2*x3^2*x4*xcp2 +512*e4e1*e3e1*e3e2^2*x1*xcp2 -896*e4e1*e3e1*e3e2^2*x1*x5*xcp2 +384*e4e1*e3e1*e3e2^2*x1*x5^2*xcp2 -640*e4e1*e3e1*e3e2^2*x1*x4*xcp2 +512*e4e1*e3e1*e3e2^2*x1*x4*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x1*x4^2*xcp2 -1024*e4e1*e3e1*e3e2^2*x1*x3*xcp2 +896*e4e1*e3e1*e3e2^2*x1*x3*x5*xcp2 +640*e4e1*e3e1*e3e2^2*x1*x3*x4*xcp2 +512*e4e1*e3e1*e3e2^2*x1*x3^2*xcp2 -64*e4e1*e3e1^2*amel2*xcp3 -64*e4e1*e3e1^2*amel2*xcp1 +256*e4e1*e3e1^2*amel2*x5*xcp3 +256*e4e1*e3e1^2*amel2*x5*xcp1 -256*e4e1*e3e1^2*amel2*x5^2*xcp3 -256*e4e1*e3e1^2*amel2*x5^2*xcp1 +64*e4e1*e3e1^2*amel2*x5^3*xcp3 +64*e4e1*e3e1^2*amel2*x5^3*xcp1 +256*e4e1*e3e1^2*amel2*x4*xcp3 -256*e4e1*e3e1^2*amel2*x4*xcp2 +256*e4e1*e3e1^2*amel2*x4*xcp1 -512*e4e1*e3e1^2*amel2*x4*x5*xcp3 +384*e4e1*e3e1^2*amel2*x4*x5*xcp2 -512*e4e1*e3e1^2*amel2*x4*x5*xcp1 +192*e4e1*e3e1^2*amel2*x4*x5^2*xcp3 -128*e4e1*e3e1^2*amel2*x4*x5^2*xcp2 +192*e4e1*e3e1^2*amel2*x4*x5^2*xcp1 -256*e4e1*e3e1^2*amel2*x4^2*xcp3 +384*e4e1*e3e1^2*amel2*x4^2*xcp2 -256*e4e1*e3e1^2*amel2*x4^2*xcp1 +192*e4e1*e3e1^2*amel2*x4^2*x5*xcp3 -256*e4e1*e3e1^2*amel2*x4^2*x5*xcp2 +192*e4e1*e3e1^2*amel2*x4^2*x5*xcp1 +64*e4e1*e3e1^2*amel2*x4^3*xcp3 -128*e4e1*e3e1^2*amel2*x4^3*xcp2 +64*e4e1*e3e1^2*amel2*x4^3*xcp1 +64*e4e1*e3e1^2*amel2*x3*xcp3 -256*e4e1*e3e1^2*amel2*x3*xcp2 +64*e4e1*e3e1^2*amel2*x3*xcp1 -192*e4e1*e3e1^2*amel2*x3*x5*xcp3 +384*e4e1*e3e1^2*amel2*x3*x5*xcp2 -192*e4e1*e3e1^2*amel2*x3*x5*xcp1 +64*e4e1*e3e1^2*amel2*x3*x5^2*xcp3 -128*e4e1*e3e1^2*amel2*x3*x5^2*xcp2 +64*e4e1*e3e1^2*amel2*x3*x5^2*xcp1 -192*e4e1*e3e1^2*amel2*x3*x4*xcp3 +640*e4e1*e3e1^2*amel2*x3*x4*xcp2 -192*e4e1*e3e1^2*amel2*x3*x4*xcp1 +128*e4e1*e3e1^2*amel2*x3*x4*x5*xcp3 -384*e4e1*e3e1^2*amel2*x3*x4*x5*xcp2 +128*e4e1*e3e1^2*amel2*x3*x4*x5*xcp1 +64*e4e1*e3e1^2*amel2*x3*x4^2*xcp3 -256*e4e1*e3e1^2*amel2*x3*x4^2*xcp2 +64*e4e1*e3e1^2*amel2*x3*x4^2*xcp1 +256*e4e1*e3e1^2*amel2*x3^2*xcp2 -128*e4e1*e3e1^2*amel2*x3^2*x5*xcp2 -128*e4e1*e3e1^2*amel2*x3^2*x4*xcp2 +320*e4e1*e3e1^2*amel2*x1*xcp3 +320*e4e1*e3e1^2*amel2*x1*xcp1 -384*e4e1*e3e1^2*amel2*x1*x5*xcp3 -384*e4e1*e3e1^2*amel2*x1*x5*xcp1 +192*e4e1*e3e1^2*amel2*x1*x5^2*xcp3 +192*e4e1*e3e1^2*amel2*x1*x5^2*xcp1 -384*e4e1*e3e1^2*amel2*x1*x4*xcp3 +128*e4e1*e3e1^2*amel2*x1*x4*xcp2 -384*e4e1*e3e1^2*amel2*x1*x4*xcp1 +384*e4e1*e3e1^2*amel2*x1*x4*x5*xcp3 -128*e4e1*e3e1^2*amel2*x1*x4*x5*xcp2 +384*e4e1*e3e1^2*amel2*x1*x4*x5*xcp1 +192*e4e1*e3e1^2*amel2*x1*x4^2*xcp3 -128*e4e1*e3e1^2*amel2*x1*x4^2*xcp2 +192*e4e1*e3e1^2*amel2*x1*x4^2*xcp1 -320*e4e1*e3e1^2*amel2*x1*x3*xcp3 +128*e4e1*e3e1^2*amel2*x1*x3*xcp2 -320*e4e1*e3e1^2*amel2*x1*x3*xcp1 +256*e4e1*e3e1^2*amel2*x1*x3*x5*xcp3 -128*e4e1*e3e1^2*amel2*x1*x3*x5*xcp2 +256*e4e1*e3e1^2*amel2*x1*x3*x5*xcp1 +256*e4e1*e3e1^2*amel2*x1*x3*x4*xcp3 -384*e4e1*e3e1^2*amel2*x1*x3*x4*xcp2 +256*e4e1*e3e1^2*amel2*x1*x3*x4*xcp1 -256*e4e1*e3e1^2*amel2*x1*x3^2*xcp2 -192*e4e1*e3e1^2*amel2*x1^2*xcp3 -192*e4e1*e3e1^2*amel2*x1^2*xcp1 +128*e4e1*e3e1^2*amel2*x1^2*x5*xcp3 +128*e4e1*e3e1^2*amel2*x1^2*x5*xcp1 +128*e4e1*e3e1^2*amel2*x1^2*x4*xcp3 +128*e4e1*e3e1^2*amel2*x1^2*x4*xcp2 +128*e4e1*e3e1^2*amel2*x1^2*x4*xcp1 +192*e4e1*e3e1^2*amel2*x1^2*x3*xcp3 +128*e4e1*e3e1^2*amel2*x1^2*x3*xcp2 +192*e4e1*e3e1^2*amel2*x1^2*x3*xcp1 +512*e4e1*e3e1^2*e2e1*xcp2 -1024*e4e1*e3e1^2*e2e1*x5*xcp2 +640*e4e1*e3e1^2*e2e1*x5^2*xcp2 -128*e4e1*e3e1^2*e2e1*x5^3*xcp2 -1024*e4e1*e3e1^2*e2e1*x4*xcp2 +1280*e4e1*e3e1^2*e2e1*x4*x5*xcp2 -384*e4e1*e3e1^2*e2e1*x4*x5^2*xcp2 +640*e4e1*e3e1^2*e2e1*x4^2*xcp2 -384*e4e1*e3e1^2*e2e1*x4^2*x5*xcp2 -128*e4e1*e3e1^2*e2e1*x4^3*xcp2 -1024*e4e1*e3e1^2*e2e1*x3*xcp2 +1280*e4e1*e3e1^2*e2e1*x3*x5*xcp2 -384*e4e1*e3e1^2*e2e1*x3*x5^2*xcp2 +1280*e4e1*e3e1^2*e2e1*x3*x4*xcp2 -768*e4e1*e3e1^2*e2e1*x3*x4*x5*xcp2 -384*e4e1*e3e1^2*e2e1*x3*x4^2*xcp2 +512*e4e1*e3e1^2*e2e1*x3^2*xcp2 -256*e4e1*e3e1^2*e2e1*x3^2*x5*xcp2 -256*e4e1*e3e1^2*e2e1*x3^2*x4*xcp2 -256*e4e1*e3e1^2*e2e1*x1*xcp2 +384*e4e1*e3e1^2*e2e1*x1*x5*xcp2 -128*e4e1*e3e1^2*e2e1*x1*x5^2*xcp2 +384*e4e1*e3e1^2*e2e1*x1*x4*xcp2 -256*e4e1*e3e1^2*e2e1*x1*x4*x5*xcp2 -128*e4e1*e3e1^2*e2e1*x1*x4^2*xcp2 +768*e4e1*e3e1^2*e2e1*x1*x3*xcp2 -512*e4e1*e3e1^2*e2e1*x1*x3*x5*xcp2 -512*e4e1*e3e1^2*e2e1*x1*x3*x4*xcp2 -512*e4e1*e3e1^2*e2e1*x1*x3^2*xcp2 -256*e4e1*e3e1^2*e2e1*x1^2*xcp2 +128*e4e1*e3e1^2*e2e1*x1^2*x5*xcp2 +128*e4e1*e3e1^2*e2e1*x1^2*x4*xcp2 +256*e4e1*e3e1^2*e2e1*x1^2*x3*xcp2 -512*e4e1*e3e1^2*e3e2*xcp2 +1152*e4e1*e3e1^2*e3e2*x5*xcp2 -768*e4e1*e3e1^2*e3e2*x5^2*xcp2 +128*e4e1*e3e1^2*e3e2*x5^3*xcp2 +1152*e4e1*e3e1^2*e3e2*x4*xcp2 -1536*e4e1*e3e1^2*e3e2*x4*x5*xcp2 +384*e4e1*e3e1^2*e3e2*x4*x5^2*xcp2 -768*e4e1*e3e1^2*e3e2*x4^2*xcp2 +384*e4e1*e3e1^2*e3e2*x4^2*x5*xcp2 +128*e4e1*e3e1^2*e3e2*x4^3*xcp2 +1024*e4e1*e3e1^2*e3e2*x3*xcp2 -1408*e4e1*e3e1^2*e3e2*x3*x5*xcp2 +384*e4e1*e3e1^2*e3e2*x3*x5^2*xcp2 -1408*e4e1*e3e1^2*e3e2*x3*x4*xcp2 +768*e4e1*e3e1^2*e3e2*x3*x4*x5*xcp2 +384*e4e1*e3e1^2*e3e2*x3*x4^2*xcp2 -512*e4e1*e3e1^2*e3e2*x3^2*xcp2 +256*e4e1*e3e1^2*e3e2*x3^2*x5*xcp2 +256*e4e1*e3e1^2*e3e2*x3^2*x4*xcp2 +256*e4e1*e3e1^2*e3e2*x1*xcp2 -384*e4e1*e3e1^2*e3e2*x1*x5*xcp2 +128*e4e1*e3e1^2*e3e2*x1*x5^2*xcp2 -384*e4e1*e3e1^2*e3e2*x1*x4*xcp2 +256*e4e1*e3e1^2*e3e2*x1*x4*x5*xcp2 +128*e4e1*e3e1^2*e3e2*x1*x4^2*xcp2 -768*e4e1*e3e1^2*e3e2*x1*x3*xcp2 +640*e4e1*e3e1^2*e3e2*x1*x3*x5*xcp2 +640*e4e1*e3e1^2*e3e2*x1*x3*x4*xcp2 +512*e4e1*e3e1^2*e3e2*x1*x3^2*xcp2 +256*e4e1*e3e1^2*e3e2*x1^2*xcp2 -256*e4e1*e3e1^2*e3e2*x1^2*x5*xcp2 -256*e4e1*e3e1^2*e3e2*x1^2*x4*xcp2 -256*e4e1*e3e1^2*e3e2*x1^2*x3*xcp2 -64*e4e1*e4e2*amel2*zk^2*xcp3 +128*e4e1*e4e2*amel2*zk^2*xcp2 -64*e4e1*e4e2*amel2*zk^2*xcp1 +48*e4e1*e4e2*amel2*zk^2*x5*xcp3 +64*e4e1*e4e2*amel2*zk^2*x5*xcp2 +48*e4e1*e4e2*amel2*zk^2*x5*xcp1 +32*e4e1*e4e2*amel2*zk^2*x4*xcp2 -32*e4e1*e4e2*amel2*zk^2*x3*xcp2 +48*e4e1*e4e2*amel2*zk^2*x1*xcp3 -160*e4e1*e4e2*amel2*zk^2*x1*xcp2 +48*e4e1*e4e2*amel2*zk^2*x1*xcp1 -128*e4e1*e4e2*amel2^2*xcp3 -128*e4e1*e4e2*amel2^2*xcp1 +128*e4e1*e4e2*amel2^2*x5*xcp3 +512*e4e1*e4e2*amel2^2*x5*xcp2 +128*e4e1*e4e2*amel2^2*x5*xcp1 -32*e4e1*e4e2*amel2^2*x5^2*xcp3 -32*e4e1*e4e2*amel2^2*x5^2*xcp1 +32*e4e1*e4e2*amel2^2*x5^3*xcp3 +32*e4e1*e4e2*amel2^2*x5^3*xcp1 +64*e4e1*e4e2*amel2^2*x4*xcp3 +640*e4e1*e4e2*amel2^2*x4*xcp2 +64*e4e1*e4e2*amel2^2*x4*xcp1 -128*e4e1*e4e2*amel2^2*x4*x5*xcp3 -192*e4e1*e4e2*amel2^2*x4*x5*xcp2 -128*e4e1*e4e2*amel2^2*x4*x5*xcp1 +64*e4e1*e4e2*amel2^2*x4*x5^2*xcp3 -128*e4e1*e4e2*amel2^2*x4*x5^2*xcp2 +64*e4e1*e4e2*amel2^2*x4*x5^2*xcp1 -128*e4e1*e4e2*amel2^2*x4^2*xcp3 -128*e4e1*e4e2*amel2^2*x4^2*xcp1 +64*e4e1*e4e2*amel2^2*x4^2*x5*xcp3 -128*e4e1*e4e2*amel2^2*x4^2*x5*xcp2 +64*e4e1*e4e2*amel2^2*x4^2*x5*xcp1 +256*e4e1*e4e2*amel2^2*x3*xcp3 +128*e4e1*e4e2*amel2^2*x3*xcp2 +256*e4e1*e4e2*amel2^2*x3*xcp1 -192*e4e1*e4e2*amel2^2*x3*x5*xcp3 -704*e4e1*e4e2*amel2^2*x3*x5*xcp2 -192*e4e1*e4e2*amel2^2*x3*x5*xcp1 -128*e4e1*e4e2*amel2^2*x3*x5^2*xcp2 -192*e4e1*e4e2*amel2^2*x3*x4*xcp3 -448*e4e1*e4e2*amel2^2*x3*x4*xcp2 -192*e4e1*e4e2*amel2^2*x3*x4*xcp1 +64*e4e1*e4e2*amel2^2*x3*x4*x5*xcp3 +64*e4e1*e4e2*amel2^2*x3*x4*x5*xcp1 +128*e4e1*e4e2*amel2^2*x3*x4^2*xcp2 -96*e4e1*e4e2*amel2^2*x3^2*xcp3 +64*e4e1*e4e2*amel2^2*x3^2*xcp2 -96*e4e1*e4e2*amel2^2*x3^2*xcp1 +32*e4e1*e4e2*amel2^2*x3^2*x5*xcp3 +128*e4e1*e4e2*amel2^2*x3^2*x5*xcp2 +32*e4e1*e4e2*amel2^2*x3^2*x5*xcp1 +128*e4e1*e4e2*amel2^2*x3^2*x4*xcp2 +192*e4e1*e4e2*amel2^2*x1*xcp3 +192*e4e1*e4e2*amel2^2*x1*xcp1 -256*e4e1*e4e2*amel2^2*x1*x5*xcp3 -384*e4e1*e4e2*amel2^2*x1*x5*xcp2 -256*e4e1*e4e2*amel2^2*x1*x5*xcp1 +96*e4e1*e4e2*amel2^2*x1*x5^2*xcp3 +128*e4e1*e4e2*amel2^2*x1*x5^2*xcp2 +96*e4e1*e4e2*amel2^2*x1*x5^2*xcp1 -64*e4e1*e4e2*amel2^2*x1*x4*xcp3 -576*e4e1*e4e2*amel2^2*x1*x4*xcp2 -64*e4e1*e4e2*amel2^2*x1*x4*xcp1 +128*e4e1*e4e2*amel2^2*x1*x4*x5*xcp3 +384*e4e1*e4e2*amel2^2*x1*x4*x5*xcp2 +128*e4e1*e4e2*amel2^2*x1*x4*x5*xcp1 +64*e4e1*e4e2*amel2^2*x1*x4^2*xcp3 -128*e4e1*e4e2*amel2^2*x1*x4^2*xcp2 +64*e4e1*e4e2*amel2^2*x1*x4^2*xcp1 -64*e4e1*e4e2*amel2^2*x1*x3*xcp3 -192*e4e1*e4e2*amel2^2*x1*x3*xcp2 -64*e4e1*e4e2*amel2^2*x1*x3*xcp1 +128*e4e1*e4e2*amel2^2*x1*x3*x5*xcp3 +640*e4e1*e4e2*amel2^2*x1*x3*x5*xcp2 +128*e4e1*e4e2*amel2^2*x1*x3*x5*xcp1 -64*e4e1*e4e2*amel2^2*x1*x3*x4*xcp3 -64*e4e1*e4e2*amel2^2*x1*x3*x4*xcp1 +32*e4e1*e4e2*amel2^2*x1*x3^2*xcp3 -256*e4e1*e4e2*amel2^2*x1*x3^2*xcp2 +32*e4e1*e4e2*amel2^2*x1*x3^2*xcp1 +32*e4e1*e4e2*amel2^2*x1^2*xcp3 +384*e4e1*e4e2*amel2^2*x1^2*xcp2 +32*e4e1*e4e2*amel2^2*x1^2*xcp1 +96*e4e1*e4e2*amel2^2*x1^2*x5*xcp3 +96*e4e1*e4e2*amel2^2*x1^2*x5*xcp1 +64*e4e1*e4e2*amel2^2*x1^2*x4*xcp3 -256*e4e1*e4e2*amel2^2*x1^2*x4*xcp2 +64*e4e1*e4e2*amel2^2*x1^2*x4*xcp1 -512*e4e1*e4e2*amel2^2*x1^2*x3*xcp2 +32*e4e1*e4e2*amel2^2*x1^3*xcp3 -128*e4e1*e4e2*amel2^2*x1^3*xcp2 +32*e4e1*e4e2*amel2^2*x1^3*xcp1 -128*e4e1*e4e2*e2e1*zk^2*xcp2 +192*e4e1*e4e2*e2e1*zk^2*x5*xcp2 +32*e4e1*e4e2*e2e1*zk^2*x4*xcp2 +96*e4e1*e4e2*e2e1*zk^2*x3*xcp2 -32*e4e1*e4e2*e2e1*zk^2*x1*xcp2 -128*e4e1*e4e2*e2e1*amel2*xcp3 -512*e4e1*e4e2*e2e1*amel2*xcp2 -128*e4e1*e4e2*e2e1*amel2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x5*xcp3 +1408*e4e1*e4e2*e2e1*amel2*x5*xcp2 -128*e4e1*e4e2*e2e1*amel2*x5*xcp1 +96*e4e1*e4e2*e2e1*amel2*x5^2*xcp3 -64*e4e1*e4e2*e2e1*amel2*x5^2*xcp2 +96*e4e1*e4e2*e2e1*amel2*x5^2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x5^3*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4*xcp3 +1408*e4e1*e4e2*e2e1*amel2*x4*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4*xcp1 -128*e4e1*e4e2*e2e1*amel2*x4*x5*xcp3 -192*e4e1*e4e2*e2e1*amel2*x4*x5*xcp2 -128*e4e1*e4e2*e2e1*amel2*x4*x5*xcp1 +64*e4e1*e4e2*e2e1*amel2*x4*x5^2*xcp3 -512*e4e1*e4e2*e2e1*amel2*x4*x5^2*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4*x5^2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x4^2*xcp3 -256*e4e1*e4e2*e2e1*amel2*x4^2*xcp2 -128*e4e1*e4e2*e2e1*amel2*x4^2*xcp1 +64*e4e1*e4e2*e2e1*amel2*x4^2*x5*xcp3 -256*e4e1*e4e2*e2e1*amel2*x4^2*x5*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4^2*x5*xcp1 +192*e4e1*e4e2*e2e1*amel2*x3*xcp3 +1024*e4e1*e4e2*e2e1*amel2*x3*xcp2 +192*e4e1*e4e2*e2e1*amel2*x3*xcp1 +128*e4e1*e4e2*e2e1*amel2*x3*x5*xcp3 -960*e4e1*e4e2*e2e1*amel2*x3*x5*xcp2 +128*e4e1*e4e2*e2e1*amel2*x3*x5*xcp1 -64*e4e1*e4e2*e2e1*amel2*x3*x5^2*xcp3 -640*e4e1*e4e2*e2e1*amel2*x3*x5^2*xcp2 -64*e4e1*e4e2*e2e1*amel2*x3*x5^2*xcp1 -192*e4e1*e4e2*e2e1*amel2*x3*x4*xcp3 -1216*e4e1*e4e2*e2e1*amel2*x3*x4*xcp2 -192*e4e1*e4e2*e2e1*amel2*x3*x4*xcp1 +64*e4e1*e4e2*e2e1*amel2*x3*x4*x5*xcp3 -256*e4e1*e4e2*e2e1*amel2*x3*x4*x5*xcp2 +64*e4e1*e4e2*e2e1*amel2*x3*x4*x5*xcp1 +256*e4e1*e4e2*e2e1*amel2*x3*x4^2*xcp2 -32*e4e1*e4e2*e2e1*amel2*x3^2*xcp3 -640*e4e1*e4e2*e2e1*amel2*x3^2*xcp2 -32*e4e1*e4e2*e2e1*amel2*x3^2*xcp1 +128*e4e1*e4e2*e2e1*amel2*x3^2*x5*xcp2 +256*e4e1*e4e2*e2e1*amel2*x3^2*x4*xcp2 +128*e4e1*e4e2*e2e1*amel2*x3^3*xcp2 +128*e4e1*e4e2*e2e1*amel2*x1*xcp3 +896*e4e1*e4e2*e2e1*amel2*x1*xcp2 +128*e4e1*e4e2*e2e1*amel2*x1*xcp1 -64*e4e1*e4e2*e2e1*amel2*x1*x5*xcp3 -2176*e4e1*e4e2*e2e1*amel2*x1*x5*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x5*xcp1 +896*e4e1*e4e2*e2e1*amel2*x1*x5^2*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x4*xcp3 -832*e4e1*e4e2*e2e1*amel2*x1*x4*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x4*xcp1 +128*e4e1*e4e2*e2e1*amel2*x1*x4*x5*xcp3 +1024*e4e1*e4e2*e2e1*amel2*x1*x4*x5*xcp2 +128*e4e1*e4e2*e2e1*amel2*x1*x4*x5*xcp1 +64*e4e1*e4e2*e2e1*amel2*x1*x4^2*xcp3 +64*e4e1*e4e2*e2e1*amel2*x1*x4^2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1*x3*xcp3 -832*e4e1*e4e2*e2e1*amel2*x1*x3*xcp2 -128*e4e1*e4e2*e2e1*amel2*x1*x3*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1*x3*x5*xcp3 +1408*e4e1*e4e2*e2e1*amel2*x1*x3*x5*xcp2 -128*e4e1*e4e2*e2e1*amel2*x1*x3*x5*xcp1 -64*e4e1*e4e2*e2e1*amel2*x1*x3*x4*xcp3 +128*e4e1*e4e2*e2e1*amel2*x1*x3*x4*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x3*x4*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1*x3^2*xcp3 +128*e4e1*e4e2*e2e1*amel2*x1*x3^2*xcp2 -128*e4e1*e4e2*e2e1*amel2*x1*x3^2*xcp1 -32*e4e1*e4e2*e2e1*amel2*x1^2*xcp3 +192*e4e1*e4e2*e2e1*amel2*x1^2*xcp2 -32*e4e1*e4e2*e2e1*amel2*x1^2*xcp1 +128*e4e1*e4e2*e2e1*amel2*x1^2*x5*xcp2 +64*e4e1*e4e2*e2e1*amel2*x1^2*x4*xcp3 -256*e4e1*e4e2*e2e1*amel2*x1^2*x4*xcp2 +64*e4e1*e4e2*e2e1*amel2*x1^2*x4*xcp1 +64*e4e1*e4e2*e2e1*amel2*x1^2*x3*xcp3 -512*e4e1*e4e2*e2e1*amel2*x1^2*x3*xcp2 +64*e4e1*e4e2*e2e1*amel2*x1^2*x3*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1^3*xcp2 -512*e4e1*e4e2*e2e1^2*xcp2 +256*e4e1*e4e2*e2e1^2*x5*xcp2 +512*e4e1*e4e2*e2e1^2*x5^2*xcp2 -256*e4e1*e4e2*e2e1^2*x5^3*xcp2 +768*e4e1*e4e2*e2e1^2*x4*xcp2 -384*e4e1*e4e2*e2e1^2*x4*x5^2*xcp2 -256*e4e1*e4e2*e2e1^2*x4^2*xcp2 -128*e4e1*e4e2*e2e1^2*x4^2*x5*xcp2 +768*e4e1*e4e2*e2e1^2*x3*xcp2 +256*e4e1*e4e2*e2e1^2*x3*x5*xcp2 -640*e4e1*e4e2*e2e1^2*x3*x5^2*xcp2 -768*e4e1*e4e2*e2e1^2*x3*x4*xcp2 -256*e4e1*e4e2*e2e1^2*x3*x4*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x3*x4^2*xcp2 -256*e4e1*e4e2*e2e1^2*x3^2*xcp2 -384*e4e1*e4e2*e2e1^2*x3^2*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x3^2*x4*xcp2 +512*e4e1*e4e2*e2e1^2*x1*xcp2 -1024*e4e1*e4e2*e2e1^2*x1*x5*xcp2 +512*e4e1*e4e2*e2e1^2*x1*x5^2*xcp2 -256*e4e1*e4e2*e2e1^2*x1*x4*xcp2 +640*e4e1*e4e2*e2e1^2*x1*x4*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x1*x4^2*xcp2 -768*e4e1*e4e2*e2e1^2*x1*x3*xcp2 +896*e4e1*e4e2*e2e1^2*x1*x3*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x1*x3*x4*xcp2 +256*e4e1*e4e2*e2e1^2*x1*x3^2*xcp2 +160*e4e1*e4e2*e3e2*zk^2*xcp2 -192*e4e1*e4e2*e3e2*zk^2*x5*xcp2 -32*e4e1*e4e2*e3e2*zk^2*x4*xcp2 -96*e4e1*e4e2*e3e2*zk^2*x3*xcp2 +512*e4e1*e4e2*e3e2*amel2*xcp2 +192*e4e1*e4e2*e3e2*amel2*x5*xcp3 -1152*e4e1*e4e2*e3e2*amel2*x5*xcp2 +192*e4e1*e4e2*e3e2*amel2*x5*xcp1 -96*e4e1*e4e2*e3e2*amel2*x5^2*xcp3 -64*e4e1*e4e2*e3e2*amel2*x5^2*xcp2 -96*e4e1*e4e2*e3e2*amel2*x5^2*xcp1 +128*e4e1*e4e2*e3e2*amel2*x5^3*xcp2 -1152*e4e1*e4e2*e3e2*amel2*x4*xcp2 +128*e4e1*e4e2*e3e2*amel2*x4*x5*xcp3 -64*e4e1*e4e2*e3e2*amel2*x4*x5*xcp2 +128*e4e1*e4e2*e3e2*amel2*x4*x5*xcp1 -64*e4e1*e4e2*e3e2*amel2*x4*x5^2*xcp3 +512*e4e1*e4e2*e3e2*amel2*x4*x5^2*xcp2 -64*e4e1*e4e2*e3e2*amel2*x4*x5^2*xcp1 +128*e4e1*e4e2*e3e2*amel2*x4^2*xcp3 +128*e4e1*e4e2*e3e2*amel2*x4^2*xcp2 +128*e4e1*e4e2*e3e2*amel2*x4^2*xcp1 -64*e4e1*e4e2*e3e2*amel2*x4^2*x5*xcp3 +256*e4e1*e4e2*e3e2*amel2*x4^2*x5*xcp2 -64*e4e1*e4e2*e3e2*amel2*x4^2*x5*xcp1 -64*e4e1*e4e2*e3e2*amel2*x3*xcp3 -1024*e4e1*e4e2*e3e2*amel2*x3*xcp2 -64*e4e1*e4e2*e3e2*amel2*x3*xcp1 -128*e4e1*e4e2*e3e2*amel2*x3*x5*xcp3 +704*e4e1*e4e2*e3e2*amel2*x3*x5*xcp2 -128*e4e1*e4e2*e3e2*amel2*x3*x5*xcp1 +64*e4e1*e4e2*e3e2*amel2*x3*x5^2*xcp3 +640*e4e1*e4e2*e3e2*amel2*x3*x5^2*xcp2 +64*e4e1*e4e2*e3e2*amel2*x3*x5^2*xcp1 +192*e4e1*e4e2*e3e2*amel2*x3*x4*xcp3 +960*e4e1*e4e2*e3e2*amel2*x3*x4*xcp2 +192*e4e1*e4e2*e3e2*amel2*x3*x4*xcp1 -64*e4e1*e4e2*e3e2*amel2*x3*x4*x5*xcp3 +256*e4e1*e4e2*e3e2*amel2*x3*x4*x5*xcp2 -64*e4e1*e4e2*e3e2*amel2*x3*x4*x5*xcp1 -256*e4e1*e4e2*e3e2*amel2*x3*x4^2*xcp2 +32*e4e1*e4e2*e3e2*amel2*x3^2*xcp3 +640*e4e1*e4e2*e3e2*amel2*x3^2*xcp2 +32*e4e1*e4e2*e3e2*amel2*x3^2*xcp1 -128*e4e1*e4e2*e3e2*amel2*x3^2*x5*xcp2 -256*e4e1*e4e2*e3e2*amel2*x3^2*x4*xcp2 -128*e4e1*e4e2*e3e2*amel2*x3^3*xcp2 -1024*e4e1*e4e2*e3e2*amel2*x1*xcp2 -32*e4e1*e4e2*e3e2*amel2*x1*x5*xcp3 +1856*e4e1*e4e2*e3e2*amel2*x1*x5*xcp2 -32*e4e1*e4e2*e3e2*amel2*x1*x5*xcp1 -640*e4e1*e4e2*e3e2*amel2*x1*x5^2*xcp2 +768*e4e1*e4e2*e3e2*amel2*x1*x4*xcp2 -64*e4e1*e4e2*e3e2*amel2*x1*x4*x5*xcp3 -512*e4e1*e4e2*e3e2*amel2*x1*x4*x5*xcp2 -64*e4e1*e4e2*e3e2*amel2*x1*x4*x5*xcp1 -64*e4e1*e4e2*e3e2*amel2*x1*x4^2*xcp3 +128*e4e1*e4e2*e3e2*amel2*x1*x4^2*xcp2 -64*e4e1*e4e2*e3e2*amel2*x1*x4^2*xcp1 -32*e4e1*e4e2*e3e2*amel2*x1*x3*xcp3 +1216*e4e1*e4e2*e3e2*amel2*x1*x3*xcp2 -32*e4e1*e4e2*e3e2*amel2*x1*x3*xcp1 +192*e4e1*e4e2*e3e2*amel2*x1*x3*x5*xcp3 -1152*e4e1*e4e2*e3e2*amel2*x1*x3*x5*xcp2 +192*e4e1*e4e2*e3e2*amel2*x1*x3*x5*xcp1 -128*e4e1*e4e2*e3e2*amel2*x1*x3*x4*xcp2 +64*e4e1*e4e2*e3e2*amel2*x1*x3^2*xcp3 -256*e4e1*e4e2*e3e2*amel2*x1*x3^2*xcp2 +64*e4e1*e4e2*e3e2*amel2*x1*x3^2*xcp1 -256*e4e1*e4e2*e3e2*amel2*x1^2*x5*xcp2 +128*e4e1*e4e2*e3e2*amel2*x1^2*x4*xcp2 +128*e4e1*e4e2*e3e2*amel2*x1^2*x3*xcp2 +512*e4e1*e4e2*e3e2*e2e1*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x5*xcp2 -1280*e4e1*e4e2*e3e2*e2e1*x5^2*xcp2 +512*e4e1*e4e2*e3e2*e2e1*x5^3*xcp2 -1024*e4e1*e4e2*e3e2*e2e1*x4*xcp2 -384*e4e1*e4e2*e3e2*e2e1*x4*x5*xcp2 +768*e4e1*e4e2*e3e2*e2e1*x4*x5^2*xcp2 +384*e4e1*e4e2*e3e2*e2e1*x4^2*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x4^2*x5*xcp2 -768*e4e1*e4e2*e3e2*e2e1*x3*xcp2 -1152*e4e1*e4e2*e3e2*e2e1*x3*x5*xcp2 +1280*e4e1*e4e2*e3e2*e2e1*x3*x5^2*xcp2 +1152*e4e1*e4e2*e3e2*e2e1*x3*x4*xcp2 +512*e4e1*e4e2*e3e2*e2e1*x3*x4*x5*xcp2 -256*e4e1*e4e2*e3e2*e2e1*x3*x4^2*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x3^2*xcp2 +768*e4e1*e4e2*e3e2*e2e1*x3^2*x5*xcp2 -256*e4e1*e4e2*e3e2*e2e1*x3^2*x4*xcp2 -512*e4e1*e4e2*e3e2*e2e1*x1*xcp2 +1024*e4e1*e4e2*e3e2*e2e1*x1*x5*xcp2 -512*e4e1*e4e2*e3e2*e2e1*x1*x5^2*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x1*x4*xcp2 -640*e4e1*e4e2*e3e2*e2e1*x1*x4*x5*xcp2 -128*e4e1*e4e2*e3e2*e2e1*x1*x4^2*xcp2 +768*e4e1*e4e2*e3e2*e2e1*x1*x3*xcp2 -896*e4e1*e4e2*e3e2*e2e1*x1*x3*x5*xcp2 -128*e4e1*e4e2*e3e2*e2e1*x1*x3*x4*xcp2 -256*e4e1*e4e2*e3e2*e2e1*x1*x3^2*xcp2 -512*e4e1*e4e2*e3e2^2*x5*xcp2 +768*e4e1*e4e2*e3e2^2*x5^2*xcp2 -256*e4e1*e4e2*e3e2^2*x5^3*xcp2 +256*e4e1*e4e2*e3e2^2*x4*xcp2 +384*e4e1*e4e2*e3e2^2*x4*x5*xcp2 -384*e4e1*e4e2*e3e2^2*x4*x5^2*xcp2 -128*e4e1*e4e2*e3e2^2*x4^2*xcp2 -128*e4e1*e4e2*e3e2^2*x4^2*x5*xcp2 +896*e4e1*e4e2*e3e2^2*x3*x5*xcp2 -640*e4e1*e4e2*e3e2^2*x3*x5^2*xcp2 -384*e4e1*e4e2*e3e2^2*x3*x4*xcp2 -256*e4e1*e4e2*e3e2^2*x3*x4*x5*xcp2 +128*e4e1*e4e2*e3e2^2*x3*x4^2*xcp2 -384*e4e1*e4e2*e3e2^2*x3^2*x5*xcp2 +128*e4e1*e4e2*e3e2^2*x3^2*x4*xcp2 +32*e4e1*e4e2*e3e1*zk^2*xcp2 -128*e4e1*e4e2*e3e1*zk^2*x3*xcp2 +160*e4e1*e4e2*e3e1*zk^2*x1*xcp2 +192*e4e1*e4e2*e3e1*amel2*xcp3 +512*e4e1*e4e2*e3e1*amel2*xcp2 +192*e4e1*e4e2*e3e1*amel2*xcp1 -256*e4e1*e4e2*e3e1*amel2*x5*xcp3 -1280*e4e1*e4e2*e3e1*amel2*x5*xcp2 -256*e4e1*e4e2*e3e1*amel2*x5*xcp1 +192*e4e1*e4e2*e3e1*amel2*x5^2*xcp3 +256*e4e1*e4e2*e3e1*amel2*x5^2*xcp2 +192*e4e1*e4e2*e3e1*amel2*x5^2*xcp1 -64*e4e1*e4e2*e3e1*amel2*x5^3*xcp3 -64*e4e1*e4e2*e3e1*amel2*x5^3*xcp1 -64*e4e1*e4e2*e3e1*amel2*x4*xcp3 -1664*e4e1*e4e2*e3e1*amel2*x4*xcp2 -64*e4e1*e4e2*e3e1*amel2*x4*xcp1 +320*e4e1*e4e2*e3e1*amel2*x4*x5*xcp3 +896*e4e1*e4e2*e3e1*amel2*x4*x5*xcp2 +320*e4e1*e4e2*e3e1*amel2*x4*x5*xcp1 -128*e4e1*e4e2*e3e1*amel2*x4*x5^2*xcp3 -128*e4e1*e4e2*e3e1*amel2*x4*x5^2*xcp1 +128*e4e1*e4e2*e3e1*amel2*x4^2*xcp3 +512*e4e1*e4e2*e3e1*amel2*x4^2*xcp2 +128*e4e1*e4e2*e3e1*amel2*x4^2*xcp1 -64*e4e1*e4e2*e3e1*amel2*x4^2*x5*xcp3 -64*e4e1*e4e2*e3e1*amel2*x4^2*x5*xcp1 -256*e4e1*e4e2*e3e1*amel2*x3*xcp3 -1408*e4e1*e4e2*e3e1*amel2*x3*xcp2 -256*e4e1*e4e2*e3e1*amel2*x3*xcp1 +384*e4e1*e4e2*e3e1*amel2*x3*x5*xcp3 +1664*e4e1*e4e2*e3e1*amel2*x3*x5*xcp2 +384*e4e1*e4e2*e3e1*amel2*x3*x5*xcp1 -128*e4e1*e4e2*e3e1*amel2*x3*x5^2*xcp3 -256*e4e1*e4e2*e3e1*amel2*x3*x5^2*xcp2 -128*e4e1*e4e2*e3e1*amel2*x3*x5^2*xcp1 +192*e4e1*e4e2*e3e1*amel2*x3*x4*xcp3 +1792*e4e1*e4e2*e3e1*amel2*x3*x4*xcp2 +192*e4e1*e4e2*e3e1*amel2*x3*x4*xcp1 -128*e4e1*e4e2*e3e1*amel2*x3*x4*x5*xcp3 -512*e4e1*e4e2*e3e1*amel2*x3*x4*x5*xcp2 -128*e4e1*e4e2*e3e1*amel2*x3*x4*x5*xcp1 -384*e4e1*e4e2*e3e1*amel2*x3*x4^2*xcp2 +768*e4e1*e4e2*e3e1*amel2*x3^2*xcp2 -256*e4e1*e4e2*e3e1*amel2*x3^2*x4*xcp2 -128*e4e1*e4e2*e3e1*amel2*x3^3*xcp2 -128*e4e1*e4e2*e3e1*amel2*x1*xcp3 -384*e4e1*e4e2*e3e1*amel2*x1*xcp2 -128*e4e1*e4e2*e3e1*amel2*x1*xcp1 +288*e4e1*e4e2*e3e1*amel2*x1*x5*xcp3 +576*e4e1*e4e2*e3e1*amel2*x1*x5*xcp2 +288*e4e1*e4e2*e3e1*amel2*x1*x5*xcp1 -128*e4e1*e4e2*e3e1*amel2*x1*x5^2*xcp3 -128*e4e1*e4e2*e3e1*amel2*x1*x5^2*xcp2 -128*e4e1*e4e2*e3e1*amel2*x1*x5^2*xcp1 +704*e4e1*e4e2*e3e1*amel2*x1*x4*xcp2 -192*e4e1*e4e2*e3e1*amel2*x1*x4*x5*xcp3 -384*e4e1*e4e2*e3e1*amel2*x1*x4*x5*xcp2 -192*e4e1*e4e2*e3e1*amel2*x1*x4*x5*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1*x4^2*xcp3 +128*e4e1*e4e2*e3e1*amel2*x1*x4^2*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1*x4^2*xcp1 +96*e4e1*e4e2*e3e1*amel2*x1*x3*xcp3 +1024*e4e1*e4e2*e3e1*amel2*x1*x3*xcp2 +96*e4e1*e4e2*e3e1*amel2*x1*x3*xcp1 -192*e4e1*e4e2*e3e1*amel2*x1*x3*x5*xcp3 -1024*e4e1*e4e2*e3e1*amel2*x1*x3*x5*xcp2 -192*e4e1*e4e2*e3e1*amel2*x1*x3*x5*xcp1 +64*e4e1*e4e2*e3e1*amel2*x1*x3*x4*xcp3 -512*e4e1*e4e2*e3e1*amel2*x1*x3*x4*xcp2 +64*e4e1*e4e2*e3e1*amel2*x1*x3*x4*xcp1 +64*e4e1*e4e2*e3e1*amel2*x1*x3^2*xcp3 -384*e4e1*e4e2*e3e1*amel2*x1*x3^2*xcp2 +64*e4e1*e4e2*e3e1*amel2*x1*x3^2*xcp1 -32*e4e1*e4e2*e3e1*amel2*x1^2*xcp3 -576*e4e1*e4e2*e3e1*amel2*x1^2*xcp2 -32*e4e1*e4e2*e3e1*amel2*x1^2*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1^2*x5*xcp3 +256*e4e1*e4e2*e3e1*amel2*x1^2*x5*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1^2*x5*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1^2*x4*xcp3 +256*e4e1*e4e2*e3e1*amel2*x1^2*x4*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1^2*x4*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1^2*x3*xcp3 +384*e4e1*e4e2*e3e1*amel2*x1^2*x3*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1^2*x3*xcp1 +128*e4e1*e4e2*e3e1*amel2*x1^3*xcp2 +1280*e4e1*e4e2*e3e1*e2e1*xcp2 -1920*e4e1*e4e2*e3e1*e2e1*x5*xcp2 +640*e4e1*e4e2*e3e1*e2e1*x5^2*xcp2 -1920*e4e1*e4e2*e3e1*e2e1*x4*xcp2 +1408*e4e1*e4e2*e3e1*e2e1*x4*x5*xcp2 +768*e4e1*e4e2*e3e1*e2e1*x4^2*xcp2 -2048*e4e1*e4e2*e3e1*e2e1*x3*xcp2 +1536*e4e1*e4e2*e3e1*e2e1*x3*x5*xcp2 +2048*e4e1*e4e2*e3e1*e2e1*x3*x4*xcp2 -384*e4e1*e4e2*e3e1*e2e1*x3*x4*x5*xcp2 -384*e4e1*e4e2*e3e1*e2e1*x3*x4^2*xcp2 +768*e4e1*e4e2*e3e1*e2e1*x3^2*xcp2 +128*e4e1*e4e2*e3e1*e2e1*x3^2*x5*xcp2 -384*e4e1*e4e2*e3e1*e2e1*x3^2*x4*xcp2 -1024*e4e1*e4e2*e3e1*e2e1*x1*xcp2 +1664*e4e1*e4e2*e3e1*e2e1*x1*x5*xcp2 -640*e4e1*e4e2*e3e1*e2e1*x1*x5^2*xcp2 +640*e4e1*e4e2*e3e1*e2e1*x1*x4*xcp2 -768*e4e1*e4e2*e3e1*e2e1*x1*x4*x5*xcp2 -128*e4e1*e4e2*e3e1*e2e1*x1*x4^2*xcp2 +1792*e4e1*e4e2*e3e1*e2e1*x1*x3*xcp2 -1536*e4e1*e4e2*e3e1*e2e1*x1*x3*x5*xcp2 -512*e4e1*e4e2*e3e1*e2e1*x1*x3*x4*xcp2 -768*e4e1*e4e2*e3e1*e2e1*x1*x3^2*xcp2 -256*e4e1*e4e2*e3e1*e2e1*x1^2*xcp2 +128*e4e1*e4e2*e3e1*e2e1*x1^2*x5*xcp2 +128*e4e1*e4e2*e3e1*e2e1*x1^2*x4*xcp2 +256*e4e1*e4e2*e3e1*e2e1*x1^2*x3*xcp2 -1024*e4e1*e4e2*e3e1*e3e2*xcp2 +1664*e4e1*e4e2*e3e1*e3e2*x5*xcp2 -640*e4e1*e4e2*e3e1*e3e2*x5^2*xcp2 +1664*e4e1*e4e2*e3e1*e3e2*x4*xcp2 -1280*e4e1*e4e2*e3e1*e3e2*x4*x5*xcp2 -640*e4e1*e4e2*e3e1*e3e2*x4^2*xcp2 +1536*e4e1*e4e2*e3e1*e3e2*x3*xcp2 -1152*e4e1*e4e2*e3e1*e3e2*x3*x5*xcp2 -1664*e4e1*e4e2*e3e1*e3e2*x3*x4*xcp2 +384*e4e1*e4e2*e3e1*e3e2*x3*x4*x5*xcp2 +384*e4e1*e4e2*e3e1*e3e2*x3*x4^2*xcp2 -512*e4e1*e4e2*e3e1*e3e2*x3^2*xcp2 -128*e4e1*e4e2*e3e1*e3e2*x3^2*x5*xcp2 +384*e4e1*e4e2*e3e1*e3e2*x3^2*x4*xcp2 +1024*e4e1*e4e2*e3e1*e3e2*x1*xcp2 -1664*e4e1*e4e2*e3e1*e3e2*x1*x5*xcp2 +640*e4e1*e4e2*e3e1*e3e2*x1*x5^2*xcp2 -640*e4e1*e4e2*e3e1*e3e2*x1*x4*xcp2 +512*e4e1*e4e2*e3e1*e3e2*x1*x4*x5*xcp2 -128*e4e1*e4e2*e3e1*e3e2*x1*x4^2*xcp2 -1536*e4e1*e4e2*e3e1*e3e2*x1*x3*xcp2 +1280*e4e1*e4e2*e3e1*e3e2*x1*x3*x5*xcp2 +256*e4e1*e4e2*e3e1*e3e2*x1*x3*x4*xcp2 +512*e4e1*e4e2*e3e1*e3e2*x1*x3^2*xcp2 -512*e4e1*e4e2*e3e1^2*xcp2 +896*e4e1*e4e2*e3e1^2*x5*xcp2 -384*e4e1*e4e2*e3e1^2*x5^2*xcp2 +896*e4e1*e4e2*e3e1^2*x4*xcp2 -768*e4e1*e4e2*e3e1^2*x4*x5*xcp2 -384*e4e1*e4e2*e3e1^2*x4^2*xcp2 +1024*e4e1*e4e2*e3e1^2*x3*xcp2 -1152*e4e1*e4e2*e3e1^2*x3*x5*xcp2 +256*e4e1*e4e2*e3e1^2*x3*x5^2*xcp2 -1152*e4e1*e4e2*e3e1^2*x3*x4*xcp2 +512*e4e1*e4e2*e3e1^2*x3*x4*x5*xcp2 +256*e4e1*e4e2*e3e1^2*x3*x4^2*xcp2 -512*e4e1*e4e2*e3e1^2*x3^2*xcp2 +256*e4e1*e4e2*e3e1^2*x3^2*x5*xcp2 +256*e4e1*e4e2*e3e1^2*x3^2*x4*xcp2 +256*e4e1*e4e2*e3e1^2*x1*xcp2 -256*e4e1*e4e2*e3e1^2*x1*x5*xcp2 -256*e4e1*e4e2*e3e1^2*x1*x4*xcp2 -768*e4e1*e4e2*e3e1^2*x1*x3*xcp2 +384*e4e1*e4e2*e3e1^2*x1*x3*x5*xcp2 +384*e4e1*e4e2*e3e1^2*x1*x3*x4*xcp2 +512*e4e1*e4e2*e3e1^2*x1*x3^2*xcp2 +256*e4e1*e4e2*e3e1^2*x1^2*xcp2 -128*e4e1*e4e2*e3e1^2*x1^2*x5*xcp2 -128*e4e1*e4e2*e3e1^2*x1^2*x4*xcp2 -256*e4e1*e4e2*e3e1^2*x1^2*x3*xcp2 +64*e4e1*e4e2^2*zk^2*xcp2 -128*e4e1*e4e2^2*zk^2*x5*xcp2 +256*e4e1*e4e2^2*amel2*xcp2 +128*e4e1*e4e2^2*amel2*x5*xcp3 -512*e4e1*e4e2^2*amel2*x5*xcp2 +128*e4e1*e4e2^2*amel2*x5*xcp1 -64*e4e1*e4e2^2*amel2*x5^2*xcp3 -128*e4e1*e4e2^2*amel2*x5^2*xcp2 -64*e4e1*e4e2^2*amel2*x5^2*xcp1 -256*e4e1*e4e2^2*amel2*x4*xcp2 -128*e4e1*e4e2^2*amel2*x4*x5*xcp2 +128*e4e1*e4e2^2*amel2*x4*x5^2*xcp2 -64*e4e1*e4e2^2*amel2*x3*xcp3 -256*e4e1*e4e2^2*amel2*x3*xcp2 -64*e4e1*e4e2^2*amel2*x3*xcp1 -128*e4e1*e4e2^2*amel2*x3*x5*xcp3 +384*e4e1*e4e2^2*amel2*x3*x5*xcp2 -128*e4e1*e4e2^2*amel2*x3*x5*xcp1 +64*e4e1*e4e2^2*amel2*x3*x5^2*xcp3 +384*e4e1*e4e2^2*amel2*x3*x5^2*xcp2 +64*e4e1*e4e2^2*amel2*x3*x5^2*xcp1 +128*e4e1*e4e2^2*amel2*x3*x4*xcp2 +128*e4e1*e4e2^2*amel2*x3*x4*x5*xcp2 -128*e4e1*e4e2^2*amel2*x3^2*x5*xcp2 -512*e4e1*e4e2^2*amel2*x1*xcp2 +896*e4e1*e4e2^2*amel2*x1*x5*xcp2 -256*e4e1*e4e2^2*amel2*x1*x5^2*xcp2 -256*e4e1*e4e2^2*amel2*x1*x4*x5*xcp2 +256*e4e1*e4e2^2*amel2*x1*x3*xcp2 +128*e4e1*e4e2^2*amel2*x1*x3*x5*xcp3 -640*e4e1*e4e2^2*amel2*x1*x3*x5*xcp2 +128*e4e1*e4e2^2*amel2*x1*x3*x5*xcp1 +128*e4e1*e4e2^2*amel2*x1*x3*x4*xcp2 +128*e4e1*e4e2^2*amel2*x1*x3^2*xcp2 -256*e4e1*e4e2^2*amel2*x1^2*x5*xcp2 +128*e4e1*e4e2^2*amel2*x1^2*x3*xcp2 +256*e4e1*e4e2^2*e2e1*xcp2 +256*e4e1*e4e2^2*e2e1*x5*xcp2 -640*e4e1*e4e2^2*e2e1*x5^2*xcp2 +128*e4e1*e4e2^2*e2e1*x5^3*xcp2 -256*e4e1*e4e2^2*e2e1*x4*xcp2 -128*e4e1*e4e2^2*e2e1*x4*x5*xcp2 +128*e4e1*e4e2^2*e2e1*x4*x5^2*xcp2 -256*e4e1*e4e2^2*e2e1*x3*xcp2 -640*e4e1*e4e2^2*e2e1*x3*x5*xcp2 +640*e4e1*e4e2^2*e2e1*x3*x5^2*xcp2 +128*e4e1*e4e2^2*e2e1*x3*x4*xcp2 +128*e4e1*e4e2^2*e2e1*x3*x4*x5*xcp2 +256*e4e1*e4e2^2*e2e1*x3^2*x5*xcp2 -256*e4e1*e4e2^2*e2e1*x1*xcp2 +512*e4e1*e4e2^2*e2e1*x1*x5*xcp2 -256*e4e1*e4e2^2*e2e1*x1*x5^2*xcp2 -256*e4e1*e4e2^2*e2e1*x1*x4*x5*xcp2 +256*e4e1*e4e2^2*e2e1*x1*x3*xcp2 -384*e4e1*e4e2^2*e2e1*x1*x3*x5*xcp2 +128*e4e1*e4e2^2*e2e1*x1*x3*x4*xcp2 -640*e4e1*e4e2^2*e3e2*x5*xcp2 +768*e4e1*e4e2^2*e3e2*x5^2*xcp2 -128*e4e1*e4e2^2*e3e2*x5^3*xcp2 +128*e4e1*e4e2^2*e3e2*x4*xcp2 +256*e4e1*e4e2^2*e3e2*x4*x5*xcp2 -128*e4e1*e4e2^2*e3e2*x4*x5^2*xcp2 +896*e4e1*e4e2^2*e3e2*x3*x5*xcp2 -640*e4e1*e4e2^2*e3e2*x3*x5^2*xcp2 -128*e4e1*e4e2^2*e3e2*x3*x4*xcp2 -128*e4e1*e4e2^2*e3e2*x3*x4*x5*xcp2 -256*e4e1*e4e2^2*e3e2*x3^2*x5*xcp2 -512*e4e1*e4e2^2*e3e1*xcp2 +640*e4e1*e4e2^2*e3e1*x5*xcp2 -128*e4e1*e4e2^2*e3e1*x5^2*xcp2 +384*e4e1*e4e2^2*e3e1*x4*xcp2 -128*e4e1*e4e2^2*e3e1*x4*x5*xcp2 +512*e4e1*e4e2^2*e3e1*x3*xcp2 -256*e4e1*e4e2^2*e3e1*x3*x5*xcp2 -256*e4e1*e4e2^2*e3e1*x3*x4*xcp2 -256*e4e1*e4e2^2*e3e1*x3^2*x5*xcp2 +512*e4e1*e4e2^2*e3e1*x1*xcp2 -768*e4e1*e4e2^2*e3e1*x1*x5*xcp2 +256*e4e1*e4e2^2*e3e1*x1*x5^2*xcp2 +256*e4e1*e4e2^2*e3e1*x1*x4*x5*xcp2 -512*e4e1*e4e2^2*e3e1*x1*x3*xcp2 +640*e4e1*e4e2^2*e3e1*x1*x3*x5*xcp2 -128*e4e1*e4e2^2*e3e1*x1*x3*x4*xcp2 -256*e4e1*e4e2^3*x5*xcp2 +256*e4e1*e4e2^3*x5^2*xcp2 +256*e4e1*e4e2^3*x3*x5*xcp2 -256*e4e1*e4e2^3*x3*x5^2*xcp2 +32*e4e1^2*amel2*zk^2*xcp3 +32*e4e1^2*amel2*zk^2*xcp1 -48*e4e1^2*amel2*zk^2*x1*xcp3 -48*e4e1^2*amel2*zk^2*x1*xcp1 +32*e4e1^2*amel2^2*x5^2*xcp3 +32*e4e1^2*amel2^2*x5^2*xcp1 +64*e4e1^2*amel2^2*x4*x5*xcp3 -128*e4e1^2*amel2^2*x4*x5*xcp2 +64*e4e1^2*amel2^2*x4*x5*xcp1 +64*e4e1^2*amel2^2*x4^2*xcp3 -128*e4e1^2*amel2^2*x4^2*xcp2 +64*e4e1^2*amel2^2*x4^2*xcp1 -128*e4e1^2*amel2^2*x3*x5*xcp2 +64*e4e1^2*amel2^2*x3*x4*xcp3 -128*e4e1^2*amel2^2*x3*x4*xcp2 +64*e4e1^2*amel2^2*x3*x4*xcp1 +32*e4e1^2*amel2^2*x3^2*xcp3 +32*e4e1^2*amel2^2*x3^2*xcp1 -192*e4e1^2*amel2^2*x1*xcp3 -192*e4e1^2*amel2^2*x1*xcp1 +32*e4e1^2*amel2^2*x1*x5*xcp3 +32*e4e1^2*amel2^2*x1*x5*xcp1 -32*e4e1^2*amel2^2*x1*x5^2*xcp3 -32*e4e1^2*amel2^2*x1*x5^2*xcp1 +64*e4e1^2*amel2^2*x1*x4*xcp3 +64*e4e1^2*amel2^2*x1*x4*xcp2 +64*e4e1^2*amel2^2*x1*x4*xcp1 -64*e4e1^2*amel2^2*x1*x4*x5*xcp3 +128*e4e1^2*amel2^2*x1*x4*x5*xcp2 -64*e4e1^2*amel2^2*x1*x4*x5*xcp1 -64*e4e1^2*amel2^2*x1*x4^2*xcp3 +128*e4e1^2*amel2^2*x1*x4^2*xcp2 -64*e4e1^2*amel2^2*x1*x4^2*xcp1 +224*e4e1^2*amel2^2*x1*x3*xcp3 +64*e4e1^2*amel2^2*x1*x3*xcp2 +224*e4e1^2*amel2^2*x1*x3*xcp1 +128*e4e1^2*amel2^2*x1*x3*x5*xcp2 -64*e4e1^2*amel2^2*x1*x3*x4*xcp3 +128*e4e1^2*amel2^2*x1*x3*x4*xcp2 -64*e4e1^2*amel2^2*x1*x3*x4*xcp1 -32*e4e1^2*amel2^2*x1*x3^2*xcp3 -32*e4e1^2*amel2^2*x1*x3^2*xcp1 +192*e4e1^2*amel2^2*x1^2*xcp3 +192*e4e1^2*amel2^2*x1^2*xcp1 -64*e4e1^2*amel2^2*x1^2*x5*xcp3 -64*e4e1^2*amel2^2*x1^2*x5*xcp1 -64*e4e1^2*amel2^2*x1^2*x4*xcp3 -256*e4e1^2*amel2^2*x1^2*x4*xcp2 -64*e4e1^2*amel2^2*x1^2*x4*xcp1 -192*e4e1^2*amel2^2*x1^2*x3*xcp3 -256*e4e1^2*amel2^2*x1^2*x3*xcp2 -192*e4e1^2*amel2^2*x1^2*x3*xcp1 -32*e4e1^2*amel2^2*x1^3*xcp3 -32*e4e1^2*amel2^2*x1^3*xcp1 +32*e4e1^2*e2e1*zk^2*xcp2 -96*e4e1^2*e2e1*zk^2*x1*xcp2 -128*e4e1^2*e2e1*amel2*xcp3 -128*e4e1^2*e2e1*amel2*xcp1 +64*e4e1^2*e2e1*amel2*x5*xcp3 +256*e4e1^2*e2e1*amel2*x5*xcp2 +64*e4e1^2*e2e1*amel2*x5*xcp1 -128*e4e1^2*e2e1*amel2*x5^2*xcp2 +384*e4e1^2*e2e1*amel2*x4*xcp2 +64*e4e1^2*e2e1*amel2*x4*x5*xcp3 -384*e4e1^2*e2e1*amel2*x4*x5*xcp2 +64*e4e1^2*e2e1*amel2*x4*x5*xcp1 +64*e4e1^2*e2e1*amel2*x4^2*xcp3 -256*e4e1^2*e2e1*amel2*x4^2*xcp2 +64*e4e1^2*e2e1*amel2*x4^2*xcp1 +128*e4e1^2*e2e1*amel2*x3*xcp3 +128*e4e1^2*e2e1*amel2*x3*xcp2 +128*e4e1^2*e2e1*amel2*x3*xcp1 -384*e4e1^2*e2e1*amel2*x3*x5*xcp2 +64*e4e1^2*e2e1*amel2*x3*x4*xcp3 -512*e4e1^2*e2e1*amel2*x3*x4*xcp2 +64*e4e1^2*e2e1*amel2*x3*x4*xcp1 -128*e4e1^2*e2e1*amel2*x3^2*xcp2 +64*e4e1^2*e2e1*amel2*x1*xcp3 -384*e4e1^2*e2e1*amel2*x1*xcp2 +64*e4e1^2*e2e1*amel2*x1*xcp1 -96*e4e1^2*e2e1*amel2*x1*x5*xcp3 -64*e4e1^2*e2e1*amel2*x1*x5*xcp2 -96*e4e1^2*e2e1*amel2*x1*x5*xcp1 +128*e4e1^2*e2e1*amel2*x1*x5^2*xcp2 +64*e4e1^2*e2e1*amel2*x1*x4*xcp3 -64*e4e1^2*e2e1*amel2*x1*x4*xcp2 +64*e4e1^2*e2e1*amel2*x1*x4*xcp1 -64*e4e1^2*e2e1*amel2*x1*x4*x5*xcp3 +512*e4e1^2*e2e1*amel2*x1*x4*x5*xcp2 -64*e4e1^2*e2e1*amel2*x1*x4*x5*xcp1 -64*e4e1^2*e2e1*amel2*x1*x4^2*xcp3 +256*e4e1^2*e2e1*amel2*x1*x4^2*xcp2 -64*e4e1^2*e2e1*amel2*x1*x4^2*xcp1 -96*e4e1^2*e2e1*amel2*x1*x3*xcp3 +384*e4e1^2*e2e1*amel2*x1*x3*xcp2 -96*e4e1^2*e2e1*amel2*x1*x3*xcp1 +64*e4e1^2*e2e1*amel2*x1*x3*x5*xcp3 +512*e4e1^2*e2e1*amel2*x1*x3*x5*xcp2 +64*e4e1^2*e2e1*amel2*x1*x3*x5*xcp1 -64*e4e1^2*e2e1*amel2*x1*x3*x4*xcp3 +384*e4e1^2*e2e1*amel2*x1*x3*x4*xcp2 -64*e4e1^2*e2e1*amel2*x1*x3*x4*xcp1 +32*e4e1^2*e2e1*amel2*x1^2*xcp3 +576*e4e1^2*e2e1*amel2*x1^2*xcp2 +32*e4e1^2*e2e1*amel2*x1^2*xcp1 -384*e4e1^2*e2e1*amel2*x1^2*x5*xcp2 -64*e4e1^2*e2e1*amel2*x1^2*x4*xcp3 -384*e4e1^2*e2e1*amel2*x1^2*x4*xcp2 -64*e4e1^2*e2e1*amel2*x1^2*x4*xcp1 -512*e4e1^2*e2e1*amel2*x1^2*x3*xcp2 -128*e4e1^2*e2e1*amel2*x1^3*xcp2 -256*e4e1^2*e2e1^2*xcp2 +384*e4e1^2*e2e1^2*x5*xcp2 -128*e4e1^2*e2e1^2*x5^2*xcp2 +384*e4e1^2*e2e1^2*x4*xcp2 -256*e4e1^2*e2e1^2*x4*x5*xcp2 -128*e4e1^2*e2e1^2*x4^2*xcp2 +512*e4e1^2*e2e1^2*x3*xcp2 -384*e4e1^2*e2e1^2*x3*x5*xcp2 -384*e4e1^2*e2e1^2*x3*x4*xcp2 -256*e4e1^2*e2e1^2*x3^2*xcp2 -384*e4e1^2*e2e1^2*x1*x5*xcp2 +256*e4e1^2*e2e1^2*x1*x5^2*xcp2 -128*e4e1^2*e2e1^2*x1*x4*xcp2 +384*e4e1^2*e2e1^2*x1*x4*x5*xcp2 +128*e4e1^2*e2e1^2*x1*x4^2*xcp2 -256*e4e1^2*e2e1^2*x1*x3*xcp2 +512*e4e1^2*e2e1^2*x1*x3*x5*xcp2 +256*e4e1^2*e2e1^2*x1*x3*x4*xcp2 +256*e4e1^2*e2e1^2*x1*x3^2*xcp2 +256*e4e1^2*e2e1^2*x1^2*xcp2 -128*e4e1^2*e2e1^2*x1^2*x5*xcp2 -128*e4e1^2*e2e1^2*x1^2*x4*xcp2 -256*e4e1^2*e2e1^2*x1^2*x3*xcp2 -32*e4e1^2*e3e2*zk^2*xcp2 +96*e4e1^2*e3e2*zk^2*x1*xcp2 +128*e4e1^2*e3e2*amel2*xcp3 +128*e4e1^2*e3e2*amel2*xcp1 -64*e4e1^2*e3e2*amel2*x5*xcp3 -256*e4e1^2*e3e2*amel2*x5*xcp2 -64*e4e1^2*e3e2*amel2*x5*xcp1 +128*e4e1^2*e3e2*amel2*x5^2*xcp2 -384*e4e1^2*e3e2*amel2*x4*xcp2 -64*e4e1^2*e3e2*amel2*x4*x5*xcp3 +384*e4e1^2*e3e2*amel2*x4*x5*xcp2 -64*e4e1^2*e3e2*amel2*x4*x5*xcp1 -64*e4e1^2*e3e2*amel2*x4^2*xcp3 +256*e4e1^2*e3e2*amel2*x4^2*xcp2 -64*e4e1^2*e3e2*amel2*x4^2*xcp1 -128*e4e1^2*e3e2*amel2*x3*xcp3 -128*e4e1^2*e3e2*amel2*x3*xcp2 -128*e4e1^2*e3e2*amel2*x3*xcp1 +384*e4e1^2*e3e2*amel2*x3*x5*xcp2 -64*e4e1^2*e3e2*amel2*x3*x4*xcp3 +512*e4e1^2*e3e2*amel2*x3*x4*xcp2 -64*e4e1^2*e3e2*amel2*x3*x4*xcp1 +128*e4e1^2*e3e2*amel2*x3^2*xcp2 -128*e4e1^2*e3e2*amel2*x1*xcp3 +384*e4e1^2*e3e2*amel2*x1*xcp2 -128*e4e1^2*e3e2*amel2*x1*xcp1 +96*e4e1^2*e3e2*amel2*x1*x5*xcp3 +64*e4e1^2*e3e2*amel2*x1*x5*xcp2 +96*e4e1^2*e3e2*amel2*x1*x5*xcp1 -128*e4e1^2*e3e2*amel2*x1*x5^2*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4*x5*xcp3 -512*e4e1^2*e3e2*amel2*x1*x4*x5*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4*x5*xcp1 +64*e4e1^2*e3e2*amel2*x1*x4^2*xcp3 -256*e4e1^2*e3e2*amel2*x1*x4^2*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4^2*xcp1 +160*e4e1^2*e3e2*amel2*x1*x3*xcp3 -384*e4e1^2*e3e2*amel2*x1*x3*xcp2 +160*e4e1^2*e3e2*amel2*x1*x3*xcp1 -64*e4e1^2*e3e2*amel2*x1*x3*x5*xcp3 -512*e4e1^2*e3e2*amel2*x1*x3*x5*xcp2 -64*e4e1^2*e3e2*amel2*x1*x3*x5*xcp1 +64*e4e1^2*e3e2*amel2*x1*x3*x4*xcp3 -384*e4e1^2*e3e2*amel2*x1*x3*x4*xcp2 +64*e4e1^2*e3e2*amel2*x1*x3*x4*xcp1 +32*e4e1^2*e3e2*amel2*x1^2*xcp3 -576*e4e1^2*e3e2*amel2*x1^2*xcp2 +32*e4e1^2*e3e2*amel2*x1^2*xcp1 +384*e4e1^2*e3e2*amel2*x1^2*x5*xcp2 +384*e4e1^2*e3e2*amel2*x1^2*x4*xcp2 -64*e4e1^2*e3e2*amel2*x1^2*x3*xcp3 +512*e4e1^2*e3e2*amel2*x1^2*x3*xcp2 -64*e4e1^2*e3e2*amel2*x1^2*x3*xcp1 +128*e4e1^2*e3e2*amel2*x1^3*xcp2 +512*e4e1^2*e3e2*e2e1*xcp2 -768*e4e1^2*e3e2*e2e1*x5*xcp2 +256*e4e1^2*e3e2*e2e1*x5^2*xcp2 -768*e4e1^2*e3e2*e2e1*x4*xcp2 +512*e4e1^2*e3e2*e2e1*x4*x5*xcp2 +256*e4e1^2*e3e2*e2e1*x4^2*xcp2 -1024*e4e1^2*e3e2*e2e1*x3*xcp2 +768*e4e1^2*e3e2*e2e1*x3*x5*xcp2 +768*e4e1^2*e3e2*e2e1*x3*x4*xcp2 +512*e4e1^2*e3e2*e2e1*x3^2*xcp2 -256*e4e1^2*e3e2*e2e1*x1*xcp2 +896*e4e1^2*e3e2*e2e1*x1*x5*xcp2 -512*e4e1^2*e3e2*e2e1*x1*x5^2*xcp2 +384*e4e1^2*e3e2*e2e1*x1*x4*xcp2 -768*e4e1^2*e3e2*e2e1*x1*x4*x5*xcp2 -256*e4e1^2*e3e2*e2e1*x1*x4^2*xcp2 +768*e4e1^2*e3e2*e2e1*x1*x3*xcp2 -1024*e4e1^2*e3e2*e2e1*x1*x3*x5*xcp2 -512*e4e1^2*e3e2*e2e1*x1*x3*x4*xcp2 -512*e4e1^2*e3e2*e2e1*x1*x3^2*xcp2 -256*e4e1^2*e3e2*e2e1*x1^2*xcp2 +128*e4e1^2*e3e2*e2e1*x1^2*x5*xcp2 +128*e4e1^2*e3e2*e2e1*x1^2*x4*xcp2 +256*e4e1^2*e3e2*e2e1*x1^2*x3*xcp2 -256*e4e1^2*e3e2^2*xcp2 +384*e4e1^2*e3e2^2*x5*xcp2 -128*e4e1^2*e3e2^2*x5^2*xcp2 +384*e4e1^2*e3e2^2*x4*xcp2 -256*e4e1^2*e3e2^2*x4*x5*xcp2 -128*e4e1^2*e3e2^2*x4^2*xcp2 +512*e4e1^2*e3e2^2*x3*xcp2 -384*e4e1^2*e3e2^2*x3*x5*xcp2 -384*e4e1^2*e3e2^2*x3*x4*xcp2 -256*e4e1^2*e3e2^2*x3^2*xcp2 +256*e4e1^2*e3e2^2*x1*xcp2 -512*e4e1^2*e3e2^2*x1*x5*xcp2 +256*e4e1^2*e3e2^2*x1*x5^2*xcp2 -256*e4e1^2*e3e2^2*x1*x4*xcp2 +384*e4e1^2*e3e2^2*x1*x4*x5*xcp2 +128*e4e1^2*e3e2^2*x1*x4^2*xcp2 -512*e4e1^2*e3e2^2*x1*x3*xcp2 +512*e4e1^2*e3e2^2*x1*x3*x5*xcp2 +256*e4e1^2*e3e2^2*x1*x3*x4*xcp2 +256*e4e1^2*e3e2^2*x1*x3^2*xcp2 +64*e4e1^2*e3e1*amel2*x5*xcp3 +64*e4e1^2*e3e1*amel2*x5*xcp1 -64*e4e1^2*e3e1*amel2*x5^2*xcp3 -64*e4e1^2*e3e1*amel2*x5^2*xcp1 +64*e4e1^2*e3e1*amel2*x4*xcp3 -128*e4e1^2*e3e1*amel2*x4*xcp2 +64*e4e1^2*e3e1*amel2*x4*xcp1 -128*e4e1^2*e3e1*amel2*x4*x5*xcp3 +128*e4e1^2*e3e1*amel2*x4*x5*xcp2 -128*e4e1^2*e3e1*amel2*x4*x5*xcp1 -64*e4e1^2*e3e1*amel2*x4^2*xcp3 +128*e4e1^2*e3e1*amel2*x4^2*xcp2 -64*e4e1^2*e3e1*amel2*x4^2*xcp1 -128*e4e1^2*e3e1*amel2*x3*xcp2 -64*e4e1^2*e3e1*amel2*x3*x5*xcp3 +128*e4e1^2*e3e1*amel2*x3*x5*xcp2 -64*e4e1^2*e3e1*amel2*x3*x5*xcp1 -64*e4e1^2*e3e1*amel2*x3*x4*xcp3 +256*e4e1^2*e3e1*amel2*x3*x4*xcp2 -64*e4e1^2*e3e1*amel2*x3*x4*xcp1 +128*e4e1^2*e3e1*amel2*x3^2*xcp2 +256*e4e1^2*e3e1*amel2*x1*xcp3 +256*e4e1^2*e3e1*amel2*x1*xcp1 -128*e4e1^2*e3e1*amel2*x1*x5*xcp3 -128*e4e1^2*e3e1*amel2*x1*x5*xcp1 +64*e4e1^2*e3e1*amel2*x1*x5^2*xcp3 +64*e4e1^2*e3e1*amel2*x1*x5^2*xcp1 -128*e4e1^2*e3e1*amel2*x1*x4*xcp3 -128*e4e1^2*e3e1*amel2*x1*x4*xcp2 -128*e4e1^2*e3e1*amel2*x1*x4*xcp1 +128*e4e1^2*e3e1*amel2*x1*x4*x5*xcp3 +128*e4e1^2*e3e1*amel2*x1*x4*x5*xcp1 +64*e4e1^2*e3e1*amel2*x1*x4^2*xcp3 +64*e4e1^2*e3e1*amel2*x1*x4^2*xcp1 -256*e4e1^2*e3e1*amel2*x1*x3*xcp3 -128*e4e1^2*e3e1*amel2*x1*x3*xcp2 -256*e4e1^2*e3e1*amel2*x1*x3*xcp1 +128*e4e1^2*e3e1*amel2*x1*x3*x5*xcp3 +128*e4e1^2*e3e1*amel2*x1*x3*x5*xcp1 +128*e4e1^2*e3e1*amel2*x1*x3*x4*xcp3 -128*e4e1^2*e3e1*amel2*x1*x3*x4*xcp2 +128*e4e1^2*e3e1*amel2*x1*x3*x4*xcp1 -128*e4e1^2*e3e1*amel2*x1*x3^2*xcp2 -192*e4e1^2*e3e1*amel2*x1^2*xcp3 -192*e4e1^2*e3e1*amel2*x1^2*xcp1 +64*e4e1^2*e3e1*amel2*x1^2*x5*xcp3 +64*e4e1^2*e3e1*amel2*x1^2*x5*xcp1 +64*e4e1^2*e3e1*amel2*x1^2*x4*xcp3 +256*e4e1^2*e3e1*amel2*x1^2*x4*xcp2 +64*e4e1^2*e3e1*amel2*x1^2*x4*xcp1 +192*e4e1^2*e3e1*amel2*x1^2*x3*xcp3 +256*e4e1^2*e3e1*amel2*x1^2*x3*xcp2 +192*e4e1^2*e3e1*amel2*x1^2*x3*xcp1 +256*e4e1^2*e3e1*e2e1*xcp2 -384*e4e1^2*e3e1*e2e1*x5*xcp2 +128*e4e1^2*e3e1*e2e1*x5^2*xcp2 -384*e4e1^2*e3e1*e2e1*x4*xcp2 +256*e4e1^2*e3e1*e2e1*x4*x5*xcp2 +128*e4e1^2*e3e1*e2e1*x4^2*xcp2 -512*e4e1^2*e3e1*e2e1*x3*xcp2 +384*e4e1^2*e3e1*e2e1*x3*x5*xcp2 +384*e4e1^2*e3e1*e2e1*x3*x4*xcp2 +256*e4e1^2*e3e1*e2e1*x3^2*xcp2 +256*e4e1^2*e3e1*e2e1*x1*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x5*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x4*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x3*x5*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x3*x4*xcp2 -256*e4e1^2*e3e1*e2e1*x1*x3^2*xcp2 -512*e4e1^2*e3e1*e2e1*x1^2*xcp2 +256*e4e1^2*e3e1*e2e1*x1^2*x5*xcp2 +256*e4e1^2*e3e1*e2e1*x1^2*x4*xcp2 +512*e4e1^2*e3e1*e2e1*x1^2*x3*xcp2 -256*e4e1^2*e3e1*e3e2*xcp2 +384*e4e1^2*e3e1*e3e2*x5*xcp2 -128*e4e1^2*e3e1*e3e2*x5^2*xcp2 +384*e4e1^2*e3e1*e3e2*x4*xcp2 -256*e4e1^2*e3e1*e3e2*x4*x5*xcp2 -128*e4e1^2*e3e1*e3e2*x4^2*xcp2 +512*e4e1^2*e3e1*e3e2*x3*xcp2 -384*e4e1^2*e3e1*e3e2*x3*x5*xcp2 -384*e4e1^2*e3e1*e3e2*x3*x4*xcp2 -256*e4e1^2*e3e1*e3e2*x3^2*xcp2 -256*e4e1^2*e3e1*e3e2*x1*xcp2 +256*e4e1^2*e3e1*e3e2*x1*x5*xcp2 +256*e4e1^2*e3e1*e3e2*x1*x4*xcp2 +128*e4e1^2*e3e1*e3e2*x1*x3*x5*xcp2 +128*e4e1^2*e3e1*e3e2*x1*x3*x4*xcp2 +256*e4e1^2*e3e1*e3e2*x1*x3^2*xcp2 +512*e4e1^2*e3e1*e3e2*x1^2*xcp2 -384*e4e1^2*e3e1*e3e2*x1^2*x5*xcp2 -384*e4e1^2*e3e1*e3e2*x1^2*x4*xcp2 -512*e4e1^2*e3e1*e3e2*x1^2*x3*xcp2 -64*e4e1^2*e4e2*zk^2*xcp2 +128*e4e1^2*e4e2*zk^2*x1*xcp2 +128*e4e1^2*e4e2*amel2*xcp3 +128*e4e1^2*e4e2*amel2*xcp1 -64*e4e1^2*e4e2*amel2*x5*xcp3 -256*e4e1^2*e4e2*amel2*x5*xcp2 -64*e4e1^2*e4e2*amel2*x5*xcp1 -384*e4e1^2*e4e2*amel2*x4*xcp2 +128*e4e1^2*e4e2*amel2*x4*x5*xcp2 -128*e4e1^2*e4e2*amel2*x3*xcp3 -128*e4e1^2*e4e2*amel2*x3*xcp2 -128*e4e1^2*e4e2*amel2*x3*xcp1 +64*e4e1^2*e4e2*amel2*x3*x5*xcp3 +384*e4e1^2*e4e2*amel2*x3*x5*xcp2 +64*e4e1^2*e4e2*amel2*x3*x5*xcp1 +256*e4e1^2*e4e2*amel2*x3*x4*xcp2 -128*e4e1^2*e4e2*amel2*x1*xcp3 +384*e4e1^2*e4e2*amel2*x1*xcp2 -128*e4e1^2*e4e2*amel2*x1*xcp1 +128*e4e1^2*e4e2*amel2*x1*x5*xcp3 +128*e4e1^2*e4e2*amel2*x1*x5*xcp2 +128*e4e1^2*e4e2*amel2*x1*x5*xcp1 +128*e4e1^2*e4e2*amel2*x1*x4*xcp2 -256*e4e1^2*e4e2*amel2*x1*x4*x5*xcp2 +128*e4e1^2*e4e2*amel2*x1*x3*xcp3 -384*e4e1^2*e4e2*amel2*x1*x3*xcp2 +128*e4e1^2*e4e2*amel2*x1*x3*xcp1 -128*e4e1^2*e4e2*amel2*x1*x3*x5*xcp3 -512*e4e1^2*e4e2*amel2*x1*x3*x5*xcp2 -128*e4e1^2*e4e2*amel2*x1*x3*x5*xcp1 -128*e4e1^2*e4e2*amel2*x1*x3*x4*xcp2 +128*e4e1^2*e4e2*amel2*x1*x3^2*xcp2 -640*e4e1^2*e4e2*amel2*x1^2*xcp2 +128*e4e1^2*e4e2*amel2*x1^2*x5*xcp2 +128*e4e1^2*e4e2*amel2*x1^2*x4*xcp2 -64*e4e1^2*e4e2*amel2*x1^2*x3*xcp3 +512*e4e1^2*e4e2*amel2*x1^2*x3*xcp2 -64*e4e1^2*e4e2*amel2*x1^2*x3*xcp1 +128*e4e1^2*e4e2*amel2*x1^3*xcp2 +512*e4e1^2*e4e2*e2e1*xcp2 -640*e4e1^2*e4e2*e2e1*x5*xcp2 +128*e4e1^2*e4e2*e2e1*x5^2*xcp2 -384*e4e1^2*e4e2*e2e1*x4*xcp2 +128*e4e1^2*e4e2*e2e1*x4*x5*xcp2 -768*e4e1^2*e4e2*e2e1*x3*xcp2 +512*e4e1^2*e4e2*e2e1*x3*x5*xcp2 +256*e4e1^2*e4e2*e2e1*x3*x4*xcp2 +256*e4e1^2*e4e2*e2e1*x3^2*xcp2 -256*e4e1^2*e4e2*e2e1*x1*xcp2 +896*e4e1^2*e4e2*e2e1*x1*x5*xcp2 -256*e4e1^2*e4e2*e2e1*x1*x5^2*xcp2 +128*e4e1^2*e4e2*e2e1*x1*x4*xcp2 -256*e4e1^2*e4e2*e2e1*x1*x4*x5*xcp2 +512*e4e1^2*e4e2*e2e1*x1*x3*xcp2 -896*e4e1^2*e4e2*e2e1*x1*x3*x5*xcp2 -128*e4e1^2*e4e2*e2e1*x1*x3*x4*xcp2 -256*e4e1^2*e4e2*e2e1*x1*x3^2*xcp2 -256*e4e1^2*e4e2*e2e1*x1^2*xcp2 +128*e4e1^2*e4e2*e2e1*x1^2*x5*xcp2 +128*e4e1^2*e4e2*e2e1*x1^2*x4*xcp2 +256*e4e1^2*e4e2*e2e1*x1^2*x3*xcp2 -512*e4e1^2*e4e2*e3e2*xcp2 +640*e4e1^2*e4e2*e3e2*x5*xcp2 -128*e4e1^2*e4e2*e3e2*x5^2*xcp2 +384*e4e1^2*e4e2*e3e2*x4*xcp2 -128*e4e1^2*e4e2*e3e2*x4*x5*xcp2 +768*e4e1^2*e4e2*e3e2*x3*xcp2 -512*e4e1^2*e4e2*e3e2*x3*x5*xcp2 -256*e4e1^2*e4e2*e3e2*x3*x4*xcp2 -256*e4e1^2*e4e2*e3e2*x3^2*xcp2 +512*e4e1^2*e4e2*e3e2*x1*xcp2 -1024*e4e1^2*e4e2*e3e2*x1*x5*xcp2 +256*e4e1^2*e4e2*e3e2*x1*x5^2*xcp2 -256*e4e1^2*e4e2*e3e2*x1*x4*xcp2 +256*e4e1^2*e4e2*e3e2*x1*x4*x5*xcp2 -768*e4e1^2*e4e2*e3e2*x1*x3*xcp2 +896*e4e1^2*e4e2*e3e2*x1*x3*x5*xcp2 +128*e4e1^2*e4e2*e3e2*x1*x3*x4*xcp2 +256*e4e1^2*e4e2*e3e2*x1*x3^2*xcp2 -256*e4e1^2*e4e2*e3e1*xcp2 +256*e4e1^2*e4e2*e3e1*x5*xcp2 +256*e4e1^2*e4e2*e3e1*x4*xcp2 +512*e4e1^2*e4e2*e3e1*x3*xcp2 -256*e4e1^2*e4e2*e3e1*x3*x5*xcp2 -256*e4e1^2*e4e2*e3e1*x3*x4*xcp2 -256*e4e1^2*e4e2*e3e1*x3^2*xcp2 -256*e4e1^2*e4e2*e3e1*x1*xcp2 +128*e4e1^2*e4e2*e3e1*x1*x5*xcp2 +128*e4e1^2*e4e2*e3e1*x1*x4*xcp2 +256*e4e1^2*e4e2*e3e1*x1*x3^2*xcp2 +512*e4e1^2*e4e2*e3e1*x1^2*xcp2 -128*e4e1^2*e4e2*e3e1*x1^2*x5*xcp2 -128*e4e1^2*e4e2*e3e1*x1^2*x4*xcp2 -512*e4e1^2*e4e2*e3e1*x1^2*x3*xcp2 -256*e4e1^2*e4e2^2*xcp2 +256*e4e1^2*e4e2^2*x5*xcp2 +256*e4e1^2*e4e2^2*x3*xcp2 -256*e4e1^2*e4e2^2*x3*x5*xcp2 +256*e4e1^2*e4e2^2*x1*xcp2 -512*e4e1^2*e4e2^2*x1*x5*xcp2 -256*e4e1^2*e4e2^2*x1*x3*xcp2 +512*e4e1^2*e4e2^2*x1*x3*x5*xcp2 +64*e4e1^3*amel2*x1*xcp3 +64*e4e1^3*amel2*x1*xcp1 -128*e4e1^3*amel2*x1*x4*xcp2 -64*e4e1^3*amel2*x1*x3*xcp3 -128*e4e1^3*amel2*x1*x3*xcp2 -64*e4e1^3*amel2*x1*x3*xcp1 -64*e4e1^3*amel2*x1^2*xcp3 -64*e4e1^3*amel2*x1^2*xcp1 +128*e4e1^3*amel2*x1^2*x4*xcp2 +64*e4e1^3*amel2*x1^2*x3*xcp3 +128*e4e1^3*amel2*x1^2*x3*xcp2 +64*e4e1^3*amel2*x1^2*x3*xcp1 +256*e4e1^3*e2e1*x1*xcp2 -128*e4e1^3*e2e1*x1*x5*xcp2 -128*e4e1^3*e2e1*x1*x4*xcp2 -256*e4e1^3*e2e1*x1*x3*xcp2 -256*e4e1^3*e2e1*x1^2*xcp2 +128*e4e1^3*e2e1*x1^2*x5*xcp2 +128*e4e1^3*e2e1*x1^2*x4*xcp2 +256*e4e1^3*e2e1*x1^2*x3*xcp2 -256*e4e1^3*e3e2*x1*xcp2 +128*e4e1^3*e3e2*x1*x5*xcp2 +128*e4e1^3*e3e2*x1*x4*xcp2 +256*e4e1^3*e3e2*x1*x3*xcp2 +256*e4e1^3*e3e2*x1^2*xcp2 -128*e4e1^3*e3e2*x1^2*x5*xcp2 -128*e4e1^3*e3e2*x1^2*x4*xcp2 -256*e4e1^3*e3e2*x1^2*x3*xcp2 -256*e4e1^3*e4e2*x1*xcp2 +256*e4e1^3*e4e2*x1*x3*xcp2 +256*e4e1^3*e4e2*x1^2*xcp2 -256*e4e1^3*e4e2*x1^2*x3*xcp2 -32*EFUN*amel2^2*x1*x5*xcp3 +32*EFUN*amel2^2*x1*x5*xcp1 -64*EFUN*amel2^2*x1*x4*xcp3 +64*EFUN*amel2^2*x1*x4*xcp1 -32*EFUN*amel2^2*x1*x3*xcp3 +32*EFUN*amel2^2*x1*x3*xcp1 -32*EFUN*amel2^2*x1^2*xcp3 +32*EFUN*amel2^2*x1^2*xcp1 +32*EFUN*e2e1*amel2*x5^2*xcp3 -32*EFUN*e2e1*amel2*x5^2*xcp1 +64*EFUN*e2e1*amel2*x4*x5*xcp3 -64*EFUN*e2e1*amel2*x4*x5*xcp1 +64*EFUN*e2e1*amel2*x3*x5*xcp3 -64*EFUN*e2e1*amel2*x3*x5*xcp1 +64*EFUN*e2e1*amel2*x3*x4*xcp3 -64*EFUN*e2e1*amel2*x3*x4*xcp1 +32*EFUN*e2e1*amel2*x3^2*xcp3 -32*EFUN*e2e1*amel2*x3^2*xcp1 +32*EFUN*e2e1*amel2*x1*x5*xcp3 -32*EFUN*e2e1*amel2*x1*x5*xcp1 +32*EFUN*e2e1*amel2*x1*x3*xcp3 -32*EFUN*e2e1*amel2*x1*x3*xcp1 -32*EFUN*e3e2*amel2*x5^2*xcp3 +32*EFUN*e3e2*amel2*x5^2*xcp1 -64*EFUN*e3e2*amel2*x4*x5*xcp3 +64*EFUN*e3e2*amel2*x4*x5*xcp1 -64*EFUN*e3e2*amel2*x3*x5*xcp3 +64*EFUN*e3e2*amel2*x3*x5*xcp1 -64*EFUN*e3e2*amel2*x3*x4*xcp3 +64*EFUN*e3e2*amel2*x3*x4*xcp1 -32*EFUN*e3e2*amel2*x3^2*xcp3 +32*EFUN*e3e2*amel2*x3^2*xcp1 -32*EFUN*e3e2*amel2*x1*x5*xcp3 +32*EFUN*e3e2*amel2*x1*x5*xcp1 -32*EFUN*e3e2*amel2*x1*x3*xcp3 +32*EFUN*e3e2*amel2*x1*x3*xcp1 -64*EFUN*e3e1*amel2*x5*xcp3 +64*EFUN*e3e1*amel2*x5*xcp1 +32*EFUN*e3e1*amel2*x5^2*xcp3 -32*EFUN*e3e1*amel2*x5^2*xcp1 -32*EFUN*e3e1*amel2*x4*xcp3 +32*EFUN*e3e1*amel2*x4*xcp1 +96*EFUN*e3e1*amel2*x4*x5*xcp3 -96*EFUN*e3e1*amel2*x4*x5*xcp1 +64*EFUN*e3e1*amel2*x4^2*xcp3 -64*EFUN*e3e1*amel2*x4^2*xcp1 +32*EFUN*e3e1*amel2*x3*xcp3 -32*EFUN*e3e1*amel2*x3*xcp1 +32*EFUN*e3e1*amel2*x3*x5*xcp3 -32*EFUN*e3e1*amel2*x3*x5*xcp1 +32*EFUN*e3e1*amel2*x3*x4*xcp3 -32*EFUN*e3e1*amel2*x3*x4*xcp1 -32*EFUN*e3e1*amel2*x1*xcp3 +32*EFUN*e3e1*amel2*x1*xcp1 +64*EFUN*e3e1*amel2*x1*x5*xcp3 -64*EFUN*e3e1*amel2*x1*x5*xcp1 +96*EFUN*e3e1*amel2*x1*x4*xcp3 -96*EFUN*e3e1*amel2*x1*x4*xcp1 +32*EFUN*e3e1*amel2*x1*x3*xcp3 -32*EFUN*e3e1*amel2*x1*x3*xcp1 +32*EFUN*e3e1*amel2*x1^2*xcp3 -32*EFUN*e3e1*amel2*x1^2*xcp1 -32*EFUN*e4e2*amel2*x5^2*xcp3 +32*EFUN*e4e2*amel2*x5^2*xcp1 -64*EFUN*e4e2*amel2*x4*x5*xcp3 +64*EFUN*e4e2*amel2*x4*x5*xcp1 -64*EFUN*e4e2*amel2*x3*x5*xcp3 +64*EFUN*e4e2*amel2*x3*x5*xcp1 -64*EFUN*e4e2*amel2*x3*x4*xcp3 +64*EFUN*e4e2*amel2*x3*x4*xcp1 -32*EFUN*e4e2*amel2*x3^2*xcp3 +32*EFUN*e4e2*amel2*x3^2*xcp1 -32*EFUN*e4e2*amel2*x1*x5*xcp3 +32*EFUN*e4e2*amel2*x1*x5*xcp1 -32*EFUN*e4e2*amel2*x1*x3*xcp3 +32*EFUN*e4e2*amel2*x1*x3*xcp1 +32*EFUN*e4e1*amel2*x1*x5*xcp3 -32*EFUN*e4e1*amel2*x1*x5*xcp1 +64*EFUN*e4e1*amel2*x1*x4*xcp3 -64*EFUN*e4e1*amel2*x1*x4*xcp1 +32*EFUN*e4e1*amel2*x1*x3*xcp3 -32*EFUN*e4e1*amel2*x1*x3*xcp1 +32*EFUN*e4e1*amel2*x1^2*xcp3 -32*EFUN*e4e1*amel2*x1^2*xcp1";
 
 fn main() {
-    let poly: MultivariatePolynomial<_, u8> = Atom::parse(SIGMA)
-        .unwrap()
-        .as_view()
-        .to_polynomial(&RationalField::new(), None)
-        .unwrap();
+    let poly: MultivariatePolynomial<_, u8> = Atom::parse(SIGMA).unwrap().to_polynomial(&Q, None);
 
     let (h, _ops, scheme) = poly.optimize_horner_scheme(4000);
-    let mut i = h.to_instr(poly.nvars);
+    let mut i = h.to_instr(poly.nvars());
 
     println!(
         "Number of operations={}, with scheme={:?}",
         BorrowedHornerScheme::from(&h).op_count_cse(),
         scheme,
     );
 
@@ -32,15 +28,15 @@
         if !i.common_pair_elimination() {
             break;
         }
         i.fuse_operations();
     }
 
     let op_count = i.op_count();
-    let o = i.to_output(poly.var_map.as_ref().unwrap().to_vec(), true);
+    let o = i.to_output(poly.variables.as_ref().to_vec(), true);
     let o_f64 = o.convert::<f64>();
 
     println!("Writing output to evaluate.cpp");
     std::fs::write(
         "evaluate.cpp",
         format!(
             "{}",
@@ -59,24 +55,24 @@
     .unwrap();
 
     let mut evaluator = o_f64.evaluator();
 
     println!("Final number of operations={}", op_count);
     println!(
         "Evaluation = {}",
-        evaluator.evaluate_with_input(&(0..poly.nvars).map(|x| x as f64 + 1.).collect::<Vec<_>>())
-            [0]
+        evaluator
+            .evaluate_with_input(&(0..poly.nvars()).map(|x| x as f64 + 1.).collect::<Vec<_>>())[0]
     );
 
     // evaluate with simd
     let o_f64x4 = o.convert::<f64x4>();
     let mut evaluator = o_f64x4.evaluator();
 
     println!(
         "Evaluation with simd = {:?}",
         evaluator.evaluate_with_input(
-            &(0..poly.nvars)
+            &(0..poly.nvars())
                 .map(|x| f64x4::new([x as f64 + 1., x as f64 + 2., x as f64 + 3., x as f64 + 4.]))
                 .collect::<Vec<_>>()
         )[0]
     );
 }
```

### Comparing `symbolica-0.3.0/examples/optimize_multiple.rs` & `symbolica-0.4.0/examples/optimize_multiple.rs`

 * *Files 0% similar despite different names*

```diff
@@ -1,45 +1,41 @@
 use symbolica::{
-    domains::rational::{Rational, RationalField},
+    atom::Atom,
+    domains::rational::{Rational, Q},
     poly::evaluate::{HornerScheme, InstructionSetPrinter},
-    representations::Atom,
 };
 
 use symbolica::poly::polynomial::MultivariatePolynomial;
 
 const SIGMA: &str = "+32*amel2^3*zk^2*xcp3 +32*amel2^3*zk^2*xcp1 -48*amel2^3*zk^2*x1*xcp3 -48*amel2^3*zk^2*x1*xcp1 +32*amel2^4*x5^2*xcp3 +32*amel2^4*x5^2*xcp1 +64*amel2^4*x4*x5*xcp3 -128*amel2^4*x4*x5*xcp2 +64*amel2^4*x4*x5*xcp1 +64*amel2^4*x4^2*xcp3 -128*amel2^4*x4^2*xcp2 +64*amel2^4*x4^2*xcp1 -128*amel2^4*x3*x5*xcp2 +64*amel2^4*x3*x4*xcp3 -128*amel2^4*x3*x4*xcp2 +64*amel2^4*x3*x4*xcp1 +32*amel2^4*x3^2*xcp3 +32*amel2^4*x3^2*xcp1 -64*amel2^4*x1*xcp3 -64*amel2^4*x1*xcp1 +32*amel2^4*x1*x5*xcp3 +32*amel2^4*x1*x5*xcp1 -32*amel2^4*x1*x5^2*xcp3 -32*amel2^4*x1*x5^2*xcp1 +64*amel2^4*x1*x4*xcp3 -192*amel2^4*x1*x4*xcp2 +64*amel2^4*x1*x4*xcp1 -64*amel2^4*x1*x4*x5*xcp3 +128*amel2^4*x1*x4*x5*xcp2 -64*amel2^4*x1*x4*x5*xcp1 -64*amel2^4*x1*x4^2*xcp3 +128*amel2^4*x1*x4^2*xcp2 -64*amel2^4*x1*x4^2*xcp1 +96*amel2^4*x1*x3*xcp3 -192*amel2^4*x1*x3*xcp2 +96*amel2^4*x1*x3*xcp1 +128*amel2^4*x1*x3*x5*xcp2 -64*amel2^4*x1*x3*x4*xcp3 +128*amel2^4*x1*x3*x4*xcp2 -64*amel2^4*x1*x3*x4*xcp1 -32*amel2^4*x1*x3^2*xcp3 -32*amel2^4*x1*x3^2*xcp1 +64*amel2^4*x1^2*xcp3 +64*amel2^4*x1^2*xcp1 -64*amel2^4*x1^2*x5*xcp3 -64*amel2^4*x1^2*x5*xcp1 -64*amel2^4*x1^2*x4*xcp3 -64*amel2^4*x1^2*x4*xcp1 -64*amel2^4*x1^2*x3*xcp3 -64*amel2^4*x1^2*x3*xcp1 -32*amel2^4*x1^3*xcp3 -32*amel2^4*x1^3*xcp1 +48*e2e1*amel2^2*zk^2*xcp3 +32*e2e1*amel2^2*zk^2*xcp2 +48*e2e1*amel2^2*zk^2*xcp1 -48*e2e1*amel2^2*zk^2*x5*xcp3 +64*e2e1*amel2^2*zk^2*x5*xcp2 -48*e2e1*amel2^2*zk^2*x5*xcp1 -96*e2e1*amel2^2*zk^2*x4*xcp3 -96*e2e1*amel2^2*zk^2*x4*xcp1 -64*e2e1*amel2^2*zk^2*x3*xcp2 -48*e2e1*amel2^2*zk^2*x1*xcp3 -48*e2e1*amel2^2*zk^2*x1*xcp1 +256*e2e1*amel2^3*x5*xcp2 +32*e2e1*amel2^3*x5^2*xcp3 -128*e2e1*amel2^3*x5^2*xcp2 +32*e2e1*amel2^3*x5^2*xcp1 -32*e2e1*amel2^3*x5^3*xcp3 -32*e2e1*amel2^3*x5^3*xcp1 -64*e2e1*amel2^3*x4*xcp3 +256*e2e1*amel2^3*x4*xcp2 -64*e2e1*amel2^3*x4*xcp1 +128*e2e1*amel2^3*x4*x5*xcp3 -448*e2e1*amel2^3*x4*x5*xcp2 +128*e2e1*amel2^3*x4*x5*xcp1 -128*e2e1*amel2^3*x4*x5^2*xcp3 +64*e2e1*amel2^3*x4*x5^2*xcp2 -128*e2e1*amel2^3*x4*x5^2*xcp1 +192*e2e1*amel2^3*x4^2*xcp3 -384*e2e1*amel2^3*x4^2*xcp2 +192*e2e1*amel2^3*x4^2*xcp1 -192*e2e1*amel2^3*x4^2*x5*xcp3 +256*e2e1*amel2^3*x4^2*x5*xcp2 -192*e2e1*amel2^3*x4^2*x5*xcp1 -128*e2e1*amel2^3*x4^3*xcp3 +128*e2e1*amel2^3*x4^3*xcp2 -128*e2e1*amel2^3*x4^3*xcp1 +64*e2e1*amel2^3*x3*xcp3 +64*e2e1*amel2^3*x3*xcp1 -448*e2e1*amel2^3*x3*x5*xcp2 +64*e2e1*amel2^3*x3*x5^2*xcp2 +192*e2e1*amel2^3*x3*x4*xcp3 -576*e2e1*amel2^3*x3*x4*xcp2 +192*e2e1*amel2^3*x3*x4*xcp1 -64*e2e1*amel2^3*x3*x4*x5*xcp3 +384*e2e1*amel2^3*x3*x4*x5*xcp2 -64*e2e1*amel2^3*x3*x4*x5*xcp1 -128*e2e1*amel2^3*x3*x4^2*xcp3 +128*e2e1*amel2^3*x3*x4^2*xcp2 -128*e2e1*amel2^3*x3*x4^2*xcp1 +32*e2e1*amel2^3*x3^2*xcp3 -64*e2e1*amel2^3*x3^2*xcp2 +32*e2e1*amel2^3*x3^2*xcp1 -32*e2e1*amel2^3*x3^2*x5*xcp3 +128*e2e1*amel2^3*x3^2*x5*xcp2 -32*e2e1*amel2^3*x3^2*x5*xcp1 -64*e2e1*amel2^3*x3^2*x4*xcp3 -64*e2e1*amel2^3*x3^2*x4*xcp2 -64*e2e1*amel2^3*x3^2*x4*xcp1 -64*e2e1*amel2^3*x3^3*xcp2 -64*e2e1*amel2^3*x1*xcp3 +128*e2e1*amel2^3*x1*xcp2 -64*e2e1*amel2^3*x1*xcp1 +32*e2e1*amel2^3*x1*x5*xcp3 -448*e2e1*amel2^3*x1*x5*xcp2 +32*e2e1*amel2^3*x1*x5*xcp1 -96*e2e1*amel2^3*x1*x5^2*xcp3 +256*e2e1*amel2^3*x1*x5^2*xcp2 -96*e2e1*amel2^3*x1*x5^2*xcp1 +192*e2e1*amel2^3*x1*x4*xcp3 -768*e2e1*amel2^3*x1*x4*xcp2 +192*e2e1*amel2^3*x1*x4*xcp1 -320*e2e1*amel2^3*x1*x4*x5*xcp3 +768*e2e1*amel2^3*x1*x4*x5*xcp2 -320*e2e1*amel2^3*x1*x4*x5*xcp1 -256*e2e1*amel2^3*x1*x4^2*xcp3 +512*e2e1*amel2^3*x1*x4^2*xcp2 -256*e2e1*amel2^3*x1*x4^2*xcp1 +160*e2e1*amel2^3*x1*x3*xcp3 -448*e2e1*amel2^3*x1*x3*xcp2 +160*e2e1*amel2^3*x1*x3*xcp1 -64*e2e1*amel2^3*x1*x3*x5*xcp3 +512*e2e1*amel2^3*x1*x3*x5*xcp2 -64*e2e1*amel2^3*x1*x3*x5*xcp1 -256*e2e1*amel2^3*x1*x3*x4*xcp3 +512*e2e1*amel2^3*x1*x3*x4*xcp2 -256*e2e1*amel2^3*x1*x3*x4*xcp1 -32*e2e1*amel2^3*x1*x3^2*xcp3 -32*e2e1*amel2^3*x1*x3^2*xcp1 +128*e2e1*amel2^3*x1^2*xcp3 -64*e2e1*amel2^3*x1^2*xcp2 +128*e2e1*amel2^3*x1^2*xcp1 -96*e2e1*amel2^3*x1^2*x5*xcp3 +128*e2e1*amel2^3*x1^2*x5*xcp2 -96*e2e1*amel2^3*x1^2*x5*xcp1 -192*e2e1*amel2^3*x1^2*x4*xcp3 +64*e2e1*amel2^3*x1^2*x4*xcp2 -192*e2e1*amel2^3*x1^2*x4*xcp1 -128*e2e1*amel2^3*x1^2*x3*xcp3 -64*e2e1*amel2^3*x1^2*x3*xcp2 -128*e2e1*amel2^3*x1^2*x3*xcp1 -32*e2e1*amel2^3*x1^3*xcp3 -32*e2e1*amel2^3*x1^3*xcp1 +96*e2e1^2*amel2*zk^2*xcp2 -48*e2e1^2*amel2*zk^2*x5*xcp3 -32*e2e1^2*amel2*zk^2*x5*xcp2 -48*e2e1^2*amel2*zk^2*x5*xcp1 -96*e2e1^2*amel2*zk^2*x4*xcp3 -32*e2e1^2*amel2*zk^2*x4*xcp2 -96*e2e1^2*amel2*zk^2*x4*xcp1 -96*e2e1^2*amel2*zk^2*x3*xcp3 +32*e2e1^2*amel2*zk^2*x3*xcp2 -96*e2e1^2*amel2*zk^2*x3*xcp1 -96*e2e1^2*amel2*zk^2*x1*xcp2 +384*e2e1^2*amel2^2*x5*xcp2 +128*e2e1^2*amel2^2*x5^2*xcp2 -32*e2e1^2*amel2^2*x5^3*xcp3 -192*e2e1^2*amel2^2*x5^3*xcp2 -32*e2e1^2*amel2^2*x5^3*xcp1 -64*e2e1^2*amel2^2*x4*xcp3 +512*e2e1^2*amel2^2*x4*xcp2 -64*e2e1^2*amel2^2*x4*xcp1 +64*e2e1^2*amel2^2*x4*x5*xcp3 -256*e2e1^2*amel2^2*x4*x5*xcp2 +64*e2e1^2*amel2^2*x4*x5*xcp1 -192*e2e1^2*amel2^2*x4*x5^2*xcp3 -192*e2e1^2*amel2^2*x4*x5^2*xcp2 -192*e2e1^2*amel2^2*x4*x5^2*xcp1 +128*e2e1^2*amel2^2*x4^2*xcp3 -384*e2e1^2*amel2^2*x4^2*xcp2 +128*e2e1^2*amel2^2*x4^2*xcp1 -384*e2e1^2*amel2^2*x4^2*x5*xcp3 +256*e2e1^2*amel2^2*x4^2*x5*xcp2 -384*e2e1^2*amel2^2*x4^2*x5*xcp1 -256*e2e1^2*amel2^2*x4^3*xcp3 +256*e2e1^2*amel2^2*x4^3*xcp2 -256*e2e1^2*amel2^2*x4^3*xcp1 +64*e2e1^2*amel2^2*x3*xcp3 +128*e2e1^2*amel2^2*x3*xcp2 +64*e2e1^2*amel2^2*x3*xcp1 -64*e2e1^2*amel2^2*x3*x5*xcp3 -640*e2e1^2*amel2^2*x3*x5*xcp2 -64*e2e1^2*amel2^2*x3*x5*xcp1 -64*e2e1^2*amel2^2*x3*x5^2*xcp3 +64*e2e1^2*amel2^2*x3*x5^2*xcp2 -64*e2e1^2*amel2^2*x3*x5^2*xcp1 +64*e2e1^2*amel2^2*x3*x4*xcp3 -896*e2e1^2*amel2^2*x3*x4*xcp2 +64*e2e1^2*amel2^2*x3*x4*xcp1 -256*e2e1^2*amel2^2*x3*x4*x5*xcp3 +768*e2e1^2*amel2^2*x3*x4*x5*xcp2 -256*e2e1^2*amel2^2*x3*x4*x5*xcp1 -384*e2e1^2*amel2^2*x3*x4^2*xcp3 +640*e2e1^2*amel2^2*x3*x4^2*xcp2 -384*e2e1^2*amel2^2*x3*x4^2*xcp1 -256*e2e1^2*amel2^2*x3^2*xcp2 -32*e2e1^2*amel2^2*x3^2*x5*xcp3 +320*e2e1^2*amel2^2*x3^2*x5*xcp2 -32*e2e1^2*amel2^2*x3^2*x5*xcp1 -192*e2e1^2*amel2^2*x3^2*x4*xcp3 +320*e2e1^2*amel2^2*x3^2*x4*xcp2 -192*e2e1^2*amel2^2*x3^2*x4*xcp1 -64*e2e1^2*amel2^2*x3^3*xcp3 +64*e2e1^2*amel2^2*x3^3*xcp2 -64*e2e1^2*amel2^2*x3^3*xcp1 +64*e2e1^2*amel2^2*x1*xcp3 +256*e2e1^2*amel2^2*x1*xcp2 +64*e2e1^2*amel2^2*x1*xcp1 -32*e2e1^2*amel2^2*x1*x5*xcp3 -640*e2e1^2*amel2^2*x1*x5*xcp2 -32*e2e1^2*amel2^2*x1*x5*xcp1 -64*e2e1^2*amel2^2*x1*x5^2*xcp3 +320*e2e1^2*amel2^2*x1*x5^2*xcp2 -64*e2e1^2*amel2^2*x1*x5^2*xcp1 +192*e2e1^2*amel2^2*x1*x4*xcp3 -832*e2e1^2*amel2^2*x1*x4*xcp2 +192*e2e1^2*amel2^2*x1*x4*xcp1 -320*e2e1^2*amel2^2*x1*x4*x5*xcp3 +1024*e2e1^2*amel2^2*x1*x4*x5*xcp2 -320*e2e1^2*amel2^2*x1*x4*x5*xcp1 -320*e2e1^2*amel2^2*x1*x4^2*xcp3 +512*e2e1^2*amel2^2*x1*x4^2*xcp2 -320*e2e1^2*amel2^2*x1*x4^2*xcp1 +32*e2e1^2*amel2^2*x1*x3*xcp3 -576*e2e1^2*amel2^2*x1*x3*xcp2 +32*e2e1^2*amel2^2*x1*x3*xcp1 -256*e2e1^2*amel2^2*x1*x3*x5*xcp3 +896*e2e1^2*amel2^2*x1*x3*x5*xcp2 -256*e2e1^2*amel2^2*x1*x3*x5*xcp1 -448*e2e1^2*amel2^2*x1*x3*x4*xcp3 +768*e2e1^2*amel2^2*x1*x3*x4*xcp2 -448*e2e1^2*amel2^2*x1*x3*x4*xcp1 -128*e2e1^2*amel2^2*x1*x3^2*xcp3 +192*e2e1^2*amel2^2*x1*x3^2*xcp2 -128*e2e1^2*amel2^2*x1*x3^2*xcp1 +32*e2e1^2*amel2^2*x1^2*xcp3 +32*e2e1^2*amel2^2*x1^2*xcp1 -32*e2e1^2*amel2^2*x1^2*x5*xcp3 +64*e2e1^2*amel2^2*x1^2*x5*xcp2 -32*e2e1^2*amel2^2*x1^2*x5*xcp1 -128*e2e1^2*amel2^2*x1^2*x4*xcp3 +64*e2e1^2*amel2^2*x1^2*x4*xcp2 -128*e2e1^2*amel2^2*x1^2*x4*xcp1 -128*e2e1^2*amel2^2*x1^2*x3*xcp3 -64*e2e1^2*amel2^2*x1^2*x3*xcp2 -128*e2e1^2*amel2^2*x1^2*x3*xcp1 -64*e2e1^2*amel2^2*x1^3*xcp2 -32*e2e1^3*zk^2*xcp2 -32*e2e1^3*zk^2*x4*xcp2 +32*e2e1^3*zk^2*x3*xcp2 -64*e2e1^3*amel2*x5*xcp3 +128*e2e1^3*amel2*x5*xcp2 -64*e2e1^3*amel2*x5*xcp1 +32*e2e1^3*amel2*x5^2*xcp3 +320*e2e1^3*amel2*x5^2*xcp2 +32*e2e1^3*amel2*x5^2*xcp1 -256*e2e1^3*amel2*x5^3*xcp2 +384*e2e1^3*amel2*x4*xcp2 +192*e2e1^3*amel2*x4*x5*xcp2 -64*e2e1^3*amel2*x4*x5^2*xcp3 -512*e2e1^3*amel2*x4*x5^2*xcp2 -64*e2e1^3*amel2*x4*x5^2*xcp1 -256*e2e1^3*amel2*x4^2*xcp2 -192*e2e1^3*amel2*x4^2*x5*xcp3 -128*e2e1^3*amel2*x4^2*x5*xcp2 -192*e2e1^3*amel2*x4^2*x5*xcp1 -128*e2e1^3*amel2*x4^3*xcp3 +128*e2e1^3*amel2*x4^3*xcp2 -128*e2e1^3*amel2*x4^3*xcp1 +128*e2e1^3*amel2*x3*xcp2 -64*e2e1^3*amel2*x3*x5*xcp2 -256*e2e1^3*amel2*x3*x5^2*xcp2 -64*e2e1^3*amel2*x3*x4*xcp3 -704*e2e1^3*amel2*x3*x4*xcp2 -64*e2e1^3*amel2*x3*x4*xcp1 -192*e2e1^3*amel2*x3*x4*x5*xcp3 +256*e2e1^3*amel2*x3*x4*x5*xcp2 -192*e2e1^3*amel2*x3*x4*x5*xcp1 -256*e2e1^3*amel2*x3*x4^2*xcp3 +640*e2e1^3*amel2*x3*x4^2*xcp2 -256*e2e1^3*amel2*x3*x4^2*xcp1 -32*e2e1^3*amel2*x3^2*xcp3 -256*e2e1^3*amel2*x3^2*xcp2 -32*e2e1^3*amel2*x3^2*xcp1 +128*e2e1^3*amel2*x3^2*x5*xcp2 -128*e2e1^3*amel2*x3^2*x4*xcp3 +512*e2e1^3*amel2*x3^2*x4*xcp2 -128*e2e1^3*amel2*x3^2*x4*xcp1 +128*e2e1^3*amel2*x3^3*xcp2 +256*e2e1^3*amel2*x1*xcp2 +32*e2e1^3*amel2*x1*x5*xcp3 -576*e2e1^3*amel2*x1*x5*xcp2 +32*e2e1^3*amel2*x1*x5*xcp1 +256*e2e1^3*amel2*x1*x5^2*xcp2 +64*e2e1^3*amel2*x1*x4*xcp3 -256*e2e1^3*amel2*x1*x4*xcp2 +64*e2e1^3*amel2*x1*x4*xcp1 -64*e2e1^3*amel2*x1*x4*x5*xcp3 +384*e2e1^3*amel2*x1*x4*x5*xcp2 -64*e2e1^3*amel2*x1*x4*x5*xcp1 -128*e2e1^3*amel2*x1*x4^2*xcp3 +128*e2e1^3*amel2*x1*x4^2*xcp2 -128*e2e1^3*amel2*x1*x4^2*xcp1 +32*e2e1^3*amel2*x1*x3*xcp3 -320*e2e1^3*amel2*x1*x3*xcp2 +32*e2e1^3*amel2*x1*x3*xcp1 -64*e2e1^3*amel2*x1*x3*x5*xcp3 +512*e2e1^3*amel2*x1*x3*x5*xcp2 -64*e2e1^3*amel2*x1*x3*x5*xcp1 -256*e2e1^3*amel2*x1*x3*x4*xcp3 +384*e2e1^3*amel2*x1*x3*x4*xcp2 -256*e2e1^3*amel2*x1*x3*x4*xcp1 -128*e2e1^3*amel2*x1*x3^2*xcp3 +256*e2e1^3*amel2*x1*x3^2*xcp2 -128*e2e1^3*amel2*x1*x3^2*xcp1 -128*e2e1^3*amel2*x1^2*xcp2 +128*e2e1^3*amel2*x1^2*x5*xcp2 -128*e2e1^4*x5*xcp2 +256*e2e1^4*x5^2*xcp2 -128*e2e1^4*x5^3*xcp2 +128*e2e1^4*x4*xcp2 +128*e2e1^4*x4*x5*xcp2 -256*e2e1^4*x4*x5^2*xcp2 -128*e2e1^4*x4^2*xcp2 -128*e2e1^4*x4^2*x5*xcp2 +256*e2e1^4*x3*x5*xcp2 -256*e2e1^4*x3*x5^2*xcp2 -256*e2e1^4*x3*x4*xcp2 -128*e2e1^4*x3*x4*x5*xcp2 +128*e2e1^4*x3*x4^2*xcp2 -128*e2e1^4*x3^2*x5*xcp2 +128*e2e1^4*x3^2*x4*xcp2 -48*e3e2*amel2^2*zk^2*xcp3 -32*e3e2*amel2^2*zk^2*xcp2 -48*e3e2*amel2^2*zk^2*xcp1 +48*e3e2*amel2^2*zk^2*x5*xcp3 -64*e3e2*amel2^2*zk^2*x5*xcp2 +48*e3e2*amel2^2*zk^2*x5*xcp1 +96*e3e2*amel2^2*zk^2*x4*xcp3 +96*e3e2*amel2^2*zk^2*x4*xcp1 +64*e3e2*amel2^2*zk^2*x3*xcp2 +48*e3e2*amel2^2*zk^2*x1*xcp3 +48*e3e2*amel2^2*zk^2*x1*xcp1 -256*e3e2*amel2^3*x5*xcp2 -32*e3e2*amel2^3*x5^2*xcp3 +128*e3e2*amel2^3*x5^2*xcp2 -32*e3e2*amel2^3*x5^2*xcp1 +32*e3e2*amel2^3*x5^3*xcp3 +32*e3e2*amel2^3*x5^3*xcp1 +64*e3e2*amel2^3*x4*xcp3 -256*e3e2*amel2^3*x4*xcp2 +64*e3e2*amel2^3*x4*xcp1 -128*e3e2*amel2^3*x4*x5*xcp3 +448*e3e2*amel2^3*x4*x5*xcp2 -128*e3e2*amel2^3*x4*x5*xcp1 +128*e3e2*amel2^3*x4*x5^2*xcp3 -64*e3e2*amel2^3*x4*x5^2*xcp2 +128*e3e2*amel2^3*x4*x5^2*xcp1 -192*e3e2*amel2^3*x4^2*xcp3 +384*e3e2*amel2^3*x4^2*xcp2 -192*e3e2*amel2^3*x4^2*xcp1 +192*e3e2*amel2^3*x4^2*x5*xcp3 -256*e3e2*amel2^3*x4^2*x5*xcp2 +192*e3e2*amel2^3*x4^2*x5*xcp1 +128*e3e2*amel2^3*x4^3*xcp3 -128*e3e2*amel2^3*x4^3*xcp2 +128*e3e2*amel2^3*x4^3*xcp1 -64*e3e2*amel2^3*x3*xcp3 -64*e3e2*amel2^3*x3*xcp1 +448*e3e2*amel2^3*x3*x5*xcp2 -64*e3e2*amel2^3*x3*x5^2*xcp2 -192*e3e2*amel2^3*x3*x4*xcp3 +576*e3e2*amel2^3*x3*x4*xcp2 -192*e3e2*amel2^3*x3*x4*xcp1 +64*e3e2*amel2^3*x3*x4*x5*xcp3 -384*e3e2*amel2^3*x3*x4*x5*xcp2 +64*e3e2*amel2^3*x3*x4*x5*xcp1 +128*e3e2*amel2^3*x3*x4^2*xcp3 -128*e3e2*amel2^3*x3*x4^2*xcp2 +128*e3e2*amel2^3*x3*x4^2*xcp1 -32*e3e2*amel2^3*x3^2*xcp3 +64*e3e2*amel2^3*x3^2*xcp2 -32*e3e2*amel2^3*x3^2*xcp1 +32*e3e2*amel2^3*x3^2*x5*xcp3 -128*e3e2*amel2^3*x3^2*x5*xcp2 +32*e3e2*amel2^3*x3^2*x5*xcp1 +64*e3e2*amel2^3*x3^2*x4*xcp3 +64*e3e2*amel2^3*x3^2*x4*xcp2 +64*e3e2*amel2^3*x3^2*x4*xcp1 +64*e3e2*amel2^3*x3^3*xcp2 -128*e3e2*amel2^3*x1*xcp2 -32*e3e2*amel2^3*x1*x5*xcp3 +448*e3e2*amel2^3*x1*x5*xcp2 -32*e3e2*amel2^3*x1*x5*xcp1 +96*e3e2*amel2^3*x1*x5^2*xcp3 -256*e3e2*amel2^3*x1*x5^2*xcp2 +96*e3e2*amel2^3*x1*x5^2*xcp1 -128*e3e2*amel2^3*x1*x4*xcp3 +768*e3e2*amel2^3*x1*x4*xcp2 -128*e3e2*amel2^3*x1*x4*xcp1 +320*e3e2*amel2^3*x1*x4*x5*xcp3 -768*e3e2*amel2^3*x1*x4*x5*xcp2 +320*e3e2*amel2^3*x1*x4*x5*xcp1 +256*e3e2*amel2^3*x1*x4^2*xcp3 -512*e3e2*amel2^3*x1*x4^2*xcp2 +256*e3e2*amel2^3*x1*x4^2*xcp1 -96*e3e2*amel2^3*x1*x3*xcp3 +448*e3e2*amel2^3*x1*x3*xcp2 -96*e3e2*amel2^3*x1*x3*xcp1 +64*e3e2*amel2^3*x1*x3*x5*xcp3 -512*e3e2*amel2^3*x1*x3*x5*xcp2 +64*e3e2*amel2^3*x1*x3*x5*xcp1 +256*e3e2*amel2^3*x1*x3*x4*xcp3 -512*e3e2*amel2^3*x1*x3*x4*xcp2 +256*e3e2*amel2^3*x1*x3*x4*xcp1 +32*e3e2*amel2^3*x1*x3^2*xcp3 +32*e3e2*amel2^3*x1*x3^2*xcp1 -64*e3e2*amel2^3*x1^2*xcp3 +64*e3e2*amel2^3*x1^2*xcp2 -64*e3e2*amel2^3*x1^2*xcp1 +96*e3e2*amel2^3*x1^2*x5*xcp3 -128*e3e2*amel2^3*x1^2*x5*xcp2 +96*e3e2*amel2^3*x1^2*x5*xcp1 +128*e3e2*amel2^3*x1^2*x4*xcp3 -64*e3e2*amel2^3*x1^2*x4*xcp2 +128*e3e2*amel2^3*x1^2*x4*xcp1 +64*e3e2*amel2^3*x1^2*x3*xcp3 +64*e3e2*amel2^3*x1^2*x3*xcp2 +64*e3e2*amel2^3*x1^2*x3*xcp1 +32*e3e2*amel2^3*x1^3*xcp3 +32*e3e2*amel2^3*x1^3*xcp1 -16*e3e2*e2e1*amel2*zk^2*xcp3 -64*e3e2*e2e1*amel2*zk^2*xcp2 -16*e3e2*e2e1*amel2*zk^2*xcp1 +96*e3e2*e2e1*amel2*zk^2*x5*xcp3 +96*e3e2*e2e1*amel2*zk^2*x5*xcp1 +144*e3e2*e2e1*amel2*zk^2*x4*xcp3 +144*e3e2*e2e1*amel2*zk^2*x4*xcp1 +144*e3e2*e2e1*amel2*zk^2*x3*xcp3 -64*e3e2*e2e1*amel2*zk^2*x3*xcp2 +144*e3e2*e2e1*amel2*zk^2*x3*xcp1 +64*e3e2*e2e1*amel2*zk^2*x1*xcp2 -512*e3e2*e2e1*amel2^2*x5*xcp2 -128*e3e2*e2e1*amel2^2*x5^2*xcp2 +64*e3e2*e2e1*amel2^2*x5^3*xcp3 +256*e3e2*e2e1*amel2^2*x5^3*xcp2 +64*e3e2*e2e1*amel2^2*x5^3*xcp1 +64*e3e2*e2e1*amel2^2*x4*xcp3 -768*e3e2*e2e1*amel2^2*x4*xcp2 +64*e3e2*e2e1*amel2^2*x4*xcp1 -192*e3e2*e2e1*amel2^2*x4*x5*xcp3 +768*e3e2*e2e1*amel2^2*x4*x5*xcp2 -192*e3e2*e2e1*amel2^2*x4*x5*xcp1 +352*e3e2*e2e1*amel2^2*x4*x5^2*xcp3 +352*e3e2*e2e1*amel2^2*x4*x5^2*xcp1 -320*e3e2*e2e1*amel2^2*x4^2*xcp3 +896*e3e2*e2e1*amel2^2*x4^2*xcp2 -320*e3e2*e2e1*amel2^2*x4^2*xcp1 +704*e3e2*e2e1*amel2^2*x4^2*x5*xcp3 -768*e3e2*e2e1*amel2^2*x4^2*x5*xcp2 +704*e3e2*e2e1*amel2^2*x4^2*x5*xcp1 +448*e3e2*e2e1*amel2^2*x4^3*xcp3 -512*e3e2*e2e1*amel2^2*x4^3*xcp2 +448*e3e2*e2e1*amel2^2*x4^3*xcp1 -64*e3e2*e2e1*amel2^2*x3*xcp3 -256*e3e2*e2e1*amel2^2*x3*xcp2 -64*e3e2*e2e1*amel2^2*x3*xcp1 +64*e3e2*e2e1*amel2^2*x3*x5*xcp3 +1024*e3e2*e2e1*amel2^2*x3*x5*xcp2 +64*e3e2*e2e1*amel2^2*x3*x5*xcp1 +96*e3e2*e2e1*amel2^2*x3*x5^2*xcp3 -128*e3e2*e2e1*amel2^2*x3*x5^2*xcp2 +96*e3e2*e2e1*amel2^2*x3*x5^2*xcp1 -192*e3e2*e2e1*amel2^2*x3*x4*xcp3 +1536*e3e2*e2e1*amel2^2*x3*x4*xcp2 -192*e3e2*e2e1*amel2^2*x3*x4*xcp1 +448*e3e2*e2e1*amel2^2*x3*x4*x5*xcp3 -1280*e3e2*e2e1*amel2^2*x3*x4*x5*xcp2 +448*e3e2*e2e1*amel2^2*x3*x4*x5*xcp1 +640*e3e2*e2e1*amel2^2*x3*x4^2*xcp3 -1024*e3e2*e2e1*amel2^2*x3*x4^2*xcp2 +640*e3e2*e2e1*amel2^2*x3*x4^2*xcp1 +512*e3e2*e2e1*amel2^2*x3^2*xcp2 +64*e3e2*e2e1*amel2^2*x3^2*x5*xcp3 -512*e3e2*e2e1*amel2^2*x3^2*x5*xcp2 +64*e3e2*e2e1*amel2^2*x3^2*x5*xcp1 +288*e3e2*e2e1*amel2^2*x3^2*x4*xcp3 -512*e3e2*e2e1*amel2^2*x3^2*x4*xcp2 +288*e3e2*e2e1*amel2^2*x3^2*x4*xcp1 +96*e3e2*e2e1*amel2^2*x3^3*xcp3 -128*e3e2*e2e1*amel2^2*x3^3*xcp2 +96*e3e2*e2e1*amel2^2*x3^3*xcp1 -128*e3e2*e2e1*amel2^2*x1*xcp3 -384*e3e2*e2e1*amel2^2*x1*xcp2 -128*e3e2*e2e1*amel2^2*x1*xcp1 +32*e3e2*e2e1*amel2^2*x1*x5*xcp3 +1216*e3e2*e2e1*amel2^2*x1*x5*xcp2 +32*e3e2*e2e1*amel2^2*x1*x5*xcp1 +128*e3e2*e2e1*amel2^2*x1*x5^2*xcp3 -576*e3e2*e2e1*amel2^2*x1*x5^2*xcp2 +128*e3e2*e2e1*amel2^2*x1*x5^2*xcp1 -192*e3e2*e2e1*amel2^2*x1*x4*xcp3 +1856*e3e2*e2e1*amel2^2*x1*x4*xcp2 -192*e3e2*e2e1*amel2^2*x1*x4*xcp1 +512*e3e2*e2e1*amel2^2*x1*x4*x5*xcp3 -1920*e3e2*e2e1*amel2^2*x1*x4*x5*xcp2 +512*e3e2*e2e1*amel2^2*x1*x4*x5*xcp1 +448*e3e2*e2e1*amel2^2*x1*x4^2*xcp3 -1152*e3e2*e2e1*amel2^2*x1*x4^2*xcp2 +448*e3e2*e2e1*amel2^2*x1*x4^2*xcp1 -32*e3e2*e2e1*amel2^2*x1*x3*xcp3 +1280*e3e2*e2e1*amel2^2*x1*x3*xcp2 -32*e3e2*e2e1*amel2^2*x1*x3*xcp1 +384*e3e2*e2e1*amel2^2*x1*x3*x5*xcp3 -1536*e3e2*e2e1*amel2^2*x1*x3*x5*xcp2 +384*e3e2*e2e1*amel2^2*x1*x3*x5*xcp1 +640*e3e2*e2e1*amel2^2*x1*x3*x4*xcp3 -1664*e3e2*e2e1*amel2^2*x1*x3*x4*xcp2 +640*e3e2*e2e1*amel2^2*x1*x3*x4*xcp1 +192*e3e2*e2e1*amel2^2*x1*x3^2*xcp3 -576*e3e2*e2e1*amel2^2*x1*x3^2*xcp2 +192*e3e2*e2e1*amel2^2*x1*x3^2*xcp1 -32*e3e2*e2e1*amel2^2*x1^2*xcp3 +64*e3e2*e2e1*amel2^2*x1^2*xcp2 -32*e3e2*e2e1*amel2^2*x1^2*xcp1 +64*e3e2*e2e1*amel2^2*x1^2*x5*xcp3 -128*e3e2*e2e1*amel2^2*x1^2*x5*xcp2 +64*e3e2*e2e1*amel2^2*x1^2*x5*xcp1 +160*e3e2*e2e1*amel2^2*x1^2*x4*xcp3 -128*e3e2*e2e1*amel2^2*x1^2*x4*xcp2 +160*e3e2*e2e1*amel2^2*x1^2*x4*xcp1 +160*e3e2*e2e1*amel2^2*x1^2*x3*xcp3 +160*e3e2*e2e1*amel2^2*x1^2*x3*xcp1 +64*e3e2*e2e1*amel2^2*x1^3*xcp2 +64*e3e2*e2e1^2*zk^2*xcp2 +64*e3e2*e2e1^2*zk^2*x4*xcp2 -64*e3e2*e2e1^2*zk^2*x3*xcp2 +128*e3e2*e2e1^2*amel2*x5*xcp3 -256*e3e2*e2e1^2*amel2*x5*xcp2 +128*e3e2*e2e1^2*amel2*x5*xcp1 -64*e3e2*e2e1^2*amel2*x5^2*xcp3 -640*e3e2*e2e1^2*amel2*x5^2*xcp2 -64*e3e2*e2e1^2*amel2*x5^2*xcp1 +512*e3e2*e2e1^2*amel2*x5^3*xcp2 -896*e3e2*e2e1^2*amel2*x4*xcp2 -64*e3e2*e2e1^2*amel2*x4*x5*xcp3 -128*e3e2*e2e1^2*amel2*x4*x5*xcp2 -64*e3e2*e2e1^2*amel2*x4*x5*xcp1 +192*e3e2*e2e1^2*amel2*x4*x5^2*xcp3 +896*e3e2*e2e1^2*amel2*x4*x5^2*xcp2 +192*e3e2*e2e1^2*amel2*x4*x5^2*xcp1 -64*e3e2*e2e1^2*amel2*x4^2*xcp3 +768*e3e2*e2e1^2*amel2*x4^2*xcp2 -64*e3e2*e2e1^2*amel2*x4^2*xcp1 +512*e3e2*e2e1^2*amel2*x4^2*x5*xcp3 +512*e3e2*e2e1^2*amel2*x4^2*x5*xcp1 +320*e3e2*e2e1^2*amel2*x4^3*xcp3 -384*e3e2*e2e1^2*amel2*x4^3*xcp2 +320*e3e2*e2e1^2*amel2*x4^3*xcp1 -256*e3e2*e2e1^2*amel2*x3*xcp2 +128*e3e2*e2e1^2*amel2*x3*x5*xcp2 +512*e3e2*e2e1^2*amel2*x3*x5^2*xcp2 +64*e3e2*e2e1^2*amel2*x3*x4*xcp3 +1664*e3e2*e2e1^2*amel2*x3*x4*xcp2 +64*e3e2*e2e1^2*amel2*x3*x4*xcp1 +512*e3e2*e2e1^2*amel2*x3*x4*x5*xcp3 -768*e3e2*e2e1^2*amel2*x3*x4*x5*xcp2 +512*e3e2*e2e1^2*amel2*x3*x4*x5*xcp1 +640*e3e2*e2e1^2*amel2*x3*x4^2*xcp3 -1536*e3e2*e2e1^2*amel2*x3*x4^2*xcp2 +640*e3e2*e2e1^2*amel2*x3*x4^2*xcp1 +64*e3e2*e2e1^2*amel2*x3^2*xcp3 +512*e3e2*e2e1^2*amel2*x3^2*xcp2 +64*e3e2*e2e1^2*amel2*x3^2*xcp1 -256*e3e2*e2e1^2*amel2*x3^2*x5*xcp2 +320*e3e2*e2e1^2*amel2*x3^2*x4*xcp3 -1152*e3e2*e2e1^2*amel2*x3^2*x4*xcp2 +320*e3e2*e2e1^2*amel2*x3^2*x4*xcp1 -256*e3e2*e2e1^2*amel2*x3^3*xcp2 -640*e3e2*e2e1^2*amel2*x1*xcp2 -64*e3e2*e2e1^2*amel2*x1*x5*xcp3 +1408*e3e2*e2e1^2*amel2*x1*x5*xcp2 -64*e3e2*e2e1^2*amel2*x1*x5*xcp1 -640*e3e2*e2e1^2*amel2*x1*x5^2*xcp2 -128*e3e2*e2e1^2*amel2*x1*x4*xcp3 +1152*e3e2*e2e1^2*amel2*x1*x4*xcp2 -128*e3e2*e2e1^2*amel2*x1*x4*xcp1 +128*e3e2*e2e1^2*amel2*x1*x4*x5*xcp3 -1152*e3e2*e2e1^2*amel2*x1*x4*x5*xcp2 +128*e3e2*e2e1^2*amel2*x1*x4*x5*xcp1 +192*e3e2*e2e1^2*amel2*x1*x4^2*xcp3 -512*e3e2*e2e1^2*amel2*x1*x4^2*xcp2 +192*e3e2*e2e1^2*amel2*x1*x4^2*xcp1 -64*e3e2*e2e1^2*amel2*x1*x3*xcp3 +1152*e3e2*e2e1^2*amel2*x1*x3*xcp2 -64*e3e2*e2e1^2*amel2*x1*x3*xcp1 +128*e3e2*e2e1^2*amel2*x1*x3*x5*xcp3 -1280*e3e2*e2e1^2*amel2*x1*x3*x5*xcp2 +128*e3e2*e2e1^2*amel2*x1*x3*x5*xcp1 +384*e3e2*e2e1^2*amel2*x1*x3*x4*xcp3 -1152*e3e2*e2e1^2*amel2*x1*x3*x4*xcp2 +384*e3e2*e2e1^2*amel2*x1*x3*x4*xcp1 +192*e3e2*e2e1^2*amel2*x1*x3^2*xcp3 -640*e3e2*e2e1^2*amel2*x1*x3^2*xcp2 +192*e3e2*e2e1^2*amel2*x1*x3^2*xcp1 +256*e3e2*e2e1^2*amel2*x1^2*xcp2 -256*e3e2*e2e1^2*amel2*x1^2*x5*xcp2 -128*e3e2*e2e1^2*amel2*x1^2*x4*xcp2 -128*e3e2*e2e1^2*amel2*x1^2*x3*xcp2 +384*e3e2*e2e1^3*x5*xcp2 -768*e3e2*e2e1^3*x5^2*xcp2 +384*e3e2*e2e1^3*x5^3*xcp2 -384*e3e2*e2e1^3*x4*xcp2 -384*e3e2*e2e1^3*x4*x5*xcp2 +768*e3e2*e2e1^3*x4*x5^2*xcp2 +384*e3e2*e2e1^3*x4^2*xcp2 +384*e3e2*e2e1^3*x4^2*x5*xcp2 -768*e3e2*e2e1^3*x3*x5*xcp2 +768*e3e2*e2e1^3*x3*x5^2*xcp2 +768*e3e2*e2e1^3*x3*x4*xcp2 +384*e3e2*e2e1^3*x3*x4*x5*xcp2 -384*e3e2*e2e1^3*x3*x4^2*xcp2 +384*e3e2*e2e1^3*x3^2*x5*xcp2 -384*e3e2*e2e1^3*x3^2*x4*xcp2 +16*e3e2^2*amel2*zk^2*xcp3 -32*e3e2^2*amel2*zk^2*xcp2 +16*e3e2^2*amel2*zk^2*xcp1 -48*e3e2^2*amel2*zk^2*x5*xcp3 +32*e3e2^2*amel2*zk^2*x5*xcp2 -48*e3e2^2*amel2*zk^2*x5*xcp1 -48*e3e2^2*amel2*zk^2*x4*xcp3 +32*e3e2^2*amel2*zk^2*x4*xcp2 -48*e3e2^2*amel2*zk^2*x4*xcp1 -48*e3e2^2*amel2*zk^2*x3*xcp3 +32*e3e2^2*amel2*zk^2*x3*xcp2 -48*e3e2^2*amel2*zk^2*x3*xcp1 +32*e3e2^2*amel2*zk^2*x1*xcp2 +128*e3e2^2*amel2^2*x5*xcp2 -32*e3e2^2*amel2^2*x5^3*xcp3 -64*e3e2^2*amel2^2*x5^3*xcp2 -32*e3e2^2*amel2^2*x5^3*xcp1 +256*e3e2^2*amel2^2*x4*xcp2 +128*e3e2^2*amel2^2*x4*x5*xcp3 -512*e3e2^2*amel2^2*x4*x5*xcp2 +128*e3e2^2*amel2^2*x4*x5*xcp1 -160*e3e2^2*amel2^2*x4*x5^2*xcp3 +192*e3e2^2*amel2^2*x4*x5^2*xcp2 -160*e3e2^2*amel2^2*x4*x5^2*xcp1 +192*e3e2^2*amel2^2*x4^2*xcp3 -512*e3e2^2*amel2^2*x4^2*xcp2 +192*e3e2^2*amel2^2*x4^2*xcp1 -320*e3e2^2*amel2^2*x4^2*x5*xcp3 +512*e3e2^2*amel2^2*x4^2*x5*xcp2 -320*e3e2^2*amel2^2*x4^2*x5*xcp1 -192*e3e2^2*amel2^2*x4^3*xcp3 +256*e3e2^2*amel2^2*x4^3*xcp2 -192*e3e2^2*amel2^2*x4^3*xcp1 +128*e3e2^2*amel2^2*x3*xcp2 -384*e3e2^2*amel2^2*x3*x5*xcp2 -32*e3e2^2*amel2^2*x3*x5^2*xcp3 +64*e3e2^2*amel2^2*x3*x5^2*xcp2 -32*e3e2^2*amel2^2*x3*x5^2*xcp1 +128*e3e2^2*amel2^2*x3*x4*xcp3 -640*e3e2^2*amel2^2*x3*x4*xcp2 +128*e3e2^2*amel2^2*x3*x4*xcp1 -192*e3e2^2*amel2^2*x3*x4*x5*xcp3 +512*e3e2^2*amel2^2*x3*x4*x5*xcp2 -192*e3e2^2*amel2^2*x3*x4*x5*xcp1 -256*e3e2^2*amel2^2*x3*x4^2*xcp3 +384*e3e2^2*amel2^2*x3*x4^2*xcp2 -256*e3e2^2*amel2^2*x3*x4^2*xcp1 -256*e3e2^2*amel2^2*x3^2*xcp2 -32*e3e2^2*amel2^2*x3^2*x5*xcp3 +192*e3e2^2*amel2^2*x3^2*x5*xcp2 -32*e3e2^2*amel2^2*x3^2*x5*xcp1 -96*e3e2^2*amel2^2*x3^2*x4*xcp3 +192*e3e2^2*amel2^2*x3^2*x4*xcp2 -96*e3e2^2*amel2^2*x3^2*x4*xcp1 -32*e3e2^2*amel2^2*x3^3*xcp3 +64*e3e2^2*amel2^2*x3^3*xcp2 -32*e3e2^2*amel2^2*x3^3*xcp1 +64*e3e2^2*amel2^2*x1*xcp3 +128*e3e2^2*amel2^2*x1*xcp2 +64*e3e2^2*amel2^2*x1*xcp1 -576*e3e2^2*amel2^2*x1*x5*xcp2 -64*e3e2^2*amel2^2*x1*x5^2*xcp3 +256*e3e2^2*amel2^2*x1*x5^2*xcp2 -64*e3e2^2*amel2^2*x1*x5^2*xcp1 -1024*e3e2^2*amel2^2*x1*x4*xcp2 -192*e3e2^2*amel2^2*x1*x4*x5*xcp3 +896*e3e2^2*amel2^2*x1*x4*x5*xcp2 -192*e3e2^2*amel2^2*x1*x4*x5*xcp1 -128*e3e2^2*amel2^2*x1*x4^2*xcp3 +640*e3e2^2*amel2^2*x1*x4^2*xcp2 -128*e3e2^2*amel2^2*x1*x4^2*xcp1 -704*e3e2^2*amel2^2*x1*x3*xcp2 -128*e3e2^2*amel2^2*x1*x3*x5*xcp3 +640*e3e2^2*amel2^2*x1*x3*x5*xcp2 -128*e3e2^2*amel2^2*x1*x3*x5*xcp1 -192*e3e2^2*amel2^2*x1*x3*x4*xcp3 +896*e3e2^2*amel2^2*x1*x3*x4*xcp2 -192*e3e2^2*amel2^2*x1*x3*x4*xcp1 -64*e3e2^2*amel2^2*x1*x3^2*xcp3 +384*e3e2^2*amel2^2*x1*x3^2*xcp2 -64*e3e2^2*amel2^2*x1*x3^2*xcp1 -64*e3e2^2*amel2^2*x1^2*xcp2 -32*e3e2^2*amel2^2*x1^2*x5*xcp3 +64*e3e2^2*amel2^2*x1^2*x5*xcp2 -32*e3e2^2*amel2^2*x1^2*x5*xcp1 -32*e3e2^2*amel2^2*x1^2*x4*xcp3 +64*e3e2^2*amel2^2*x1^2*x4*xcp2 -32*e3e2^2*amel2^2*x1^2*x4*xcp1 -32*e3e2^2*amel2^2*x1^2*x3*xcp3 +64*e3e2^2*amel2^2*x1^2*x3*xcp2 -32*e3e2^2*amel2^2*x1^2*x3*xcp1 -32*e3e2^2*e2e1*zk^2*xcp2 -32*e3e2^2*e2e1*zk^2*x4*xcp2 +32*e3e2^2*e2e1*zk^2*x3*xcp2 -64*e3e2^2*e2e1*amel2*x5*xcp3 +128*e3e2^2*e2e1*amel2*x5*xcp2 -64*e3e2^2*e2e1*amel2*x5*xcp1 +32*e3e2^2*e2e1*amel2*x5^2*xcp3 +320*e3e2^2*e2e1*amel2*x5^2*xcp2 +32*e3e2^2*e2e1*amel2*x5^2*xcp1 -256*e3e2^2*e2e1*amel2*x5^3*xcp2 +640*e3e2^2*e2e1*amel2*x4*xcp2 +128*e3e2^2*e2e1*amel2*x4*x5*xcp3 -320*e3e2^2*e2e1*amel2*x4*x5*xcp2 +128*e3e2^2*e2e1*amel2*x4*x5*xcp1 -192*e3e2^2*e2e1*amel2*x4*x5^2*xcp3 -256*e3e2^2*e2e1*amel2*x4*x5^2*xcp2 -192*e3e2^2*e2e1*amel2*x4*x5^2*xcp1 +128*e3e2^2*e2e1*amel2*x4^2*xcp3 -768*e3e2^2*e2e1*amel2*x4^2*xcp2 +128*e3e2^2*e2e1*amel2*x4^2*xcp1 -448*e3e2^2*e2e1*amel2*x4^2*x5*xcp3 +384*e3e2^2*e2e1*amel2*x4^2*x5*xcp2 -448*e3e2^2*e2e1*amel2*x4^2*x5*xcp1 -256*e3e2^2*e2e1*amel2*x4^3*xcp3 +384*e3e2^2*e2e1*amel2*x4^3*xcp2 -256*e3e2^2*e2e1*amel2*x4^3*xcp1 +128*e3e2^2*e2e1*amel2*x3*xcp2 -64*e3e2^2*e2e1*amel2*x3*x5*xcp2 -256*e3e2^2*e2e1*amel2*x3*x5^2*xcp2 +64*e3e2^2*e2e1*amel2*x3*x4*xcp3 -1216*e3e2^2*e2e1*amel2*x3*x4*xcp2 +64*e3e2^2*e2e1*amel2*x3*x4*xcp1 -448*e3e2^2*e2e1*amel2*x3*x4*x5*xcp3 +768*e3e2^2*e2e1*amel2*x3*x4*x5*xcp2 -448*e3e2^2*e2e1*amel2*x3*x4*x5*xcp1 -512*e3e2^2*e2e1*amel2*x3*x4^2*xcp3 +1152*e3e2^2*e2e1*amel2*x3*x4^2*xcp2 -512*e3e2^2*e2e1*amel2*x3*x4^2*xcp1 -32*e3e2^2*e2e1*amel2*x3^2*xcp3 -256*e3e2^2*e2e1*amel2*x3^2*xcp2 -32*e3e2^2*e2e1*amel2*x3^2*xcp1 +128*e3e2^2*e2e1*amel2*x3^2*x5*xcp2 -256*e3e2^2*e2e1*amel2*x3^2*x4*xcp3 +768*e3e2^2*e2e1*amel2*x3^2*x4*xcp2 -256*e3e2^2*e2e1*amel2*x3^2*x4*xcp1 +128*e3e2^2*e2e1*amel2*x3^3*xcp2 +512*e3e2^2*e2e1*amel2*x1*xcp2 +32*e3e2^2*e2e1*amel2*x1*x5*xcp3 -1088*e3e2^2*e2e1*amel2*x1*x5*xcp2 +32*e3e2^2*e2e1*amel2*x1*x5*xcp1 +512*e3e2^2*e2e1*amel2*x1*x5^2*xcp2 +64*e3e2^2*e2e1*amel2*x1*x4*xcp3 -1280*e3e2^2*e2e1*amel2*x1*x4*xcp2 +64*e3e2^2*e2e1*amel2*x1*x4*xcp1 -64*e3e2^2*e2e1*amel2*x1*x4*x5*xcp3 +1152*e3e2^2*e2e1*amel2*x1*x4*x5*xcp2 -64*e3e2^2*e2e1*amel2*x1*x4*x5*xcp1 -64*e3e2^2*e2e1*amel2*x1*x4^2*xcp3 +640*e3e2^2*e2e1*amel2*x1*x4^2*xcp2 -64*e3e2^2*e2e1*amel2*x1*x4^2*xcp1 +32*e3e2^2*e2e1*amel2*x1*x3*xcp3 -1088*e3e2^2*e2e1*amel2*x1*x3*xcp2 +32*e3e2^2*e2e1*amel2*x1*x3*xcp1 -64*e3e2^2*e2e1*amel2*x1*x3*x5*xcp3 +1024*e3e2^2*e2e1*amel2*x1*x3*x5*xcp2 -64*e3e2^2*e2e1*amel2*x1*x3*x5*xcp1 -128*e3e2^2*e2e1*amel2*x1*x3*x4*xcp3 +1152*e3e2^2*e2e1*amel2*x1*x3*x4*xcp2 -128*e3e2^2*e2e1*amel2*x1*x3*x4*xcp1 -64*e3e2^2*e2e1*amel2*x1*x3^2*xcp3 +512*e3e2^2*e2e1*amel2*x1*x3^2*xcp2 -64*e3e2^2*e2e1*amel2*x1*x3^2*xcp1 -128*e3e2^2*e2e1*amel2*x1^2*xcp2 +128*e3e2^2*e2e1*amel2*x1^2*x5*xcp2 +128*e3e2^2*e2e1*amel2*x1^2*x4*xcp2 +128*e3e2^2*e2e1*amel2*x1^2*x3*xcp2 -384*e3e2^2*e2e1^2*x5*xcp2 +768*e3e2^2*e2e1^2*x5^2*xcp2 -384*e3e2^2*e2e1^2*x5^3*xcp2 +384*e3e2^2*e2e1^2*x4*xcp2 +384*e3e2^2*e2e1^2*x4*x5*xcp2 -768*e3e2^2*e2e1^2*x4*x5^2*xcp2 -384*e3e2^2*e2e1^2*x4^2*xcp2 -384*e3e2^2*e2e1^2*x4^2*x5*xcp2 +768*e3e2^2*e2e1^2*x3*x5*xcp2 -768*e3e2^2*e2e1^2*x3*x5^2*xcp2 -768*e3e2^2*e2e1^2*x3*x4*xcp2 -384*e3e2^2*e2e1^2*x3*x4*x5*xcp2 +384*e3e2^2*e2e1^2*x3*x4^2*xcp2 -384*e3e2^2*e2e1^2*x3^2*x5*xcp2 +384*e3e2^2*e2e1^2*x3^2*x4*xcp2 -128*e3e2^3*amel2*x4*xcp2 -64*e3e2^3*amel2*x4*x5*xcp3 +256*e3e2^3*amel2*x4*x5*xcp2 -64*e3e2^3*amel2*x4*x5*xcp1 +64*e3e2^3*amel2*x4*x5^2*xcp3 -128*e3e2^3*amel2*x4*x5^2*xcp2 +64*e3e2^3*amel2*x4*x5^2*xcp1 -64*e3e2^3*amel2*x4^2*xcp3 +256*e3e2^3*amel2*x4^2*xcp2 -64*e3e2^3*amel2*x4^2*xcp1 +128*e3e2^3*amel2*x4^2*x5*xcp3 -256*e3e2^3*amel2*x4^2*x5*xcp2 +128*e3e2^3*amel2*x4^2*x5*xcp1 +64*e3e2^3*amel2*x4^3*xcp3 -128*e3e2^3*amel2*x4^3*xcp2 +64*e3e2^3*amel2*x4^3*xcp1 -64*e3e2^3*amel2*x3*x4*xcp3 +256*e3e2^3*amel2*x3*x4*xcp2 -64*e3e2^3*amel2*x3*x4*xcp1 +128*e3e2^3*amel2*x3*x4*x5*xcp3 -256*e3e2^3*amel2*x3*x4*x5*xcp2 +128*e3e2^3*amel2*x3*x4*x5*xcp1 +128*e3e2^3*amel2*x3*x4^2*xcp3 -256*e3e2^3*amel2*x3*x4^2*xcp2 +128*e3e2^3*amel2*x3*x4^2*xcp1 +64*e3e2^3*amel2*x3^2*x4*xcp3 -128*e3e2^3*amel2*x3^2*x4*xcp2 +64*e3e2^3*amel2*x3^2*x4*xcp1 -128*e3e2^3*amel2*x1*xcp2 +256*e3e2^3*amel2*x1*x5*xcp2 -128*e3e2^3*amel2*x1*x5^2*xcp2 +384*e3e2^3*amel2*x1*x4*xcp2 -384*e3e2^3*amel2*x1*x4*x5*xcp2 -256*e3e2^3*amel2*x1*x4^2*xcp2 +256*e3e2^3*amel2*x1*x3*xcp2 -256*e3e2^3*amel2*x1*x3*x5*xcp2 -384*e3e2^3*amel2*x1*x3*x4*xcp2 -128*e3e2^3*amel2*x1*x3^2*xcp2 +128*e3e2^3*e2e1*x5*xcp2 -256*e3e2^3*e2e1*x5^2*xcp2 +128*e3e2^3*e2e1*x5^3*xcp2 -128*e3e2^3*e2e1*x4*xcp2 -128*e3e2^3*e2e1*x4*x5*xcp2 +256*e3e2^3*e2e1*x4*x5^2*xcp2 +128*e3e2^3*e2e1*x4^2*xcp2 +128*e3e2^3*e2e1*x4^2*x5*xcp2 -256*e3e2^3*e2e1*x3*x5*xcp2 +256*e3e2^3*e2e1*x3*x5^2*xcp2 +256*e3e2^3*e2e1*x3*x4*xcp2 +128*e3e2^3*e2e1*x3*x4*x5*xcp2 -128*e3e2^3*e2e1*x3*x4^2*xcp2 +128*e3e2^3*e2e1*x3^2*x5*xcp2 -128*e3e2^3*e2e1*x3^2*x4*xcp2 -112*e3e1*amel2^2*zk^2*xcp3 -112*e3e1*amel2^2*zk^2*xcp1 +48*e3e1*amel2^2*zk^2*x5*xcp3 +48*e3e1*amel2^2*zk^2*x5*xcp1 +48*e3e1*amel2^2*zk^2*x4*xcp3 -32*e3e1*amel2^2*zk^2*x4*xcp2 +48*e3e1*amel2^2*zk^2*x4*xcp1 -32*e3e1*amel2^2*zk^2*x3*xcp2 +96*e3e1*amel2^2*zk^2*x1*xcp3 +96*e3e1*amel2^2*zk^2*x1*xcp1 +96*e3e1*amel2^3*x5*xcp3 +96*e3e1*amel2^3*x5*xcp1 -160*e3e1*amel2^3*x5^2*xcp3 -160*e3e1*amel2^3*x5^2*xcp1 +32*e3e1*amel2^3*x5^3*xcp3 +32*e3e1*amel2^3*x5^3*xcp1 +96*e3e1*amel2^3*x4*xcp3 -128*e3e1*amel2^3*x4*xcp2 +96*e3e1*amel2^3*x4*xcp1 -352*e3e1*amel2^3*x4*x5*xcp3 +576*e3e1*amel2^3*x4*x5*xcp2 -352*e3e1*amel2^3*x4*x5*xcp1 +96*e3e1*amel2^3*x4*x5^2*xcp3 -128*e3e1*amel2^3*x4*x5^2*xcp2 +96*e3e1*amel2^3*x4*x5^2*xcp1 -320*e3e1*amel2^3*x4^2*xcp3 +576*e3e1*amel2^3*x4^2*xcp2 -320*e3e1*amel2^3*x4^2*xcp1 +128*e3e1*amel2^3*x4^2*x5*xcp3 -256*e3e1*amel2^3*x4^2*x5*xcp2 +128*e3e1*amel2^3*x4^2*x5*xcp1 +64*e3e1*amel2^3*x4^3*xcp3 -128*e3e1*amel2^3*x4^3*xcp2 +64*e3e1*amel2^3*x4^3*xcp1 -128*e3e1*amel2^3*x3*xcp2 -96*e3e1*amel2^3*x3*x5*xcp3 +576*e3e1*amel2^3*x3*x5*xcp2 -96*e3e1*amel2^3*x3*x5*xcp1 -128*e3e1*amel2^3*x3*x5^2*xcp2 -352*e3e1*amel2^3*x3*x4*xcp3 +704*e3e1*amel2^3*x3*x4*xcp2 -352*e3e1*amel2^3*x3*x4*xcp1 +64*e3e1*amel2^3*x3*x4*x5*xcp3 -256*e3e1*amel2^3*x3*x4*x5*xcp2 +64*e3e1*amel2^3*x3*x4*x5*xcp1 +64*e3e1*amel2^3*x3*x4^2*xcp3 -128*e3e1*amel2^3*x3*x4^2*xcp2 +64*e3e1*amel2^3*x3*x4^2*xcp1 -128*e3e1*amel2^3*x3^2*xcp3 +128*e3e1*amel2^3*x3^2*xcp2 -128*e3e1*amel2^3*x3^2*xcp1 +32*e3e1*amel2^3*x3^2*x5*xcp3 +32*e3e1*amel2^3*x3^2*x5*xcp1 +32*e3e1*amel2^3*x3^2*x4*xcp3 +32*e3e1*amel2^3*x3^2*x4*xcp1 +256*e3e1*amel2^3*x1*xcp3 +256*e3e1*amel2^3*x1*xcp1 -256*e3e1*amel2^3*x1*x5*xcp3 -256*e3e1*amel2^3*x1*x5*xcp1 +192*e3e1*amel2^3*x1*x5^2*xcp3 +192*e3e1*amel2^3*x1*x5^2*xcp1 -352*e3e1*amel2^3*x1*x4*xcp3 +448*e3e1*amel2^3*x1*x4*xcp2 -352*e3e1*amel2^3*x1*x4*xcp1 +384*e3e1*amel2^3*x1*x4*x5*xcp3 -384*e3e1*amel2^3*x1*x4*x5*xcp2 +384*e3e1*amel2^3*x1*x4*x5*xcp1 +256*e3e1*amel2^3*x1*x4^2*xcp3 -384*e3e1*amel2^3*x1*x4^2*xcp2 +256*e3e1*amel2^3*x1*x4^2*xcp1 -352*e3e1*amel2^3*x1*x3*xcp3 +448*e3e1*amel2^3*x1*x3*xcp2 -352*e3e1*amel2^3*x1*x3*xcp1 +128*e3e1*amel2^3*x1*x3*x5*xcp3 -384*e3e1*amel2^3*x1*x3*x5*xcp2 +128*e3e1*amel2^3*x1*x3*x5*xcp1 +256*e3e1*amel2^3*x1*x3*x4*xcp3 -512*e3e1*amel2^3*x1*x3*x4*xcp2 +256*e3e1*amel2^3*x1*x3*x4*xcp1 +64*e3e1*amel2^3*x1*x3^2*xcp3 -128*e3e1*amel2^3*x1*x3^2*xcp2 +64*e3e1*amel2^3*x1*x3^2*xcp1 -224*e3e1*amel2^3*x1^2*xcp3 -224*e3e1*amel2^3*x1^2*xcp1 +224*e3e1*amel2^3*x1^2*x5*xcp3 +224*e3e1*amel2^3*x1^2*x5*xcp1 +224*e3e1*amel2^3*x1^2*x4*xcp3 +224*e3e1*amel2^3*x1^2*x4*xcp1 +192*e3e1*amel2^3*x1^2*x3*xcp3 +192*e3e1*amel2^3*x1^2*x3*xcp1 +64*e3e1*amel2^3*x1^3*xcp3 +64*e3e1*amel2^3*x1^3*xcp1 -16*e3e1*e2e1*amel2*zk^2*xcp3 +96*e3e1*e2e1*amel2*zk^2*xcp2 -16*e3e1*e2e1*amel2*zk^2*xcp1 +48*e3e1*e2e1*amel2*zk^2*x5*xcp3 -192*e3e1*e2e1*amel2*zk^2*x5*xcp2 +48*e3e1*e2e1*amel2*zk^2*x5*xcp1 +96*e3e1*e2e1*amel2*zk^2*x4*xcp3 -224*e3e1*e2e1*amel2*zk^2*x4*xcp2 +96*e3e1*e2e1*amel2*zk^2*x4*xcp1 +48*e3e1*e2e1*amel2*zk^2*x3*xcp3 -160*e3e1*e2e1*amel2*zk^2*x3*xcp2 +48*e3e1*e2e1*amel2*zk^2*x3*xcp1 +64*e3e1*e2e1*amel2^2*xcp3 +256*e3e1*e2e1*amel2^2*xcp2 +64*e3e1*e2e1*amel2^2*xcp1 -32*e3e1*e2e1*amel2^2*x5*xcp3 -1152*e3e1*e2e1*amel2^2*x5*xcp2 -32*e3e1*e2e1*amel2^2*x5*xcp1 -96*e3e1*e2e1*amel2^2*x5^2*xcp3 +896*e3e1*e2e1*amel2^2*x5^2*xcp2 -96*e3e1*e2e1*amel2^2*x5^2*xcp1 +96*e3e1*e2e1*amel2^2*x5^3*xcp3 -256*e3e1*e2e1*amel2^2*x5^3*xcp2 +96*e3e1*e2e1*amel2^2*x5^3*xcp1 +128*e3e1*e2e1*amel2^2*x4*xcp3 -1408*e3e1*e2e1*amel2^2*x4*xcp2 +128*e3e1*e2e1*amel2^2*x4*xcp1 -448*e3e1*e2e1*amel2^2*x4*x5*xcp3 +2496*e3e1*e2e1*amel2^2*x4*x5*xcp2 -448*e3e1*e2e1*amel2^2*x4*x5*xcp1 +448*e3e1*e2e1*amel2^2*x4*x5^2*xcp3 -1024*e3e1*e2e1*amel2^2*x4*x5^2*xcp2 +448*e3e1*e2e1*amel2^2*x4*x5^2*xcp1 -448*e3e1*e2e1*amel2^2*x4^2*xcp3 +1792*e3e1*e2e1*amel2^2*x4^2*xcp2 -448*e3e1*e2e1*amel2^2*x4^2*xcp1 +640*e3e1*e2e1*amel2^2*x4^2*x5*xcp3 -1536*e3e1*e2e1*amel2^2*x4^2*x5*xcp2 +640*e3e1*e2e1*amel2^2*x4^2*x5*xcp1 +320*e3e1*e2e1*amel2^2*x4^3*xcp3 -768*e3e1*e2e1*amel2^2*x4^3*xcp2 +320*e3e1*e2e1*amel2^2*x4^3*xcp1 -160*e3e1*e2e1*amel2^2*x3*xcp3 -768*e3e1*e2e1*amel2^2*x3*xcp2 -160*e3e1*e2e1*amel2^2*x3*xcp1 -64*e3e1*e2e1*amel2^2*x3*x5*xcp3 +1856*e3e1*e2e1*amel2^2*x3*x5*xcp2 -64*e3e1*e2e1*amel2^2*x3*x5*xcp1 +96*e3e1*e2e1*amel2^2*x3*x5^2*xcp3 -512*e3e1*e2e1*amel2^2*x3*x5^2*xcp2 +96*e3e1*e2e1*amel2^2*x3*x5^2*xcp1 -384*e3e1*e2e1*amel2^2*x3*x4*xcp3 +2496*e3e1*e2e1*amel2^2*x3*x4*xcp2 -384*e3e1*e2e1*amel2^2*x3*x4*xcp1 +384*e3e1*e2e1*amel2^2*x3*x4*x5*xcp3 -1664*e3e1*e2e1*amel2^2*x3*x4*x5*xcp2 +384*e3e1*e2e1*amel2^2*x3*x4*x5*xcp1 +384*e3e1*e2e1*amel2^2*x3*x4^2*xcp3 -1280*e3e1*e2e1*amel2^2*x3*x4^2*xcp2 +384*e3e1*e2e1*amel2^2*x3*x4^2*xcp1 -32*e3e1*e2e1*amel2^2*x3^2*xcp3 +704*e3e1*e2e1*amel2^2*x3^2*xcp2 -32*e3e1*e2e1*amel2^2*x3^2*xcp1 +32*e3e1*e2e1*amel2^2*x3^2*x5*xcp3 -384*e3e1*e2e1*amel2^2*x3^2*x5*xcp2 +32*e3e1*e2e1*amel2^2*x3^2*x5*xcp1 +128*e3e1*e2e1*amel2^2*x3^2*x4*xcp3 -640*e3e1*e2e1*amel2^2*x3^2*x4*xcp2 +128*e3e1*e2e1*amel2^2*x3^2*x4*xcp1 +32*e3e1*e2e1*amel2^2*x3^3*xcp3 -128*e3e1*e2e1*amel2^2*x3^3*xcp2 +32*e3e1*e2e1*amel2^2*x3^3*xcp1 +96*e3e1*e2e1*amel2^2*x1*xcp3 -640*e3e1*e2e1*amel2^2*x1*xcp2 +96*e3e1*e2e1*amel2^2*x1*xcp1 -160*e3e1*e2e1*amel2^2*x1*x5*xcp3 +1472*e3e1*e2e1*amel2^2*x1*x5*xcp2 -160*e3e1*e2e1*amel2^2*x1*x5*xcp1 +192*e3e1*e2e1*amel2^2*x1*x5^2*xcp3 -768*e3e1*e2e1*amel2^2*x1*x5^2*xcp2 +192*e3e1*e2e1*amel2^2*x1*x5^2*xcp1 -576*e3e1*e2e1*amel2^2*x1*x4*xcp3 +1920*e3e1*e2e1*amel2^2*x1*x4*xcp2 -576*e3e1*e2e1*amel2^2*x1*x4*xcp1 +704*e3e1*e2e1*amel2^2*x1*x4*x5*xcp3 -1920*e3e1*e2e1*amel2^2*x1*x4*x5*xcp2 +704*e3e1*e2e1*amel2^2*x1*x4*x5*xcp1 +512*e3e1*e2e1*amel2^2*x1*x4^2*xcp3 -1152*e3e1*e2e1*amel2^2*x1*x4^2*xcp2 +512*e3e1*e2e1*amel2^2*x1*x4^2*xcp1 -288*e3e1*e2e1*amel2^2*x1*x3*xcp3 +1344*e3e1*e2e1*amel2^2*x1*x3*xcp2 -288*e3e1*e2e1*amel2^2*x1*x3*xcp1 +320*e3e1*e2e1*amel2^2*x1*x3*x5*xcp3 -1408*e3e1*e2e1*amel2^2*x1*x3*x5*xcp2 +320*e3e1*e2e1*amel2^2*x1*x3*x5*xcp1 +576*e3e1*e2e1*amel2^2*x1*x3*x4*xcp3 -1792*e3e1*e2e1*amel2^2*x1*x3*x4*xcp2 +576*e3e1*e2e1*amel2^2*x1*x3*x4*xcp1 +64*e3e1*e2e1*amel2^2*x1*x3^2*xcp3 -640*e3e1*e2e1*amel2^2*x1*x3^2*xcp2 +64*e3e1*e2e1*amel2^2*x1*x3^2*xcp1 -192*e3e1*e2e1*amel2^2*x1^2*xcp3 +192*e3e1*e2e1*amel2^2*x1^2*xcp2 -192*e3e1*e2e1*amel2^2*x1^2*xcp1 +96*e3e1*e2e1*amel2^2*x1^2*x5*xcp3 -256*e3e1*e2e1*amel2^2*x1^2*x5*xcp2 +96*e3e1*e2e1*amel2^2*x1^2*x5*xcp1 +256*e3e1*e2e1*amel2^2*x1^2*x4*xcp3 -256*e3e1*e2e1*amel2^2*x1^2*x4*xcp2 +256*e3e1*e2e1*amel2^2*x1^2*x4*xcp1 +224*e3e1*e2e1*amel2^2*x1^2*x3*xcp3 -128*e3e1*e2e1*amel2^2*x1^2*x3*xcp2 +224*e3e1*e2e1*amel2^2*x1^2*x3*xcp1 +128*e3e1*e2e1^2*zk^2*xcp2 -64*e3e1*e2e1^2*zk^2*x5*xcp2 -32*e3e1*e2e1^2*zk^2*x4*xcp2 -160*e3e1*e2e1^2*zk^2*x3*xcp2 +32*e3e1*e2e1^2*zk^2*x1*xcp2 +64*e3e1*e2e1^2*amel2*xcp3 +512*e3e1*e2e1^2*amel2*xcp2 +64*e3e1*e2e1^2*amel2*xcp1 -64*e3e1*e2e1^2*amel2*x5*xcp3 -1536*e3e1*e2e1^2*amel2*x5*xcp2 -64*e3e1*e2e1^2*amel2*x5*xcp1 +640*e3e1*e2e1^2*amel2*x5^2*xcp2 +64*e3e1*e2e1^2*amel2*x5^3*xcp3 +64*e3e1*e2e1^2*amel2*x5^3*xcp1 -32*e3e1*e2e1^2*amel2*x4*xcp3 -2048*e3e1*e2e1^2*amel2*x4*xcp2 -32*e3e1*e2e1^2*amel2*x4*xcp1 -32*e3e1*e2e1^2*amel2*x4*x5*xcp3 +2240*e3e1*e2e1^2*amel2*x4*x5*xcp2 -32*e3e1*e2e1^2*amel2*x4*x5*xcp1 +320*e3e1*e2e1^2*amel2*x4*x5^2*xcp3 -512*e3e1*e2e1^2*amel2*x4*x5^2*xcp2 +320*e3e1*e2e1^2*amel2*x4*x5^2*xcp1 -64*e3e1*e2e1^2*amel2*x4^2*xcp3 +1856*e3e1*e2e1^2*amel2*x4^2*xcp2 -64*e3e1*e2e1^2*amel2*x4^2*xcp1 +512*e3e1*e2e1^2*amel2*x4^2*x5*xcp3 -1280*e3e1*e2e1^2*amel2*x4^2*x5*xcp2 +512*e3e1*e2e1^2*amel2*x4^2*x5*xcp1 +256*e3e1*e2e1^2*amel2*x4^3*xcp3 -768*e3e1*e2e1^2*amel2*x4^3*xcp2 +256*e3e1*e2e1^2*amel2*x4^3*xcp1 -96*e3e1*e2e1^2*amel2*x3*xcp3 -1280*e3e1*e2e1^2*amel2*x3*xcp2 -96*e3e1*e2e1^2*amel2*x3*xcp1 +32*e3e1*e2e1^2*amel2*x3*x5*xcp3 +1856*e3e1*e2e1^2*amel2*x3*x5*xcp2 +32*e3e1*e2e1^2*amel2*x3*x5*xcp1 +192*e3e1*e2e1^2*amel2*x3*x5^2*xcp3 -384*e3e1*e2e1^2*amel2*x3*x5^2*xcp2 +192*e3e1*e2e1^2*amel2*x3*x5^2*xcp1 +96*e3e1*e2e1^2*amel2*x3*x4*xcp3 +3136*e3e1*e2e1^2*amel2*x3*x4*xcp2 +96*e3e1*e2e1^2*amel2*x3*x4*xcp1 +576*e3e1*e2e1^2*amel2*x3*x4*x5*xcp3 -2176*e3e1*e2e1^2*amel2*x3*x4*x5*xcp2 +576*e3e1*e2e1^2*amel2*x3*x4*x5*xcp1 +448*e3e1*e2e1^2*amel2*x3*x4^2*xcp3 -2048*e3e1*e2e1^2*amel2*x3*x4^2*xcp2 +448*e3e1*e2e1^2*amel2*x3*x4^2*xcp1 +32*e3e1*e2e1^2*amel2*x3^2*xcp3 +1024*e3e1*e2e1^2*amel2*x3^2*xcp2 +32*e3e1*e2e1^2*amel2*x3^2*xcp1 +128*e3e1*e2e1^2*amel2*x3^2*x5*xcp3 -512*e3e1*e2e1^2*amel2*x3^2*x5*xcp2 +128*e3e1*e2e1^2*amel2*x3^2*x5*xcp1 +192*e3e1*e2e1^2*amel2*x3^2*x4*xcp3 -1280*e3e1*e2e1^2*amel2*x3^2*x4*xcp2 +192*e3e1*e2e1^2*amel2*x3^2*x4*xcp1 -256*e3e1*e2e1^2*amel2*x3^3*xcp2 -32*e3e1*e2e1^2*amel2*x1*xcp3 -1024*e3e1*e2e1^2*amel2*x1*xcp2 -32*e3e1*e2e1^2*amel2*x1*xcp1 -32*e3e1*e2e1^2*amel2*x1*x5*xcp3 +1600*e3e1*e2e1^2*amel2*x1*x5*xcp2 -32*e3e1*e2e1^2*amel2*x1*x5*xcp1 +64*e3e1*e2e1^2*amel2*x1*x5^2*xcp3 -640*e3e1*e2e1^2*amel2*x1*x5^2*xcp2 +64*e3e1*e2e1^2*amel2*x1*x5^2*xcp1 -224*e3e1*e2e1^2*amel2*x1*x4*xcp3 +1536*e3e1*e2e1^2*amel2*x1*x4*xcp2 -224*e3e1*e2e1^2*amel2*x1*x4*xcp1 +256*e3e1*e2e1^2*amel2*x1*x4*x5*xcp3 -1408*e3e1*e2e1^2*amel2*x1*x4*x5*xcp2 +256*e3e1*e2e1^2*amel2*x1*x4*x5*xcp1 +256*e3e1*e2e1^2*amel2*x1*x4^2*xcp3 -768*e3e1*e2e1^2*amel2*x1*x4^2*xcp2 +256*e3e1*e2e1^2*amel2*x1*x4^2*xcp1 -64*e3e1*e2e1^2*amel2*x1*x3*xcp3 +1600*e3e1*e2e1^2*amel2*x1*x3*xcp2 -64*e3e1*e2e1^2*amel2*x1*x3*xcp1 +256*e3e1*e2e1^2*amel2*x1*x3*x5*xcp3 -1536*e3e1*e2e1^2*amel2*x1*x3*x5*xcp2 +256*e3e1*e2e1^2*amel2*x1*x3*x5*xcp1 +448*e3e1*e2e1^2*amel2*x1*x3*x4*xcp3 -1664*e3e1*e2e1^2*amel2*x1*x3*x4*xcp2 +448*e3e1*e2e1^2*amel2*x1*x3*x4*xcp1 +192*e3e1*e2e1^2*amel2*x1*x3^2*xcp3 -768*e3e1*e2e1^2*amel2*x1*x3^2*xcp2 +192*e3e1*e2e1^2*amel2*x1*x3^2*xcp1 -32*e3e1*e2e1^2*amel2*x1^2*xcp3 +192*e3e1*e2e1^2*amel2*x1^2*xcp2 -32*e3e1*e2e1^2*amel2*x1^2*xcp1 -128*e3e1*e2e1^2*amel2*x1^2*x5*xcp2 -128*e3e1*e2e1^2*amel2*x1^2*x4*xcp2 -128*e3e1*e2e1^2*amel2*x1^2*x3*xcp2 +256*e3e1*e2e1^3*xcp2 -384*e3e1*e2e1^3*x5*xcp2 +128*e3e1*e2e1^3*x5^3*xcp2 -896*e3e1*e2e1^3*x4*xcp2 +768*e3e1*e2e1^3*x4*x5*xcp2 +128*e3e1*e2e1^3*x4*x5^2*xcp2 +768*e3e1*e2e1^3*x4^2*xcp2 -128*e3e1*e2e1^3*x4^2*x5*xcp2 -128*e3e1*e2e1^3*x4^3*xcp2 -512*e3e1*e2e1^3*x3*xcp2 +384*e3e1*e2e1^3*x3*x5*xcp2 +128*e3e1*e2e1^3*x3*x5^2*xcp2 +1408*e3e1*e2e1^3*x3*x4*xcp2 -512*e3e1*e2e1^3*x3*x4*x5*xcp2 -640*e3e1*e2e1^3*x3*x4^2*xcp2 +256*e3e1*e2e1^3*x3^2*xcp2 -512*e3e1*e2e1^3*x3^2*x4*xcp2 -256*e3e1*e2e1^3*x1*xcp2 +384*e3e1*e2e1^3*x1*x5*xcp2 -128*e3e1*e2e1^3*x1*x5^2*xcp2 +384*e3e1*e2e1^3*x1*x4*xcp2 -256*e3e1*e2e1^3*x1*x4*x5*xcp2 -128*e3e1*e2e1^3*x1*x4^2*xcp2 +512*e3e1*e2e1^3*x1*x3*xcp2 -384*e3e1*e2e1^3*x1*x3*x5*xcp2 -384*e3e1*e2e1^3*x1*x3*x4*xcp2 -256*e3e1*e2e1^3*x1*x3^2*xcp2 +16*e3e1*e3e2*amel2*zk^2*xcp3 -128*e3e1*e3e2*amel2*zk^2*xcp2 +16*e3e1*e3e2*amel2*zk^2*xcp1 -48*e3e1*e3e2*amel2*zk^2*x5*xcp3 +192*e3e1*e3e2*amel2*zk^2*x5*xcp2 -48*e3e1*e3e2*amel2*zk^2*x5*xcp1 -96*e3e1*e3e2*amel2*zk^2*x4*xcp3 +224*e3e1*e3e2*amel2*zk^2*x4*xcp2 -96*e3e1*e3e2*amel2*zk^2*x4*xcp1 -48*e3e1*e3e2*amel2*zk^2*x3*xcp3 +160*e3e1*e3e2*amel2*zk^2*x3*xcp2 -48*e3e1*e3e2*amel2*zk^2*x3*xcp1 +32*e3e1*e3e2*amel2*zk^2*x1*xcp2 -64*e3e1*e3e2*amel2^2*xcp3 -256*e3e1*e3e2*amel2^2*xcp2 -64*e3e1*e3e2*amel2^2*xcp1 +96*e3e1*e3e2*amel2^2*x5*xcp3 +1152*e3e1*e3e2*amel2^2*x5*xcp2 +96*e3e1*e3e2*amel2^2*x5*xcp1 +96*e3e1*e3e2*amel2^2*x5^2*xcp3 -1024*e3e1*e3e2*amel2^2*x5^2*xcp2 +96*e3e1*e3e2*amel2^2*x5^2*xcp1 -96*e3e1*e3e2*amel2^2*x5^3*xcp3 +256*e3e1*e3e2*amel2^2*x5^3*xcp2 -96*e3e1*e3e2*amel2^2*x5^3*xcp1 -64*e3e1*e3e2*amel2^2*x4*xcp3 +1408*e3e1*e3e2*amel2^2*x4*xcp2 -64*e3e1*e3e2*amel2^2*x4*xcp1 +448*e3e1*e3e2*amel2^2*x4*x5*xcp3 -2752*e3e1*e3e2*amel2^2*x4*x5*xcp2 +448*e3e1*e3e2*amel2^2*x4*x5*xcp1 -448*e3e1*e3e2*amel2^2*x4*x5^2*xcp3 +1024*e3e1*e3e2*amel2^2*x4*x5^2*xcp2 -448*e3e1*e3e2*amel2^2*x4*x5^2*xcp1 +448*e3e1*e3e2*amel2^2*x4^2*xcp3 -1920*e3e1*e3e2*amel2^2*x4^2*xcp2 +448*e3e1*e3e2*amel2^2*x4^2*xcp1 -640*e3e1*e3e2*amel2^2*x4^2*x5*xcp3 +1536*e3e1*e3e2*amel2^2*x4^2*x5*xcp2 -640*e3e1*e3e2*amel2^2*x4^2*x5*xcp1 -320*e3e1*e3e2*amel2^2*x4^3*xcp3 +768*e3e1*e3e2*amel2^2*x4^3*xcp2 -320*e3e1*e3e2*amel2^2*x4^3*xcp1 +160*e3e1*e3e2*amel2^2*x3*xcp3 +768*e3e1*e3e2*amel2^2*x3*xcp2 +160*e3e1*e3e2*amel2^2*x3*xcp1 +64*e3e1*e3e2*amel2^2*x3*x5*xcp3 -1856*e3e1*e3e2*amel2^2*x3*x5*xcp2 +64*e3e1*e3e2*amel2^2*x3*x5*xcp1 -96*e3e1*e3e2*amel2^2*x3*x5^2*xcp3 +512*e3e1*e3e2*amel2^2*x3*x5^2*xcp2 -96*e3e1*e3e2*amel2^2*x3*x5^2*xcp1 +384*e3e1*e3e2*amel2^2*x3*x4*xcp3 -2496*e3e1*e3e2*amel2^2*x3*x4*xcp2 +384*e3e1*e3e2*amel2^2*x3*x4*xcp1 -384*e3e1*e3e2*amel2^2*x3*x4*x5*xcp3 +1664*e3e1*e3e2*amel2^2*x3*x4*x5*xcp2 -384*e3e1*e3e2*amel2^2*x3*x4*x5*xcp1 -384*e3e1*e3e2*amel2^2*x3*x4^2*xcp3 +1280*e3e1*e3e2*amel2^2*x3*x4^2*xcp2 -384*e3e1*e3e2*amel2^2*x3*x4^2*xcp1 +32*e3e1*e3e2*amel2^2*x3^2*xcp3 -704*e3e1*e3e2*amel2^2*x3^2*xcp2 +32*e3e1*e3e2*amel2^2*x3^2*xcp1 -32*e3e1*e3e2*amel2^2*x3^2*x5*xcp3 +384*e3e1*e3e2*amel2^2*x3^2*x5*xcp2 -32*e3e1*e3e2*amel2^2*x3^2*x5*xcp1 -128*e3e1*e3e2*amel2^2*x3^2*x4*xcp3 +640*e3e1*e3e2*amel2^2*x3^2*x4*xcp2 -128*e3e1*e3e2*amel2^2*x3^2*x4*xcp1 -32*e3e1*e3e2*amel2^2*x3^3*xcp3 +128*e3e1*e3e2*amel2^2*x3^3*xcp2 -32*e3e1*e3e2*amel2^2*x3^3*xcp1 +96*e3e1*e3e2*amel2^2*x1*xcp3 +640*e3e1*e3e2*amel2^2*x1*xcp2 +96*e3e1*e3e2*amel2^2*x1*xcp1 +64*e3e1*e3e2*amel2^2*x1*x5*xcp3 -1664*e3e1*e3e2*amel2^2*x1*x5*xcp2 +64*e3e1*e3e2*amel2^2*x1*x5*xcp1 -192*e3e1*e3e2*amel2^2*x1*x5^2*xcp3 +896*e3e1*e3e2*amel2^2*x1*x5^2*xcp2 -192*e3e1*e3e2*amel2^2*x1*x5^2*xcp1 +256*e3e1*e3e2*amel2^2*x1*x4*xcp3 -2112*e3e1*e3e2*amel2^2*x1*x4*xcp2 +256*e3e1*e3e2*amel2^2*x1*x4*xcp1 -640*e3e1*e3e2*amel2^2*x1*x4*x5*xcp3 +2176*e3e1*e3e2*amel2^2*x1*x4*x5*xcp2 -640*e3e1*e3e2*amel2^2*x1*x4*x5*xcp1 -448*e3e1*e3e2*amel2^2*x1*x4^2*xcp3 +1280*e3e1*e3e2*amel2^2*x1*x4^2*xcp2 -448*e3e1*e3e2*amel2^2*x1*x4^2*xcp1 +64*e3e1*e3e2*amel2^2*x1*x3*xcp3 -1344*e3e1*e3e2*amel2^2*x1*x3*xcp2 +64*e3e1*e3e2*amel2^2*x1*x3*xcp1 -256*e3e1*e3e2*amel2^2*x1*x3*x5*xcp3 +1408*e3e1*e3e2*amel2^2*x1*x3*x5*xcp2 -256*e3e1*e3e2*amel2^2*x1*x3*x5*xcp1 -512*e3e1*e3e2*amel2^2*x1*x3*x4*xcp3 +1792*e3e1*e3e2*amel2^2*x1*x3*x4*xcp2 -512*e3e1*e3e2*amel2^2*x1*x3*x4*xcp1 -64*e3e1*e3e2*amel2^2*x1*x3^2*xcp3 +640*e3e1*e3e2*amel2^2*x1*x3^2*xcp2 -64*e3e1*e3e2*amel2^2*x1*x3^2*xcp1 +32*e3e1*e3e2*amel2^2*x1^2*xcp3 -256*e3e1*e3e2*amel2^2*x1^2*xcp2 +32*e3e1*e3e2*amel2^2*x1^2*xcp1 -96*e3e1*e3e2*amel2^2*x1^2*x5*xcp3 +256*e3e1*e3e2*amel2^2*x1^2*x5*xcp2 -96*e3e1*e3e2*amel2^2*x1^2*x5*xcp1 -128*e3e1*e3e2*amel2^2*x1^2*x4*xcp3 +256*e3e1*e3e2*amel2^2*x1^2*x4*xcp2 -128*e3e1*e3e2*amel2^2*x1^2*x4*xcp1 -96*e3e1*e3e2*amel2^2*x1^2*x3*xcp3 +128*e3e1*e3e2*amel2^2*x1^2*x3*xcp2 -96*e3e1*e3e2*amel2^2*x1^2*x3*xcp1 -256*e3e1*e3e2*e2e1*zk^2*xcp2 +192*e3e1*e3e2*e2e1*zk^2*x5*xcp2 +160*e3e1*e3e2*e2e1*zk^2*x4*xcp2 +288*e3e1*e3e2*e2e1*zk^2*x3*xcp2 -32*e3e1*e3e2*e2e1*zk^2*x1*xcp2 -64*e3e1*e3e2*e2e1*amel2*xcp3 -768*e3e1*e3e2*e2e1*amel2*xcp2 -64*e3e1*e3e2*e2e1*amel2*xcp1 +64*e3e1*e3e2*e2e1*amel2*x5*xcp3 +2304*e3e1*e3e2*e2e1*amel2*x5*xcp2 +64*e3e1*e3e2*e2e1*amel2*x5*xcp1 +64*e3e1*e3e2*e2e1*amel2*x5^2*xcp3 -1280*e3e1*e3e2*e2e1*amel2*x5^2*xcp2 +64*e3e1*e3e2*e2e1*amel2*x5^2*xcp1 -128*e3e1*e3e2*e2e1*amel2*x5^3*xcp3 +128*e3e1*e3e2*e2e1*amel2*x5^3*xcp2 -128*e3e1*e3e2*e2e1*amel2*x5^3*xcp1 +96*e3e1*e3e2*e2e1*amel2*x4*xcp3 +3328*e3e1*e3e2*e2e1*amel2*x4*xcp2 +96*e3e1*e3e2*e2e1*amel2*x4*xcp1 +160*e3e1*e3e2*e2e1*amel2*x4*x5*xcp3 -4672*e3e1*e3e2*e2e1*amel2*x4*x5*xcp2 +160*e3e1*e3e2*e2e1*amel2*x4*x5*xcp1 -576*e3e1*e3e2*e2e1*amel2*x4*x5^2*xcp3 +1536*e3e1*e3e2*e2e1*amel2*x4*x5^2*xcp2 -576*e3e1*e3e2*e2e1*amel2*x4*x5^2*xcp1 +192*e3e1*e3e2*e2e1*amel2*x4^2*xcp3 -3776*e3e1*e3e2*e2e1*amel2*x4^2*xcp2 +192*e3e1*e3e2*e2e1*amel2*x4^2*xcp1 -896*e3e1*e3e2*e2e1*amel2*x4^2*x5*xcp3 +3072*e3e1*e3e2*e2e1*amel2*x4^2*x5*xcp2 -896*e3e1*e3e2*e2e1*amel2*x4^2*x5*xcp1 -448*e3e1*e3e2*e2e1*amel2*x4^3*xcp3 +1664*e3e1*e3e2*e2e1*amel2*x4^3*xcp2 -448*e3e1*e3e2*e2e1*amel2*x4^3*xcp1 +96*e3e1*e3e2*e2e1*amel2*x3*xcp3 +2048*e3e1*e3e2*e2e1*amel2*x3*xcp2 +96*e3e1*e3e2*e2e1*amel2*x3*xcp1 +32*e3e1*e3e2*e2e1*amel2*x3*x5*xcp3 -3136*e3e1*e3e2*e2e1*amel2*x3*x5*xcp2 +32*e3e1*e3e2*e2e1*amel2*x3*x5*xcp1 -320*e3e1*e3e2*e2e1*amel2*x3*x5^2*xcp3 +768*e3e1*e3e2*e2e1*amel2*x3*x5^2*xcp2 -320*e3e1*e3e2*e2e1*amel2*x3*x5^2*xcp1 -32*e3e1*e3e2*e2e1*amel2*x3*x4*xcp3 -5440*e3e1*e3e2*e2e1*amel2*x3*x4*xcp2 -32*e3e1*e3e2*e2e1*amel2*x3*x4*xcp1 -960*e3e1*e3e2*e2e1*amel2*x3*x4*x5*xcp3 +4096*e3e1*e3e2*e2e1*amel2*x3*x4*x5*xcp2 -960*e3e1*e3e2*e2e1*amel2*x3*x4*x5*xcp1 -768*e3e1*e3e2*e2e1*amel2*x3*x4^2*xcp3 +3712*e3e1*e3e2*e2e1*amel2*x3*x4^2*xcp2 -768*e3e1*e3e2*e2e1*amel2*x3*x4^2*xcp1 -32*e3e1*e3e2*e2e1*amel2*x3^2*xcp3 -1664*e3e1*e3e2*e2e1*amel2*x3^2*xcp2 -32*e3e1*e3e2*e2e1*amel2*x3^2*xcp1 -192*e3e1*e3e2*e2e1*amel2*x3^2*x5*xcp3 +896*e3e1*e3e2*e2e1*amel2*x3^2*x5*xcp2 -192*e3e1*e3e2*e2e1*amel2*x3^2*x5*xcp1 -320*e3e1*e3e2*e2e1*amel2*x3^2*x4*xcp3 +2176*e3e1*e3e2*e2e1*amel2*x3^2*x4*xcp2 -320*e3e1*e3e2*e2e1*amel2*x3^2*x4*xcp1 +384*e3e1*e3e2*e2e1*amel2*x3^3*xcp2 +32*e3e1*e3e2*e2e1*amel2*x1*xcp3 +1664*e3e1*e3e2*e2e1*amel2*x1*xcp2 +32*e3e1*e3e2*e2e1*amel2*x1*xcp1 +96*e3e1*e3e2*e2e1*amel2*x1*x5*xcp3 -2880*e3e1*e3e2*e2e1*amel2*x1*x5*xcp2 +96*e3e1*e3e2*e2e1*amel2*x1*x5*xcp1 -128*e3e1*e3e2*e2e1*amel2*x1*x5^2*xcp3 +1280*e3e1*e3e2*e2e1*amel2*x1*x5^2*xcp2 -128*e3e1*e3e2*e2e1*amel2*x1*x5^2*xcp1 +288*e3e1*e3e2*e2e1*amel2*x1*x4*xcp3 -2944*e3e1*e3e2*e2e1*amel2*x1*x4*xcp2 +288*e3e1*e3e2*e2e1*amel2*x1*x4*xcp1 -384*e3e1*e3e2*e2e1*amel2*x1*x4*x5*xcp3 +2816*e3e1*e3e2*e2e1*amel2*x1*x4*x5*xcp2 -384*e3e1*e3e2*e2e1*amel2*x1*x4*x5*xcp1 -320*e3e1*e3e2*e2e1*amel2*x1*x4^2*xcp3 +1536*e3e1*e3e2*e2e1*amel2*x1*x4^2*xcp2 -320*e3e1*e3e2*e2e1*amel2*x1*x4^2*xcp1 +128*e3e1*e3e2*e2e1*amel2*x1*x3*xcp3 -2752*e3e1*e3e2*e2e1*amel2*x1*x3*xcp2 +128*e3e1*e3e2*e2e1*amel2*x1*x3*xcp1 -384*e3e1*e3e2*e2e1*amel2*x1*x3*x5*xcp3 +2688*e3e1*e3e2*e2e1*amel2*x1*x3*x5*xcp2 -384*e3e1*e3e2*e2e1*amel2*x1*x3*x5*xcp1 -576*e3e1*e3e2*e2e1*amel2*x1*x3*x4*xcp3 +2944*e3e1*e3e2*e2e1*amel2*x1*x3*x4*xcp2 -576*e3e1*e3e2*e2e1*amel2*x1*x3*x4*xcp1 -256*e3e1*e3e2*e2e1*amel2*x1*x3^2*xcp3 +1280*e3e1*e3e2*e2e1*amel2*x1*x3^2*xcp2 -256*e3e1*e3e2*e2e1*amel2*x1*x3^2*xcp1 +32*e3e1*e3e2*e2e1*amel2*x1^2*xcp3 -320*e3e1*e3e2*e2e1*amel2*x1^2*xcp2 +32*e3e1*e3e2*e2e1*amel2*x1^2*xcp1 +256*e3e1*e3e2*e2e1*amel2*x1^2*x5*xcp2 +256*e3e1*e3e2*e2e1*amel2*x1^2*x4*xcp2 +256*e3e1*e3e2*e2e1*amel2*x1^2*x3*xcp2 -512*e3e1*e3e2*e2e1^2*xcp2 +768*e3e1*e3e2*e2e1^2*x5*xcp2 -256*e3e1*e3e2*e2e1^2*x5^3*xcp2 +2048*e3e1*e3e2*e2e1^2*x4*xcp2 -2048*e3e1*e3e2*e2e1^2*x4*x5*xcp2 -2048*e3e1*e3e2*e2e1^2*x4^2*xcp2 +768*e3e1*e3e2*e2e1^2*x4^2*x5*xcp2 +512*e3e1*e3e2*e2e1^2*x4^3*xcp2 +1024*e3e1*e3e2*e2e1^2*x3*xcp2 -768*e3e1*e3e2*e2e1^2*x3*x5*xcp2 -256*e3e1*e3e2*e2e1^2*x3*x5^2*xcp2 -3328*e3e1*e3e2*e2e1^2*x3*x4*xcp2 +1536*e3e1*e3e2*e2e1^2*x3*x4*x5*xcp2 +1792*e3e1*e3e2*e2e1^2*x3*x4^2*xcp2 -512*e3e1*e3e2*e2e1^2*x3^2*xcp2 +1280*e3e1*e3e2*e2e1^2*x3^2*x4*xcp2 +512*e3e1*e3e2*e2e1^2*x1*xcp2 -768*e3e1*e3e2*e2e1^2*x1*x5*xcp2 +256*e3e1*e3e2*e2e1^2*x1*x5^2*xcp2 -768*e3e1*e3e2*e2e1^2*x1*x4*xcp2 +512*e3e1*e3e2*e2e1^2*x1*x4*x5*xcp2 +256*e3e1*e3e2*e2e1^2*x1*x4^2*xcp2 -1024*e3e1*e3e2*e2e1^2*x1*x3*xcp2 +768*e3e1*e3e2*e2e1^2*x1*x3*x5*xcp2 +768*e3e1*e3e2*e2e1^2*x1*x3*x4*xcp2 +512*e3e1*e3e2*e2e1^2*x1*x3^2*xcp2 +128*e3e1*e3e2^2*zk^2*xcp2 -128*e3e1*e3e2^2*zk^2*x5*xcp2 -128*e3e1*e3e2^2*zk^2*x4*xcp2 -128*e3e1*e3e2^2*zk^2*x3*xcp2 +256*e3e1*e3e2^2*amel2*xcp2 -768*e3e1*e3e2^2*amel2*x5*xcp2 -64*e3e1*e3e2^2*amel2*x5^2*xcp3 +640*e3e1*e3e2^2*amel2*x5^2*xcp2 -64*e3e1*e3e2^2*amel2*x5^2*xcp1 +64*e3e1*e3e2^2*amel2*x5^3*xcp3 -128*e3e1*e3e2^2*amel2*x5^3*xcp2 +64*e3e1*e3e2^2*amel2*x5^3*xcp1 -64*e3e1*e3e2^2*amel2*x4*xcp3 -1280*e3e1*e3e2^2*amel2*x4*xcp2 -64*e3e1*e3e2^2*amel2*x4*xcp1 -128*e3e1*e3e2^2*amel2*x4*x5*xcp3 +2432*e3e1*e3e2^2*amel2*x4*x5*xcp2 -128*e3e1*e3e2^2*amel2*x4*x5*xcp1 +256*e3e1*e3e2^2*amel2*x4*x5^2*xcp3 -1024*e3e1*e3e2^2*amel2*x4*x5^2*xcp2 +256*e3e1*e3e2^2*amel2*x4*x5^2*xcp1 -128*e3e1*e3e2^2*amel2*x4^2*xcp3 +1920*e3e1*e3e2^2*amel2*x4^2*xcp2 -128*e3e1*e3e2^2*amel2*x4^2*xcp1 +384*e3e1*e3e2^2*amel2*x4^2*x5*xcp3 -1792*e3e1*e3e2^2*amel2*x4^2*x5*xcp2 +384*e3e1*e3e2^2*amel2*x4^2*x5*xcp1 +192*e3e1*e3e2^2*amel2*x4^3*xcp3 -896*e3e1*e3e2^2*amel2*x4^3*xcp2 +192*e3e1*e3e2^2*amel2*x4^3*xcp1 -768*e3e1*e3e2^2*amel2*x3*xcp2 -64*e3e1*e3e2^2*amel2*x3*x5*xcp3 +1280*e3e1*e3e2^2*amel2*x3*x5*xcp2 -64*e3e1*e3e2^2*amel2*x3*x5*xcp1 +128*e3e1*e3e2^2*amel2*x3*x5^2*xcp3 -384*e3e1*e3e2^2*amel2*x3*x5^2*xcp2 +128*e3e1*e3e2^2*amel2*x3*x5^2*xcp1 -64*e3e1*e3e2^2*amel2*x3*x4*xcp3 +2304*e3e1*e3e2^2*amel2*x3*x4*xcp2 -64*e3e1*e3e2^2*amel2*x3*x4*xcp1 +384*e3e1*e3e2^2*amel2*x3*x4*x5*xcp3 -1920*e3e1*e3e2^2*amel2*x3*x4*x5*xcp2 +384*e3e1*e3e2^2*amel2*x3*x4*x5*xcp1 +320*e3e1*e3e2^2*amel2*x3*x4^2*xcp3 -1664*e3e1*e3e2^2*amel2*x3*x4^2*xcp2 +320*e3e1*e3e2^2*amel2*x3*x4^2*xcp1 +640*e3e1*e3e2^2*amel2*x3^2*xcp2 +64*e3e1*e3e2^2*amel2*x3^2*x5*xcp3 -384*e3e1*e3e2^2*amel2*x3^2*x5*xcp2 +64*e3e1*e3e2^2*amel2*x3^2*x5*xcp1 +128*e3e1*e3e2^2*amel2*x3^2*x4*xcp3 -896*e3e1*e3e2^2*amel2*x3^2*x4*xcp2 +128*e3e1*e3e2^2*amel2*x3^2*x4*xcp1 -128*e3e1*e3e2^2*amel2*x3^3*xcp2 -640*e3e1*e3e2^2*amel2*x1*xcp2 -64*e3e1*e3e2^2*amel2*x1*x5*xcp3 +1280*e3e1*e3e2^2*amel2*x1*x5*xcp2 -64*e3e1*e3e2^2*amel2*x1*x5*xcp1 +64*e3e1*e3e2^2*amel2*x1*x5^2*xcp3 -640*e3e1*e3e2^2*amel2*x1*x5^2*xcp2 +64*e3e1*e3e2^2*amel2*x1*x5^2*xcp1 -64*e3e1*e3e2^2*amel2*x1*x4*xcp3 +1408*e3e1*e3e2^2*amel2*x1*x4*xcp2 -64*e3e1*e3e2^2*amel2*x1*x4*xcp1 +128*e3e1*e3e2^2*amel2*x1*x4*x5*xcp3 -1408*e3e1*e3e2^2*amel2*x1*x4*x5*xcp2 +128*e3e1*e3e2^2*amel2*x1*x4*x5*xcp1 +64*e3e1*e3e2^2*amel2*x1*x4^2*xcp3 -768*e3e1*e3e2^2*amel2*x1*x4^2*xcp2 +64*e3e1*e3e2^2*amel2*x1*x4^2*xcp1 -64*e3e1*e3e2^2*amel2*x1*x3*xcp3 +1152*e3e1*e3e2^2*amel2*x1*x3*xcp2 -64*e3e1*e3e2^2*amel2*x1*x3*xcp1 +128*e3e1*e3e2^2*amel2*x1*x3*x5*xcp3 -1152*e3e1*e3e2^2*amel2*x1*x3*x5*xcp2 +128*e3e1*e3e2^2*amel2*x1*x3*x5*xcp1 +128*e3e1*e3e2^2*amel2*x1*x3*x4*xcp3 -1280*e3e1*e3e2^2*amel2*x1*x3*x4*xcp2 +128*e3e1*e3e2^2*amel2*x1*x3*x4*xcp1 +64*e3e1*e3e2^2*amel2*x1*x3^2*xcp3 -512*e3e1*e3e2^2*amel2*x1*x3^2*xcp2 +64*e3e1*e3e2^2*amel2*x1*x3^2*xcp1 +128*e3e1*e3e2^2*amel2*x1^2*xcp2 -128*e3e1*e3e2^2*amel2*x1^2*x5*xcp2 -128*e3e1*e3e2^2*amel2*x1^2*x4*xcp2 -128*e3e1*e3e2^2*amel2*x1^2*x3*xcp2 +256*e3e1*e3e2^2*e2e1*xcp2 -384*e3e1*e3e2^2*e2e1*x5*xcp2 +128*e3e1*e3e2^2*e2e1*x5^3*xcp2 -1408*e3e1*e3e2^2*e2e1*x4*xcp2 +1792*e3e1*e3e2^2*e2e1*x4*x5*xcp2 -384*e3e1*e3e2^2*e2e1*x4*x5^2*xcp2 +1792*e3e1*e3e2^2*e2e1*x4^2*xcp2 -1152*e3e1*e3e2^2*e2e1*x4^2*x5*xcp2 -640*e3e1*e3e2^2*e2e1*x4^3*xcp2 -512*e3e1*e3e2^2*e2e1*x3*xcp2 +384*e3e1*e3e2^2*e2e1*x3*x5*xcp2 +128*e3e1*e3e2^2*e2e1*x3*x5^2*xcp2 +2432*e3e1*e3e2^2*e2e1*x3*x4*xcp2 -1536*e3e1*e3e2^2*e2e1*x3*x4*x5*xcp2 -1664*e3e1*e3e2^2*e2e1*x3*x4^2*xcp2 +256*e3e1*e3e2^2*e2e1*x3^2*xcp2 -1024*e3e1*e3e2^2*e2e1*x3^2*x4*xcp2 -256*e3e1*e3e2^2*e2e1*x1*xcp2 +384*e3e1*e3e2^2*e2e1*x1*x5*xcp2 -128*e3e1*e3e2^2*e2e1*x1*x5^2*xcp2 +384*e3e1*e3e2^2*e2e1*x1*x4*xcp2 -256*e3e1*e3e2^2*e2e1*x1*x4*x5*xcp2 -128*e3e1*e3e2^2*e2e1*x1*x4^2*xcp2 +512*e3e1*e3e2^2*e2e1*x1*x3*xcp2 -384*e3e1*e3e2^2*e2e1*x1*x3*x5*xcp2 -384*e3e1*e3e2^2*e2e1*x1*x3*x4*xcp2 -256*e3e1*e3e2^2*e2e1*x1*x3^2*xcp2 +256*e3e1*e3e2^3*x4*xcp2 -512*e3e1*e3e2^3*x4*x5*xcp2 +256*e3e1*e3e2^3*x4*x5^2*xcp2 -512*e3e1*e3e2^3*x4^2*xcp2 +512*e3e1*e3e2^3*x4^2*x5*xcp2 +256*e3e1*e3e2^3*x4^3*xcp2 -512*e3e1*e3e2^3*x3*x4*xcp2 +512*e3e1*e3e2^3*x3*x4*x5*xcp2 +512*e3e1*e3e2^3*x3*x4^2*xcp2 +256*e3e1*e3e2^3*x3^2*x4*xcp2 +80*e3e1^2*amel2*zk^2*xcp3 +80*e3e1^2*amel2*zk^2*xcp1 -48*e3e1^2*amel2*zk^2*x5*xcp3 -48*e3e1^2*amel2*zk^2*x5*xcp1 -48*e3e1^2*amel2*zk^2*x4*xcp3 +32*e3e1^2*amel2*zk^2*x4*xcp2 -48*e3e1^2*amel2*zk^2*x4*xcp1 +32*e3e1^2*amel2*zk^2*x3*xcp2 -48*e3e1^2*amel2*zk^2*x1*xcp3 -48*e3e1^2*amel2*zk^2*x1*xcp1 +64*e3e1^2*amel2^2*xcp3 +64*e3e1^2*amel2^2*xcp1 -288*e3e1^2*amel2^2*x5*xcp3 -288*e3e1^2*amel2^2*x5*xcp1 +288*e3e1^2*amel2^2*x5^2*xcp3 +288*e3e1^2*amel2^2*x5^2*xcp1 -96*e3e1^2*amel2^2*x5^3*xcp3 -96*e3e1^2*amel2^2*x5^3*xcp1 -320*e3e1^2*amel2^2*x4*xcp3 +256*e3e1^2*amel2^2*x4*xcp2 -320*e3e1^2*amel2^2*x4*xcp1 +640*e3e1^2*amel2^2*x4*x5*xcp3 -640*e3e1^2*amel2^2*x4*x5*xcp2 +640*e3e1^2*amel2^2*x4*x5*xcp1 -288*e3e1^2*amel2^2*x4*x5^2*xcp3 +256*e3e1^2*amel2^2*x4*x5^2*xcp2 -288*e3e1^2*amel2^2*x4*x5^2*xcp1 +448*e3e1^2*amel2^2*x4^2*xcp3 -640*e3e1^2*amel2^2*x4^2*xcp2 +448*e3e1^2*amel2^2*x4^2*xcp1 -320*e3e1^2*amel2^2*x4^2*x5*xcp3 +512*e3e1^2*amel2^2*x4^2*x5*xcp2 -320*e3e1^2*amel2^2*x4^2*x5*xcp1 -128*e3e1^2*amel2^2*x4^3*xcp3 +256*e3e1^2*amel2^2*x4^3*xcp2 -128*e3e1^2*amel2^2*x4^3*xcp1 -96*e3e1^2*amel2^2*x3*xcp3 +256*e3e1^2*amel2^2*x3*xcp2 -96*e3e1^2*amel2^2*x3*xcp1 +256*e3e1^2*amel2^2*x3*x5*xcp3 -640*e3e1^2*amel2^2*x3*x5*xcp2 +256*e3e1^2*amel2^2*x3*x5*xcp1 -64*e3e1^2*amel2^2*x3*x5^2*xcp3 +256*e3e1^2*amel2^2*x3*x5^2*xcp2 -64*e3e1^2*amel2^2*x3*x5^2*xcp1 +448*e3e1^2*amel2^2*x3*x4*xcp3 -896*e3e1^2*amel2^2*x3*x4*xcp2 +448*e3e1^2*amel2^2*x3*x4*xcp1 -192*e3e1^2*amel2^2*x3*x4*x5*xcp3 +640*e3e1^2*amel2^2*x3*x4*x5*xcp2 -192*e3e1^2*amel2^2*x3*x4*x5*xcp1 -128*e3e1^2*amel2^2*x3*x4^2*xcp3 +384*e3e1^2*amel2^2*x3*x4^2*xcp2 -128*e3e1^2*amel2^2*x3*x4^2*xcp1 +96*e3e1^2*amel2^2*x3^2*xcp3 -256*e3e1^2*amel2^2*x3^2*xcp2 +96*e3e1^2*amel2^2*x3^2*xcp1 -32*e3e1^2*amel2^2*x3^2*x5*xcp3 +128*e3e1^2*amel2^2*x3^2*x5*xcp2 -32*e3e1^2*amel2^2*x3^2*x5*xcp1 -32*e3e1^2*amel2^2*x3^2*x4*xcp3 +128*e3e1^2*amel2^2*x3^2*x4*xcp2 -32*e3e1^2*amel2^2*x3^2*x4*xcp1 -352*e3e1^2*amel2^2*x1*xcp3 -352*e3e1^2*amel2^2*x1*xcp1 +448*e3e1^2*amel2^2*x1*x5*xcp3 +448*e3e1^2*amel2^2*x1*x5*xcp1 -288*e3e1^2*amel2^2*x1*x5^2*xcp3 -288*e3e1^2*amel2^2*x1*x5^2*xcp1 +512*e3e1^2*amel2^2*x1*x4*xcp3 -384*e3e1^2*amel2^2*x1*x4*xcp2 +512*e3e1^2*amel2^2*x1*x4*xcp1 -576*e3e1^2*amel2^2*x1*x4*x5*xcp3 +384*e3e1^2*amel2^2*x1*x4*x5*xcp2 -576*e3e1^2*amel2^2*x1*x4*x5*xcp1 -320*e3e1^2*amel2^2*x1*x4^2*xcp3 +384*e3e1^2*amel2^2*x1*x4^2*xcp2 -320*e3e1^2*amel2^2*x1*x4^2*xcp1 +384*e3e1^2*amel2^2*x1*x3*xcp3 -384*e3e1^2*amel2^2*x1*x3*xcp2 +384*e3e1^2*amel2^2*x1*x3*xcp1 -256*e3e1^2*amel2^2*x1*x3*x5*xcp3 +384*e3e1^2*amel2^2*x1*x3*x5*xcp2 -256*e3e1^2*amel2^2*x1*x3*x5*xcp1 -320*e3e1^2*amel2^2*x1*x3*x4*xcp3 +640*e3e1^2*amel2^2*x1*x3*x4*xcp2 -320*e3e1^2*amel2^2*x1*x3*x4*xcp1 -32*e3e1^2*amel2^2*x1*x3^2*xcp3 +256*e3e1^2*amel2^2*x1*x3^2*xcp2 -32*e3e1^2*amel2^2*x1*x3^2*xcp1 +224*e3e1^2*amel2^2*x1^2*xcp3 +224*e3e1^2*amel2^2*x1^2*xcp1 -224*e3e1^2*amel2^2*x1^2*x5*xcp3 -224*e3e1^2*amel2^2*x1^2*x5*xcp1 -224*e3e1^2*amel2^2*x1^2*x4*xcp3 -224*e3e1^2*amel2^2*x1^2*x4*xcp1 -192*e3e1^2*amel2^2*x1^2*x3*xcp3 -192*e3e1^2*amel2^2*x1^2*x3*xcp1 -32*e3e1^2*amel2^2*x1^3*xcp3 -32*e3e1^2*amel2^2*x1^3*xcp1 -96*e3e1^2*e2e1*zk^2*xcp2 +64*e3e1^2*e2e1*zk^2*x5*xcp2 +64*e3e1^2*e2e1*zk^2*x4*xcp2 +128*e3e1^2*e2e1*zk^2*x3*xcp2 -32*e3e1^2*e2e1*zk^2*x1*xcp2 -512*e3e1^2*e2e1*amel2*xcp2 +1536*e3e1^2*e2e1*amel2*x5*xcp2 +32*e3e1^2*e2e1*amel2*x5^2*xcp3 -1216*e3e1^2*e2e1*amel2*x5^2*xcp2 +32*e3e1^2*e2e1*amel2*x5^2*xcp1 -64*e3e1^2*e2e1*amel2*x5^3*xcp3 +384*e3e1^2*e2e1*amel2*x5^3*xcp2 -64*e3e1^2*e2e1*amel2*x5^3*xcp1 -160*e3e1^2*e2e1*amel2*x4*xcp3 +1792*e3e1^2*e2e1*amel2*x4*xcp2 -160*e3e1^2*e2e1*amel2*x4*xcp1 +288*e3e1^2*e2e1*amel2*x4*x5*xcp3 -2944*e3e1^2*e2e1*amel2*x4*x5*xcp2 +288*e3e1^2*e2e1*amel2*x4*x5*xcp1 -320*e3e1^2*e2e1*amel2*x4*x5^2*xcp3 +1408*e3e1^2*e2e1*amel2*x4*x5^2*xcp2 -320*e3e1^2*e2e1*amel2*x4*x5^2*xcp1 +256*e3e1^2*e2e1*amel2*x4^2*xcp3 -1856*e3e1^2*e2e1*amel2*x4^2*xcp2 +256*e3e1^2*e2e1*amel2*x4^2*xcp1 -448*e3e1^2*e2e1*amel2*x4^2*x5*xcp3 +1792*e3e1^2*e2e1*amel2*x4^2*x5*xcp2 -448*e3e1^2*e2e1*amel2*x4^2*x5*xcp1 -192*e3e1^2*e2e1*amel2*x4^3*xcp3 +768*e3e1^2*e2e1*amel2*x4^3*xcp2 -192*e3e1^2*e2e1*amel2*x4^3*xcp1 +32*e3e1^2*e2e1*amel2*x3*xcp3 +1280*e3e1^2*e2e1*amel2*x3*xcp2 +32*e3e1^2*e2e1*amel2*x3*xcp1 -32*e3e1^2*e2e1*amel2*x3*x5*xcp3 -2304*e3e1^2*e2e1*amel2*x3*x5*xcp2 -32*e3e1^2*e2e1*amel2*x3*x5*xcp1 -128*e3e1^2*e2e1*amel2*x3*x5^2*xcp3 +1024*e3e1^2*e2e1*amel2*x3*x5^2*xcp2 -128*e3e1^2*e2e1*amel2*x3*x5^2*xcp1 +96*e3e1^2*e2e1*amel2*x3*x4*xcp3 -2816*e3e1^2*e2e1*amel2*x3*x4*xcp2 +96*e3e1^2*e2e1*amel2*x3*x4*xcp1 -384*e3e1^2*e2e1*amel2*x3*x4*x5*xcp3 +2560*e3e1^2*e2e1*amel2*x3*x4*x5*xcp2 -384*e3e1^2*e2e1*amel2*x3*x4*x5*xcp1 -256*e3e1^2*e2e1*amel2*x3*x4^2*xcp3 +1664*e3e1^2*e2e1*amel2*x3*x4^2*xcp2 -256*e3e1^2*e2e1*amel2*x3*x4^2*xcp1 -896*e3e1^2*e2e1*amel2*x3^2*xcp2 -64*e3e1^2*e2e1*amel2*x3^2*x5*xcp3 +640*e3e1^2*e2e1*amel2*x3^2*x5*xcp2 -64*e3e1^2*e2e1*amel2*x3^2*x5*xcp1 -64*e3e1^2*e2e1*amel2*x3^2*x4*xcp3 +896*e3e1^2*e2e1*amel2*x3^2*x4*xcp2 -64*e3e1^2*e2e1*amel2*x3^2*x4*xcp1 +128*e3e1^2*e2e1*amel2*x3^3*xcp2 -96*e3e1^2*e2e1*amel2*x1*xcp3 +768*e3e1^2*e2e1*amel2*x1*xcp2 -96*e3e1^2*e2e1*amel2*x1*xcp1 +128*e3e1^2*e2e1*amel2*x1*x5*xcp3 -1280*e3e1^2*e2e1*amel2*x1*x5*xcp2 +128*e3e1^2*e2e1*amel2*x1*x5*xcp1 -64*e3e1^2*e2e1*amel2*x1*x5^2*xcp3 +640*e3e1^2*e2e1*amel2*x1*x5^2*xcp2 -64*e3e1^2*e2e1*amel2*x1*x5^2*xcp1 +416*e3e1^2*e2e1*amel2*x1*x4*xcp3 -1408*e3e1^2*e2e1*amel2*x1*x4*xcp2 +416*e3e1^2*e2e1*amel2*x1*x4*xcp1 -320*e3e1^2*e2e1*amel2*x1*x4*x5*xcp3 +1408*e3e1^2*e2e1*amel2*x1*x4*x5*xcp2 -320*e3e1^2*e2e1*amel2*x1*x4*x5*xcp1 -256*e3e1^2*e2e1*amel2*x1*x4^2*xcp3 +768*e3e1^2*e2e1*amel2*x1*x4^2*xcp2 -256*e3e1^2*e2e1*amel2*x1*x4^2*xcp1 +160*e3e1^2*e2e1*amel2*x1*x3*xcp3 -1408*e3e1^2*e2e1*amel2*x1*x3*xcp2 +160*e3e1^2*e2e1*amel2*x1*x3*xcp1 -192*e3e1^2*e2e1*amel2*x1*x3*x5*xcp3 +1408*e3e1^2*e2e1*amel2*x1*x3*x5*xcp2 -192*e3e1^2*e2e1*amel2*x1*x3*x5*xcp1 -320*e3e1^2*e2e1*amel2*x1*x3*x4*xcp3 +1536*e3e1^2*e2e1*amel2*x1*x3*x4*xcp2 -320*e3e1^2*e2e1*amel2*x1*x3*x4*xcp1 -64*e3e1^2*e2e1*amel2*x1*x3^2*xcp3 +640*e3e1^2*e2e1*amel2*x1*x3^2*xcp2 -64*e3e1^2*e2e1*amel2*x1*x3^2*xcp1 +96*e3e1^2*e2e1*amel2*x1^2*xcp3 -64*e3e1^2*e2e1*amel2*x1^2*xcp2 +96*e3e1^2*e2e1*amel2*x1^2*xcp1 +128*e3e1^2*e2e1*amel2*x1^2*x5*xcp2 -64*e3e1^2*e2e1*amel2*x1^2*x4*xcp3 +128*e3e1^2*e2e1*amel2*x1^2*x4*xcp2 -64*e3e1^2*e2e1*amel2*x1^2*x4*xcp1 -64*e3e1^2*e2e1*amel2*x1^2*x3*xcp3 +128*e3e1^2*e2e1*amel2*x1^2*x3*xcp2 -64*e3e1^2*e2e1*amel2*x1^2*x3*xcp1 -512*e3e1^2*e2e1^2*xcp2 +1152*e3e1^2*e2e1^2*x5*xcp2 -768*e3e1^2*e2e1^2*x5^2*xcp2 +128*e3e1^2*e2e1^2*x5^3*xcp2 +1408*e3e1^2*e2e1^2*x4*xcp2 -1920*e3e1^2*e2e1^2*x4*x5*xcp2 +512*e3e1^2*e2e1^2*x4*x5^2*xcp2 -1152*e3e1^2*e2e1^2*x4^2*xcp2 +640*e3e1^2*e2e1^2*x4^2*x5*xcp2 +256*e3e1^2*e2e1^2*x4^3*xcp2 +1024*e3e1^2*e2e1^2*x3*xcp2 -1536*e3e1^2*e2e1^2*x3*x5*xcp2 +512*e3e1^2*e2e1^2*x3*x5^2*xcp2 -2048*e3e1^2*e2e1^2*x3*x4*xcp2 +1408*e3e1^2*e2e1^2*x3*x4*x5*xcp2 +896*e3e1^2*e2e1^2*x3*x4^2*xcp2 -512*e3e1^2*e2e1^2*x3^2*xcp2 +384*e3e1^2*e2e1^2*x3^2*x5*xcp2 +640*e3e1^2*e2e1^2*x3^2*x4*xcp2 +512*e3e1^2*e2e1^2*x1*xcp2 -768*e3e1^2*e2e1^2*x1*x5*xcp2 +256*e3e1^2*e2e1^2*x1*x5^2*xcp2 -768*e3e1^2*e2e1^2*x1*x4*xcp2 +512*e3e1^2*e2e1^2*x1*x4*x5*xcp2 +256*e3e1^2*e2e1^2*x1*x4^2*xcp2 -1024*e3e1^2*e2e1^2*x1*x3*xcp2 +768*e3e1^2*e2e1^2*x1*x3*x5*xcp2 +768*e3e1^2*e2e1^2*x1*x3*x4*xcp2 +512*e3e1^2*e2e1^2*x1*x3^2*xcp2 +128*e3e1^2*e3e2*zk^2*xcp2 -128*e3e1^2*e3e2*zk^2*x5*xcp2 -128*e3e1^2*e3e2*zk^2*x4*xcp2 -128*e3e1^2*e3e2*zk^2*x3*xcp2 +64*e3e1^2*e3e2*amel2*xcp3 +512*e3e1^2*e3e2*amel2*xcp2 +64*e3e1^2*e3e2*amel2*xcp1 -128*e3e1^2*e3e2*amel2*x5*xcp3 -1664*e3e1^2*e3e2*amel2*x5*xcp2 -128*e3e1^2*e3e2*amel2*x5*xcp1 +1664*e3e1^2*e3e2*amel2*x5^2*xcp2 +64*e3e1^2*e3e2*amel2*x5^3*xcp3 -512*e3e1^2*e3e2*amel2*x5^3*xcp2 +64*e3e1^2*e3e2*amel2*x5^3*xcp1 -1920*e3e1^2*e3e2*amel2*x4*xcp2 -256*e3e1^2*e3e2*amel2*x4*x5*xcp3 +3840*e3e1^2*e3e2*amel2*x4*x5*xcp2 -256*e3e1^2*e3e2*amel2*x4*x5*xcp1 +320*e3e1^2*e3e2*amel2*x4*x5^2*xcp3 -1792*e3e1^2*e3e2*amel2*x4*x5^2*xcp2 +320*e3e1^2*e3e2*amel2*x4*x5^2*xcp1 -256*e3e1^2*e3e2*amel2*x4^2*xcp3 +2304*e3e1^2*e3e2*amel2*x4^2*xcp2 -256*e3e1^2*e3e2*amel2*x4^2*xcp1 +448*e3e1^2*e3e2*amel2*x4^2*x5*xcp3 -2176*e3e1^2*e3e2*amel2*x4^2*x5*xcp2 +448*e3e1^2*e3e2*amel2*x4^2*x5*xcp1 +192*e3e1^2*e3e2*amel2*x4^3*xcp3 -896*e3e1^2*e3e2*amel2*x4^3*xcp2 +192*e3e1^2*e3e2*amel2*x4^3*xcp1 -64*e3e1^2*e3e2*amel2*x3*xcp3 -1280*e3e1^2*e3e2*amel2*x3*xcp2 -64*e3e1^2*e3e2*amel2*x3*xcp1 +2432*e3e1^2*e3e2*amel2*x3*x5*xcp2 +128*e3e1^2*e3e2*amel2*x3*x5^2*xcp3 -1024*e3e1^2*e3e2*amel2*x3*x5^2*xcp2 +128*e3e1^2*e3e2*amel2*x3*x5^2*xcp1 -128*e3e1^2*e3e2*amel2*x3*x4*xcp3 +2944*e3e1^2*e3e2*amel2*x3*x4*xcp2 -128*e3e1^2*e3e2*amel2*x3*x4*xcp1 +384*e3e1^2*e3e2*amel2*x3*x4*x5*xcp3 -2560*e3e1^2*e3e2*amel2*x3*x4*x5*xcp2 +384*e3e1^2*e3e2*amel2*x3*x4*x5*xcp1 +256*e3e1^2*e3e2*amel2*x3*x4^2*xcp3 -1664*e3e1^2*e3e2*amel2*x3*x4^2*xcp2 +256*e3e1^2*e3e2*amel2*x3*x4^2*xcp1 +896*e3e1^2*e3e2*amel2*x3^2*xcp2 +64*e3e1^2*e3e2*amel2*x3^2*x5*xcp3 -640*e3e1^2*e3e2*amel2*x3^2*x5*xcp2 +64*e3e1^2*e3e2*amel2*x3^2*x5*xcp1 +64*e3e1^2*e3e2*amel2*x3^2*x4*xcp3 -896*e3e1^2*e3e2*amel2*x3^2*x4*xcp2 +64*e3e1^2*e3e2*amel2*x3^2*x4*xcp1 -128*e3e1^2*e3e2*amel2*x3^3*xcp2 -64*e3e1^2*e3e2*amel2*x1*xcp3 -768*e3e1^2*e3e2*amel2*x1*xcp2 -64*e3e1^2*e3e2*amel2*x1*xcp1 +1664*e3e1^2*e3e2*amel2*x1*x5*xcp2 +64*e3e1^2*e3e2*amel2*x1*x5^2*xcp3 -896*e3e1^2*e3e2*amel2*x1*x5^2*xcp2 +64*e3e1^2*e3e2*amel2*x1*x5^2*xcp1 -128*e3e1^2*e3e2*amel2*x1*x4*xcp3 +1792*e3e1^2*e3e2*amel2*x1*x4*xcp2 -128*e3e1^2*e3e2*amel2*x1*x4*xcp1 +256*e3e1^2*e3e2*amel2*x1*x4*x5*xcp3 -1920*e3e1^2*e3e2*amel2*x1*x4*x5*xcp2 +256*e3e1^2*e3e2*amel2*x1*x4*x5*xcp1 +192*e3e1^2*e3e2*amel2*x1*x4^2*xcp3 -1024*e3e1^2*e3e2*amel2*x1*x4^2*xcp2 +192*e3e1^2*e3e2*amel2*x1*x4^2*xcp1 +1408*e3e1^2*e3e2*amel2*x1*x3*xcp2 +128*e3e1^2*e3e2*amel2*x1*x3*x5*xcp3 -1536*e3e1^2*e3e2*amel2*x1*x3*x5*xcp2 +128*e3e1^2*e3e2*amel2*x1*x3*x5*xcp1 +256*e3e1^2*e3e2*amel2*x1*x3*x4*xcp3 -1664*e3e1^2*e3e2*amel2*x1*x3*x4*xcp2 +256*e3e1^2*e3e2*amel2*x1*x3*x4*xcp1 +64*e3e1^2*e3e2*amel2*x1*x3^2*xcp3 -640*e3e1^2*e3e2*amel2*x1*x3^2*xcp2 +64*e3e1^2*e3e2*amel2*x1*x3^2*xcp1 +128*e3e1^2*e3e2*amel2*x1^2*xcp2 -128*e3e1^2*e3e2*amel2*x1^2*x5*xcp2 -128*e3e1^2*e3e2*amel2*x1^2*x4*xcp2 -128*e3e1^2*e3e2*amel2*x1^2*x3*xcp2 +768*e3e1^2*e3e2*e2e1*xcp2 -1920*e3e1^2*e3e2*e2e1*x5*xcp2 +1536*e3e1^2*e3e2*e2e1*x5^2*xcp2 -384*e3e1^2*e3e2*e2e1*x5^3*xcp2 -2432*e3e1^2*e3e2*e2e1*x4*xcp2 +3968*e3e1^2*e3e2*e2e1*x4*x5*xcp2 -1536*e3e1^2*e3e2*e2e1*x4*x5^2*xcp2 +2432*e3e1^2*e3e2*e2e1*x4^2*xcp2 -1920*e3e1^2*e3e2*e2e1*x4^2*x5*xcp2 -768*e3e1^2*e3e2*e2e1*x4^3*xcp2 -1536*e3e1^2*e3e2*e2e1*x3*xcp2 +2560*e3e1^2*e3e2*e2e1*x3*x5*xcp2 -1024*e3e1^2*e3e2*e2e1*x3*x5^2*xcp2 +3584*e3e1^2*e3e2*e2e1*x3*x4*xcp2 -2944*e3e1^2*e3e2*e2e1*x3*x4*x5*xcp2 -1920*e3e1^2*e3e2*e2e1*x3*x4^2*xcp2 +768*e3e1^2*e3e2*e2e1*x3^2*xcp2 -640*e3e1^2*e3e2*e2e1*x3^2*x5*xcp2 -1152*e3e1^2*e3e2*e2e1*x3^2*x4*xcp2 -768*e3e1^2*e3e2*e2e1*x1*xcp2 +1280*e3e1^2*e3e2*e2e1*x1*x5*xcp2 -512*e3e1^2*e3e2*e2e1*x1*x5^2*xcp2 +1280*e3e1^2*e3e2*e2e1*x1*x4*xcp2 -1024*e3e1^2*e3e2*e2e1*x1*x4*x5*xcp2 -512*e3e1^2*e3e2*e2e1*x1*x4^2*xcp2 +1536*e3e1^2*e3e2*e2e1*x1*x3*xcp2 -1280*e3e1^2*e3e2*e2e1*x1*x3*x5*xcp2 -1280*e3e1^2*e3e2*e2e1*x1*x3*x4*xcp2 -768*e3e1^2*e3e2*e2e1*x1*x3^2*xcp2 -256*e3e1^2*e3e2^2*xcp2 +768*e3e1^2*e3e2^2*x5*xcp2 -768*e3e1^2*e3e2^2*x5^2*xcp2 +256*e3e1^2*e3e2^2*x5^3*xcp2 +1024*e3e1^2*e3e2^2*x4*xcp2 -2048*e3e1^2*e3e2^2*x4*x5*xcp2 +1024*e3e1^2*e3e2^2*x4*x5^2*xcp2 -1280*e3e1^2*e3e2^2*x4^2*xcp2 +1280*e3e1^2*e3e2^2*x4^2*x5*xcp2 +512*e3e1^2*e3e2^2*x4^3*xcp2 +512*e3e1^2*e3e2^2*x3*xcp2 -1024*e3e1^2*e3e2^2*x3*x5*xcp2 +512*e3e1^2*e3e2^2*x3*x5^2*xcp2 -1536*e3e1^2*e3e2^2*x3*x4*xcp2 +1536*e3e1^2*e3e2^2*x3*x4*x5*xcp2 +1024*e3e1^2*e3e2^2*x3*x4^2*xcp2 -256*e3e1^2*e3e2^2*x3^2*xcp2 +256*e3e1^2*e3e2^2*x3^2*x5*xcp2 +512*e3e1^2*e3e2^2*x3^2*x4*xcp2 +256*e3e1^2*e3e2^2*x1*xcp2 -512*e3e1^2*e3e2^2*x1*x5*xcp2 +256*e3e1^2*e3e2^2*x1*x5^2*xcp2 -512*e3e1^2*e3e2^2*x1*x4*xcp2 +512*e3e1^2*e3e2^2*x1*x4*x5*xcp2 +256*e3e1^2*e3e2^2*x1*x4^2*xcp2 -512*e3e1^2*e3e2^2*x1*x3*xcp2 +512*e3e1^2*e3e2^2*x1*x3*x5*xcp2 +512*e3e1^2*e3e2^2*x1*x3*x4*xcp2 +256*e3e1^2*e3e2^2*x1*x3^2*xcp2 -64*e3e1^3*amel2*xcp3 -64*e3e1^3*amel2*xcp1 +192*e3e1^3*amel2*x5*xcp3 +192*e3e1^3*amel2*x5*xcp1 -192*e3e1^3*amel2*x5^2*xcp3 -192*e3e1^3*amel2*x5^2*xcp1 +64*e3e1^3*amel2*x5^3*xcp3 +64*e3e1^3*amel2*x5^3*xcp1 +192*e3e1^3*amel2*x4*xcp3 -128*e3e1^3*amel2*x4*xcp2 +192*e3e1^3*amel2*x4*xcp1 -384*e3e1^3*amel2*x4*x5*xcp3 +256*e3e1^3*amel2*x4*x5*xcp2 -384*e3e1^3*amel2*x4*x5*xcp1 +192*e3e1^3*amel2*x4*x5^2*xcp3 -128*e3e1^3*amel2*x4*x5^2*xcp2 +192*e3e1^3*amel2*x4*x5^2*xcp1 -192*e3e1^3*amel2*x4^2*xcp3 +256*e3e1^3*amel2*x4^2*xcp2 -192*e3e1^3*amel2*x4^2*xcp1 +192*e3e1^3*amel2*x4^2*x5*xcp3 -256*e3e1^3*amel2*x4^2*x5*xcp2 +192*e3e1^3*amel2*x4^2*x5*xcp1 +64*e3e1^3*amel2*x4^3*xcp3 -128*e3e1^3*amel2*x4^3*xcp2 +64*e3e1^3*amel2*x4^3*xcp1 +64*e3e1^3*amel2*x3*xcp3 -128*e3e1^3*amel2*x3*xcp2 +64*e3e1^3*amel2*x3*xcp1 -128*e3e1^3*amel2*x3*x5*xcp3 +256*e3e1^3*amel2*x3*x5*xcp2 -128*e3e1^3*amel2*x3*x5*xcp1 +64*e3e1^3*amel2*x3*x5^2*xcp3 -128*e3e1^3*amel2*x3*x5^2*xcp2 +64*e3e1^3*amel2*x3*x5^2*xcp1 -128*e3e1^3*amel2*x3*x4*xcp3 +384*e3e1^3*amel2*x3*x4*xcp2 -128*e3e1^3*amel2*x3*x4*xcp1 +128*e3e1^3*amel2*x3*x4*x5*xcp3 -384*e3e1^3*amel2*x3*x4*x5*xcp2 +128*e3e1^3*amel2*x3*x4*x5*xcp1 +64*e3e1^3*amel2*x3*x4^2*xcp3 -256*e3e1^3*amel2*x3*x4^2*xcp2 +64*e3e1^3*amel2*x3*x4^2*xcp1 +128*e3e1^3*amel2*x3^2*xcp2 -128*e3e1^3*amel2*x3^2*x5*xcp2 -128*e3e1^3*amel2*x3^2*x4*xcp2 +128*e3e1^3*amel2*x1*xcp3 +128*e3e1^3*amel2*x1*xcp1 -256*e3e1^3*amel2*x1*x5*xcp3 -256*e3e1^3*amel2*x1*x5*xcp1 +128*e3e1^3*amel2*x1*x5^2*xcp3 +128*e3e1^3*amel2*x1*x5^2*xcp1 -256*e3e1^3*amel2*x1*x4*xcp3 +128*e3e1^3*amel2*x1*x4*xcp2 -256*e3e1^3*amel2*x1*x4*xcp1 +256*e3e1^3*amel2*x1*x4*x5*xcp3 -128*e3e1^3*amel2*x1*x4*x5*xcp2 +256*e3e1^3*amel2*x1*x4*x5*xcp1 +128*e3e1^3*amel2*x1*x4^2*xcp3 -128*e3e1^3*amel2*x1*x4^2*xcp2 +128*e3e1^3*amel2*x1*x4^2*xcp1 -128*e3e1^3*amel2*x1*x3*xcp3 +128*e3e1^3*amel2*x1*x3*xcp2 -128*e3e1^3*amel2*x1*x3*xcp1 +128*e3e1^3*amel2*x1*x3*x5*xcp3 -128*e3e1^3*amel2*x1*x3*x5*xcp2 +128*e3e1^3*amel2*x1*x3*x5*xcp1 +128*e3e1^3*amel2*x1*x3*x4*xcp3 -256*e3e1^3*amel2*x1*x3*x4*xcp2 +128*e3e1^3*amel2*x1*x3*x4*xcp1 -128*e3e1^3*amel2*x1*x3^2*xcp2 -64*e3e1^3*amel2*x1^2*xcp3 -64*e3e1^3*amel2*x1^2*xcp1 +64*e3e1^3*amel2*x1^2*x5*xcp3 +64*e3e1^3*amel2*x1^2*x5*xcp1 +64*e3e1^3*amel2*x1^2*x4*xcp3 +64*e3e1^3*amel2*x1^2*x4*xcp1 +64*e3e1^3*amel2*x1^2*x3*xcp3 +64*e3e1^3*amel2*x1^2*x3*xcp1 +256*e3e1^3*e2e1*xcp2 -640*e3e1^3*e2e1*x5*xcp2 +512*e3e1^3*e2e1*x5^2*xcp2 -128*e3e1^3*e2e1*x5^3*xcp2 -640*e3e1^3*e2e1*x4*xcp2 +1024*e3e1^3*e2e1*x4*x5*xcp2 -384*e3e1^3*e2e1*x4*x5^2*xcp2 +512*e3e1^3*e2e1*x4^2*xcp2 -384*e3e1^3*e2e1*x4^2*x5*xcp2 -128*e3e1^3*e2e1*x4^3*xcp2 -512*e3e1^3*e2e1*x3*xcp2 +896*e3e1^3*e2e1*x3*x5*xcp2 -384*e3e1^3*e2e1*x3*x5^2*xcp2 +896*e3e1^3*e2e1*x3*x4*xcp2 -768*e3e1^3*e2e1*x3*x4*x5*xcp2 -384*e3e1^3*e2e1*x3*x4^2*xcp2 +256*e3e1^3*e2e1*x3^2*xcp2 -256*e3e1^3*e2e1*x3^2*x5*xcp2 -256*e3e1^3*e2e1*x3^2*x4*xcp2 -256*e3e1^3*e2e1*x1*xcp2 +384*e3e1^3*e2e1*x1*x5*xcp2 -128*e3e1^3*e2e1*x1*x5^2*xcp2 +384*e3e1^3*e2e1*x1*x4*xcp2 -256*e3e1^3*e2e1*x1*x4*x5*xcp2 -128*e3e1^3*e2e1*x1*x4^2*xcp2 +512*e3e1^3*e2e1*x1*x3*xcp2 -384*e3e1^3*e2e1*x1*x3*x5*xcp2 -384*e3e1^3*e2e1*x1*x3*x4*xcp2 -256*e3e1^3*e2e1*x1*x3^2*xcp2 -256*e3e1^3*e3e2*xcp2 +768*e3e1^3*e3e2*x5*xcp2 -768*e3e1^3*e3e2*x5^2*xcp2 +256*e3e1^3*e3e2*x5^3*xcp2 +768*e3e1^3*e3e2*x4*xcp2 -1536*e3e1^3*e3e2*x4*x5*xcp2 +768*e3e1^3*e3e2*x4*x5^2*xcp2 -768*e3e1^3*e3e2*x4^2*xcp2 +768*e3e1^3*e3e2*x4^2*x5*xcp2 +256*e3e1^3*e3e2*x4^3*xcp2 +512*e3e1^3*e3e2*x3*xcp2 -1024*e3e1^3*e3e2*x3*x5*xcp2 +512*e3e1^3*e3e2*x3*x5^2*xcp2 -1024*e3e1^3*e3e2*x3*x4*xcp2 +1024*e3e1^3*e3e2*x3*x4*x5*xcp2 +512*e3e1^3*e3e2*x3*x4^2*xcp2 -256*e3e1^3*e3e2*x3^2*xcp2 +256*e3e1^3*e3e2*x3^2*x5*xcp2 +256*e3e1^3*e3e2*x3^2*x4*xcp2 +256*e3e1^3*e3e2*x1*xcp2 -512*e3e1^3*e3e2*x1*x5*xcp2 +256*e3e1^3*e3e2*x1*x5^2*xcp2 -512*e3e1^3*e3e2*x1*x4*xcp2 +512*e3e1^3*e3e2*x1*x4*x5*xcp2 +256*e3e1^3*e3e2*x1*x4^2*xcp2 -512*e3e1^3*e3e2*x1*x3*xcp2 +512*e3e1^3*e3e2*x1*x3*x5*xcp2 +512*e3e1^3*e3e2*x1*x3*x4*xcp2 +256*e3e1^3*e3e2*x1*x3^2*xcp2 -48*e4e2*amel2^2*zk^2*xcp3 -64*e4e2*amel2^2*zk^2*xcp2 -48*e4e2*amel2^2*zk^2*xcp1 +48*e4e2*amel2^2*zk^2*x5*xcp3 -64*e4e2*amel2^2*zk^2*x5*xcp2 +48*e4e2*amel2^2*zk^2*x5*xcp1 +96*e4e2*amel2^2*zk^2*x4*xcp3 +96*e4e2*amel2^2*zk^2*x4*xcp1 +64*e4e2*amel2^2*zk^2*x3*xcp2 +48*e4e2*amel2^2*zk^2*x1*xcp3 +32*e4e2*amel2^2*zk^2*x1*xcp2 +48*e4e2*amel2^2*zk^2*x1*xcp1 -256*e4e2*amel2^3*x5*xcp2 -32*e4e2*amel2^3*x5^2*xcp3 -32*e4e2*amel2^3*x5^2*xcp1 +32*e4e2*amel2^3*x5^3*xcp3 +32*e4e2*amel2^3*x5^3*xcp1 +64*e4e2*amel2^3*x4*xcp3 -256*e4e2*amel2^3*x4*xcp2 +64*e4e2*amel2^3*x4*xcp1 -64*e4e2*amel2^3*x4*x5*xcp3 +192*e4e2*amel2^3*x4*x5*xcp2 -64*e4e2*amel2^3*x4*x5*xcp1 +128*e4e2*amel2^3*x4*x5^2*xcp3 -64*e4e2*amel2^3*x4*x5^2*xcp2 +128*e4e2*amel2^3*x4*x5^2*xcp1 -128*e4e2*amel2^3*x4^2*xcp3 +128*e4e2*amel2^3*x4^2*xcp2 -128*e4e2*amel2^3*x4^2*xcp1 +192*e4e2*amel2^3*x4^2*x5*xcp3 -256*e4e2*amel2^3*x4^2*x5*xcp2 +192*e4e2*amel2^3*x4^2*x5*xcp1 +128*e4e2*amel2^3*x4^3*xcp3 -128*e4e2*amel2^3*x4^3*xcp2 +128*e4e2*amel2^3*x4^3*xcp1 -64*e4e2*amel2^3*x3*xcp3 -64*e4e2*amel2^3*x3*xcp1 +64*e4e2*amel2^3*x3*x5*xcp3 +448*e4e2*amel2^3*x3*x5*xcp2 +64*e4e2*amel2^3*x3*x5*xcp1 -64*e4e2*amel2^3*x3*x5^2*xcp2 -128*e4e2*amel2^3*x3*x4*xcp3 +320*e4e2*amel2^3*x3*x4*xcp2 -128*e4e2*amel2^3*x3*x4*xcp1 +64*e4e2*amel2^3*x3*x4*x5*xcp3 -384*e4e2*amel2^3*x3*x4*x5*xcp2 +64*e4e2*amel2^3*x3*x4*x5*xcp1 +128*e4e2*amel2^3*x3*x4^2*xcp3 -128*e4e2*amel2^3*x3*x4^2*xcp2 +128*e4e2*amel2^3*x3*x4^2*xcp1 -32*e4e2*amel2^3*x3^2*xcp3 -64*e4e2*amel2^3*x3^2*xcp2 -32*e4e2*amel2^3*x3^2*xcp1 +32*e4e2*amel2^3*x3^2*x5*xcp3 -128*e4e2*amel2^3*x3^2*x5*xcp2 +32*e4e2*amel2^3*x3^2*x5*xcp1 +64*e4e2*amel2^3*x3^2*x4*xcp3 +64*e4e2*amel2^3*x3^2*x4*xcp2 +64*e4e2*amel2^3*x3^2*x4*xcp1 +64*e4e2*amel2^3*x3^3*xcp2 -128*e4e2*amel2^3*x1*xcp2 +256*e4e2*amel2^3*x1*x5*xcp2 +96*e4e2*amel2^3*x1*x5^2*xcp3 -128*e4e2*amel2^3*x1*x5^2*xcp2 +96*e4e2*amel2^3*x1*x5^2*xcp1 -128*e4e2*amel2^3*x1*x4*xcp3 +576*e4e2*amel2^3*x1*x4*xcp2 -128*e4e2*amel2^3*x1*x4*xcp1 +256*e4e2*amel2^3*x1*x4*x5*xcp3 -512*e4e2*amel2^3*x1*x4*x5*xcp2 +256*e4e2*amel2^3*x1*x4*x5*xcp1 +192*e4e2*amel2^3*x1*x4^2*xcp3 -256*e4e2*amel2^3*x1*x4^2*xcp2 +192*e4e2*amel2^3*x1*x4^2*xcp1 -128*e4e2*amel2^3*x1*x3*xcp3 +448*e4e2*amel2^3*x1*x3*xcp2 -128*e4e2*amel2^3*x1*x3*xcp1 -512*e4e2*amel2^3*x1*x3*x5*xcp2 +192*e4e2*amel2^3*x1*x3*x4*xcp3 -256*e4e2*amel2^3*x1*x3*x4*xcp2 +192*e4e2*amel2^3*x1*x3*x4*xcp1 +32*e4e2*amel2^3*x1*x3^2*xcp3 +128*e4e2*amel2^3*x1*x3^2*xcp2 +32*e4e2*amel2^3*x1*x3^2*xcp1 -96*e4e2*amel2^3*x1^2*xcp3 -96*e4e2*amel2^3*x1^2*xcp1 +96*e4e2*amel2^3*x1^2*x5*xcp3 -128*e4e2*amel2^3*x1^2*x5*xcp2 +96*e4e2*amel2^3*x1^2*x5*xcp1 +128*e4e2*amel2^3*x1^2*x4*xcp3 -64*e4e2*amel2^3*x1^2*x4*xcp2 +128*e4e2*amel2^3*x1^2*x4*xcp1 +64*e4e2*amel2^3*x1^2*x3*xcp3 +64*e4e2*amel2^3*x1^2*x3*xcp2 +64*e4e2*amel2^3*x1^2*x3*xcp1 +32*e4e2*amel2^3*x1^3*xcp3 +32*e4e2*amel2^3*x1^3*xcp1 -16*e4e2*e2e1*amel2*zk^2*xcp3 -160*e4e2*e2e1*amel2*zk^2*xcp2 -16*e4e2*e2e1*amel2*zk^2*xcp1 +96*e4e2*e2e1*amel2*zk^2*x5*xcp3 -32*e4e2*e2e1*amel2*zk^2*x5*xcp2 +96*e4e2*e2e1*amel2*zk^2*x5*xcp1 +96*e4e2*e2e1*amel2*zk^2*x4*xcp3 +64*e4e2*e2e1*amel2*zk^2*x4*xcp2 +96*e4e2*e2e1*amel2*zk^2*x4*xcp1 +96*e4e2*e2e1*amel2*zk^2*x3*xcp3 +32*e4e2*e2e1*amel2*zk^2*x3*xcp2 +96*e4e2*e2e1*amel2*zk^2*x3*xcp1 +128*e4e2*e2e1*amel2*zk^2*x1*xcp2 -512*e4e2*e2e1*amel2^2*x5*xcp2 -448*e4e2*e2e1*amel2^2*x5^2*xcp2 +64*e4e2*e2e1*amel2^2*x5^3*xcp3 +320*e4e2*e2e1*amel2^2*x5^3*xcp2 +64*e4e2*e2e1*amel2^2*x5^3*xcp1 -512*e4e2*e2e1*amel2^2*x4*xcp2 -64*e4e2*e2e1*amel2^2*x4*x5*xcp3 -64*e4e2*e2e1*amel2^2*x4*x5*xcp2 -64*e4e2*e2e1*amel2^2*x4*x5*xcp1 +256*e4e2*e2e1*amel2^2*x4*x5^2*xcp3 +320*e4e2*e2e1*amel2^2*x4*x5^2*xcp2 +256*e4e2*e2e1*amel2^2*x4*x5^2*xcp1 -192*e4e2*e2e1*amel2^2*x4^2*xcp3 +256*e4e2*e2e1*amel2^2*x4^2*xcp2 -192*e4e2*e2e1*amel2^2*x4^2*xcp1 +448*e4e2*e2e1*amel2^2*x4^2*x5*xcp3 -384*e4e2*e2e1*amel2^2*x4^2*x5*xcp2 +448*e4e2*e2e1*amel2^2*x4^2*x5*xcp1 +256*e4e2*e2e1*amel2^2*x4^3*xcp3 -256*e4e2*e2e1*amel2^2*x4^3*xcp2 +256*e4e2*e2e1*amel2^2*x4^3*xcp1 -128*e4e2*e2e1*amel2^2*x3*xcp3 -128*e4e2*e2e1*amel2^2*x3*xcp1 +128*e4e2*e2e1*amel2^2*x3*x5*xcp3 +832*e4e2*e2e1*amel2^2*x3*x5*xcp2 +128*e4e2*e2e1*amel2^2*x3*x5*xcp1 -128*e4e2*e2e1*amel2^2*x3*x4*xcp3 +832*e4e2*e2e1*amel2^2*x3*x4*xcp2 -128*e4e2*e2e1*amel2^2*x3*x4*xcp1 +192*e4e2*e2e1*amel2^2*x3*x4*x5*xcp3 -1152*e4e2*e2e1*amel2^2*x3*x4*x5*xcp2 +192*e4e2*e2e1*amel2^2*x3*x4*x5*xcp1 +384*e4e2*e2e1*amel2^2*x3*x4^2*xcp3 -640*e4e2*e2e1*amel2^2*x3*x4^2*xcp2 +384*e4e2*e2e1*amel2^2*x3*x4^2*xcp1 +128*e4e2*e2e1*amel2^2*x3^2*xcp2 +64*e4e2*e2e1*amel2^2*x3^2*x5*xcp3 -576*e4e2*e2e1*amel2^2*x3^2*x5*xcp2 +64*e4e2*e2e1*amel2^2*x3^2*x5*xcp1 +192*e4e2*e2e1*amel2^2*x3^2*x4*xcp3 -192*e4e2*e2e1*amel2^2*x3^2*x4*xcp2 +192*e4e2*e2e1*amel2^2*x3^2*x4*xcp1 +64*e4e2*e2e1*amel2^2*x3^3*xcp3 +64*e4e2*e2e1*amel2^2*x3^3*xcp1 -128*e4e2*e2e1*amel2^2*x1*xcp3 -384*e4e2*e2e1*amel2^2*x1*xcp2 -128*e4e2*e2e1*amel2^2*x1*xcp1 +64*e4e2*e2e1*amel2^2*x1*x5*xcp3 +768*e4e2*e2e1*amel2^2*x1*x5*xcp2 +64*e4e2*e2e1*amel2^2*x1*x5*xcp1 +128*e4e2*e2e1*amel2^2*x1*x5^2*xcp3 -320*e4e2*e2e1*amel2^2*x1*x5^2*xcp2 +128*e4e2*e2e1*amel2^2*x1*x5^2*xcp1 -256*e4e2*e2e1*amel2^2*x1*x4*xcp3 +960*e4e2*e2e1*amel2^2*x1*x4*xcp2 -256*e4e2*e2e1*amel2^2*x1*x4*xcp1 +384*e4e2*e2e1*amel2^2*x1*x4*x5*xcp3 -1152*e4e2*e2e1*amel2^2*x1*x4*x5*xcp2 +384*e4e2*e2e1*amel2^2*x1*x4*x5*xcp1 +320*e4e2*e2e1*amel2^2*x1*x4^2*xcp3 -384*e4e2*e2e1*amel2^2*x1*x4^2*xcp2 +320*e4e2*e2e1*amel2^2*x1*x4^2*xcp1 -64*e4e2*e2e1*amel2^2*x1*x3*xcp3 +832*e4e2*e2e1*amel2^2*x1*x3*xcp2 -64*e4e2*e2e1*amel2^2*x1*x3*xcp1 +256*e4e2*e2e1*amel2^2*x1*x3*x5*xcp3 -1280*e4e2*e2e1*amel2^2*x1*x3*x5*xcp2 +256*e4e2*e2e1*amel2^2*x1*x3*x5*xcp1 +448*e4e2*e2e1*amel2^2*x1*x3*x4*xcp3 -640*e4e2*e2e1*amel2^2*x1*x3*x4*xcp2 +448*e4e2*e2e1*amel2^2*x1*x3*x4*xcp1 +128*e4e2*e2e1*amel2^2*x1*x3^2*xcp3 -64*e4e2*e2e1*amel2^2*x1*x3^2*xcp2 +128*e4e2*e2e1*amel2^2*x1*x3^2*xcp1 -64*e4e2*e2e1*amel2^2*x1^2*xcp3 -64*e4e2*e2e1*amel2^2*x1^2*xcp2 -64*e4e2*e2e1*amel2^2*x1^2*xcp1 +64*e4e2*e2e1*amel2^2*x1^2*x5*xcp3 -192*e4e2*e2e1*amel2^2*x1^2*x5*xcp2 +64*e4e2*e2e1*amel2^2*x1^2*x5*xcp1 +128*e4e2*e2e1*amel2^2*x1^2*x4*xcp3 -64*e4e2*e2e1*amel2^2*x1^2*x4*xcp2 +128*e4e2*e2e1*amel2^2*x1^2*x4*xcp1 +128*e4e2*e2e1*amel2^2*x1^2*x3*xcp3 +128*e4e2*e2e1*amel2^2*x1^2*x3*xcp2 +128*e4e2*e2e1*amel2^2*x1^2*x3*xcp1 +64*e4e2*e2e1*amel2^2*x1^3*xcp2 +64*e4e2*e2e1^2*zk^2*xcp2 +64*e4e2*e2e1^2*zk^2*x4*xcp2 -64*e4e2*e2e1^2*zk^2*x3*xcp2 +128*e4e2*e2e1^2*amel2*x5*xcp3 -256*e4e2*e2e1^2*amel2*x5*xcp2 +128*e4e2*e2e1^2*amel2*x5*xcp1 -64*e4e2*e2e1^2*amel2*x5^2*xcp3 -896*e4e2*e2e1^2*amel2*x5^2*xcp2 -64*e4e2*e2e1^2*amel2*x5^2*xcp1 +640*e4e2*e2e1^2*amel2*x5^3*xcp2 -64*e4e2*e2e1^2*amel2*x4*xcp3 -640*e4e2*e2e1^2*amel2*x4*xcp2 -64*e4e2*e2e1^2*amel2*x4*xcp1 -512*e4e2*e2e1^2*amel2*x4*x5*xcp2 +128*e4e2*e2e1^2*amel2*x4*x5^2*xcp3 +1024*e4e2*e2e1^2*amel2*x4*x5^2*xcp2 +128*e4e2*e2e1^2*amel2*x4*x5^2*xcp1 -64*e4e2*e2e1^2*amel2*x4^2*xcp3 +384*e4e2*e2e1^2*amel2*x4^2*xcp2 -64*e4e2*e2e1^2*amel2*x4^2*xcp1 +256*e4e2*e2e1^2*amel2*x4^2*x5*xcp3 +128*e4e2*e2e1^2*amel2*x4^2*x5*xcp2 +256*e4e2*e2e1^2*amel2*x4^2*x5*xcp1 +128*e4e2*e2e1^2*amel2*x4^3*xcp3 -128*e4e2*e2e1^2*amel2*x4^3*xcp2 +128*e4e2*e2e1^2*amel2*x4^3*xcp1 -64*e4e2*e2e1^2*amel2*x3*xcp3 -64*e4e2*e2e1^2*amel2*x3*xcp1 +128*e4e2*e2e1^2*amel2*x3*x5*xcp2 -64*e4e2*e2e1^2*amel2*x3*x5^2*xcp3 +512*e4e2*e2e1^2*amel2*x3*x5^2*xcp2 -64*e4e2*e2e1^2*amel2*x3*x5^2*xcp1 +1152*e4e2*e2e1^2*amel2*x3*x4*xcp2 +128*e4e2*e2e1^2*amel2*x3*x4*x5*xcp3 -640*e4e2*e2e1^2*amel2*x3*x4*x5*xcp2 +128*e4e2*e2e1^2*amel2*x3*x4*x5*xcp1 +256*e4e2*e2e1^2*amel2*x3*x4^2*xcp3 -768*e4e2*e2e1^2*amel2*x3*x4^2*xcp2 +256*e4e2*e2e1^2*amel2*x3*x4^2*xcp1 +256*e4e2*e2e1^2*amel2*x3^2*xcp2 -128*e4e2*e2e1^2*amel2*x3^2*x5*xcp3 -256*e4e2*e2e1^2*amel2*x3^2*x5*xcp2 -128*e4e2*e2e1^2*amel2*x3^2*x5*xcp1 +128*e4e2*e2e1^2*amel2*x3^2*x4*xcp3 -512*e4e2*e2e1^2*amel2*x3^2*x4*xcp2 +128*e4e2*e2e1^2*amel2*x3^2*x4*xcp1 -128*e4e2*e2e1^2*amel2*x3^3*xcp2 -640*e4e2*e2e1^2*amel2*x1*xcp2 -64*e4e2*e2e1^2*amel2*x1*x5*xcp3 +1152*e4e2*e2e1^2*amel2*x1*x5*xcp2 -64*e4e2*e2e1^2*amel2*x1*x5*xcp1 -384*e4e2*e2e1^2*amel2*x1*x5^2*xcp2 -128*e4e2*e2e1^2*amel2*x1*x4*xcp3 +384*e4e2*e2e1^2*amel2*x1*x4*xcp2 -128*e4e2*e2e1^2*amel2*x1*x4*xcp1 +128*e4e2*e2e1^2*amel2*x1*x4*x5*xcp3 -640*e4e2*e2e1^2*amel2*x1*x4*x5*xcp2 +128*e4e2*e2e1^2*amel2*x1*x4*x5*xcp1 +128*e4e2*e2e1^2*amel2*x1*x4^2*xcp3 -128*e4e2*e2e1^2*amel2*x1*x4^2*xcp2 +128*e4e2*e2e1^2*amel2*x1*x4^2*xcp1 -64*e4e2*e2e1^2*amel2*x1*x3*xcp3 +640*e4e2*e2e1^2*amel2*x1*x3*xcp2 -64*e4e2*e2e1^2*amel2*x1*x3*xcp1 +128*e4e2*e2e1^2*amel2*x1*x3*x5*xcp3 -1024*e4e2*e2e1^2*amel2*x1*x3*x5*xcp2 +128*e4e2*e2e1^2*amel2*x1*x3*x5*xcp1 +256*e4e2*e2e1^2*amel2*x1*x3*x4*xcp3 -384*e4e2*e2e1^2*amel2*x1*x3*x4*xcp2 +256*e4e2*e2e1^2*amel2*x1*x3*x4*xcp1 +128*e4e2*e2e1^2*amel2*x1*x3^2*xcp3 -256*e4e2*e2e1^2*amel2*x1*x3^2*xcp2 +128*e4e2*e2e1^2*amel2*x1*x3^2*xcp1 +256*e4e2*e2e1^2*amel2*x1^2*xcp2 -256*e4e2*e2e1^2*amel2*x1^2*x5*xcp2 +384*e4e2*e2e1^3*x5*xcp2 -768*e4e2*e2e1^3*x5^2*xcp2 +384*e4e2*e2e1^3*x5^3*xcp2 -384*e4e2*e2e1^3*x4*xcp2 -256*e4e2*e2e1^3*x4*x5*xcp2 +640*e4e2*e2e1^3*x4*x5^2*xcp2 +256*e4e2*e2e1^3*x4^2*xcp2 +256*e4e2*e2e1^3*x4^2*x5*xcp2 -640*e4e2*e2e1^3*x3*x5*xcp2 +640*e4e2*e2e1^3*x3*x5^2*xcp2 +640*e4e2*e2e1^3*x3*x4*xcp2 +128*e4e2*e2e1^3*x3*x4*x5*xcp2 -256*e4e2*e2e1^3*x3*x4^2*xcp2 +256*e4e2*e2e1^3*x3^2*x5*xcp2 -256*e4e2*e2e1^3*x3^2*x4*xcp2 +32*e4e2*e3e2*amel2*zk^2*xcp3 +32*e4e2*e3e2*amel2*zk^2*xcp2 +32*e4e2*e3e2*amel2*zk^2*xcp1 -96*e4e2*e3e2*amel2*zk^2*x5*xcp3 +96*e4e2*e3e2*amel2*zk^2*x5*xcp2 -96*e4e2*e3e2*amel2*zk^2*x5*xcp1 -48*e4e2*e3e2*amel2*zk^2*x4*xcp3 -48*e4e2*e3e2*amel2*zk^2*x4*xcp1 -48*e4e2*e3e2*amel2*zk^2*x3*xcp3 -32*e4e2*e3e2*amel2*zk^2*x3*xcp2 -48*e4e2*e3e2*amel2*zk^2*x3*xcp1 +256*e4e2*e3e2*amel2^2*x5*xcp2 +320*e4e2*e3e2*amel2^2*x5^2*xcp2 -64*e4e2*e3e2*amel2^2*x5^3*xcp3 -192*e4e2*e3e2*amel2^2*x5^3*xcp2 -64*e4e2*e3e2*amel2^2*x5^3*xcp1 +64*e4e2*e3e2*amel2^2*x4*xcp3 +256*e4e2*e3e2*amel2^2*x4*xcp2 +64*e4e2*e3e2*amel2^2*x4*xcp1 +128*e4e2*e3e2*amel2^2*x4*x5*xcp3 -192*e4e2*e3e2*amel2^2*x4*x5*xcp2 +128*e4e2*e3e2*amel2^2*x4*x5*xcp1 -224*e4e2*e3e2*amel2^2*x4*x5^2*xcp3 +64*e4e2*e3e2*amel2^2*x4*x5^2*xcp2 -224*e4e2*e3e2*amel2^2*x4*x5^2*xcp1 +256*e4e2*e3e2*amel2^2*x4^2*xcp3 -384*e4e2*e3e2*amel2^2*x4^2*xcp2 +256*e4e2*e3e2*amel2^2*x4^2*xcp1 -384*e4e2*e3e2*amel2^2*x4^2*x5*xcp3 +640*e4e2*e3e2*amel2^2*x4^2*x5*xcp2 -384*e4e2*e3e2*amel2^2*x4^2*x5*xcp1 -192*e4e2*e3e2*amel2^2*x4^3*xcp3 +256*e4e2*e3e2*amel2^2*x4^3*xcp2 -192*e4e2*e3e2*amel2^2*x4^3*xcp1 +64*e4e2*e3e2*amel2^2*x3*xcp3 +64*e4e2*e3e2*amel2^2*x3*xcp1 -64*e4e2*e3e2*amel2^2*x3*x5*xcp3 -576*e4e2*e3e2*amel2^2*x3*x5*xcp2 -64*e4e2*e3e2*amel2^2*x3*x5*xcp1 +32*e4e2*e3e2*amel2^2*x3*x5^2*xcp3 +32*e4e2*e3e2*amel2^2*x3*x5^2*xcp1 +192*e4e2*e3e2*amel2^2*x3*x4*xcp3 -576*e4e2*e3e2*amel2^2*x3*x4*xcp2 +192*e4e2*e3e2*amel2^2*x3*x4*xcp1 -128*e4e2*e3e2*amel2^2*x3*x4*x5*xcp3 +896*e4e2*e3e2*amel2^2*x3*x4*x5*xcp2 -128*e4e2*e3e2*amel2^2*x3*x4*x5*xcp1 -256*e4e2*e3e2*amel2^2*x3*x4^2*xcp3 +384*e4e2*e3e2*amel2^2*x3*x4^2*xcp2 -256*e4e2*e3e2*amel2^2*x3*x4^2*xcp1 -128*e4e2*e3e2*amel2^2*x3^2*xcp2 -64*e4e2*e3e2*amel2^2*x3^2*x5*xcp3 +448*e4e2*e3e2*amel2^2*x3^2*x5*xcp2 -64*e4e2*e3e2*amel2^2*x3^2*x5*xcp1 -96*e4e2*e3e2*amel2^2*x3^2*x4*xcp3 +64*e4e2*e3e2*amel2^2*x3^2*x4*xcp2 -96*e4e2*e3e2*amel2^2*x3^2*x4*xcp1 -32*e4e2*e3e2*amel2^2*x3^3*xcp3 -32*e4e2*e3e2*amel2^2*x3^3*xcp1 +128*e4e2*e3e2*amel2^2*x1*xcp3 +256*e4e2*e3e2*amel2^2*x1*xcp2 +128*e4e2*e3e2*amel2^2*x1*xcp1 -32*e4e2*e3e2*amel2^2*x1*x5*xcp3 -704*e4e2*e3e2*amel2^2*x1*x5*xcp2 -32*e4e2*e3e2*amel2^2*x1*x5*xcp1 -128*e4e2*e3e2*amel2^2*x1*x5^2*xcp3 +256*e4e2*e3e2*amel2^2*x1*x5^2*xcp2 -128*e4e2*e3e2*amel2^2*x1*x5^2*xcp1 +64*e4e2*e3e2*amel2^2*x1*x4*xcp3 -1152*e4e2*e3e2*amel2^2*x1*x4*xcp2 +64*e4e2*e3e2*amel2^2*x1*x4*xcp1 -256*e4e2*e3e2*amel2^2*x1*x4*x5*xcp3 +1024*e4e2*e3e2*amel2^2*x1*x4*x5*xcp2 -256*e4e2*e3e2*amel2^2*x1*x4*x5*xcp1 -128*e4e2*e3e2*amel2^2*x1*x4^2*xcp3 +512*e4e2*e3e2*amel2^2*x1*x4^2*xcp2 -128*e4e2*e3e2*amel2^2*x1*x4^2*xcp1 +32*e4e2*e3e2*amel2^2*x1*x3*xcp3 -960*e4e2*e3e2*amel2^2*x1*x3*xcp2 +32*e4e2*e3e2*amel2^2*x1*x3*xcp1 -128*e4e2*e3e2*amel2^2*x1*x3*x5*xcp3 +1024*e4e2*e3e2*amel2^2*x1*x3*x5*xcp2 -128*e4e2*e3e2*amel2^2*x1*x3*x5*xcp1 -192*e4e2*e3e2*amel2^2*x1*x3*x4*xcp3 +768*e4e2*e3e2*amel2^2*x1*x3*x4*xcp2 -192*e4e2*e3e2*amel2^2*x1*x3*x4*xcp1 -64*e4e2*e3e2*amel2^2*x1*x3^2*xcp3 +256*e4e2*e3e2*amel2^2*x1*x3^2*xcp2 -64*e4e2*e3e2*amel2^2*x1*x3^2*xcp1 +32*e4e2*e3e2*amel2^2*x1^2*xcp3 +32*e4e2*e3e2*amel2^2*x1^2*xcp1 -64*e4e2*e3e2*amel2^2*x1^2*x5*xcp3 +192*e4e2*e3e2*amel2^2*x1^2*x5*xcp2 -64*e4e2*e3e2*amel2^2*x1^2*x5*xcp1 -32*e4e2*e3e2*amel2^2*x1^2*x4*xcp3 +64*e4e2*e3e2*amel2^2*x1^2*x4*xcp2 -32*e4e2*e3e2*amel2^2*x1^2*x4*xcp1 -32*e4e2*e3e2*amel2^2*x1^2*x3*xcp3 -32*e4e2*e3e2*amel2^2*x1^2*x3*xcp1 -64*e4e2*e3e2*e2e1*zk^2*xcp2 -64*e4e2*e3e2*e2e1*zk^2*x4*xcp2 +64*e4e2*e3e2*e2e1*zk^2*x3*xcp2 -128*e4e2*e3e2*e2e1*amel2*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x5*xcp2 -128*e4e2*e3e2*e2e1*amel2*x5*xcp1 +64*e4e2*e3e2*e2e1*amel2*x5^2*xcp3 +1152*e4e2*e3e2*e2e1*amel2*x5^2*xcp2 +64*e4e2*e3e2*e2e1*amel2*x5^2*xcp1 -768*e4e2*e3e2*e2e1*amel2*x5^3*xcp2 +64*e4e2*e3e2*e2e1*amel2*x4*xcp3 +1024*e4e2*e3e2*e2e1*amel2*x4*xcp2 +64*e4e2*e3e2*e2e1*amel2*x4*xcp1 +128*e4e2*e3e2*e2e1*amel2*x4*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x4*x5*xcp2 +128*e4e2*e3e2*e2e1*amel2*x4*x5*xcp1 -256*e4e2*e3e2*e2e1*amel2*x4*x5^2*xcp3 -896*e4e2*e3e2*e2e1*amel2*x4*x5^2*xcp2 -256*e4e2*e3e2*e2e1*amel2*x4*x5^2*xcp1 +192*e4e2*e3e2*e2e1*amel2*x4^2*xcp3 -640*e4e2*e3e2*e2e1*amel2*x4^2*xcp2 +192*e4e2*e3e2*e2e1*amel2*x4^2*xcp1 -448*e4e2*e3e2*e2e1*amel2*x4^2*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x4^2*x5*xcp2 -448*e4e2*e3e2*e2e1*amel2*x4^2*x5*xcp1 -192*e4e2*e3e2*e2e1*amel2*x4^3*xcp3 +256*e4e2*e3e2*e2e1*amel2*x4^3*xcp2 -192*e4e2*e3e2*e2e1*amel2*x4^3*xcp1 +64*e4e2*e3e2*e2e1*amel2*x3*xcp3 +64*e4e2*e3e2*e2e1*amel2*x3*xcp1 +128*e4e2*e3e2*e2e1*amel2*x3*x5^2*xcp3 -640*e4e2*e3e2*e2e1*amel2*x3*x5^2*xcp2 +128*e4e2*e3e2*e2e1*amel2*x3*x5^2*xcp1 +128*e4e2*e3e2*e2e1*amel2*x3*x4*xcp3 -1536*e4e2*e3e2*e2e1*amel2*x3*x4*xcp2 +128*e4e2*e3e2*e2e1*amel2*x3*x4*xcp1 -256*e4e2*e3e2*e2e1*amel2*x3*x4*x5*xcp3 +1024*e4e2*e3e2*e2e1*amel2*x3*x4*x5*xcp2 -256*e4e2*e3e2*e2e1*amel2*x3*x4*x5*xcp1 -384*e4e2*e3e2*e2e1*amel2*x3*x4^2*xcp3 +1024*e4e2*e3e2*e2e1*amel2*x3*x4^2*xcp2 -384*e4e2*e3e2*e2e1*amel2*x3*x4^2*xcp1 -256*e4e2*e3e2*e2e1*amel2*x3^2*xcp2 +192*e4e2*e3e2*e2e1*amel2*x3^2*x5*xcp3 +256*e4e2*e3e2*e2e1*amel2*x3^2*x5*xcp2 +192*e4e2*e3e2*e2e1*amel2*x3^2*x5*xcp1 -192*e4e2*e3e2*e2e1*amel2*x3^2*x4*xcp3 +640*e4e2*e3e2*e2e1*amel2*x3^2*x4*xcp2 -192*e4e2*e3e2*e2e1*amel2*x3^2*x4*xcp1 +128*e4e2*e3e2*e2e1*amel2*x3^3*xcp2 +1024*e4e2*e3e2*e2e1*amel2*x1*xcp2 +64*e4e2*e3e2*e2e1*amel2*x1*x5*xcp3 -1664*e4e2*e3e2*e2e1*amel2*x1*x5*xcp2 +64*e4e2*e3e2*e2e1*amel2*x1*x5*xcp1 +512*e4e2*e3e2*e2e1*amel2*x1*x5^2*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1*x4*xcp3 -1408*e4e2*e3e2*e2e1*amel2*x1*x4*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1*x4*xcp1 -128*e4e2*e3e2*e2e1*amel2*x1*x4*x5*xcp3 +1152*e4e2*e3e2*e2e1*amel2*x1*x4*x5*xcp2 -128*e4e2*e3e2*e2e1*amel2*x1*x4*x5*xcp1 -64*e4e2*e3e2*e2e1*amel2*x1*x4^2*xcp3 +384*e4e2*e3e2*e2e1*amel2*x1*x4^2*xcp2 -64*e4e2*e3e2*e2e1*amel2*x1*x4^2*xcp1 +64*e4e2*e3e2*e2e1*amel2*x1*x3*xcp3 -1536*e4e2*e3e2*e2e1*amel2*x1*x3*xcp2 +64*e4e2*e3e2*e2e1*amel2*x1*x3*xcp1 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x5*xcp3 +1408*e4e2*e3e2*e2e1*amel2*x1*x3*x5*xcp2 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x5*xcp1 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x4*xcp3 +896*e4e2*e3e2*e2e1*amel2*x1*x3*x4*xcp2 -128*e4e2*e3e2*e2e1*amel2*x1*x3*x4*xcp1 -64*e4e2*e3e2*e2e1*amel2*x1*x3^2*xcp3 +512*e4e2*e3e2*e2e1*amel2*x1*x3^2*xcp2 -64*e4e2*e3e2*e2e1*amel2*x1*x3^2*xcp1 -256*e4e2*e3e2*e2e1*amel2*x1^2*xcp2 +256*e4e2*e3e2*e2e1*amel2*x1^2*x5*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1^2*x4*xcp2 +128*e4e2*e3e2*e2e1*amel2*x1^2*x3*xcp2 -768*e4e2*e3e2*e2e1^2*x5*xcp2 +1536*e4e2*e3e2*e2e1^2*x5^2*xcp2 -768*e4e2*e3e2*e2e1^2*x5^3*xcp2 +768*e4e2*e3e2*e2e1^2*x4*xcp2 +512*e4e2*e3e2*e2e1^2*x4*x5*xcp2 -1280*e4e2*e3e2*e2e1^2*x4*x5^2*xcp2 -512*e4e2*e3e2*e2e1^2*x4^2*xcp2 -512*e4e2*e3e2*e2e1^2*x4^2*x5*xcp2 +1280*e4e2*e3e2*e2e1^2*x3*x5*xcp2 -1280*e4e2*e3e2*e2e1^2*x3*x5^2*xcp2 -1280*e4e2*e3e2*e2e1^2*x3*x4*xcp2 -256*e4e2*e3e2*e2e1^2*x3*x4*x5*xcp2 +512*e4e2*e3e2*e2e1^2*x3*x4^2*xcp2 -512*e4e2*e3e2*e2e1^2*x3^2*x5*xcp2 +512*e4e2*e3e2*e2e1^2*x3^2*x4*xcp2 -256*e4e2*e3e2^2*amel2*x5^2*xcp2 +128*e4e2*e3e2^2*amel2*x5^3*xcp2 -384*e4e2*e3e2^2*amel2*x4*xcp2 -128*e4e2*e3e2^2*amel2*x4*x5*xcp3 +256*e4e2*e3e2^2*amel2*x4*x5*xcp2 -128*e4e2*e3e2^2*amel2*x4*x5*xcp1 +128*e4e2*e3e2^2*amel2*x4*x5^2*xcp3 -128*e4e2*e3e2^2*amel2*x4*x5^2*xcp2 +128*e4e2*e3e2^2*amel2*x4*x5^2*xcp1 -128*e4e2*e3e2^2*amel2*x4^2*xcp3 +256*e4e2*e3e2^2*amel2*x4^2*xcp2 -128*e4e2*e3e2^2*amel2*x4^2*xcp1 +192*e4e2*e3e2^2*amel2*x4^2*x5*xcp3 -384*e4e2*e3e2^2*amel2*x4^2*x5*xcp2 +192*e4e2*e3e2^2*amel2*x4^2*x5*xcp1 +64*e4e2*e3e2^2*amel2*x4^3*xcp3 -128*e4e2*e3e2^2*amel2*x4^3*xcp2 +64*e4e2*e3e2^2*amel2*x4^3*xcp1 -128*e4e2*e3e2^2*amel2*x3*x5*xcp2 -64*e4e2*e3e2^2*amel2*x3*x5^2*xcp3 +128*e4e2*e3e2^2*amel2*x3*x5^2*xcp2 -64*e4e2*e3e2^2*amel2*x3*x5^2*xcp1 -128*e4e2*e3e2^2*amel2*x3*x4*xcp3 +384*e4e2*e3e2^2*amel2*x3*x4*xcp2 -128*e4e2*e3e2^2*amel2*x3*x4*xcp1 +128*e4e2*e3e2^2*amel2*x3*x4*x5*xcp3 -384*e4e2*e3e2^2*amel2*x3*x4*x5*xcp2 +128*e4e2*e3e2^2*amel2*x3*x4*x5*xcp1 +128*e4e2*e3e2^2*amel2*x3*x4^2*xcp3 -256*e4e2*e3e2^2*amel2*x3*x4^2*xcp2 +128*e4e2*e3e2^2*amel2*x3*x4^2*xcp1 -64*e4e2*e3e2^2*amel2*x3^2*x5*xcp3 -64*e4e2*e3e2^2*amel2*x3^2*x5*xcp1 +64*e4e2*e3e2^2*amel2*x3^2*x4*xcp3 -128*e4e2*e3e2^2*amel2*x3^2*x4*xcp2 +64*e4e2*e3e2^2*amel2*x3^2*x4*xcp1 -384*e4e2*e3e2^2*amel2*x1*xcp2 +512*e4e2*e3e2^2*amel2*x1*x5*xcp2 -128*e4e2*e3e2^2*amel2*x1*x5^2*xcp2 +768*e4e2*e3e2^2*amel2*x1*x4*xcp2 -512*e4e2*e3e2^2*amel2*x1*x4*x5*xcp2 -256*e4e2*e3e2^2*amel2*x1*x4^2*xcp2 +640*e4e2*e3e2^2*amel2*x1*x3*xcp2 -384*e4e2*e3e2^2*amel2*x1*x3*x5*xcp2 -512*e4e2*e3e2^2*amel2*x1*x3*x4*xcp2 -256*e4e2*e3e2^2*amel2*x1*x3^2*xcp2 +384*e4e2*e3e2^2*e2e1*x5*xcp2 -768*e4e2*e3e2^2*e2e1*x5^2*xcp2 +384*e4e2*e3e2^2*e2e1*x5^3*xcp2 -384*e4e2*e3e2^2*e2e1*x4*xcp2 -256*e4e2*e3e2^2*e2e1*x4*x5*xcp2 +640*e4e2*e3e2^2*e2e1*x4*x5^2*xcp2 +256*e4e2*e3e2^2*e2e1*x4^2*xcp2 +256*e4e2*e3e2^2*e2e1*x4^2*x5*xcp2 -640*e4e2*e3e2^2*e2e1*x3*x5*xcp2 +640*e4e2*e3e2^2*e2e1*x3*x5^2*xcp2 +640*e4e2*e3e2^2*e2e1*x3*x4*xcp2 +128*e4e2*e3e2^2*e2e1*x3*x4*x5*xcp2 -256*e4e2*e3e2^2*e2e1*x3*x4^2*xcp2 +256*e4e2*e3e2^2*e2e1*x3^2*x5*xcp2 -256*e4e2*e3e2^2*e2e1*x3^2*x4*xcp2 +16*e4e2*e3e1*amel2*zk^2*xcp3 -64*e4e2*e3e1*amel2*zk^2*xcp2 +16*e4e2*e3e1*amel2*zk^2*xcp1 -48*e4e2*e3e1*amel2*zk^2*x5*xcp3 +128*e4e2*e3e1*amel2*zk^2*x5*xcp2 -48*e4e2*e3e1*amel2*zk^2*x5*xcp1 -96*e4e2*e3e1*amel2*zk^2*x4*xcp3 +160*e4e2*e3e1*amel2*zk^2*x4*xcp2 -96*e4e2*e3e1*amel2*zk^2*x4*xcp1 -48*e4e2*e3e1*amel2*zk^2*x3*xcp3 +160*e4e2*e3e1*amel2*zk^2*x3*xcp2 -48*e4e2*e3e1*amel2*zk^2*x3*xcp1 -32*e4e2*e3e1*amel2*zk^2*x1*xcp2 -64*e4e2*e3e1*amel2^2*xcp3 -256*e4e2*e3e1*amel2^2*xcp2 -64*e4e2*e3e1*amel2^2*xcp1 +96*e4e2*e3e1*amel2^2*x5*xcp3 +1024*e4e2*e3e1*amel2^2*x5*xcp2 +96*e4e2*e3e1*amel2^2*x5*xcp1 +64*e4e2*e3e1*amel2^2*x5^2*xcp3 -448*e4e2*e3e1*amel2^2*x5^2*xcp2 +64*e4e2*e3e1*amel2^2*x5^2*xcp1 -96*e4e2*e3e1*amel2^2*x5^3*xcp3 +128*e4e2*e3e1*amel2^2*x5^3*xcp2 -96*e4e2*e3e1*amel2^2*x5^3*xcp1 -32*e4e2*e3e1*amel2^2*x4*xcp3 +1280*e4e2*e3e1*amel2^2*x4*xcp2 -32*e4e2*e3e1*amel2^2*x4*xcp1 +160*e4e2*e3e1*amel2^2*x4*x5*xcp3 -1600*e4e2*e3e1*amel2^2*x4*x5*xcp2 +160*e4e2*e3e1*amel2^2*x4*x5*xcp1 -384*e4e2*e3e1*amel2^2*x4*x5^2*xcp3 +640*e4e2*e3e1*amel2^2*x4*x5^2*xcp2 -384*e4e2*e3e1*amel2^2*x4*x5^2*xcp1 +192*e4e2*e3e1*amel2^2*x4^2*xcp3 -1088*e4e2*e3e1*amel2^2*x4^2*xcp2 +192*e4e2*e3e1*amel2^2*x4^2*xcp1 -512*e4e2*e3e1*amel2^2*x4^2*x5*xcp3 +1024*e4e2*e3e1*amel2^2*x4^2*x5*xcp2 -512*e4e2*e3e1*amel2^2*x4^2*x5*xcp1 -256*e4e2*e3e1*amel2^2*x4^3*xcp3 +512*e4e2*e3e1*amel2^2*x4^3*xcp2 -256*e4e2*e3e1*amel2^2*x4^3*xcp1 +192*e4e2*e3e1*amel2^2*x3*xcp3 +768*e4e2*e3e1*amel2^2*x3*xcp2 +192*e4e2*e3e1*amel2^2*x3*xcp1 -160*e4e2*e3e1*amel2^2*x3*x5*xcp3 -1728*e4e2*e3e1*amel2^2*x3*x5*xcp2 -160*e4e2*e3e1*amel2^2*x3*x5*xcp1 -32*e4e2*e3e1*amel2^2*x3*x5^2*xcp3 +512*e4e2*e3e1*amel2^2*x3*x5^2*xcp2 -32*e4e2*e3e1*amel2^2*x3*x5^2*xcp1 +160*e4e2*e3e1*amel2^2*x3*x4*xcp3 -1856*e4e2*e3e1*amel2^2*x3*x4*xcp2 +160*e4e2*e3e1*amel2^2*x3*x4*xcp1 -256*e4e2*e3e1*amel2^2*x3*x4*x5*xcp3 +1408*e4e2*e3e1*amel2^2*x3*x4*x5*xcp2 -256*e4e2*e3e1*amel2^2*x3*x4*x5*xcp1 -320*e4e2*e3e1*amel2^2*x3*x4^2*xcp3 +1024*e4e2*e3e1*amel2^2*x3*x4^2*xcp2 -320*e4e2*e3e1*amel2^2*x3*x4^2*xcp1 +32*e4e2*e3e1*amel2^2*x3^2*xcp3 -448*e4e2*e3e1*amel2^2*x3^2*xcp2 +32*e4e2*e3e1*amel2^2*x3^2*xcp1 -32*e4e2*e3e1*amel2^2*x3^2*x5*xcp3 +256*e4e2*e3e1*amel2^2*x3^2*x5*xcp2 -32*e4e2*e3e1*amel2^2*x3^2*x5*xcp1 -128*e4e2*e3e1*amel2^2*x3^2*x4*xcp3 +512*e4e2*e3e1*amel2^2*x3^2*x4*xcp2 -128*e4e2*e3e1*amel2^2*x3^2*x4*xcp1 -32*e4e2*e3e1*amel2^2*x3^3*xcp3 +128*e4e2*e3e1*amel2^2*x3^3*xcp2 -32*e4e2*e3e1*amel2^2*x3^3*xcp1 +64*e4e2*e3e1*amel2^2*x1*xcp3 +640*e4e2*e3e1*amel2^2*x1*xcp2 +64*e4e2*e3e1*amel2^2*x1*xcp1 +32*e4e2*e3e1*amel2^2*x1*x5*xcp3 -1088*e4e2*e3e1*amel2^2*x1*x5*xcp2 +32*e4e2*e3e1*amel2^2*x1*x5*xcp1 -192*e4e2*e3e1*amel2^2*x1*x5^2*xcp3 +512*e4e2*e3e1*amel2^2*x1*x5^2*xcp2 -192*e4e2*e3e1*amel2^2*x1*x5^2*xcp1 +288*e4e2*e3e1*amel2^2*x1*x4*xcp3 -1536*e4e2*e3e1*amel2^2*x1*x4*xcp2 +288*e4e2*e3e1*amel2^2*x1*x4*xcp1 -512*e4e2*e3e1*amel2^2*x1*x4*x5*xcp3 +1408*e4e2*e3e1*amel2^2*x1*x4*x5*xcp2 -512*e4e2*e3e1*amel2^2*x1*x4*x5*xcp1 -320*e4e2*e3e1*amel2^2*x1*x4^2*xcp3 +640*e4e2*e3e1*amel2^2*x1*x4^2*xcp2 -320*e4e2*e3e1*amel2^2*x1*x4^2*xcp1 +128*e4e2*e3e1*amel2^2*x1*x3*xcp3 -1344*e4e2*e3e1*amel2^2*x1*x3*xcp2 +128*e4e2*e3e1*amel2^2*x1*x3*xcp1 -128*e4e2*e3e1*amel2^2*x1*x3*x5*xcp3 +1280*e4e2*e3e1*amel2^2*x1*x3*x5*xcp2 -128*e4e2*e3e1*amel2^2*x1*x3*x5*xcp1 -384*e4e2*e3e1*amel2^2*x1*x3*x4*xcp3 +1152*e4e2*e3e1*amel2^2*x1*x3*x4*xcp2 -384*e4e2*e3e1*amel2^2*x1*x3*x4*xcp1 -64*e4e2*e3e1*amel2^2*x1*x3^2*xcp3 +384*e4e2*e3e1*amel2^2*x1*x3^2*xcp2 -64*e4e2*e3e1*amel2^2*x1*x3^2*xcp1 +96*e4e2*e3e1*amel2^2*x1^2*xcp3 -128*e4e2*e3e1*amel2^2*x1^2*xcp2 +96*e4e2*e3e1*amel2^2*x1^2*xcp1 -96*e4e2*e3e1*amel2^2*x1^2*x5*xcp3 +256*e4e2*e3e1*amel2^2*x1^2*x5*xcp2 -96*e4e2*e3e1*amel2^2*x1^2*x5*xcp1 -128*e4e2*e3e1*amel2^2*x1^2*x4*xcp3 +256*e4e2*e3e1*amel2^2*x1^2*x4*xcp2 -128*e4e2*e3e1*amel2^2*x1^2*x4*xcp1 -96*e4e2*e3e1*amel2^2*x1^2*x3*xcp3 +128*e4e2*e3e1*amel2^2*x1^2*x3*xcp2 -96*e4e2*e3e1*amel2^2*x1^2*x3*xcp1 -224*e4e2*e3e1*e2e1*zk^2*xcp2 +128*e4e2*e3e1*e2e1*zk^2*x5*xcp2 +192*e4e2*e3e1*e2e1*zk^2*x3*xcp2 -32*e4e2*e3e1*e2e1*zk^2*x1*xcp2 -64*e4e2*e3e1*e2e1*amel2*xcp3 -768*e4e2*e3e1*e2e1*amel2*xcp2 -64*e4e2*e3e1*e2e1*amel2*xcp1 +64*e4e2*e3e1*e2e1*amel2*x5*xcp3 +2048*e4e2*e3e1*e2e1*amel2*x5*xcp2 +64*e4e2*e3e1*e2e1*amel2*x5*xcp1 +32*e4e2*e3e1*e2e1*amel2*x5^2*xcp3 -448*e4e2*e3e1*e2e1*amel2*x5^2*xcp2 +32*e4e2*e3e1*e2e1*amel2*x5^2*xcp1 -128*e4e2*e3e1*e2e1*amel2*x5^3*xcp3 -128*e4e2*e3e1*e2e1*amel2*x5^3*xcp2 -128*e4e2*e3e1*e2e1*amel2*x5^3*xcp1 +96*e4e2*e3e1*e2e1*amel2*x4*xcp3 +2560*e4e2*e3e1*e2e1*amel2*x4*xcp2 +96*e4e2*e3e1*e2e1*amel2*x4*xcp1 +32*e4e2*e3e1*e2e1*amel2*x4*x5*xcp3 -2176*e4e2*e3e1*e2e1*amel2*x4*x5*xcp2 +32*e4e2*e3e1*e2e1*amel2*x4*x5*xcp1 -448*e4e2*e3e1*e2e1*amel2*x4*x5^2*xcp3 +256*e4e2*e3e1*e2e1*amel2*x4*x5^2*xcp2 -448*e4e2*e3e1*e2e1*amel2*x4*x5^2*xcp1 +128*e4e2*e3e1*e2e1*amel2*x4^2*xcp3 -1984*e4e2*e3e1*e2e1*amel2*x4^2*xcp2 +128*e4e2*e3e1*e2e1*amel2*x4^2*xcp1 -576*e4e2*e3e1*e2e1*amel2*x4^2*x5*xcp3 +1152*e4e2*e3e1*e2e1*amel2*x4^2*x5*xcp2 -576*e4e2*e3e1*e2e1*amel2*x4^2*x5*xcp1 -256*e4e2*e3e1*e2e1*amel2*x4^3*xcp3 +640*e4e2*e3e1*e2e1*amel2*x4^3*xcp2 -256*e4e2*e3e1*e2e1*amel2*x4^3*xcp1 +160*e4e2*e3e1*e2e1*amel2*x3*xcp3 +1536*e4e2*e3e1*e2e1*amel2*x3*xcp2 +160*e4e2*e3e1*e2e1*amel2*x3*xcp1 -32*e4e2*e3e1*e2e1*amel2*x3*x5*xcp3 -2048*e4e2*e3e1*e2e1*amel2*x3*x5*xcp2 -32*e4e2*e3e1*e2e1*amel2*x3*x5*xcp1 -192*e4e2*e3e1*e2e1*amel2*x3*x5^2*xcp3 +128*e4e2*e3e1*e2e1*amel2*x3*x5^2*xcp2 -192*e4e2*e3e1*e2e1*amel2*x3*x5^2*xcp1 -32*e4e2*e3e1*e2e1*amel2*x3*x4*xcp3 -3584*e4e2*e3e1*e2e1*amel2*x3*x4*xcp2 -32*e4e2*e3e1*e2e1*amel2*x3*x4*xcp1 -512*e4e2*e3e1*e2e1*amel2*x3*x4*x5*xcp3 +2176*e4e2*e3e1*e2e1*amel2*x3*x4*x5*xcp2 -512*e4e2*e3e1*e2e1*amel2*x3*x4*x5*xcp1 -448*e4e2*e3e1*e2e1*amel2*x3*x4^2*xcp3 +2048*e4e2*e3e1*e2e1*amel2*x3*x4^2*xcp2 -448*e4e2*e3e1*e2e1*amel2*x3*x4^2*xcp1 -1024*e4e2*e3e1*e2e1*amel2*x3^2*xcp2 -64*e4e2*e3e1*e2e1*amel2*x3^2*x5*xcp3 +384*e4e2*e3e1*e2e1*amel2*x3^2*x5*xcp2 -64*e4e2*e3e1*e2e1*amel2*x3^2*x5*xcp1 -192*e4e2*e3e1*e2e1*amel2*x3^2*x4*xcp3 +1280*e4e2*e3e1*e2e1*amel2*x3^2*x4*xcp2 -192*e4e2*e3e1*e2e1*amel2*x3^2*x4*xcp1 +256*e4e2*e3e1*e2e1*amel2*x3^3*xcp2 +32*e4e2*e3e1*e2e1*amel2*x1*xcp3 +1664*e4e2*e3e1*e2e1*amel2*x1*xcp2 +32*e4e2*e3e1*e2e1*amel2*x1*xcp1 +64*e4e2*e3e1*e2e1*amel2*x1*x5*xcp3 -2304*e4e2*e3e1*e2e1*amel2*x1*x5*xcp2 +64*e4e2*e3e1*e2e1*amel2*x1*x5*xcp1 -128*e4e2*e3e1*e2e1*amel2*x1*x5^2*xcp3 +896*e4e2*e3e1*e2e1*amel2*x1*x5^2*xcp2 -128*e4e2*e3e1*e2e1*amel2*x1*x5^2*xcp1 +288*e4e2*e3e1*e2e1*amel2*x1*x4*xcp3 -1664*e4e2*e3e1*e2e1*amel2*x1*x4*xcp2 +288*e4e2*e3e1*e2e1*amel2*x1*x4*xcp1 -320*e4e2*e3e1*e2e1*amel2*x1*x4*x5*xcp3 +1536*e4e2*e3e1*e2e1*amel2*x1*x4*x5*xcp2 -320*e4e2*e3e1*e2e1*amel2*x1*x4*x5*xcp1 -256*e4e2*e3e1*e2e1*amel2*x1*x4^2*xcp3 +640*e4e2*e3e1*e2e1*amel2*x1*x4^2*xcp2 -256*e4e2*e3e1*e2e1*amel2*x1*x4^2*xcp1 +96*e4e2*e3e1*e2e1*amel2*x1*x3*xcp3 -2048*e4e2*e3e1*e2e1*amel2*x1*x3*xcp2 +96*e4e2*e3e1*e2e1*amel2*x1*x3*xcp1 -320*e4e2*e3e1*e2e1*amel2*x1*x3*x5*xcp3 +1792*e4e2*e3e1*e2e1*amel2*x1*x3*x5*xcp2 -320*e4e2*e3e1*e2e1*amel2*x1*x3*x5*xcp1 -448*e4e2*e3e1*e2e1*amel2*x1*x3*x4*xcp3 +1536*e4e2*e3e1*e2e1*amel2*x1*x3*x4*xcp2 -448*e4e2*e3e1*e2e1*amel2*x1*x3*x4*xcp1 -192*e4e2*e3e1*e2e1*amel2*x1*x3^2*xcp3 +768*e4e2*e3e1*e2e1*amel2*x1*x3^2*xcp2 -192*e4e2*e3e1*e2e1*amel2*x1*x3^2*xcp1 +32*e4e2*e3e1*e2e1*amel2*x1^2*xcp3 -320*e4e2*e3e1*e2e1*amel2*x1^2*xcp2 +32*e4e2*e3e1*e2e1*amel2*x1^2*xcp1 +256*e4e2*e3e1*e2e1*amel2*x1^2*x5*xcp2 +128*e4e2*e3e1*e2e1*amel2*x1^2*x4*xcp2 +128*e4e2*e3e1*e2e1*amel2*x1^2*x3*xcp2 -512*e4e2*e3e1*e2e1^2*xcp2 +640*e4e2*e3e1*e2e1^2*x5*xcp2 +256*e4e2*e3e1*e2e1^2*x5^2*xcp2 -384*e4e2*e3e1*e2e1^2*x5^3*xcp2 +1664*e4e2*e3e1*e2e1^2*x4*xcp2 -1152*e4e2*e3e1*e2e1^2*x4*x5*xcp2 -512*e4e2*e3e1*e2e1^2*x4*x5^2*xcp2 -1152*e4e2*e3e1*e2e1^2*x4^2*xcp2 +128*e4e2*e3e1*e2e1^2*x4^3*xcp2 +768*e4e2*e3e1*e2e1^2*x3*xcp2 -256*e4e2*e3e1*e2e1^2*x3*x5*xcp2 -512*e4e2*e3e1*e2e1^2*x3*x5^2*xcp2 -2304*e4e2*e3e1*e2e1^2*x3*x4*xcp2 +640*e4e2*e3e1*e2e1^2*x3*x4*x5*xcp2 +896*e4e2*e3e1*e2e1^2*x3*x4^2*xcp2 -256*e4e2*e3e1*e2e1^2*x3^2*xcp2 -256*e4e2*e3e1*e2e1^2*x3^2*x5*xcp2 +768*e4e2*e3e1*e2e1^2*x3^2*x4*xcp2 +512*e4e2*e3e1*e2e1^2*x1*xcp2 -768*e4e2*e3e1*e2e1^2*x1*x5*xcp2 +256*e4e2*e3e1*e2e1^2*x1*x5^2*xcp2 -512*e4e2*e3e1*e2e1^2*x1*x4*xcp2 +384*e4e2*e3e1*e2e1^2*x1*x4*x5*xcp2 +128*e4e2*e3e1*e2e1^2*x1*x4^2*xcp2 -768*e4e2*e3e1*e2e1^2*x1*x3*xcp2 +640*e4e2*e3e1*e2e1^2*x1*x3*x5*xcp2 +384*e4e2*e3e1*e2e1^2*x1*x3*x4*xcp2 +256*e4e2*e3e1*e2e1^2*x1*x3^2*xcp2 +224*e4e2*e3e1*e3e2*zk^2*xcp2 -192*e4e2*e3e1*e3e2*zk^2*x5*xcp2 -96*e4e2*e3e1*e3e2*zk^2*x4*xcp2 -160*e4e2*e3e1*e3e2*zk^2*x3*xcp2 +512*e4e2*e3e1*e3e2*amel2*xcp2 -1280*e4e2*e3e1*e3e2*amel2*x5*xcp2 -96*e4e2*e3e1*e3e2*amel2*x5^2*xcp3 +448*e4e2*e3e1*e3e2*amel2*x5^2*xcp2 -96*e4e2*e3e1*e3e2*amel2*x5^2*xcp1 +128*e4e2*e3e1*e3e2*amel2*x5^3*xcp3 +128*e4e2*e3e1*e3e2*amel2*x5^3*xcp1 -128*e4e2*e3e1*e3e2*amel2*x4*xcp3 -1792*e4e2*e3e1*e3e2*amel2*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x4*xcp1 -128*e4e2*e3e1*e3e2*amel2*x4*x5*xcp3 +2240*e4e2*e3e1*e3e2*amel2*x4*x5*xcp2 -128*e4e2*e3e1*e3e2*amel2*x4*x5*xcp1 +384*e4e2*e3e1*e3e2*amel2*x4*x5^2*xcp3 -768*e4e2*e3e1*e3e2*amel2*x4*x5^2*xcp2 +384*e4e2*e3e1*e3e2*amel2*x4*x5^2*xcp1 -192*e4e2*e3e1*e3e2*amel2*x4^2*xcp3 +1920*e4e2*e3e1*e3e2*amel2*x4^2*xcp2 -192*e4e2*e3e1*e3e2*amel2*x4^2*xcp1 +448*e4e2*e3e1*e3e2*amel2*x4^2*x5*xcp3 -1664*e4e2*e3e1*e3e2*amel2*x4^2*x5*xcp2 +448*e4e2*e3e1*e3e2*amel2*x4^2*x5*xcp1 +192*e4e2*e3e1*e3e2*amel2*x4^3*xcp3 -768*e4e2*e3e1*e3e2*amel2*x4^3*xcp2 +192*e4e2*e3e1*e3e2*amel2*x4^3*xcp1 -64*e4e2*e3e1*e3e2*amel2*x3*xcp3 -1024*e4e2*e3e1*e3e2*amel2*x3*xcp2 -64*e4e2*e3e1*e3e2*amel2*x3*xcp1 -64*e4e2*e3e1*e3e2*amel2*x3*x5*xcp3 +1344*e4e2*e3e1*e3e2*amel2*x3*x5*xcp2 -64*e4e2*e3e1*e3e2*amel2*x3*x5*xcp1 +128*e4e2*e3e1*e3e2*amel2*x3*x5^2*xcp3 -128*e4e2*e3e1*e3e2*amel2*x3*x5^2*xcp2 +128*e4e2*e3e1*e3e2*amel2*x3*x5^2*xcp1 -128*e4e2*e3e1*e3e2*amel2*x3*x4*xcp3 +2624*e4e2*e3e1*e3e2*amel2*x3*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x3*x4*xcp1 +320*e4e2*e3e1*e3e2*amel2*x3*x4*x5*xcp3 -1920*e4e2*e3e1*e3e2*amel2*x3*x4*x5*xcp2 +320*e4e2*e3e1*e3e2*amel2*x3*x4*x5*xcp1 +320*e4e2*e3e1*e3e2*amel2*x3*x4^2*xcp3 -1664*e4e2*e3e1*e3e2*amel2*x3*x4^2*xcp2 +320*e4e2*e3e1*e3e2*amel2*x3*x4^2*xcp1 -32*e4e2*e3e1*e3e2*amel2*x3^2*xcp3 +640*e4e2*e3e1*e3e2*amel2*x3^2*xcp2 -32*e4e2*e3e1*e3e2*amel2*x3^2*xcp1 -256*e4e2*e3e1*e3e2*amel2*x3^2*x5*xcp2 +128*e4e2*e3e1*e3e2*amel2*x3^2*x4*xcp3 -896*e4e2*e3e1*e3e2*amel2*x3^2*x4*xcp2 +128*e4e2*e3e1*e3e2*amel2*x3^2*x4*xcp1 -128*e4e2*e3e1*e3e2*amel2*x3^3*xcp2 -1280*e4e2*e3e1*e3e2*amel2*x1*xcp2 -96*e4e2*e3e1*e3e2*amel2*x1*x5*xcp3 +1984*e4e2*e3e1*e3e2*amel2*x1*x5*xcp2 -96*e4e2*e3e1*e3e2*amel2*x1*x5*xcp1 +128*e4e2*e3e1*e3e2*amel2*x1*x5^2*xcp3 -896*e4e2*e3e1*e3e2*amel2*x1*x5^2*xcp2 +128*e4e2*e3e1*e3e2*amel2*x1*x5^2*xcp1 -128*e4e2*e3e1*e3e2*amel2*x1*x4*xcp3 +1536*e4e2*e3e1*e3e2*amel2*x1*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x1*x4*xcp1 +192*e4e2*e3e1*e3e2*amel2*x1*x4*x5*xcp3 -1408*e4e2*e3e1*e3e2*amel2*x1*x4*x5*xcp2 +192*e4e2*e3e1*e3e2*amel2*x1*x4*x5*xcp1 +64*e4e2*e3e1*e3e2*amel2*x1*x4^2*xcp3 -512*e4e2*e3e1*e3e2*amel2*x1*x4^2*xcp2 +64*e4e2*e3e1*e3e2*amel2*x1*x4^2*xcp1 -96*e4e2*e3e1*e3e2*amel2*x1*x3*xcp3 +1600*e4e2*e3e1*e3e2*amel2*x1*x3*xcp2 -96*e4e2*e3e1*e3e2*amel2*x1*x3*xcp1 +192*e4e2*e3e1*e3e2*amel2*x1*x3*x5*xcp3 -1280*e4e2*e3e1*e3e2*amel2*x1*x3*x5*xcp2 +192*e4e2*e3e1*e3e2*amel2*x1*x3*x5*xcp1 +128*e4e2*e3e1*e3e2*amel2*x1*x3*x4*xcp3 -1024*e4e2*e3e1*e3e2*amel2*x1*x3*x4*xcp2 +128*e4e2*e3e1*e3e2*amel2*x1*x3*x4*xcp1 +64*e4e2*e3e1*e3e2*amel2*x1*x3^2*xcp3 -512*e4e2*e3e1*e3e2*amel2*x1*x3^2*xcp2 +64*e4e2*e3e1*e3e2*amel2*x1*x3^2*xcp1 +256*e4e2*e3e1*e3e2*amel2*x1^2*xcp2 -256*e4e2*e3e1*e3e2*amel2*x1^2*x5*xcp2 -128*e4e2*e3e1*e3e2*amel2*x1^2*x4*xcp2 -128*e4e2*e3e1*e3e2*amel2*x1^2*x3*xcp2 +512*e4e2*e3e1*e3e2*e2e1*xcp2 -512*e4e2*e3e1*e3e2*e2e1*x5*xcp2 -512*e4e2*e3e1*e3e2*e2e1*x5^2*xcp2 +512*e4e2*e3e1*e3e2*e2e1*x5^3*xcp2 -2304*e4e2*e3e1*e3e2*e2e1*x4*xcp2 +2048*e4e2*e3e1*e3e2*e2e1*x4*x5*xcp2 +256*e4e2*e3e1*e3e2*e2e1*x4*x5^2*xcp2 +2048*e4e2*e3e1*e3e2*e2e1*x4^2*xcp2 -640*e4e2*e3e1*e3e2*e2e1*x4^2*x5*xcp2 -384*e4e2*e3e1*e3e2*e2e1*x4^3*xcp2 -768*e4e2*e3e1*e3e2*e2e1*x3*xcp2 +768*e4e2*e3e1*e3e2*e2e1*x3*x5^2*xcp2 +3328*e4e2*e3e1*e3e2*e2e1*x3*x4*xcp2 -1280*e4e2*e3e1*e3e2*e2e1*x3*x4*x5*xcp2 -1536*e4e2*e3e1*e3e2*e2e1*x3*x4^2*xcp2 +256*e4e2*e3e1*e3e2*e2e1*x3^2*xcp2 +384*e4e2*e3e1*e3e2*e2e1*x3^2*x5*xcp2 -1152*e4e2*e3e1*e3e2*e2e1*x3^2*x4*xcp2 -512*e4e2*e3e1*e3e2*e2e1*x1*xcp2 +768*e4e2*e3e1*e3e2*e2e1*x1*x5*xcp2 -256*e4e2*e3e1*e3e2*e2e1*x1*x5^2*xcp2 +512*e4e2*e3e1*e3e2*e2e1*x1*x4*xcp2 -384*e4e2*e3e1*e3e2*e2e1*x1*x4*x5*xcp2 -128*e4e2*e3e1*e3e2*e2e1*x1*x4^2*xcp2 +768*e4e2*e3e1*e3e2*e2e1*x1*x3*xcp2 -640*e4e2*e3e1*e3e2*e2e1*x1*x3*x5*xcp2 -384*e4e2*e3e1*e3e2*e2e1*x1*x3*x4*xcp2 -256*e4e2*e3e1*e3e2*e2e1*x1*x3^2*xcp2 -128*e4e2*e3e1*e3e2^2*x5*xcp2 +256*e4e2*e3e1*e3e2^2*x5^2*xcp2 -128*e4e2*e3e1*e3e2^2*x5^3*xcp2 +640*e4e2*e3e1*e3e2^2*x4*xcp2 -896*e4e2*e3e1*e3e2^2*x4*x5*xcp2 +256*e4e2*e3e1*e3e2^2*x4*x5^2*xcp2 -896*e4e2*e3e1*e3e2^2*x4^2*xcp2 +640*e4e2*e3e1*e3e2^2*x4^2*x5*xcp2 +256*e4e2*e3e1*e3e2^2*x4^3*xcp2 +256*e4e2*e3e1*e3e2^2*x3*x5*xcp2 -256*e4e2*e3e1*e3e2^2*x3*x5^2*xcp2 -1024*e4e2*e3e1*e3e2^2*x3*x4*xcp2 +640*e4e2*e3e1*e3e2^2*x3*x4*x5*xcp2 +640*e4e2*e3e1*e3e2^2*x3*x4^2*xcp2 -128*e4e2*e3e1*e3e2^2*x3^2*x5*xcp2 +384*e4e2*e3e1*e3e2^2*x3^2*x4*xcp2 +96*e4e2*e3e1^2*zk^2*xcp2 -64*e4e2*e3e1^2*zk^2*x5*xcp2 -64*e4e2*e3e1^2*zk^2*x4*xcp2 -128*e4e2*e3e1^2*zk^2*x3*xcp2 +32*e4e2*e3e1^2*zk^2*x1*xcp2 +64*e4e2*e3e1^2*amel2*xcp3 +512*e4e2*e3e1^2*amel2*xcp2 +64*e4e2*e3e1^2*amel2*xcp1 -128*e4e2*e3e1^2*amel2*x5*xcp3 -1408*e4e2*e3e1^2*amel2*x5*xcp2 -128*e4e2*e3e1^2*amel2*x5*xcp1 +32*e4e2*e3e1^2*amel2*x5^2*xcp3 +960*e4e2*e3e1^2*amel2*x5^2*xcp2 +32*e4e2*e3e1^2*amel2*x5^2*xcp1 +64*e4e2*e3e1^2*amel2*x5^3*xcp3 -256*e4e2*e3e1^2*amel2*x5^3*xcp2 +64*e4e2*e3e1^2*amel2*x5^3*xcp1 -32*e4e2*e3e1^2*amel2*x4*xcp3 -1664*e4e2*e3e1^2*amel2*x4*xcp2 -32*e4e2*e3e1^2*amel2*x4*xcp1 -32*e4e2*e3e1^2*amel2*x4*x5*xcp3 +2432*e4e2*e3e1^2*amel2*x4*x5*xcp2 -32*e4e2*e3e1^2*amel2*x4*x5*xcp1 +256*e4e2*e3e1^2*amel2*x4*x5^2*xcp3 -1024*e4e2*e3e1^2*amel2*x4*x5^2*xcp2 +256*e4e2*e3e1^2*amel2*x4*x5^2*xcp1 -64*e4e2*e3e1^2*amel2*x4^2*xcp3 +1472*e4e2*e3e1^2*amel2*x4^2*xcp2 -64*e4e2*e3e1^2*amel2*x4^2*xcp1 +320*e4e2*e3e1^2*amel2*x4^2*x5*xcp3 -1280*e4e2*e3e1^2*amel2*x4^2*x5*xcp2 +320*e4e2*e3e1^2*amel2*x4^2*x5*xcp1 +128*e4e2*e3e1^2*amel2*x4^3*xcp3 -512*e4e2*e3e1^2*amel2*x4^3*xcp2 +128*e4e2*e3e1^2*amel2*x4^3*xcp1 -96*e4e2*e3e1^2*amel2*x3*xcp3 -1280*e4e2*e3e1^2*amel2*x3*xcp2 -96*e4e2*e3e1^2*amel2*x3*xcp1 +160*e4e2*e3e1^2*amel2*x3*x5*xcp3 +2176*e4e2*e3e1^2*amel2*x3*x5*xcp2 +160*e4e2*e3e1^2*amel2*x3*x5*xcp1 +64*e4e2*e3e1^2*amel2*x3*x5^2*xcp3 -896*e4e2*e3e1^2*amel2*x3*x5^2*xcp2 +64*e4e2*e3e1^2*amel2*x3*x5^2*xcp1 +32*e4e2*e3e1^2*amel2*x3*x4*xcp3 +2432*e4e2*e3e1^2*amel2*x3*x4*xcp2 +32*e4e2*e3e1^2*amel2*x3*x4*xcp1 +256*e4e2*e3e1^2*amel2*x3*x4*x5*xcp3 -2048*e4e2*e3e1^2*amel2*x3*x4*x5*xcp2 +256*e4e2*e3e1^2*amel2*x3*x4*x5*xcp1 +192*e4e2*e3e1^2*amel2*x3*x4^2*xcp3 -1280*e4e2*e3e1^2*amel2*x3*x4^2*xcp2 +192*e4e2*e3e1^2*amel2*x3*x4^2*xcp1 +768*e4e2*e3e1^2*amel2*x3^2*xcp2 +64*e4e2*e3e1^2*amel2*x3^2*x5*xcp3 -512*e4e2*e3e1^2*amel2*x3^2*x5*xcp2 +64*e4e2*e3e1^2*amel2*x3^2*x5*xcp1 +64*e4e2*e3e1^2*amel2*x3^2*x4*xcp3 -768*e4e2*e3e1^2*amel2*x3^2*x4*xcp2 +64*e4e2*e3e1^2*amel2*x3^2*x4*xcp1 -128*e4e2*e3e1^2*amel2*x3^3*xcp2 -32*e4e2*e3e1^2*amel2*x1*xcp3 -768*e4e2*e3e1^2*amel2*x1*xcp2 -32*e4e2*e3e1^2*amel2*x1*xcp1 +1152*e4e2*e3e1^2*amel2*x1*x5*xcp2 +64*e4e2*e3e1^2*amel2*x1*x5^2*xcp3 -512*e4e2*e3e1^2*amel2*x1*x5^2*xcp2 +64*e4e2*e3e1^2*amel2*x1*x5^2*xcp1 -160*e4e2*e3e1^2*amel2*x1*x4*xcp3 +1280*e4e2*e3e1^2*amel2*x1*x4*xcp2 -160*e4e2*e3e1^2*amel2*x1*x4*xcp1 +192*e4e2*e3e1^2*amel2*x1*x4*x5*xcp3 -1152*e4e2*e3e1^2*amel2*x1*x4*x5*xcp2 +192*e4e2*e3e1^2*amel2*x1*x4*x5*xcp1 +128*e4e2*e3e1^2*amel2*x1*x4^2*xcp3 -512*e4e2*e3e1^2*amel2*x1*x4^2*xcp2 +128*e4e2*e3e1^2*amel2*x1*x4^2*xcp1 -32*e4e2*e3e1^2*amel2*x1*x3*xcp3 +1408*e4e2*e3e1^2*amel2*x1*x3*xcp2 -32*e4e2*e3e1^2*amel2*x1*x3*xcp1 +64*e4e2*e3e1^2*amel2*x1*x3*x5*xcp3 -1280*e4e2*e3e1^2*amel2*x1*x3*x5*xcp2 +64*e4e2*e3e1^2*amel2*x1*x3*x5*xcp1 +192*e4e2*e3e1^2*amel2*x1*x3*x4*xcp3 -1152*e4e2*e3e1^2*amel2*x1*x3*x4*xcp2 +192*e4e2*e3e1^2*amel2*x1*x3*x4*xcp1 +64*e4e2*e3e1^2*amel2*x1*x3^2*xcp3 -512*e4e2*e3e1^2*amel2*x1*x3^2*xcp2 +64*e4e2*e3e1^2*amel2*x1*x3^2*xcp1 -32*e4e2*e3e1^2*amel2*x1^2*xcp3 +64*e4e2*e3e1^2*amel2*x1^2*xcp2 -32*e4e2*e3e1^2*amel2*x1^2*xcp1 -128*e4e2*e3e1^2*amel2*x1^2*x5*xcp2 -128*e4e2*e3e1^2*amel2*x1^2*x4*xcp2 -128*e4e2*e3e1^2*amel2*x1^2*x3*xcp2 +768*e4e2*e3e1^2*e2e1*xcp2 -1664*e4e2*e3e1^2*e2e1*x5*xcp2 +1024*e4e2*e3e1^2*e2e1*x5^2*xcp2 -128*e4e2*e3e1^2*e2e1*x5^3*xcp2 -1920*e4e2*e3e1^2*e2e1*x4*xcp2 +2432*e4e2*e3e1^2*e2e1*x4*x5*xcp2 -512*e4e2*e3e1^2*e2e1*x4*x5^2*xcp2 +1408*e4e2*e3e1^2*e2e1*x4^2*xcp2 -640*e4e2*e3e1^2*e2e1*x4^2*x5*xcp2 -256*e4e2*e3e1^2*e2e1*x4^3*xcp2 -1280*e4e2*e3e1^2*e2e1*x3*xcp2 +1792*e4e2*e3e1^2*e2e1*x3*x5*xcp2 -512*e4e2*e3e1^2*e2e1*x3*x5^2*xcp2 +2560*e4e2*e3e1^2*e2e1*x3*x4*xcp2 -1536*e4e2*e3e1^2*e2e1*x3*x4*x5*xcp2 -1024*e4e2*e3e1^2*e2e1*x3*x4^2*xcp2 +512*e4e2*e3e1^2*e2e1*x3^2*xcp2 -256*e4e2*e3e1^2*e2e1*x3^2*x5*xcp2 -768*e4e2*e3e1^2*e2e1*x3^2*x4*xcp2 -768*e4e2*e3e1^2*e2e1*x1*xcp2 +1152*e4e2*e3e1^2*e2e1*x1*x5*xcp2 -384*e4e2*e3e1^2*e2e1*x1*x5^2*xcp2 +896*e4e2*e3e1^2*e2e1*x1*x4*xcp2 -640*e4e2*e3e1^2*e2e1*x1*x4*x5*xcp2 -256*e4e2*e3e1^2*e2e1*x1*x4^2*xcp2 +1280*e4e2*e3e1^2*e2e1*x1*x3*xcp2 -1024*e4e2*e3e1^2*e2e1*x1*x3*x5*xcp2 -768*e4e2*e3e1^2*e2e1*x1*x3*x4*xcp2 -512*e4e2*e3e1^2*e2e1*x1*x3^2*xcp2 -512*e4e2*e3e1^2*e3e2*xcp2 +1280*e4e2*e3e1^2*e3e2*x5*xcp2 -1024*e4e2*e3e1^2*e3e2*x5^2*xcp2 +256*e4e2*e3e1^2*e3e2*x5^3*xcp2 +1536*e4e2*e3e1^2*e3e2*x4*xcp2 -2432*e4e2*e3e1^2*e3e2*x4*x5*xcp2 +896*e4e2*e3e1^2*e3e2*x4*x5^2*xcp2 -1408*e4e2*e3e1^2*e3e2*x4^2*xcp2 +1024*e4e2*e3e1^2*e3e2*x4^2*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x4^3*xcp2 +768*e4e2*e3e1^2*e3e2*x3*xcp2 -1152*e4e2*e3e1^2*e3e2*x3*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x3*x5^2*xcp2 -1920*e4e2*e3e1^2*e3e2*x3*x4*xcp2 +1408*e4e2*e3e1^2*e3e2*x3*x4*x5*xcp2 +1024*e4e2*e3e1^2*e3e2*x3*x4^2*xcp2 -256*e4e2*e3e1^2*e3e2*x3^2*xcp2 +128*e4e2*e3e1^2*e3e2*x3^2*x5*xcp2 +640*e4e2*e3e1^2*e3e2*x3^2*x4*xcp2 +512*e4e2*e3e1^2*e3e2*x1*xcp2 -896*e4e2*e3e1^2*e3e2*x1*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x1*x5^2*xcp2 -640*e4e2*e3e1^2*e3e2*x1*x4*xcp2 +512*e4e2*e3e1^2*e3e2*x1*x4*x5*xcp2 +128*e4e2*e3e1^2*e3e2*x1*x4^2*xcp2 -768*e4e2*e3e1^2*e3e2*x1*x3*xcp2 +640*e4e2*e3e1^2*e3e2*x1*x3*x5*xcp2 +384*e4e2*e3e1^2*e3e2*x1*x3*x4*xcp2 +256*e4e2*e3e1^2*e3e2*x1*x3^2*xcp2 -256*e4e2*e3e1^3*xcp2 +640*e4e2*e3e1^3*x5*xcp2 -512*e4e2*e3e1^3*x5^2*xcp2 +128*e4e2*e3e1^3*x5^3*xcp2 +640*e4e2*e3e1^3*x4*xcp2 -1024*e4e2*e3e1^3*x4*x5*xcp2 +384*e4e2*e3e1^3*x4*x5^2*xcp2 -512*e4e2*e3e1^3*x4^2*xcp2 +384*e4e2*e3e1^3*x4^2*x5*xcp2 +128*e4e2*e3e1^3*x4^3*xcp2 +512*e4e2*e3e1^3*x3*xcp2 -896*e4e2*e3e1^3*x3*x5*xcp2 +384*e4e2*e3e1^3*x3*x5^2*xcp2 -896*e4e2*e3e1^3*x3*x4*xcp2 +768*e4e2*e3e1^3*x3*x4*x5*xcp2 +384*e4e2*e3e1^3*x3*x4^2*xcp2 -256*e4e2*e3e1^3*x3^2*xcp2 +256*e4e2*e3e1^3*x3^2*x5*xcp2 +256*e4e2*e3e1^3*x3^2*x4*xcp2 +256*e4e2*e3e1^3*x1*xcp2 -384*e4e2*e3e1^3*x1*x5*xcp2 +128*e4e2*e3e1^3*x1*x5^2*xcp2 -384*e4e2*e3e1^3*x1*x4*xcp2 +256*e4e2*e3e1^3*x1*x4*x5*xcp2 +128*e4e2*e3e1^3*x1*x4^2*xcp2 -512*e4e2*e3e1^3*x1*x3*xcp2 +384*e4e2*e3e1^3*x1*x3*x5*xcp2 +384*e4e2*e3e1^3*x1*x3*x4*xcp2 +256*e4e2*e3e1^3*x1*x3^2*xcp2 +16*e4e2^2*amel2*zk^2*xcp3 +64*e4e2^2*amel2*zk^2*xcp2 +16*e4e2^2*amel2*zk^2*xcp1 -48*e4e2^2*amel2*zk^2*x5*xcp3 +64*e4e2^2*amel2*zk^2*x5*xcp2 -48*e4e2^2*amel2*zk^2*x5*xcp1 -32*e4e2^2*amel2*zk^2*x4*xcp2 -64*e4e2^2*amel2*zk^2*x3*xcp2 -32*e4e2^2*amel2*zk^2*x1*xcp2 +128*e4e2^2*amel2^2*x5*xcp2 +320*e4e2^2*amel2^2*x5^2*xcp2 -32*e4e2^2*amel2^2*x5^3*xcp3 -128*e4e2^2*amel2^2*x5^3*xcp2 -32*e4e2^2*amel2^2*x5^3*xcp1 +64*e4e2^2*amel2^2*x4*xcp3 +64*e4e2^2*amel2^2*x4*xcp1 +192*e4e2^2*amel2^2*x4*x5*xcp2 -64*e4e2^2*amel2^2*x4*x5^2*xcp3 -128*e4e2^2*amel2^2*x4*x5^2*xcp2 -64*e4e2^2*amel2^2*x4*x5^2*xcp1 +64*e4e2^2*amel2^2*x4^2*xcp3 +64*e4e2^2*amel2^2*x4^2*xcp1 -64*e4e2^2*amel2^2*x4^2*x5*xcp3 +128*e4e2^2*amel2^2*x4^2*x5*xcp2 -64*e4e2^2*amel2^2*x4^2*x5*xcp1 +64*e4e2^2*amel2^2*x3*xcp3 -128*e4e2^2*amel2^2*x3*xcp2 +64*e4e2^2*amel2^2*x3*xcp1 -64*e4e2^2*amel2^2*x3*x5*xcp3 -320*e4e2^2*amel2^2*x3*x5*xcp2 -64*e4e2^2*amel2^2*x3*x5*xcp1 +64*e4e2^2*amel2^2*x3*x5^2*xcp3 -64*e4e2^2*amel2^2*x3*x5^2*xcp2 +64*e4e2^2*amel2^2*x3*x5^2*xcp1 +64*e4e2^2*amel2^2*x3*x4*xcp3 -64*e4e2^2*amel2^2*x3*x4*xcp2 +64*e4e2^2*amel2^2*x3*x4*xcp1 +64*e4e2^2*amel2^2*x3*x4*x5*xcp3 +384*e4e2^2*amel2^2*x3*x4*x5*xcp2 +64*e4e2^2*amel2^2*x3*x4*x5*xcp1 +128*e4e2^2*amel2^2*x3^2*xcp2 -32*e4e2^2*amel2^2*x3^2*x5*xcp3 +256*e4e2^2*amel2^2*x3^2*x5*xcp2 -32*e4e2^2*amel2^2*x3^2*x5*xcp1 -128*e4e2^2*amel2^2*x3^2*x4*xcp2 -64*e4e2^2*amel2^2*x3^3*xcp2 +64*e4e2^2*amel2^2*x1*xcp3 +128*e4e2^2*amel2^2*x1*xcp2 +64*e4e2^2*amel2^2*x1*xcp1 -32*e4e2^2*amel2^2*x1*x5*xcp3 -128*e4e2^2*amel2^2*x1*x5*xcp2 -32*e4e2^2*amel2^2*x1*x5*xcp1 -64*e4e2^2*amel2^2*x1*x5^2*xcp3 -64*e4e2^2*amel2^2*x1*x5^2*xcp1 +64*e4e2^2*amel2^2*x1*x4*xcp3 -128*e4e2^2*amel2^2*x1*x4*xcp2 +64*e4e2^2*amel2^2*x1*x4*xcp1 -64*e4e2^2*amel2^2*x1*x4*x5*xcp3 +256*e4e2^2*amel2^2*x1*x4*x5*xcp2 -64*e4e2^2*amel2^2*x1*x4*x5*xcp1 +32*e4e2^2*amel2^2*x1*x3*xcp3 -256*e4e2^2*amel2^2*x1*x3*xcp2 +32*e4e2^2*amel2^2*x1*x3*xcp1 +512*e4e2^2*amel2^2*x1*x3*x5*xcp2 -128*e4e2^2*amel2^2*x1*x3^2*xcp2 +32*e4e2^2*amel2^2*x1^2*xcp3 +64*e4e2^2*amel2^2*x1^2*xcp2 +32*e4e2^2*amel2^2*x1^2*xcp1 -32*e4e2^2*amel2^2*x1^2*x5*xcp3 +128*e4e2^2*amel2^2*x1^2*x5*xcp2 -32*e4e2^2*amel2^2*x1^2*x5*xcp1 -64*e4e2^2*amel2^2*x1^2*x3*xcp2 -32*e4e2^2*e2e1*zk^2*xcp2 -32*e4e2^2*e2e1*zk^2*x4*xcp2 +32*e4e2^2*e2e1*zk^2*x3*xcp2 -64*e4e2^2*e2e1*amel2*x5*xcp3 +128*e4e2^2*e2e1*amel2*x5*xcp2 -64*e4e2^2*e2e1*amel2*x5*xcp1 +32*e4e2^2*e2e1*amel2*x5^2*xcp3 +832*e4e2^2*e2e1*amel2*x5^2*xcp2 +32*e4e2^2*e2e1*amel2*x5^2*xcp1 -512*e4e2^2*e2e1*amel2*x5^3*xcp2 +64*e4e2^2*e2e1*amel2*x4*xcp3 +384*e4e2^2*e2e1*amel2*x4*xcp2 +64*e4e2^2*e2e1*amel2*x4*xcp1 +320*e4e2^2*e2e1*amel2*x4*x5*xcp2 -64*e4e2^2*e2e1*amel2*x4*x5^2*xcp3 -640*e4e2^2*e2e1*amel2*x4*x5^2*xcp2 -64*e4e2^2*e2e1*amel2*x4*x5^2*xcp1 +64*e4e2^2*e2e1*amel2*x4^2*xcp3 -128*e4e2^2*e2e1*amel2*x4^2*xcp2 +64*e4e2^2*e2e1*amel2*x4^2*xcp1 -64*e4e2^2*e2e1*amel2*x4^2*x5*xcp3 -64*e4e2^2*e2e1*amel2*x4^2*x5*xcp1 +64*e4e2^2*e2e1*amel2*x3*xcp3 -128*e4e2^2*e2e1*amel2*x3*xcp2 +64*e4e2^2*e2e1*amel2*x3*xcp1 -192*e4e2^2*e2e1*amel2*x3*x5*xcp2 +128*e4e2^2*e2e1*amel2*x3*x5^2*xcp3 -384*e4e2^2*e2e1*amel2*x3*x5^2*xcp2 +128*e4e2^2*e2e1*amel2*x3*x5^2*xcp1 +64*e4e2^2*e2e1*amel2*x3*x4*xcp3 -576*e4e2^2*e2e1*amel2*x3*x4*xcp2 +64*e4e2^2*e2e1*amel2*x3*x4*xcp1 +64*e4e2^2*e2e1*amel2*x3*x4*x5*xcp3 +512*e4e2^2*e2e1*amel2*x3*x4*x5*xcp2 +64*e4e2^2*e2e1*amel2*x3*x4*x5*xcp1 +128*e4e2^2*e2e1*amel2*x3*x4^2*xcp2 +32*e4e2^2*e2e1*amel2*x3^2*xcp3 +32*e4e2^2*e2e1*amel2*x3^2*xcp1 +128*e4e2^2*e2e1*amel2*x3^2*x5*xcp3 +256*e4e2^2*e2e1*amel2*x3^2*x5*xcp2 +128*e4e2^2*e2e1*amel2*x3^2*x5*xcp1 +512*e4e2^2*e2e1*amel2*x1*xcp2 +32*e4e2^2*e2e1*amel2*x1*x5*xcp3 -576*e4e2^2*e2e1*amel2*x1*x5*xcp2 +32*e4e2^2*e2e1*amel2*x1*x5*xcp1 +64*e4e2^2*e2e1*amel2*x1*x4*xcp3 -128*e4e2^2*e2e1*amel2*x1*x4*xcp2 +64*e4e2^2*e2e1*amel2*x1*x4*xcp1 -64*e4e2^2*e2e1*amel2*x1*x4*x5*xcp3 +256*e4e2^2*e2e1*amel2*x1*x4*x5*xcp2 -64*e4e2^2*e2e1*amel2*x1*x4*x5*xcp1 +32*e4e2^2*e2e1*amel2*x1*x3*xcp3 -448*e4e2^2*e2e1*amel2*x1*x3*xcp2 +32*e4e2^2*e2e1*amel2*x1*x3*xcp1 -64*e4e2^2*e2e1*amel2*x1*x3*x5*xcp3 +640*e4e2^2*e2e1*amel2*x1*x3*x5*xcp2 -64*e4e2^2*e2e1*amel2*x1*x3*x5*xcp1 -128*e4e2^2*e2e1*amel2*x1^2*xcp2 +128*e4e2^2*e2e1*amel2*x1^2*x5*xcp2 -384*e4e2^2*e2e1^2*x5*xcp2 +768*e4e2^2*e2e1^2*x5^2*xcp2 -384*e4e2^2*e2e1^2*x5^3*xcp2 +384*e4e2^2*e2e1^2*x4*xcp2 +128*e4e2^2*e2e1^2*x4*x5*xcp2 -512*e4e2^2*e2e1^2*x4*x5^2*xcp2 -128*e4e2^2*e2e1^2*x4^2*xcp2 -128*e4e2^2*e2e1^2*x4^2*x5*xcp2 +512*e4e2^2*e2e1^2*x3*x5*xcp2 -512*e4e2^2*e2e1^2*x3*x5^2*xcp2 -512*e4e2^2*e2e1^2*x3*x4*xcp2 +128*e4e2^2*e2e1^2*x3*x4*x5*xcp2 +128*e4e2^2*e2e1^2*x3*x4^2*xcp2 -128*e4e2^2*e2e1^2*x3^2*x5*xcp2 +128*e4e2^2*e2e1^2*x3^2*x4*xcp2 -512*e4e2^2*e3e2*amel2*x5^2*xcp2 +256*e4e2^2*e3e2*amel2*x5^3*xcp2 -384*e4e2^2*e3e2*amel2*x4*xcp2 -64*e4e2^2*e3e2*amel2*x4*x5*xcp3 -64*e4e2^2*e3e2*amel2*x4*x5*xcp1 +64*e4e2^2*e3e2*amel2*x4*x5^2*xcp3 +128*e4e2^2*e3e2*amel2*x4*x5^2*xcp2 +64*e4e2^2*e3e2*amel2*x4*x5^2*xcp1 -64*e4e2^2*e3e2*amel2*x4^2*xcp3 -64*e4e2^2*e3e2*amel2*x4^2*xcp1 +64*e4e2^2*e3e2*amel2*x4^2*x5*xcp3 -128*e4e2^2*e3e2*amel2*x4^2*x5*xcp2 +64*e4e2^2*e3e2*amel2*x4^2*x5*xcp1 -128*e4e2^2*e3e2*amel2*x3*x5^2*xcp3 +256*e4e2^2*e3e2*amel2*x3*x5^2*xcp2 -128*e4e2^2*e3e2*amel2*x3*x5^2*xcp1 -64*e4e2^2*e3e2*amel2*x3*x4*xcp3 +256*e4e2^2*e3e2*amel2*x3*x4*xcp2 -64*e4e2^2*e3e2*amel2*x3*x4*xcp1 -256*e4e2^2*e3e2*amel2*x3*x4*x5*xcp2 -64*e4e2^2*e3e2*amel2*x3^2*x5*xcp3 -128*e4e2^2*e3e2*amel2*x3^2*x5*xcp2 -64*e4e2^2*e3e2*amel2*x3^2*x5*xcp1 -384*e4e2^2*e3e2*amel2*x1*xcp2 +256*e4e2^2*e3e2*amel2*x1*x5*xcp2 +128*e4e2^2*e3e2*amel2*x1*x5^2*xcp2 +384*e4e2^2*e3e2*amel2*x1*x4*xcp2 -128*e4e2^2*e3e2*amel2*x1*x4*x5*xcp2 +512*e4e2^2*e3e2*amel2*x1*x3*xcp2 -256*e4e2^2*e3e2*amel2*x1*x3*x5*xcp2 -128*e4e2^2*e3e2*amel2*x1*x3*x4*xcp2 -128*e4e2^2*e3e2*amel2*x1*x3^2*xcp2 +384*e4e2^2*e3e2*e2e1*x5*xcp2 -768*e4e2^2*e3e2*e2e1*x5^2*xcp2 +384*e4e2^2*e3e2*e2e1*x5^3*xcp2 -384*e4e2^2*e3e2*e2e1*x4*xcp2 -128*e4e2^2*e3e2*e2e1*x4*x5*xcp2 +512*e4e2^2*e3e2*e2e1*x4*x5^2*xcp2 +128*e4e2^2*e3e2*e2e1*x4^2*xcp2 +128*e4e2^2*e3e2*e2e1*x4^2*x5*xcp2 -512*e4e2^2*e3e2*e2e1*x3*x5*xcp2 +512*e4e2^2*e3e2*e2e1*x3*x5^2*xcp2 +512*e4e2^2*e3e2*e2e1*x3*x4*xcp2 -128*e4e2^2*e3e2*e2e1*x3*x4*x5*xcp2 -128*e4e2^2*e3e2*e2e1*x3*x4^2*xcp2 +128*e4e2^2*e3e2*e2e1*x3^2*x5*xcp2 -128*e4e2^2*e3e2*e2e1*x3^2*x4*xcp2 +96*e4e2^2*e3e1*zk^2*xcp2 -64*e4e2^2*e3e1*zk^2*x5*xcp2 +32*e4e2^2*e3e1*zk^2*x4*xcp2 -32*e4e2^2*e3e1*zk^2*x3*xcp2 +256*e4e2^2*e3e1*amel2*xcp2 -512*e4e2^2*e3e1*amel2*x5*xcp2 -32*e4e2^2*e3e1*amel2*x5^2*xcp3 -192*e4e2^2*e3e1*amel2*x5^2*xcp2 -32*e4e2^2*e3e1*amel2*x5^2*xcp1 +64*e4e2^2*e3e1*amel2*x5^3*xcp3 +128*e4e2^2*e3e1*amel2*x5^3*xcp2 +64*e4e2^2*e3e1*amel2*x5^3*xcp1 -64*e4e2^2*e3e1*amel2*x4*xcp3 -512*e4e2^2*e3e1*amel2*x4*xcp2 -64*e4e2^2*e3e1*amel2*x4*xcp1 +64*e4e2^2*e3e1*amel2*x4*x5*xcp2 +128*e4e2^2*e3e1*amel2*x4*x5^2*xcp3 +128*e4e2^2*e3e1*amel2*x4*x5^2*xcp2 +128*e4e2^2*e3e1*amel2*x4*x5^2*xcp1 -64*e4e2^2*e3e1*amel2*x4^2*xcp3 +256*e4e2^2*e3e1*amel2*x4^2*xcp2 -64*e4e2^2*e3e1*amel2*x4^2*xcp1 +64*e4e2^2*e3e1*amel2*x4^2*x5*xcp3 -128*e4e2^2*e3e1*amel2*x4^2*x5*xcp2 +64*e4e2^2*e3e1*amel2*x4^2*x5*xcp1 -64*e4e2^2*e3e1*amel2*x3*xcp3 -256*e4e2^2*e3e1*amel2*x3*xcp2 -64*e4e2^2*e3e1*amel2*x3*xcp1 +320*e4e2^2*e3e1*amel2*x3*x5*xcp2 +128*e4e2^2*e3e1*amel2*x3*x5^2*xcp2 -64*e4e2^2*e3e1*amel2*x3*x4*xcp3 +576*e4e2^2*e3e1*amel2*x3*x4*xcp2 -64*e4e2^2*e3e1*amel2*x3*x4*xcp1 -64*e4e2^2*e3e1*amel2*x3*x4*x5*xcp3 -256*e4e2^2*e3e1*amel2*x3*x4*x5*xcp2 -64*e4e2^2*e3e1*amel2*x3*x4*x5*xcp1 -128*e4e2^2*e3e1*amel2*x3*x4^2*xcp2 -32*e4e2^2*e3e1*amel2*x3^2*xcp3 -32*e4e2^2*e3e1*amel2*x3^2*xcp1 -64*e4e2^2*e3e1*amel2*x3^2*x5*xcp3 +128*e4e2^2*e3e1*amel2*x3^2*x5*xcp2 -64*e4e2^2*e3e1*amel2*x3^2*x5*xcp1 -640*e4e2^2*e3e1*amel2*x1*xcp2 -32*e4e2^2*e3e1*amel2*x1*x5*xcp3 +704*e4e2^2*e3e1*amel2*x1*x5*xcp2 -32*e4e2^2*e3e1*amel2*x1*x5*xcp1 +64*e4e2^2*e3e1*amel2*x1*x5^2*xcp3 -256*e4e2^2*e3e1*amel2*x1*x5^2*xcp2 +64*e4e2^2*e3e1*amel2*x1*x5^2*xcp1 -64*e4e2^2*e3e1*amel2*x1*x4*xcp3 +128*e4e2^2*e3e1*amel2*x1*x4*xcp2 -64*e4e2^2*e3e1*amel2*x1*x4*xcp1 +64*e4e2^2*e3e1*amel2*x1*x4*x5*xcp3 -256*e4e2^2*e3e1*amel2*x1*x4*x5*xcp2 +64*e4e2^2*e3e1*amel2*x1*x4*x5*xcp1 -32*e4e2^2*e3e1*amel2*x1*x3*xcp3 +448*e4e2^2*e3e1*amel2*x1*x3*xcp2 -32*e4e2^2*e3e1*amel2*x1*x3*xcp1 +64*e4e2^2*e3e1*amel2*x1*x3*x5*xcp3 -384*e4e2^2*e3e1*amel2*x1*x3*x5*xcp2 +64*e4e2^2*e3e1*amel2*x1*x3*x5*xcp1 +128*e4e2^2*e3e1*amel2*x1^2*xcp2 -128*e4e2^2*e3e1*amel2*x1^2*x5*xcp2 +256*e4e2^2*e3e1*e2e1*xcp2 -128*e4e2^2*e3e1*e2e1*x5*xcp2 -512*e4e2^2*e3e1*e2e1*x5^2*xcp2 +384*e4e2^2*e3e1*e2e1*x5^3*xcp2 -896*e4e2^2*e3e1*e2e1*x4*xcp2 +384*e4e2^2*e3e1*e2e1*x4*x5*xcp2 +512*e4e2^2*e3e1*e2e1*x4*x5^2*xcp2 +384*e4e2^2*e3e1*e2e1*x4^2*xcp2 +128*e4e2^2*e3e1*e2e1*x4^2*x5*xcp2 -256*e4e2^2*e3e1*e2e1*x3*xcp2 -256*e4e2^2*e3e1*e2e1*x3*x5*xcp2 +512*e4e2^2*e3e1*e2e1*x3*x5^2*xcp2 +1024*e4e2^2*e3e1*e2e1*x3*x4*xcp2 -256*e4e2^2*e3e1*e2e1*x3*x4*x5*xcp2 -256*e4e2^2*e3e1*e2e1*x3*x4^2*xcp2 +256*e4e2^2*e3e1*e2e1*x3^2*x5*xcp2 -256*e4e2^2*e3e1*e2e1*x3^2*x4*xcp2 -256*e4e2^2*e3e1*e2e1*x1*xcp2 +384*e4e2^2*e3e1*e2e1*x1*x5*xcp2 -128*e4e2^2*e3e1*e2e1*x1*x5^2*xcp2 +128*e4e2^2*e3e1*e2e1*x1*x4*xcp2 -128*e4e2^2*e3e1*e2e1*x1*x4*x5*xcp2 +256*e4e2^2*e3e1*e2e1*x1*x3*xcp2 -256*e4e2^2*e3e1*e2e1*x1*x3*x5*xcp2 -256*e4e2^2*e3e1*e3e2*x5*xcp2 +512*e4e2^2*e3e1*e3e2*x5^2*xcp2 -256*e4e2^2*e3e1*e3e2*x5^3*xcp2 +512*e4e2^2*e3e1*e3e2*x4*xcp2 -384*e4e2^2*e3e1*e3e2*x4*x5*xcp2 -128*e4e2^2*e3e1*e3e2*x4*x5^2*xcp2 -384*e4e2^2*e3e1*e3e2*x4^2*xcp2 +128*e4e2^2*e3e1*e3e2*x4^2*x5*xcp2 +384*e4e2^2*e3e1*e3e2*x3*x5*xcp2 -384*e4e2^2*e3e1*e3e2*x3*x5^2*xcp2 -640*e4e2^2*e3e1*e3e2*x3*x4*xcp2 +256*e4e2^2*e3e1*e3e2*x3*x4*x5*xcp2 +128*e4e2^2*e3e1*e3e2*x3*x4^2*xcp2 -128*e4e2^2*e3e1*e3e2*x3^2*x5*xcp2 +128*e4e2^2*e3e1*e3e2*x3^2*x4*xcp2 -256*e4e2^2*e3e1^2*xcp2 +512*e4e2^2*e3e1^2*x5*xcp2 -256*e4e2^2*e3e1^2*x5^2*xcp2 +512*e4e2^2*e3e1^2*x4*xcp2 -512*e4e2^2*e3e1^2*x4*x5*xcp2 -256*e4e2^2*e3e1^2*x4^2*xcp2 +256*e4e2^2*e3e1^2*x3*xcp2 -256*e4e2^2*e3e1^2*x3*x5*xcp2 -512*e4e2^2*e3e1^2*x3*x4*xcp2 +128*e4e2^2*e3e1^2*x3*x4*x5*xcp2 +128*e4e2^2*e3e1^2*x3*x4^2*xcp2 -128*e4e2^2*e3e1^2*x3^2*x5*xcp2 +128*e4e2^2*e3e1^2*x3^2*x4*xcp2 +256*e4e2^2*e3e1^2*x1*xcp2 -384*e4e2^2*e3e1^2*x1*x5*xcp2 +128*e4e2^2*e3e1^2*x1*x5^2*xcp2 -128*e4e2^2*e3e1^2*x1*x4*xcp2 +128*e4e2^2*e3e1^2*x1*x4*x5*xcp2 -256*e4e2^2*e3e1^2*x1*x3*xcp2 +256*e4e2^2*e3e1^2*x1*x3*x5*xcp2 -256*e4e2^3*amel2*x5^2*xcp2 +128*e4e2^3*amel2*x5^3*xcp2 -128*e4e2^3*amel2*x4*xcp2 +128*e4e2^3*amel2*x4*x5^2*xcp2 +128*e4e2^3*amel2*x3*x5*xcp2 -64*e4e2^3*amel2*x3*x5^2*xcp3 +128*e4e2^3*amel2*x3*x5^2*xcp2 -64*e4e2^3*amel2*x3*x5^2*xcp1 +128*e4e2^3*amel2*x3*x4*xcp2 -128*e4e2^3*amel2*x3*x4*x5*xcp2 -128*e4e2^3*amel2*x3^2*x5*xcp2 -128*e4e2^3*amel2*x1*xcp2 +128*e4e2^3*amel2*x1*x5^2*xcp2 +128*e4e2^3*amel2*x1*x3*xcp2 -128*e4e2^3*amel2*x1*x3*x5*xcp2 +128*e4e2^3*e2e1*x5*xcp2 -256*e4e2^3*e2e1*x5^2*xcp2 +128*e4e2^3*e2e1*x5^3*xcp2 -128*e4e2^3*e2e1*x4*xcp2 +128*e4e2^3*e2e1*x4*x5^2*xcp2 -128*e4e2^3*e2e1*x3*x5*xcp2 +128*e4e2^3*e2e1*x3*x5^2*xcp2 +128*e4e2^3*e2e1*x3*x4*xcp2 -128*e4e2^3*e2e1*x3*x4*x5*xcp2 -128*e4e2^3*e3e1*x5*xcp2 +256*e4e2^3*e3e1*x5^2*xcp2 -128*e4e2^3*e3e1*x5^3*xcp2 +128*e4e2^3*e3e1*x4*xcp2 -128*e4e2^3*e3e1*x4*x5^2*xcp2 +128*e4e2^3*e3e1*x3*x5*xcp2 -128*e4e2^3*e3e1*x3*x5^2*xcp2 -128*e4e2^3*e3e1*x3*x4*xcp2 +128*e4e2^3*e3e1*x3*x4*x5*xcp2 -64*e4e1*amel2^2*zk^2*xcp3 -64*e4e1*amel2^2*zk^2*xcp1 +96*e4e1*amel2^2*zk^2*x1*xcp3 +96*e4e1*amel2^2*zk^2*x1*xcp1 -64*e4e1*amel2^3*x5^2*xcp3 -64*e4e1*amel2^3*x5^2*xcp1 -128*e4e1*amel2^3*x4*x5*xcp3 +256*e4e1*amel2^3*x4*x5*xcp2 -128*e4e1*amel2^3*x4*x5*xcp1 -128*e4e1*amel2^3*x4^2*xcp3 +256*e4e1*amel2^3*x4^2*xcp2 -128*e4e1*amel2^3*x4^2*xcp1 +256*e4e1*amel2^3*x3*x5*xcp2 -128*e4e1*amel2^3*x3*x4*xcp3 +256*e4e1*amel2^3*x3*x4*xcp2 -128*e4e1*amel2^3*x3*x4*xcp1 -64*e4e1*amel2^3*x3^2*xcp3 -64*e4e1*amel2^3*x3^2*xcp1 +192*e4e1*amel2^3*x1*xcp3 +192*e4e1*amel2^3*x1*xcp1 -64*e4e1*amel2^3*x1*x5*xcp3 -64*e4e1*amel2^3*x1*x5*xcp1 +64*e4e1*amel2^3*x1*x5^2*xcp3 +64*e4e1*amel2^3*x1*x5^2*xcp1 -128*e4e1*amel2^3*x1*x4*xcp3 +256*e4e1*amel2^3*x1*x4*xcp2 -128*e4e1*amel2^3*x1*x4*xcp1 +128*e4e1*amel2^3*x1*x4*x5*xcp3 -256*e4e1*amel2^3*x1*x4*x5*xcp2 +128*e4e1*amel2^3*x1*x4*x5*xcp1 +128*e4e1*amel2^3*x1*x4^2*xcp3 -256*e4e1*amel2^3*x1*x4^2*xcp2 +128*e4e1*amel2^3*x1*x4^2*xcp1 -256*e4e1*amel2^3*x1*x3*xcp3 +256*e4e1*amel2^3*x1*x3*xcp2 -256*e4e1*amel2^3*x1*x3*xcp1 -256*e4e1*amel2^3*x1*x3*x5*xcp2 +128*e4e1*amel2^3*x1*x3*x4*xcp3 -256*e4e1*amel2^3*x1*x3*x4*xcp2 +128*e4e1*amel2^3*x1*x3*x4*xcp1 +64*e4e1*amel2^3*x1*x3^2*xcp3 +64*e4e1*amel2^3*x1*x3^2*xcp1 -192*e4e1*amel2^3*x1^2*xcp3 -192*e4e1*amel2^3*x1^2*xcp1 +128*e4e1*amel2^3*x1^2*x5*xcp3 +128*e4e1*amel2^3*x1^2*x5*xcp1 +128*e4e1*amel2^3*x1^2*x4*xcp3 +128*e4e1*amel2^3*x1^2*x4*xcp2 +128*e4e1*amel2^3*x1^2*x4*xcp1 +192*e4e1*amel2^3*x1^2*x3*xcp3 +128*e4e1*amel2^3*x1^2*x3*xcp2 +192*e4e1*amel2^3*x1^2*x3*xcp1 +64*e4e1*amel2^3*x1^3*xcp3 +64*e4e1*amel2^3*x1^3*xcp1 +64*e4e1*e2e1*amel2*zk^2*xcp3 -64*e4e1*e2e1*amel2*zk^2*xcp2 +64*e4e1*e2e1*amel2*zk^2*xcp1 -48*e4e1*e2e1*amel2*zk^2*x5*xcp3 -64*e4e1*e2e1*amel2*zk^2*x5*xcp2 -48*e4e1*e2e1*amel2*zk^2*x5*xcp1 -32*e4e1*e2e1*amel2*zk^2*x4*xcp2 +32*e4e1*e2e1*amel2*zk^2*x3*xcp2 -48*e4e1*e2e1*amel2*zk^2*x1*xcp3 +96*e4e1*e2e1*amel2*zk^2*x1*xcp2 -48*e4e1*e2e1*amel2*zk^2*x1*xcp1 +128*e4e1*e2e1*amel2^2*xcp3 +128*e4e1*e2e1*amel2^2*xcp1 -128*e4e1*e2e1*amel2^2*x5*xcp3 -512*e4e1*e2e1*amel2^2*x5*xcp2 -128*e4e1*e2e1*amel2^2*x5*xcp1 +32*e4e1*e2e1*amel2^2*x5^2*xcp3 +256*e4e1*e2e1*amel2^2*x5^2*xcp2 +32*e4e1*e2e1*amel2^2*x5^2*xcp1 -32*e4e1*e2e1*amel2^2*x5^3*xcp3 -32*e4e1*e2e1*amel2^2*x5^3*xcp1 -64*e4e1*e2e1*amel2^2*x4*xcp3 -640*e4e1*e2e1*amel2^2*x4*xcp2 -64*e4e1*e2e1*amel2^2*x4*xcp1 +704*e4e1*e2e1*amel2^2*x4*x5*xcp2 -64*e4e1*e2e1*amel2^2*x4*x5^2*xcp3 +128*e4e1*e2e1*amel2^2*x4*x5^2*xcp2 -64*e4e1*e2e1*amel2^2*x4*x5^2*xcp1 +512*e4e1*e2e1*amel2^2*x4^2*xcp2 -64*e4e1*e2e1*amel2^2*x4^2*x5*xcp3 +128*e4e1*e2e1*amel2^2*x4^2*x5*xcp2 -64*e4e1*e2e1*amel2^2*x4^2*x5*xcp1 -256*e4e1*e2e1*amel2^2*x3*xcp3 -128*e4e1*e2e1*amel2^2*x3*xcp2 -256*e4e1*e2e1*amel2^2*x3*xcp1 +64*e4e1*e2e1*amel2^2*x3*x5*xcp3 +704*e4e1*e2e1*amel2^2*x3*x5*xcp2 +64*e4e1*e2e1*amel2^2*x3*x5*xcp1 +128*e4e1*e2e1*amel2^2*x3*x5^2*xcp2 +64*e4e1*e2e1*amel2^2*x3*x4*xcp3 +960*e4e1*e2e1*amel2^2*x3*x4*xcp2 +64*e4e1*e2e1*amel2^2*x3*x4*xcp1 -64*e4e1*e2e1*amel2^2*x3*x4*x5*xcp3 -64*e4e1*e2e1*amel2^2*x3*x4*x5*xcp1 -128*e4e1*e2e1*amel2^2*x3*x4^2*xcp2 +96*e4e1*e2e1*amel2^2*x3^2*xcp3 +192*e4e1*e2e1*amel2^2*x3^2*xcp2 +96*e4e1*e2e1*amel2^2*x3^2*xcp1 -32*e4e1*e2e1*amel2^2*x3^2*x5*xcp3 -128*e4e1*e2e1*amel2^2*x3^2*x5*xcp2 -32*e4e1*e2e1*amel2^2*x3^2*x5*xcp1 -128*e4e1*e2e1*amel2^2*x3^2*x4*xcp2 -64*e4e1*e2e1*amel2^2*x1*xcp3 -64*e4e1*e2e1*amel2^2*x1*xcp1 +192*e4e1*e2e1*amel2^2*x1*x5*xcp3 +640*e4e1*e2e1*amel2^2*x1*x5*xcp2 +192*e4e1*e2e1*amel2^2*x1*x5*xcp1 -96*e4e1*e2e1*amel2^2*x1*x5^2*xcp3 -384*e4e1*e2e1*amel2^2*x1*x5^2*xcp2 -96*e4e1*e2e1*amel2^2*x1*x5^2*xcp1 -64*e4e1*e2e1*amel2^2*x1*x4*xcp3 +832*e4e1*e2e1*amel2^2*x1*x4*xcp2 -64*e4e1*e2e1*amel2^2*x1*x4*xcp1 -896*e4e1*e2e1*amel2^2*x1*x4*x5*xcp2 +64*e4e1*e2e1*amel2^2*x1*x4^2*xcp3 -384*e4e1*e2e1*amel2^2*x1*x4^2*xcp2 +64*e4e1*e2e1*amel2^2*x1*x4^2*xcp1 +192*e4e1*e2e1*amel2^2*x1*x3*xcp2 -640*e4e1*e2e1*amel2^2*x1*x3*x5*xcp2 +192*e4e1*e2e1*amel2^2*x1*x3*x4*xcp3 -512*e4e1*e2e1*amel2^2*x1*x3*x4*xcp2 +192*e4e1*e2e1*amel2^2*x1*x3*x4*xcp1 -32*e4e1*e2e1*amel2^2*x1*x3^2*xcp3 -32*e4e1*e2e1*amel2^2*x1*x3^2*xcp1 -96*e4e1*e2e1*amel2^2*x1^2*xcp3 -256*e4e1*e2e1*amel2^2*x1^2*xcp2 -96*e4e1*e2e1*amel2^2*x1^2*xcp1 -96*e4e1*e2e1*amel2^2*x1^2*x5*xcp3 +128*e4e1*e2e1*amel2^2*x1^2*x5*xcp2 -96*e4e1*e2e1*amel2^2*x1^2*x5*xcp1 +64*e4e1*e2e1*amel2^2*x1^2*x4*xcp3 +384*e4e1*e2e1*amel2^2*x1^2*x4*xcp2 +64*e4e1*e2e1*amel2^2*x1^2*x4*xcp1 +128*e4e1*e2e1*amel2^2*x1^2*x3*xcp3 +512*e4e1*e2e1*amel2^2*x1^2*x3*xcp2 +128*e4e1*e2e1*amel2^2*x1^2*x3*xcp1 -32*e4e1*e2e1*amel2^2*x1^3*xcp3 +128*e4e1*e2e1*amel2^2*x1^3*xcp2 -32*e4e1*e2e1*amel2^2*x1^3*xcp1 +64*e4e1*e2e1^2*zk^2*xcp2 -64*e4e1*e2e1^2*zk^2*x5*xcp2 -32*e4e1*e2e1^2*zk^2*x4*xcp2 -96*e4e1*e2e1^2*zk^2*x3*xcp2 +32*e4e1*e2e1^2*zk^2*x1*xcp2 +128*e4e1*e2e1^2*amel2*xcp3 +256*e4e1*e2e1^2*amel2*xcp2 +128*e4e1*e2e1^2*amel2*xcp1 -896*e4e1*e2e1^2*amel2*x5*xcp2 -32*e4e1*e2e1^2*amel2*x5^2*xcp3 +192*e4e1*e2e1^2*amel2*x5^2*xcp2 -32*e4e1*e2e1^2*amel2*x5^2*xcp1 +128*e4e1*e2e1^2*amel2*x5^3*xcp2 -64*e4e1*e2e1^2*amel2*x4*xcp3 -1152*e4e1*e2e1^2*amel2*x4*xcp2 -64*e4e1*e2e1^2*amel2*x4*xcp1 +128*e4e1*e2e1^2*amel2*x4*x5*xcp3 +576*e4e1*e2e1^2*amel2*x4*x5*xcp2 +128*e4e1*e2e1^2*amel2*x4*x5*xcp1 -64*e4e1*e2e1^2*amel2*x4*x5^2*xcp3 +384*e4e1*e2e1^2*amel2*x4*x5^2*xcp2 -64*e4e1*e2e1^2*amel2*x4*x5^2*xcp1 +128*e4e1*e2e1^2*amel2*x4^2*xcp3 +512*e4e1*e2e1^2*amel2*x4^2*xcp2 +128*e4e1*e2e1^2*amel2*x4^2*xcp1 -64*e4e1*e2e1^2*amel2*x4^2*x5*xcp3 +256*e4e1*e2e1^2*amel2*x4^2*x5*xcp2 -64*e4e1*e2e1^2*amel2*x4^2*x5*xcp1 -128*e4e1*e2e1^2*amel2*x3*xcp3 -768*e4e1*e2e1^2*amel2*x3*xcp2 -128*e4e1*e2e1^2*amel2*x3*xcp1 +832*e4e1*e2e1^2*amel2*x3*x5*xcp2 +256*e4e1*e2e1^2*amel2*x3*x5^2*xcp2 +192*e4e1*e2e1^2*amel2*x3*x4*xcp3 +1344*e4e1*e2e1^2*amel2*x3*x4*xcp2 +192*e4e1*e2e1^2*amel2*x3*x4*xcp1 -64*e4e1*e2e1^2*amel2*x3*x4*x5*xcp3 +128*e4e1*e2e1^2*amel2*x3*x4*x5*xcp2 -64*e4e1*e2e1^2*amel2*x3*x4*x5*xcp1 -256*e4e1*e2e1^2*amel2*x3*x4^2*xcp2 +32*e4e1*e2e1^2*amel2*x3^2*xcp3 +640*e4e1*e2e1^2*amel2*x3^2*xcp2 +32*e4e1*e2e1^2*amel2*x3^2*xcp1 -256*e4e1*e2e1^2*amel2*x3^2*x4*xcp2 -128*e4e1*e2e1^2*amel2*x3^3*xcp2 -128*e4e1*e2e1^2*amel2*x1*xcp3 -384*e4e1*e2e1^2*amel2*x1*xcp2 -128*e4e1*e2e1^2*amel2*x1*xcp1 +64*e4e1*e2e1^2*amel2*x1*x5*xcp3 +1280*e4e1*e2e1^2*amel2*x1*x5*xcp2 +64*e4e1*e2e1^2*amel2*x1*x5*xcp1 -640*e4e1*e2e1^2*amel2*x1*x5^2*xcp2 +64*e4e1*e2e1^2*amel2*x1*x4*xcp3 +832*e4e1*e2e1^2*amel2*x1*x4*xcp2 +64*e4e1*e2e1^2*amel2*x1*x4*xcp1 -128*e4e1*e2e1^2*amel2*x1*x4*x5*xcp3 -1024*e4e1*e2e1^2*amel2*x1*x4*x5*xcp2 -128*e4e1*e2e1^2*amel2*x1*x4*x5*xcp1 -64*e4e1*e2e1^2*amel2*x1*x4^2*xcp3 -256*e4e1*e2e1^2*amel2*x1*x4^2*xcp2 -64*e4e1*e2e1^2*amel2*x1*x4^2*xcp1 +128*e4e1*e2e1^2*amel2*x1*x3*xcp3 +576*e4e1*e2e1^2*amel2*x1*x3*xcp2 +128*e4e1*e2e1^2*amel2*x1*x3*xcp1 -1024*e4e1*e2e1^2*amel2*x1*x3*x5*xcp2 +64*e4e1*e2e1^2*amel2*x1*x3*x4*xcp3 -512*e4e1*e2e1^2*amel2*x1*x3*x4*xcp2 +64*e4e1*e2e1^2*amel2*x1*x3*x4*xcp1 +128*e4e1*e2e1^2*amel2*x1*x3^2*xcp3 -256*e4e1*e2e1^2*amel2*x1*x3^2*xcp2 +128*e4e1*e2e1^2*amel2*x1*x3^2*xcp1 +32*e4e1*e2e1^2*amel2*x1^2*xcp3 -192*e4e1*e2e1^2*amel2*x1^2*xcp2 +32*e4e1*e2e1^2*amel2*x1^2*xcp1 +128*e4e1*e2e1^2*amel2*x1^2*x5*xcp2 -64*e4e1*e2e1^2*amel2*x1^2*x4*xcp3 +256*e4e1*e2e1^2*amel2*x1^2*x4*xcp2 -64*e4e1*e2e1^2*amel2*x1^2*x4*xcp1 -64*e4e1*e2e1^2*amel2*x1^2*x3*xcp3 +384*e4e1*e2e1^2*amel2*x1^2*x3*xcp2 -64*e4e1*e2e1^2*amel2*x1^2*x3*xcp1 +128*e4e1*e2e1^2*amel2*x1^3*xcp2 +256*e4e1*e2e1^3*xcp2 -256*e4e1*e2e1^3*x5*xcp2 -128*e4e1*e2e1^3*x5^2*xcp2 +128*e4e1*e2e1^3*x5^3*xcp2 -512*e4e1*e2e1^3*x4*xcp2 +128*e4e1*e2e1^3*x4*x5*xcp2 +256*e4e1*e2e1^3*x4*x5^2*xcp2 +256*e4e1*e2e1^3*x4^2*xcp2 +128*e4e1*e2e1^3*x4^2*x5*xcp2 -512*e4e1*e2e1^3*x3*xcp2 +128*e4e1*e2e1^3*x3*x5*xcp2 +256*e4e1*e2e1^3*x3*x5^2*xcp2 +640*e4e1*e2e1^3*x3*x4*xcp2 +128*e4e1*e2e1^3*x3*x4*x5*xcp2 -128*e4e1*e2e1^3*x3*x4^2*xcp2 +256*e4e1*e2e1^3*x3^2*xcp2 +128*e4e1*e2e1^3*x3^2*x5*xcp2 -128*e4e1*e2e1^3*x3^2*x4*xcp2 -256*e4e1*e2e1^3*x1*xcp2 +512*e4e1*e2e1^3*x1*x5*xcp2 -256*e4e1*e2e1^3*x1*x5^2*xcp2 +256*e4e1*e2e1^3*x1*x4*xcp2 -384*e4e1*e2e1^3*x1*x4*x5*xcp2 -128*e4e1*e2e1^3*x1*x4^2*xcp2 +512*e4e1*e2e1^3*x1*x3*xcp2 -512*e4e1*e2e1^3*x1*x3*x5*xcp2 -256*e4e1*e2e1^3*x1*x3*x4*xcp2 -256*e4e1*e2e1^3*x1*x3^2*xcp2 -64*e4e1*e3e2*amel2*zk^2*xcp3 +64*e4e1*e3e2*amel2*zk^2*xcp2 -64*e4e1*e3e2*amel2*zk^2*xcp1 +48*e4e1*e3e2*amel2*zk^2*x5*xcp3 +64*e4e1*e3e2*amel2*zk^2*x5*xcp2 +48*e4e1*e3e2*amel2*zk^2*x5*xcp1 +32*e4e1*e3e2*amel2*zk^2*x4*xcp2 -32*e4e1*e3e2*amel2*zk^2*x3*xcp2 +48*e4e1*e3e2*amel2*zk^2*x1*xcp3 -96*e4e1*e3e2*amel2*zk^2*x1*xcp2 +48*e4e1*e3e2*amel2*zk^2*x1*xcp1 -128*e4e1*e3e2*amel2^2*xcp3 -128*e4e1*e3e2*amel2^2*xcp1 +128*e4e1*e3e2*amel2^2*x5*xcp3 +512*e4e1*e3e2*amel2^2*x5*xcp2 +128*e4e1*e3e2*amel2^2*x5*xcp1 -32*e4e1*e3e2*amel2^2*x5^2*xcp3 -256*e4e1*e3e2*amel2^2*x5^2*xcp2 -32*e4e1*e3e2*amel2^2*x5^2*xcp1 +32*e4e1*e3e2*amel2^2*x5^3*xcp3 +32*e4e1*e3e2*amel2^2*x5^3*xcp1 +64*e4e1*e3e2*amel2^2*x4*xcp3 +640*e4e1*e3e2*amel2^2*x4*xcp2 +64*e4e1*e3e2*amel2^2*x4*xcp1 -704*e4e1*e3e2*amel2^2*x4*x5*xcp2 +64*e4e1*e3e2*amel2^2*x4*x5^2*xcp3 -128*e4e1*e3e2*amel2^2*x4*x5^2*xcp2 +64*e4e1*e3e2*amel2^2*x4*x5^2*xcp1 -512*e4e1*e3e2*amel2^2*x4^2*xcp2 +64*e4e1*e3e2*amel2^2*x4^2*x5*xcp3 -128*e4e1*e3e2*amel2^2*x4^2*x5*xcp2 +64*e4e1*e3e2*amel2^2*x4^2*x5*xcp1 +256*e4e1*e3e2*amel2^2*x3*xcp3 +128*e4e1*e3e2*amel2^2*x3*xcp2 +256*e4e1*e3e2*amel2^2*x3*xcp1 -64*e4e1*e3e2*amel2^2*x3*x5*xcp3 -704*e4e1*e3e2*amel2^2*x3*x5*xcp2 -64*e4e1*e3e2*amel2^2*x3*x5*xcp1 -128*e4e1*e3e2*amel2^2*x3*x5^2*xcp2 -64*e4e1*e3e2*amel2^2*x3*x4*xcp3 -960*e4e1*e3e2*amel2^2*x3*x4*xcp2 -64*e4e1*e3e2*amel2^2*x3*x4*xcp1 +64*e4e1*e3e2*amel2^2*x3*x4*x5*xcp3 +64*e4e1*e3e2*amel2^2*x3*x4*x5*xcp1 +128*e4e1*e3e2*amel2^2*x3*x4^2*xcp2 -96*e4e1*e3e2*amel2^2*x3^2*xcp3 -192*e4e1*e3e2*amel2^2*x3^2*xcp2 -96*e4e1*e3e2*amel2^2*x3^2*xcp1 +32*e4e1*e3e2*amel2^2*x3^2*x5*xcp3 +128*e4e1*e3e2*amel2^2*x3^2*x5*xcp2 +32*e4e1*e3e2*amel2^2*x3^2*x5*xcp1 +128*e4e1*e3e2*amel2^2*x3^2*x4*xcp2 +192*e4e1*e3e2*amel2^2*x1*xcp3 +192*e4e1*e3e2*amel2^2*x1*xcp1 -192*e4e1*e3e2*amel2^2*x1*x5*xcp3 -640*e4e1*e3e2*amel2^2*x1*x5*xcp2 -192*e4e1*e3e2*amel2^2*x1*x5*xcp1 +96*e4e1*e3e2*amel2^2*x1*x5^2*xcp3 +384*e4e1*e3e2*amel2^2*x1*x5^2*xcp2 +96*e4e1*e3e2*amel2^2*x1*x5^2*xcp1 -64*e4e1*e3e2*amel2^2*x1*x4*xcp3 -832*e4e1*e3e2*amel2^2*x1*x4*xcp2 -64*e4e1*e3e2*amel2^2*x1*x4*xcp1 +896*e4e1*e3e2*amel2^2*x1*x4*x5*xcp2 -64*e4e1*e3e2*amel2^2*x1*x4^2*xcp3 +384*e4e1*e3e2*amel2^2*x1*x4^2*xcp2 -64*e4e1*e3e2*amel2^2*x1*x4^2*xcp1 -128*e4e1*e3e2*amel2^2*x1*x3*xcp3 -192*e4e1*e3e2*amel2^2*x1*x3*xcp2 -128*e4e1*e3e2*amel2^2*x1*x3*xcp1 +640*e4e1*e3e2*amel2^2*x1*x3*x5*xcp2 -192*e4e1*e3e2*amel2^2*x1*x3*x4*xcp3 +512*e4e1*e3e2*amel2^2*x1*x3*x4*xcp2 -192*e4e1*e3e2*amel2^2*x1*x3*x4*xcp1 +32*e4e1*e3e2*amel2^2*x1*x3^2*xcp3 +32*e4e1*e3e2*amel2^2*x1*x3^2*xcp1 -32*e4e1*e3e2*amel2^2*x1^2*xcp3 +256*e4e1*e3e2*amel2^2*x1^2*xcp2 -32*e4e1*e3e2*amel2^2*x1^2*xcp1 +96*e4e1*e3e2*amel2^2*x1^2*x5*xcp3 -128*e4e1*e3e2*amel2^2*x1^2*x5*xcp2 +96*e4e1*e3e2*amel2^2*x1^2*x5*xcp1 +64*e4e1*e3e2*amel2^2*x1^2*x4*xcp3 -384*e4e1*e3e2*amel2^2*x1^2*x4*xcp2 +64*e4e1*e3e2*amel2^2*x1^2*x4*xcp1 -512*e4e1*e3e2*amel2^2*x1^2*x3*xcp2 +32*e4e1*e3e2*amel2^2*x1^3*xcp3 -128*e4e1*e3e2*amel2^2*x1^3*xcp2 +32*e4e1*e3e2*amel2^2*x1^3*xcp1 -160*e4e1*e3e2*e2e1*zk^2*xcp2 +128*e4e1*e3e2*e2e1*zk^2*x5*xcp2 +64*e4e1*e3e2*e2e1*zk^2*x4*xcp2 +192*e4e1*e3e2*e2e1*zk^2*x3*xcp2 -32*e4e1*e3e2*e2e1*zk^2*x1*xcp2 -128*e4e1*e3e2*e2e1*amel2*xcp3 -512*e4e1*e3e2*e2e1*amel2*xcp2 -128*e4e1*e3e2*e2e1*amel2*xcp1 -64*e4e1*e3e2*e2e1*amel2*x5*xcp3 +1536*e4e1*e3e2*e2e1*amel2*x5*xcp2 -64*e4e1*e3e2*e2e1*amel2*x5*xcp1 +64*e4e1*e3e2*e2e1*amel2*x5^2*xcp3 -256*e4e1*e3e2*e2e1*amel2*x5^2*xcp2 +64*e4e1*e3e2*e2e1*amel2*x5^2*xcp1 -256*e4e1*e3e2*e2e1*amel2*x5^3*xcp2 +64*e4e1*e3e2*e2e1*amel2*x4*xcp3 +2048*e4e1*e3e2*e2e1*amel2*x4*xcp2 +64*e4e1*e3e2*e2e1*amel2*x4*xcp1 -256*e4e1*e3e2*e2e1*amel2*x4*x5*xcp3 -896*e4e1*e3e2*e2e1*amel2*x4*x5*xcp2 -256*e4e1*e3e2*e2e1*amel2*x4*x5*xcp1 +128*e4e1*e3e2*e2e1*amel2*x4*x5^2*xcp3 -768*e4e1*e3e2*e2e1*amel2*x4*x5^2*xcp2 +128*e4e1*e3e2*e2e1*amel2*x4*x5^2*xcp1 -256*e4e1*e3e2*e2e1*amel2*x4^2*xcp3 -896*e4e1*e3e2*e2e1*amel2*x4^2*xcp2 -256*e4e1*e3e2*e2e1*amel2*x4^2*xcp1 +128*e4e1*e3e2*e2e1*amel2*x4^2*x5*xcp3 -512*e4e1*e3e2*e2e1*amel2*x4^2*x5*xcp2 +128*e4e1*e3e2*e2e1*amel2*x4^2*x5*xcp1 +128*e4e1*e3e2*e2e1*amel2*x3*xcp3 +1536*e4e1*e3e2*e2e1*amel2*x3*xcp2 +128*e4e1*e3e2*e2e1*amel2*x3*xcp1 -1408*e4e1*e3e2*e2e1*amel2*x3*x5*xcp2 -512*e4e1*e3e2*e2e1*amel2*x3*x5^2*xcp2 -384*e4e1*e3e2*e2e1*amel2*x3*x4*xcp3 -2432*e4e1*e3e2*e2e1*amel2*x3*x4*xcp2 -384*e4e1*e3e2*e2e1*amel2*x3*x4*xcp1 +128*e4e1*e3e2*e2e1*amel2*x3*x4*x5*xcp3 -256*e4e1*e3e2*e2e1*amel2*x3*x4*x5*xcp2 +128*e4e1*e3e2*e2e1*amel2*x3*x4*x5*xcp1 +512*e4e1*e3e2*e2e1*amel2*x3*x4^2*xcp2 -64*e4e1*e3e2*e2e1*amel2*x3^2*xcp3 -1280*e4e1*e3e2*e2e1*amel2*x3^2*xcp2 -64*e4e1*e3e2*e2e1*amel2*x3^2*xcp1 +512*e4e1*e3e2*e2e1*amel2*x3^2*x4*xcp2 +256*e4e1*e3e2*e2e1*amel2*x3^3*xcp2 +128*e4e1*e3e2*e2e1*amel2*x1*xcp3 +896*e4e1*e3e2*e2e1*amel2*x1*xcp2 +128*e4e1*e3e2*e2e1*amel2*x1*xcp1 -32*e4e1*e3e2*e2e1*amel2*x1*x5*xcp3 -2240*e4e1*e3e2*e2e1*amel2*x1*x5*xcp2 -32*e4e1*e3e2*e2e1*amel2*x1*x5*xcp1 +1024*e4e1*e3e2*e2e1*amel2*x1*x5^2*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x4*xcp3 -1600*e4e1*e3e2*e2e1*amel2*x1*x4*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x4*xcp1 +192*e4e1*e3e2*e2e1*amel2*x1*x4*x5*xcp3 +1536*e4e1*e3e2*e2e1*amel2*x1*x4*x5*xcp2 +192*e4e1*e3e2*e2e1*amel2*x1*x4*x5*xcp1 +128*e4e1*e3e2*e2e1*amel2*x1*x4^2*xcp3 +384*e4e1*e3e2*e2e1*amel2*x1*x4^2*xcp2 +128*e4e1*e3e2*e2e1*amel2*x1*x4^2*xcp1 -96*e4e1*e3e2*e2e1*amel2*x1*x3*xcp3 -1536*e4e1*e3e2*e2e1*amel2*x1*x3*xcp2 -96*e4e1*e3e2*e2e1*amel2*x1*x3*xcp1 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x5*xcp3 +1792*e4e1*e3e2*e2e1*amel2*x1*x3*x5*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x5*xcp1 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x4*xcp3 +1024*e4e1*e3e2*e2e1*amel2*x1*x3*x4*xcp2 -64*e4e1*e3e2*e2e1*amel2*x1*x3*x4*xcp1 -192*e4e1*e3e2*e2e1*amel2*x1*x3^2*xcp3 +640*e4e1*e3e2*e2e1*amel2*x1*x3^2*xcp2 -192*e4e1*e3e2*e2e1*amel2*x1*x3^2*xcp1 -32*e4e1*e3e2*e2e1*amel2*x1^2*xcp3 +192*e4e1*e3e2*e2e1*amel2*x1^2*xcp2 -32*e4e1*e3e2*e2e1*amel2*x1^2*xcp1 -128*e4e1*e3e2*e2e1*amel2*x1^2*x5*xcp2 +64*e4e1*e3e2*e2e1*amel2*x1^2*x4*xcp3 -384*e4e1*e3e2*e2e1*amel2*x1^2*x4*xcp2 +64*e4e1*e3e2*e2e1*amel2*x1^2*x4*xcp1 +64*e4e1*e3e2*e2e1*amel2*x1^2*x3*xcp3 -384*e4e1*e3e2*e2e1*amel2*x1^2*x3*xcp2 +64*e4e1*e3e2*e2e1*amel2*x1^2*x3*xcp1 -128*e4e1*e3e2*e2e1*amel2*x1^3*xcp2 -512*e4e1*e3e2*e2e1^2*xcp2 +384*e4e1*e3e2*e2e1^2*x5*xcp2 +512*e4e1*e3e2*e2e1^2*x5^2*xcp2 -384*e4e1*e3e2*e2e1^2*x5^3*xcp2 +1152*e4e1*e3e2*e2e1^2*x4*xcp2 -128*e4e1*e3e2*e2e1^2*x4*x5*xcp2 -768*e4e1*e3e2*e2e1^2*x4*x5^2*xcp2 -640*e4e1*e3e2*e2e1^2*x4^2*xcp2 -384*e4e1*e3e2*e2e1^2*x4^2*x5*xcp2 +1024*e4e1*e3e2*e2e1^2*x3*xcp2 -768*e4e1*e3e2*e2e1^2*x3*x5^2*xcp2 -1536*e4e1*e3e2*e2e1^2*x3*x4*xcp2 -384*e4e1*e3e2*e2e1^2*x3*x4*x5*xcp2 +384*e4e1*e3e2*e2e1^2*x3*x4^2*xcp2 -512*e4e1*e3e2*e2e1^2*x3^2*xcp2 -384*e4e1*e3e2*e2e1^2*x3^2*x5*xcp2 +384*e4e1*e3e2*e2e1^2*x3^2*x4*xcp2 +512*e4e1*e3e2*e2e1^2*x1*xcp2 -1024*e4e1*e3e2*e2e1^2*x1*x5*xcp2 +512*e4e1*e3e2*e2e1^2*x1*x5^2*xcp2 -512*e4e1*e3e2*e2e1^2*x1*x4*xcp2 +768*e4e1*e3e2*e2e1^2*x1*x4*x5*xcp2 +256*e4e1*e3e2*e2e1^2*x1*x4^2*xcp2 -1024*e4e1*e3e2*e2e1^2*x1*x3*xcp2 +1024*e4e1*e3e2*e2e1^2*x1*x3*x5*xcp2 +512*e4e1*e3e2*e2e1^2*x1*x3*x4*xcp2 +512*e4e1*e3e2*e2e1^2*x1*x3^2*xcp2 +96*e4e1*e3e2^2*zk^2*xcp2 -64*e4e1*e3e2^2*zk^2*x5*xcp2 -32*e4e1*e3e2^2*zk^2*x4*xcp2 -96*e4e1*e3e2^2*zk^2*x3*xcp2 +256*e4e1*e3e2^2*amel2*xcp2 +64*e4e1*e3e2^2*amel2*x5*xcp3 -640*e4e1*e3e2^2*amel2*x5*xcp2 +64*e4e1*e3e2^2*amel2*x5*xcp1 -32*e4e1*e3e2^2*amel2*x5^2*xcp3 +64*e4e1*e3e2^2*amel2*x5^2*xcp2 -32*e4e1*e3e2^2*amel2*x5^2*xcp1 +128*e4e1*e3e2^2*amel2*x5^3*xcp2 -896*e4e1*e3e2^2*amel2*x4*xcp2 +128*e4e1*e3e2^2*amel2*x4*x5*xcp3 +320*e4e1*e3e2^2*amel2*x4*x5*xcp2 +128*e4e1*e3e2^2*amel2*x4*x5*xcp1 -64*e4e1*e3e2^2*amel2*x4*x5^2*xcp3 +384*e4e1*e3e2^2*amel2*x4*x5^2*xcp2 -64*e4e1*e3e2^2*amel2*x4*x5^2*xcp1 +128*e4e1*e3e2^2*amel2*x4^2*xcp3 +384*e4e1*e3e2^2*amel2*x4^2*xcp2 +128*e4e1*e3e2^2*amel2*x4^2*xcp1 -64*e4e1*e3e2^2*amel2*x4^2*x5*xcp3 +256*e4e1*e3e2^2*amel2*x4^2*x5*xcp2 -64*e4e1*e3e2^2*amel2*x4^2*x5*xcp1 -768*e4e1*e3e2^2*amel2*x3*xcp2 +576*e4e1*e3e2^2*amel2*x3*x5*xcp2 +256*e4e1*e3e2^2*amel2*x3*x5^2*xcp2 +192*e4e1*e3e2^2*amel2*x3*x4*xcp3 +1088*e4e1*e3e2^2*amel2*x3*x4*xcp2 +192*e4e1*e3e2^2*amel2*x3*x4*xcp1 -64*e4e1*e3e2^2*amel2*x3*x4*x5*xcp3 +128*e4e1*e3e2^2*amel2*x3*x4*x5*xcp2 -64*e4e1*e3e2^2*amel2*x3*x4*x5*xcp1 -256*e4e1*e3e2^2*amel2*x3*x4^2*xcp2 +32*e4e1*e3e2^2*amel2*x3^2*xcp3 +640*e4e1*e3e2^2*amel2*x3^2*xcp2 +32*e4e1*e3e2^2*amel2*x3^2*xcp1 -256*e4e1*e3e2^2*amel2*x3^2*x4*xcp2 -128*e4e1*e3e2^2*amel2*x3^3*xcp2 -512*e4e1*e3e2^2*amel2*x1*xcp2 -32*e4e1*e3e2^2*amel2*x1*x5*xcp3 +960*e4e1*e3e2^2*amel2*x1*x5*xcp2 -32*e4e1*e3e2^2*amel2*x1*x5*xcp1 -384*e4e1*e3e2^2*amel2*x1*x5^2*xcp2 +768*e4e1*e3e2^2*amel2*x1*x4*xcp2 -64*e4e1*e3e2^2*amel2*x1*x4*x5*xcp3 -512*e4e1*e3e2^2*amel2*x1*x4*x5*xcp2 -64*e4e1*e3e2^2*amel2*x1*x4*x5*xcp1 -64*e4e1*e3e2^2*amel2*x1*x4^2*xcp3 -128*e4e1*e3e2^2*amel2*x1*x4^2*xcp2 -64*e4e1*e3e2^2*amel2*x1*x4^2*xcp1 -32*e4e1*e3e2^2*amel2*x1*x3*xcp3 +960*e4e1*e3e2^2*amel2*x1*x3*xcp2 -32*e4e1*e3e2^2*amel2*x1*x3*xcp1 +64*e4e1*e3e2^2*amel2*x1*x3*x5*xcp3 -768*e4e1*e3e2^2*amel2*x1*x3*x5*xcp2 +64*e4e1*e3e2^2*amel2*x1*x3*x5*xcp1 -512*e4e1*e3e2^2*amel2*x1*x3*x4*xcp2 +64*e4e1*e3e2^2*amel2*x1*x3^2*xcp3 -384*e4e1*e3e2^2*amel2*x1*x3^2*xcp2 +64*e4e1*e3e2^2*amel2*x1*x3^2*xcp1 +128*e4e1*e3e2^2*amel2*x1^2*x4*xcp2 +256*e4e1*e3e2^2*e2e1*xcp2 -640*e4e1*e3e2^2*e2e1*x5^2*xcp2 +384*e4e1*e3e2^2*e2e1*x5^3*xcp2 -768*e4e1*e3e2^2*e2e1*x4*xcp2 -128*e4e1*e3e2^2*e2e1*x4*x5*xcp2 +768*e4e1*e3e2^2*e2e1*x4*x5^2*xcp2 +512*e4e1*e3e2^2*e2e1*x4^2*xcp2 +384*e4e1*e3e2^2*e2e1*x4^2*x5*xcp2 -512*e4e1*e3e2^2*e2e1*x3*xcp2 -384*e4e1*e3e2^2*e2e1*x3*x5*xcp2 +768*e4e1*e3e2^2*e2e1*x3*x5^2*xcp2 +1152*e4e1*e3e2^2*e2e1*x3*x4*xcp2 +384*e4e1*e3e2^2*e2e1*x3*x4*x5*xcp2 -384*e4e1*e3e2^2*e2e1*x3*x4^2*xcp2 +256*e4e1*e3e2^2*e2e1*x3^2*xcp2 +384*e4e1*e3e2^2*e2e1*x3^2*x5*xcp2 -384*e4e1*e3e2^2*e2e1*x3^2*x4*xcp2 -256*e4e1*e3e2^2*e2e1*x1*xcp2 +512*e4e1*e3e2^2*e2e1*x1*x5*xcp2 -256*e4e1*e3e2^2*e2e1*x1*x5^2*xcp2 +256*e4e1*e3e2^2*e2e1*x1*x4*xcp2 -384*e4e1*e3e2^2*e2e1*x1*x4*x5*xcp2 -128*e4e1*e3e2^2*e2e1*x1*x4^2*xcp2 +512*e4e1*e3e2^2*e2e1*x1*x3*xcp2 -512*e4e1*e3e2^2*e2e1*x1*x3*x5*xcp2 -256*e4e1*e3e2^2*e2e1*x1*x3*x4*xcp2 -256*e4e1*e3e2^2*e2e1*x1*x3^2*xcp2 -128*e4e1*e3e2^3*x5*xcp2 +256*e4e1*e3e2^3*x5^2*xcp2 -128*e4e1*e3e2^3*x5^3*xcp2 +128*e4e1*e3e2^3*x4*xcp2 +128*e4e1*e3e2^3*x4*x5*xcp2 -256*e4e1*e3e2^3*x4*x5^2*xcp2 -128*e4e1*e3e2^3*x4^2*xcp2 -128*e4e1*e3e2^3*x4^2*x5*xcp2 +256*e4e1*e3e2^3*x3*x5*xcp2 -256*e4e1*e3e2^3*x3*x5^2*xcp2 -256*e4e1*e3e2^3*x3*x4*xcp2 -128*e4e1*e3e2^3*x3*x4*x5*xcp2 +128*e4e1*e3e2^3*x3*x4^2*xcp2 -128*e4e1*e3e2^3*x3^2*x5*xcp2 +128*e4e1*e3e2^3*x3^2*x4*xcp2 +112*e4e1*e3e1*amel2*zk^2*xcp3 +112*e4e1*e3e1*amel2*zk^2*xcp1 -48*e4e1*e3e1*amel2*zk^2*x5*xcp3 -48*e4e1*e3e1*amel2*zk^2*x5*xcp1 -48*e4e1*e3e1*amel2*zk^2*x4*xcp3 +32*e4e1*e3e1*amel2*zk^2*x4*xcp2 -48*e4e1*e3e1*amel2*zk^2*x4*xcp1 +32*e4e1*e3e1*amel2*zk^2*x3*xcp2 -96*e4e1*e3e1*amel2*zk^2*x1*xcp3 -96*e4e1*e3e1*amel2*zk^2*x1*xcp1 -160*e4e1*e3e1*amel2^2*x5*xcp3 -160*e4e1*e3e1*amel2^2*x5*xcp1 +224*e4e1*e3e1*amel2^2*x5^2*xcp3 +224*e4e1*e3e1*amel2^2*x5^2*xcp1 -32*e4e1*e3e1*amel2^2*x5^3*xcp3 -32*e4e1*e3e1*amel2^2*x5^3*xcp1 -160*e4e1*e3e1*amel2^2*x4*xcp3 +256*e4e1*e3e1*amel2^2*x4*xcp2 -160*e4e1*e3e1*amel2^2*x4*xcp1 +480*e4e1*e3e1*amel2^2*x4*x5*xcp3 -704*e4e1*e3e1*amel2^2*x4*x5*xcp2 +480*e4e1*e3e1*amel2^2*x4*x5*xcp1 -96*e4e1*e3e1*amel2^2*x4*x5^2*xcp3 +128*e4e1*e3e1*amel2^2*x4*x5^2*xcp2 -96*e4e1*e3e1*amel2^2*x4*x5^2*xcp1 +384*e4e1*e3e1*amel2^2*x4^2*xcp3 -704*e4e1*e3e1*amel2^2*x4^2*xcp2 +384*e4e1*e3e1*amel2^2*x4^2*xcp1 -128*e4e1*e3e1*amel2^2*x4^2*x5*xcp3 +256*e4e1*e3e1*amel2^2*x4^2*x5*xcp2 -128*e4e1*e3e1*amel2^2*x4^2*x5*xcp1 -64*e4e1*e3e1*amel2^2*x4^3*xcp3 +128*e4e1*e3e1*amel2^2*x4^3*xcp2 -64*e4e1*e3e1*amel2^2*x4^3*xcp1 +256*e4e1*e3e1*amel2^2*x3*xcp2 +160*e4e1*e3e1*amel2^2*x3*x5*xcp3 -704*e4e1*e3e1*amel2^2*x3*x5*xcp2 +160*e4e1*e3e1*amel2^2*x3*x5*xcp1 +128*e4e1*e3e1*amel2^2*x3*x5^2*xcp2 +416*e4e1*e3e1*amel2^2*x3*x4*xcp3 -960*e4e1*e3e1*amel2^2*x3*x4*xcp2 +416*e4e1*e3e1*amel2^2*x3*x4*xcp1 -64*e4e1*e3e1*amel2^2*x3*x4*x5*xcp3 +256*e4e1*e3e1*amel2^2*x3*x4*x5*xcp2 -64*e4e1*e3e1*amel2^2*x3*x4*x5*xcp1 -64*e4e1*e3e1*amel2^2*x3*x4^2*xcp3 +128*e4e1*e3e1*amel2^2*x3*x4^2*xcp2 -64*e4e1*e3e1*amel2^2*x3*x4^2*xcp1 +128*e4e1*e3e1*amel2^2*x3^2*xcp3 -256*e4e1*e3e1*amel2^2*x3^2*xcp2 +128*e4e1*e3e1*amel2^2*x3^2*xcp1 -32*e4e1*e3e1*amel2^2*x3^2*x5*xcp3 -32*e4e1*e3e1*amel2^2*x3^2*x5*xcp1 -32*e4e1*e3e1*amel2^2*x3^2*x4*xcp3 -32*e4e1*e3e1*amel2^2*x3^2*x4*xcp1 -512*e4e1*e3e1*amel2^2*x1*xcp3 -512*e4e1*e3e1*amel2^2*x1*xcp1 +384*e4e1*e3e1*amel2^2*x1*x5*xcp3 +384*e4e1*e3e1*amel2^2*x1*x5*xcp1 -256*e4e1*e3e1*amel2^2*x1*x5^2*xcp3 -256*e4e1*e3e1*amel2^2*x1*x5^2*xcp1 +480*e4e1*e3e1*amel2^2*x1*x4*xcp3 -320*e4e1*e3e1*amel2^2*x1*x4*xcp2 +480*e4e1*e3e1*amel2^2*x1*x4*xcp1 -512*e4e1*e3e1*amel2^2*x1*x4*x5*xcp3 +384*e4e1*e3e1*amel2^2*x1*x4*x5*xcp2 -512*e4e1*e3e1*amel2^2*x1*x4*x5*xcp1 -320*e4e1*e3e1*amel2^2*x1*x4^2*xcp3 +384*e4e1*e3e1*amel2^2*x1*x4^2*xcp2 -320*e4e1*e3e1*amel2^2*x1*x4^2*xcp1 +608*e4e1*e3e1*amel2^2*x1*x3*xcp3 -320*e4e1*e3e1*amel2^2*x1*x3*xcp2 +608*e4e1*e3e1*amel2^2*x1*x3*xcp1 -256*e4e1*e3e1*amel2^2*x1*x3*x5*xcp3 +384*e4e1*e3e1*amel2^2*x1*x3*x5*xcp2 -256*e4e1*e3e1*amel2^2*x1*x3*x5*xcp1 -384*e4e1*e3e1*amel2^2*x1*x3*x4*xcp3 +640*e4e1*e3e1*amel2^2*x1*x3*x4*xcp2 -384*e4e1*e3e1*amel2^2*x1*x3*x4*xcp1 -64*e4e1*e3e1*amel2^2*x1*x3^2*xcp3 +256*e4e1*e3e1*amel2^2*x1*x3^2*xcp2 -64*e4e1*e3e1*amel2^2*x1*x3^2*xcp1 +416*e4e1*e3e1*amel2^2*x1^2*xcp3 +416*e4e1*e3e1*amel2^2*x1^2*xcp1 -288*e4e1*e3e1*amel2^2*x1^2*x5*xcp3 -288*e4e1*e3e1*amel2^2*x1^2*x5*xcp1 -288*e4e1*e3e1*amel2^2*x1^2*x4*xcp3 -256*e4e1*e3e1*amel2^2*x1^2*x4*xcp2 -288*e4e1*e3e1*amel2^2*x1^2*x4*xcp1 -384*e4e1*e3e1*amel2^2*x1^2*x3*xcp3 -256*e4e1*e3e1*amel2^2*x1^2*x3*xcp2 -384*e4e1*e3e1*amel2^2*x1^2*x3*xcp1 -64*e4e1*e3e1*amel2^2*x1^3*xcp3 -64*e4e1*e3e1*amel2^2*x1^3*xcp1 -64*e4e1*e3e1*e2e1*zk^2*xcp2 +64*e4e1*e3e1*e2e1*zk^2*x5*xcp2 +64*e4e1*e3e1*e2e1*zk^2*x4*xcp2 +128*e4e1*e3e1*e2e1*zk^2*x3*xcp2 -128*e4e1*e3e1*e2e1*zk^2*x1*xcp2 -192*e4e1*e3e1*e2e1*amel2*xcp3 -512*e4e1*e3e1*e2e1*amel2*xcp2 -192*e4e1*e3e1*e2e1*amel2*xcp1 +192*e4e1*e3e1*e2e1*amel2*x5*xcp3 +1536*e4e1*e3e1*e2e1*amel2*x5*xcp2 +192*e4e1*e3e1*e2e1*amel2*x5*xcp1 -160*e4e1*e3e1*e2e1*amel2*x5^2*xcp3 -832*e4e1*e3e1*e2e1*amel2*x5^2*xcp2 -160*e4e1*e3e1*e2e1*amel2*x5^2*xcp1 +64*e4e1*e3e1*e2e1*amel2*x5^3*xcp3 +128*e4e1*e3e1*e2e1*amel2*x5^3*xcp2 +64*e4e1*e3e1*e2e1*amel2*x5^3*xcp1 -32*e4e1*e3e1*e2e1*amel2*x4*xcp3 +1920*e4e1*e3e1*e2e1*amel2*x4*xcp2 -32*e4e1*e3e1*e2e1*amel2*x4*xcp1 -32*e4e1*e3e1*e2e1*amel2*x4*x5*xcp3 -2048*e4e1*e3e1*e2e1*amel2*x4*x5*xcp2 -32*e4e1*e3e1*e2e1*amel2*x4*x5*xcp1 +64*e4e1*e3e1*e2e1*amel2*x4*x5^2*xcp3 +384*e4e1*e3e1*e2e1*amel2*x4*x5^2*xcp2 +64*e4e1*e3e1*e2e1*amel2*x4*x5^2*xcp1 +128*e4e1*e3e1*e2e1*amel2*x4^2*xcp3 -1344*e4e1*e3e1*e2e1*amel2*x4^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x4^2*xcp1 -64*e4e1*e3e1*e2e1*amel2*x4^2*x5*xcp3 +512*e4e1*e3e1*e2e1*amel2*x4^2*x5*xcp2 -64*e4e1*e3e1*e2e1*amel2*x4^2*x5*xcp1 -64*e4e1*e3e1*e2e1*amel2*x4^3*xcp3 +256*e4e1*e3e1*e2e1*amel2*x4^3*xcp2 -64*e4e1*e3e1*e2e1*amel2*x4^3*xcp1 +224*e4e1*e3e1*e2e1*amel2*x3*xcp3 +1408*e4e1*e3e1*e2e1*amel2*x3*xcp2 +224*e4e1*e3e1*e2e1*amel2*x3*xcp1 -160*e4e1*e3e1*e2e1*amel2*x3*x5*xcp3 -1920*e4e1*e3e1*e2e1*amel2*x3*x5*xcp2 -160*e4e1*e3e1*e2e1*amel2*x3*x5*xcp1 +64*e4e1*e3e1*e2e1*amel2*x3*x5^2*xcp3 +256*e4e1*e3e1*e2e1*amel2*x3*x5^2*xcp2 +64*e4e1*e3e1*e2e1*amel2*x3*x5^2*xcp1 +32*e4e1*e3e1*e2e1*amel2*x3*x4*xcp3 -2560*e4e1*e3e1*e2e1*amel2*x3*x4*xcp2 +32*e4e1*e3e1*e2e1*amel2*x3*x4*xcp1 +768*e4e1*e3e1*e2e1*amel2*x3*x4*x5*xcp2 -64*e4e1*e3e1*e2e1*amel2*x3*x4^2*xcp3 +640*e4e1*e3e1*e2e1*amel2*x3*x4^2*xcp2 -64*e4e1*e3e1*e2e1*amel2*x3*x4^2*xcp1 -1024*e4e1*e3e1*e2e1*amel2*x3^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x3^2*x5*xcp2 +384*e4e1*e3e1*e2e1*amel2*x3^2*x4*xcp2 +128*e4e1*e3e1*e2e1*amel2*x3^3*xcp2 -32*e4e1*e3e1*e2e1*amel2*x1*xcp3 +384*e4e1*e3e1*e2e1*amel2*x1*xcp2 -32*e4e1*e3e1*e2e1*amel2*x1*xcp1 -160*e4e1*e3e1*e2e1*amel2*x1*x5*xcp3 -960*e4e1*e3e1*e2e1*amel2*x1*x5*xcp2 -160*e4e1*e3e1*e2e1*amel2*x1*x5*xcp1 +128*e4e1*e3e1*e2e1*amel2*x1*x5^2*xcp3 +384*e4e1*e3e1*e2e1*amel2*x1*x5^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x1*x5^2*xcp1 +288*e4e1*e3e1*e2e1*amel2*x1*x4*xcp3 -1088*e4e1*e3e1*e2e1*amel2*x1*x4*xcp2 +288*e4e1*e3e1*e2e1*amel2*x1*x4*xcp1 +896*e4e1*e3e1*e2e1*amel2*x1*x4*x5*xcp2 -128*e4e1*e3e1*e2e1*amel2*x1*x4^2*xcp3 +384*e4e1*e3e1*e2e1*amel2*x1*x4^2*xcp2 -128*e4e1*e3e1*e2e1*amel2*x1*x4^2*xcp1 +64*e4e1*e3e1*e2e1*amel2*x1*x3*xcp3 -1024*e4e1*e3e1*e2e1*amel2*x1*x3*xcp2 +64*e4e1*e3e1*e2e1*amel2*x1*x3*xcp1 +1280*e4e1*e3e1*e2e1*amel2*x1*x3*x5*xcp2 -256*e4e1*e3e1*e2e1*amel2*x1*x3*x4*xcp3 +1280*e4e1*e3e1*e2e1*amel2*x1*x3*x4*xcp2 -256*e4e1*e3e1*e2e1*amel2*x1*x3*x4*xcp1 -64*e4e1*e3e1*e2e1*amel2*x1*x3^2*xcp3 +640*e4e1*e3e1*e2e1*amel2*x1*x3^2*xcp2 -64*e4e1*e3e1*e2e1*amel2*x1*x3^2*xcp1 +128*e4e1*e3e1*e2e1*amel2*x1^2*xcp3 +512*e4e1*e3e1*e2e1*amel2*x1^2*xcp2 +128*e4e1*e3e1*e2e1*amel2*x1^2*xcp1 +64*e4e1*e3e1*e2e1*amel2*x1^2*x5*xcp3 -384*e4e1*e3e1*e2e1*amel2*x1^2*x5*xcp2 +64*e4e1*e3e1*e2e1*amel2*x1^2*x5*xcp1 -64*e4e1*e3e1*e2e1*amel2*x1^2*x4*xcp3 -384*e4e1*e3e1*e2e1*amel2*x1^2*x4*xcp2 -64*e4e1*e3e1*e2e1*amel2*x1^2*x4*xcp1 -64*e4e1*e3e1*e2e1*amel2*x1^2*x3*xcp3 -384*e4e1*e3e1*e2e1*amel2*x1^2*x3*xcp2 -64*e4e1*e3e1*e2e1*amel2*x1^2*x3*xcp1 -128*e4e1*e3e1*e2e1*amel2*x1^3*xcp2 -768*e4e1*e3e1*e2e1^2*xcp2 +1280*e4e1*e3e1*e2e1^2*x5*xcp2 -512*e4e1*e3e1*e2e1^2*x5^2*xcp2 +1536*e4e1*e3e1*e2e1^2*x4*xcp2 -1408*e4e1*e3e1*e2e1^2*x4*x5*xcp2 +128*e4e1*e3e1*e2e1^2*x4*x5^2*xcp2 -896*e4e1*e3e1*e2e1^2*x4^2*xcp2 +256*e4e1*e3e1*e2e1^2*x4^2*x5*xcp2 +128*e4e1*e3e1*e2e1^2*x4^3*xcp2 +1536*e4e1*e3e1*e2e1^2*x3*xcp2 -1408*e4e1*e3e1*e2e1^2*x3*x5*xcp2 +128*e4e1*e3e1*e2e1^2*x3*x5^2*xcp2 -1920*e4e1*e3e1*e2e1^2*x3*x4*xcp2 +640*e4e1*e3e1*e2e1^2*x3*x4*x5*xcp2 +512*e4e1*e3e1*e2e1^2*x3*x4^2*xcp2 -768*e4e1*e3e1*e2e1^2*x3^2*xcp2 +128*e4e1*e3e1*e2e1^2*x3^2*x5*xcp2 +384*e4e1*e3e1*e2e1^2*x3^2*x4*xcp2 +512*e4e1*e3e1*e2e1^2*x1*xcp2 -896*e4e1*e3e1*e2e1^2*x1*x5*xcp2 +384*e4e1*e3e1*e2e1^2*x1*x5^2*xcp2 -640*e4e1*e3e1*e2e1^2*x1*x4*xcp2 +640*e4e1*e3e1*e2e1^2*x1*x4*x5*xcp2 +256*e4e1*e3e1*e2e1^2*x1*x4^2*xcp2 -1280*e4e1*e3e1*e2e1^2*x1*x3*xcp2 +1024*e4e1*e3e1*e2e1^2*x1*x3*x5*xcp2 +768*e4e1*e3e1*e2e1^2*x1*x3*x4*xcp2 +768*e4e1*e3e1*e2e1^2*x1*x3^2*xcp2 +256*e4e1*e3e1*e2e1^2*x1^2*xcp2 -128*e4e1*e3e1*e2e1^2*x1^2*x5*xcp2 -128*e4e1*e3e1*e2e1^2*x1^2*x4*xcp2 -256*e4e1*e3e1*e2e1^2*x1^2*x3*xcp2 +96*e4e1*e3e1*e3e2*zk^2*xcp2 -64*e4e1*e3e1*e3e2*zk^2*x5*xcp2 -64*e4e1*e3e1*e3e2*zk^2*x4*xcp2 -128*e4e1*e3e1*e3e2*zk^2*x3*xcp2 +96*e4e1*e3e1*e3e2*zk^2*x1*xcp2 +192*e4e1*e3e1*e3e2*amel2*xcp3 +512*e4e1*e3e1*e3e2*amel2*xcp2 +192*e4e1*e3e1*e3e2*amel2*xcp1 -256*e4e1*e3e1*e3e2*amel2*x5*xcp3 -1536*e4e1*e3e1*e3e2*amel2*x5*xcp2 -256*e4e1*e3e1*e3e2*amel2*x5*xcp1 +160*e4e1*e3e1*e3e2*amel2*x5^2*xcp3 +960*e4e1*e3e1*e3e2*amel2*x5^2*xcp2 +160*e4e1*e3e1*e3e2*amel2*x5^2*xcp1 -64*e4e1*e3e1*e3e2*amel2*x5^3*xcp3 -128*e4e1*e3e1*e3e2*amel2*x5^3*xcp2 -64*e4e1*e3e1*e3e2*amel2*x5^3*xcp1 -32*e4e1*e3e1*e3e2*amel2*x4*xcp3 -1920*e4e1*e3e1*e3e2*amel2*x4*xcp2 -32*e4e1*e3e1*e3e2*amel2*x4*xcp1 +32*e4e1*e3e1*e3e2*amel2*x4*x5*xcp3 +2304*e4e1*e3e1*e3e2*amel2*x4*x5*xcp2 +32*e4e1*e3e1*e3e2*amel2*x4*x5*xcp1 -64*e4e1*e3e1*e3e2*amel2*x4*x5^2*xcp3 -384*e4e1*e3e1*e3e2*amel2*x4*x5^2*xcp2 -64*e4e1*e3e1*e3e2*amel2*x4*x5^2*xcp1 -128*e4e1*e3e1*e3e2*amel2*x4^2*xcp3 +1472*e4e1*e3e1*e3e2*amel2*x4^2*xcp2 -128*e4e1*e3e1*e3e2*amel2*x4^2*xcp1 +64*e4e1*e3e1*e3e2*amel2*x4^2*x5*xcp3 -512*e4e1*e3e1*e3e2*amel2*x4^2*x5*xcp2 +64*e4e1*e3e1*e3e2*amel2*x4^2*x5*xcp1 +64*e4e1*e3e1*e3e2*amel2*x4^3*xcp3 -256*e4e1*e3e1*e3e2*amel2*x4^3*xcp2 +64*e4e1*e3e1*e3e2*amel2*x4^3*xcp1 -224*e4e1*e3e1*e3e2*amel2*x3*xcp3 -1408*e4e1*e3e1*e3e2*amel2*x3*xcp2 -224*e4e1*e3e1*e3e2*amel2*x3*xcp1 +160*e4e1*e3e1*e3e2*amel2*x3*x5*xcp3 +1920*e4e1*e3e1*e3e2*amel2*x3*x5*xcp2 +160*e4e1*e3e1*e3e2*amel2*x3*x5*xcp1 -64*e4e1*e3e1*e3e2*amel2*x3*x5^2*xcp3 -256*e4e1*e3e1*e3e2*amel2*x3*x5^2*xcp2 -64*e4e1*e3e1*e3e2*amel2*x3*x5^2*xcp1 -32*e4e1*e3e1*e3e2*amel2*x3*x4*xcp3 +2560*e4e1*e3e1*e3e2*amel2*x3*x4*xcp2 -32*e4e1*e3e1*e3e2*amel2*x3*x4*xcp1 -768*e4e1*e3e1*e3e2*amel2*x3*x4*x5*xcp2 +64*e4e1*e3e1*e3e2*amel2*x3*x4^2*xcp3 -640*e4e1*e3e1*e3e2*amel2*x3*x4^2*xcp2 +64*e4e1*e3e1*e3e2*amel2*x3*x4^2*xcp1 +1024*e4e1*e3e1*e3e2*amel2*x3^2*xcp2 -128*e4e1*e3e1*e3e2*amel2*x3^2*x5*xcp2 -384*e4e1*e3e1*e3e2*amel2*x3^2*x4*xcp2 -128*e4e1*e3e1*e3e2*amel2*x3^3*xcp2 -160*e4e1*e3e1*e3e2*amel2*x1*xcp3 -384*e4e1*e3e1*e3e2*amel2*x1*xcp2 -160*e4e1*e3e1*e3e2*amel2*x1*xcp1 +256*e4e1*e3e1*e3e2*amel2*x1*x5*xcp3 +1024*e4e1*e3e1*e3e2*amel2*x1*x5*xcp2 +256*e4e1*e3e1*e3e2*amel2*x1*x5*xcp1 -128*e4e1*e3e1*e3e2*amel2*x1*x5^2*xcp3 -512*e4e1*e3e1*e3e2*amel2*x1*x5^2*xcp2 -128*e4e1*e3e1*e3e2*amel2*x1*x5^2*xcp1 +32*e4e1*e3e1*e3e2*amel2*x1*x4*xcp3 +1152*e4e1*e3e1*e3e2*amel2*x1*x4*xcp2 +32*e4e1*e3e1*e3e2*amel2*x1*x4*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1*x4*x5*xcp3 -1152*e4e1*e3e1*e3e2*amel2*x1*x4*x5*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1*x4*x5*xcp1 +64*e4e1*e3e1*e3e2*amel2*x1*x4^2*xcp3 -512*e4e1*e3e1*e3e2*amel2*x1*x4^2*xcp2 +64*e4e1*e3e1*e3e2*amel2*x1*x4^2*xcp1 +160*e4e1*e3e1*e3e2*amel2*x1*x3*xcp3 +1024*e4e1*e3e1*e3e2*amel2*x1*x3*xcp2 +160*e4e1*e3e1*e3e2*amel2*x1*x3*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1*x3*x5*xcp3 -1280*e4e1*e3e1*e3e2*amel2*x1*x3*x5*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1*x3*x5*xcp1 +192*e4e1*e3e1*e3e2*amel2*x1*x3*x4*xcp3 -1280*e4e1*e3e1*e3e2*amel2*x1*x3*x4*xcp2 +192*e4e1*e3e1*e3e2*amel2*x1*x3*x4*xcp1 +64*e4e1*e3e1*e3e2*amel2*x1*x3^2*xcp3 -640*e4e1*e3e1*e3e2*amel2*x1*x3^2*xcp2 +64*e4e1*e3e1*e3e2*amel2*x1*x3^2*xcp1 +32*e4e1*e3e1*e3e2*amel2*x1^2*xcp3 -448*e4e1*e3e1*e3e2*amel2*x1^2*xcp2 +32*e4e1*e3e1*e3e2*amel2*x1^2*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1^2*x5*xcp3 +512*e4e1*e3e1*e3e2*amel2*x1^2*x5*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1^2*x5*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1^2*x4*xcp3 +512*e4e1*e3e1*e3e2*amel2*x1^2*x4*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1^2*x4*xcp1 -64*e4e1*e3e1*e3e2*amel2*x1^2*x3*xcp3 +384*e4e1*e3e1*e3e2*amel2*x1^2*x3*xcp2 -64*e4e1*e3e1*e3e2*amel2*x1^2*x3*xcp1 +128*e4e1*e3e1*e3e2*amel2*x1^3*xcp2 +1280*e4e1*e3e1*e3e2*e2e1*xcp2 -2304*e4e1*e3e1*e3e2*e2e1*x5*xcp2 +1024*e4e1*e3e1*e3e2*e2e1*x5^2*xcp2 -2816*e4e1*e3e1*e3e2*e2e1*x4*xcp2 +2816*e4e1*e3e1*e3e2*e2e1*x4*x5*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x4*x5^2*xcp2 +1792*e4e1*e3e1*e3e2*e2e1*x4^2*xcp2 -512*e4e1*e3e1*e3e2*e2e1*x4^2*x5*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x4^3*xcp2 -2560*e4e1*e3e1*e3e2*e2e1*x3*xcp2 +2560*e4e1*e3e1*e3e2*e2e1*x3*x5*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x3*x5^2*xcp2 +3584*e4e1*e3e1*e3e2*e2e1*x3*x4*xcp2 -1280*e4e1*e3e1*e3e2*e2e1*x3*x4*x5*xcp2 -1024*e4e1*e3e1*e3e2*e2e1*x3*x4^2*xcp2 +1280*e4e1*e3e1*e3e2*e2e1*x3^2*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x3^2*x5*xcp2 -768*e4e1*e3e1*e3e2*e2e1*x3^2*x4*xcp2 -1024*e4e1*e3e1*e3e2*e2e1*x1*xcp2 +1792*e4e1*e3e1*e3e2*e2e1*x1*x5*xcp2 -768*e4e1*e3e1*e3e2*e2e1*x1*x5^2*xcp2 +1280*e4e1*e3e1*e3e2*e2e1*x1*x4*xcp2 -1152*e4e1*e3e1*e3e2*e2e1*x1*x4*x5*xcp2 -384*e4e1*e3e1*e3e2*e2e1*x1*x4^2*xcp2 +2304*e4e1*e3e1*e3e2*e2e1*x1*x3*xcp2 -1920*e4e1*e3e1*e3e2*e2e1*x1*x3*x5*xcp2 -1408*e4e1*e3e1*e3e2*e2e1*x1*x3*x4*xcp2 -1280*e4e1*e3e1*e3e2*e2e1*x1*x3^2*xcp2 -256*e4e1*e3e1*e3e2*e2e1*x1^2*xcp2 +128*e4e1*e3e1*e3e2*e2e1*x1^2*x5*xcp2 +128*e4e1*e3e1*e3e2*e2e1*x1^2*x4*xcp2 +256*e4e1*e3e1*e3e2*e2e1*x1^2*x3*xcp2 -512*e4e1*e3e1*e3e2^2*xcp2 +1024*e4e1*e3e1*e3e2^2*x5*xcp2 -512*e4e1*e3e1*e3e2^2*x5^2*xcp2 +1280*e4e1*e3e1*e3e2^2*x4*xcp2 -1408*e4e1*e3e1*e3e2^2*x4*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x4*x5^2*xcp2 -896*e4e1*e3e1*e3e2^2*x4^2*xcp2 +256*e4e1*e3e1*e3e2^2*x4^2*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x4^3*xcp2 +1024*e4e1*e3e1*e3e2^2*x3*xcp2 -1152*e4e1*e3e1*e3e2^2*x3*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x3*x5^2*xcp2 -1664*e4e1*e3e1*e3e2^2*x3*x4*xcp2 +640*e4e1*e3e1*e3e2^2*x3*x4*x5*xcp2 +512*e4e1*e3e1*e3e2^2*x3*x4^2*xcp2 -512*e4e1*e3e1*e3e2^2*x3^2*xcp2 +128*e4e1*e3e1*e3e2^2*x3^2*x5*xcp2 +384*e4e1*e3e1*e3e2^2*x3^2*x4*xcp2 +512*e4e1*e3e1*e3e2^2*x1*xcp2 -896*e4e1*e3e1*e3e2^2*x1*x5*xcp2 +384*e4e1*e3e1*e3e2^2*x1*x5^2*xcp2 -640*e4e1*e3e1*e3e2^2*x1*x4*xcp2 +512*e4e1*e3e1*e3e2^2*x1*x4*x5*xcp2 +128*e4e1*e3e1*e3e2^2*x1*x4^2*xcp2 -1024*e4e1*e3e1*e3e2^2*x1*x3*xcp2 +896*e4e1*e3e1*e3e2^2*x1*x3*x5*xcp2 +640*e4e1*e3e1*e3e2^2*x1*x3*x4*xcp2 +512*e4e1*e3e1*e3e2^2*x1*x3^2*xcp2 -64*e4e1*e3e1^2*amel2*xcp3 -64*e4e1*e3e1^2*amel2*xcp1 +256*e4e1*e3e1^2*amel2*x5*xcp3 +256*e4e1*e3e1^2*amel2*x5*xcp1 -256*e4e1*e3e1^2*amel2*x5^2*xcp3 -256*e4e1*e3e1^2*amel2*x5^2*xcp1 +64*e4e1*e3e1^2*amel2*x5^3*xcp3 +64*e4e1*e3e1^2*amel2*x5^3*xcp1 +256*e4e1*e3e1^2*amel2*x4*xcp3 -256*e4e1*e3e1^2*amel2*x4*xcp2 +256*e4e1*e3e1^2*amel2*x4*xcp1 -512*e4e1*e3e1^2*amel2*x4*x5*xcp3 +384*e4e1*e3e1^2*amel2*x4*x5*xcp2 -512*e4e1*e3e1^2*amel2*x4*x5*xcp1 +192*e4e1*e3e1^2*amel2*x4*x5^2*xcp3 -128*e4e1*e3e1^2*amel2*x4*x5^2*xcp2 +192*e4e1*e3e1^2*amel2*x4*x5^2*xcp1 -256*e4e1*e3e1^2*amel2*x4^2*xcp3 +384*e4e1*e3e1^2*amel2*x4^2*xcp2 -256*e4e1*e3e1^2*amel2*x4^2*xcp1 +192*e4e1*e3e1^2*amel2*x4^2*x5*xcp3 -256*e4e1*e3e1^2*amel2*x4^2*x5*xcp2 +192*e4e1*e3e1^2*amel2*x4^2*x5*xcp1 +64*e4e1*e3e1^2*amel2*x4^3*xcp3 -128*e4e1*e3e1^2*amel2*x4^3*xcp2 +64*e4e1*e3e1^2*amel2*x4^3*xcp1 +64*e4e1*e3e1^2*amel2*x3*xcp3 -256*e4e1*e3e1^2*amel2*x3*xcp2 +64*e4e1*e3e1^2*amel2*x3*xcp1 -192*e4e1*e3e1^2*amel2*x3*x5*xcp3 +384*e4e1*e3e1^2*amel2*x3*x5*xcp2 -192*e4e1*e3e1^2*amel2*x3*x5*xcp1 +64*e4e1*e3e1^2*amel2*x3*x5^2*xcp3 -128*e4e1*e3e1^2*amel2*x3*x5^2*xcp2 +64*e4e1*e3e1^2*amel2*x3*x5^2*xcp1 -192*e4e1*e3e1^2*amel2*x3*x4*xcp3 +640*e4e1*e3e1^2*amel2*x3*x4*xcp2 -192*e4e1*e3e1^2*amel2*x3*x4*xcp1 +128*e4e1*e3e1^2*amel2*x3*x4*x5*xcp3 -384*e4e1*e3e1^2*amel2*x3*x4*x5*xcp2 +128*e4e1*e3e1^2*amel2*x3*x4*x5*xcp1 +64*e4e1*e3e1^2*amel2*x3*x4^2*xcp3 -256*e4e1*e3e1^2*amel2*x3*x4^2*xcp2 +64*e4e1*e3e1^2*amel2*x3*x4^2*xcp1 +256*e4e1*e3e1^2*amel2*x3^2*xcp2 -128*e4e1*e3e1^2*amel2*x3^2*x5*xcp2 -128*e4e1*e3e1^2*amel2*x3^2*x4*xcp2 +320*e4e1*e3e1^2*amel2*x1*xcp3 +320*e4e1*e3e1^2*amel2*x1*xcp1 -384*e4e1*e3e1^2*amel2*x1*x5*xcp3 -384*e4e1*e3e1^2*amel2*x1*x5*xcp1 +192*e4e1*e3e1^2*amel2*x1*x5^2*xcp3 +192*e4e1*e3e1^2*amel2*x1*x5^2*xcp1 -384*e4e1*e3e1^2*amel2*x1*x4*xcp3 +128*e4e1*e3e1^2*amel2*x1*x4*xcp2 -384*e4e1*e3e1^2*amel2*x1*x4*xcp1 +384*e4e1*e3e1^2*amel2*x1*x4*x5*xcp3 -128*e4e1*e3e1^2*amel2*x1*x4*x5*xcp2 +384*e4e1*e3e1^2*amel2*x1*x4*x5*xcp1 +192*e4e1*e3e1^2*amel2*x1*x4^2*xcp3 -128*e4e1*e3e1^2*amel2*x1*x4^2*xcp2 +192*e4e1*e3e1^2*amel2*x1*x4^2*xcp1 -320*e4e1*e3e1^2*amel2*x1*x3*xcp3 +128*e4e1*e3e1^2*amel2*x1*x3*xcp2 -320*e4e1*e3e1^2*amel2*x1*x3*xcp1 +256*e4e1*e3e1^2*amel2*x1*x3*x5*xcp3 -128*e4e1*e3e1^2*amel2*x1*x3*x5*xcp2 +256*e4e1*e3e1^2*amel2*x1*x3*x5*xcp1 +256*e4e1*e3e1^2*amel2*x1*x3*x4*xcp3 -384*e4e1*e3e1^2*amel2*x1*x3*x4*xcp2 +256*e4e1*e3e1^2*amel2*x1*x3*x4*xcp1 -256*e4e1*e3e1^2*amel2*x1*x3^2*xcp2 -192*e4e1*e3e1^2*amel2*x1^2*xcp3 -192*e4e1*e3e1^2*amel2*x1^2*xcp1 +128*e4e1*e3e1^2*amel2*x1^2*x5*xcp3 +128*e4e1*e3e1^2*amel2*x1^2*x5*xcp1 +128*e4e1*e3e1^2*amel2*x1^2*x4*xcp3 +128*e4e1*e3e1^2*amel2*x1^2*x4*xcp2 +128*e4e1*e3e1^2*amel2*x1^2*x4*xcp1 +192*e4e1*e3e1^2*amel2*x1^2*x3*xcp3 +128*e4e1*e3e1^2*amel2*x1^2*x3*xcp2 +192*e4e1*e3e1^2*amel2*x1^2*x3*xcp1 +512*e4e1*e3e1^2*e2e1*xcp2 -1024*e4e1*e3e1^2*e2e1*x5*xcp2 +640*e4e1*e3e1^2*e2e1*x5^2*xcp2 -128*e4e1*e3e1^2*e2e1*x5^3*xcp2 -1024*e4e1*e3e1^2*e2e1*x4*xcp2 +1280*e4e1*e3e1^2*e2e1*x4*x5*xcp2 -384*e4e1*e3e1^2*e2e1*x4*x5^2*xcp2 +640*e4e1*e3e1^2*e2e1*x4^2*xcp2 -384*e4e1*e3e1^2*e2e1*x4^2*x5*xcp2 -128*e4e1*e3e1^2*e2e1*x4^3*xcp2 -1024*e4e1*e3e1^2*e2e1*x3*xcp2 +1280*e4e1*e3e1^2*e2e1*x3*x5*xcp2 -384*e4e1*e3e1^2*e2e1*x3*x5^2*xcp2 +1280*e4e1*e3e1^2*e2e1*x3*x4*xcp2 -768*e4e1*e3e1^2*e2e1*x3*x4*x5*xcp2 -384*e4e1*e3e1^2*e2e1*x3*x4^2*xcp2 +512*e4e1*e3e1^2*e2e1*x3^2*xcp2 -256*e4e1*e3e1^2*e2e1*x3^2*x5*xcp2 -256*e4e1*e3e1^2*e2e1*x3^2*x4*xcp2 -256*e4e1*e3e1^2*e2e1*x1*xcp2 +384*e4e1*e3e1^2*e2e1*x1*x5*xcp2 -128*e4e1*e3e1^2*e2e1*x1*x5^2*xcp2 +384*e4e1*e3e1^2*e2e1*x1*x4*xcp2 -256*e4e1*e3e1^2*e2e1*x1*x4*x5*xcp2 -128*e4e1*e3e1^2*e2e1*x1*x4^2*xcp2 +768*e4e1*e3e1^2*e2e1*x1*x3*xcp2 -512*e4e1*e3e1^2*e2e1*x1*x3*x5*xcp2 -512*e4e1*e3e1^2*e2e1*x1*x3*x4*xcp2 -512*e4e1*e3e1^2*e2e1*x1*x3^2*xcp2 -256*e4e1*e3e1^2*e2e1*x1^2*xcp2 +128*e4e1*e3e1^2*e2e1*x1^2*x5*xcp2 +128*e4e1*e3e1^2*e2e1*x1^2*x4*xcp2 +256*e4e1*e3e1^2*e2e1*x1^2*x3*xcp2 -512*e4e1*e3e1^2*e3e2*xcp2 +1152*e4e1*e3e1^2*e3e2*x5*xcp2 -768*e4e1*e3e1^2*e3e2*x5^2*xcp2 +128*e4e1*e3e1^2*e3e2*x5^3*xcp2 +1152*e4e1*e3e1^2*e3e2*x4*xcp2 -1536*e4e1*e3e1^2*e3e2*x4*x5*xcp2 +384*e4e1*e3e1^2*e3e2*x4*x5^2*xcp2 -768*e4e1*e3e1^2*e3e2*x4^2*xcp2 +384*e4e1*e3e1^2*e3e2*x4^2*x5*xcp2 +128*e4e1*e3e1^2*e3e2*x4^3*xcp2 +1024*e4e1*e3e1^2*e3e2*x3*xcp2 -1408*e4e1*e3e1^2*e3e2*x3*x5*xcp2 +384*e4e1*e3e1^2*e3e2*x3*x5^2*xcp2 -1408*e4e1*e3e1^2*e3e2*x3*x4*xcp2 +768*e4e1*e3e1^2*e3e2*x3*x4*x5*xcp2 +384*e4e1*e3e1^2*e3e2*x3*x4^2*xcp2 -512*e4e1*e3e1^2*e3e2*x3^2*xcp2 +256*e4e1*e3e1^2*e3e2*x3^2*x5*xcp2 +256*e4e1*e3e1^2*e3e2*x3^2*x4*xcp2 +256*e4e1*e3e1^2*e3e2*x1*xcp2 -384*e4e1*e3e1^2*e3e2*x1*x5*xcp2 +128*e4e1*e3e1^2*e3e2*x1*x5^2*xcp2 -384*e4e1*e3e1^2*e3e2*x1*x4*xcp2 +256*e4e1*e3e1^2*e3e2*x1*x4*x5*xcp2 +128*e4e1*e3e1^2*e3e2*x1*x4^2*xcp2 -768*e4e1*e3e1^2*e3e2*x1*x3*xcp2 +640*e4e1*e3e1^2*e3e2*x1*x3*x5*xcp2 +640*e4e1*e3e1^2*e3e2*x1*x3*x4*xcp2 +512*e4e1*e3e1^2*e3e2*x1*x3^2*xcp2 +256*e4e1*e3e1^2*e3e2*x1^2*xcp2 -256*e4e1*e3e1^2*e3e2*x1^2*x5*xcp2 -256*e4e1*e3e1^2*e3e2*x1^2*x4*xcp2 -256*e4e1*e3e1^2*e3e2*x1^2*x3*xcp2 -64*e4e1*e4e2*amel2*zk^2*xcp3 +128*e4e1*e4e2*amel2*zk^2*xcp2 -64*e4e1*e4e2*amel2*zk^2*xcp1 +48*e4e1*e4e2*amel2*zk^2*x5*xcp3 +64*e4e1*e4e2*amel2*zk^2*x5*xcp2 +48*e4e1*e4e2*amel2*zk^2*x5*xcp1 +32*e4e1*e4e2*amel2*zk^2*x4*xcp2 -32*e4e1*e4e2*amel2*zk^2*x3*xcp2 +48*e4e1*e4e2*amel2*zk^2*x1*xcp3 -160*e4e1*e4e2*amel2*zk^2*x1*xcp2 +48*e4e1*e4e2*amel2*zk^2*x1*xcp1 -128*e4e1*e4e2*amel2^2*xcp3 -128*e4e1*e4e2*amel2^2*xcp1 +128*e4e1*e4e2*amel2^2*x5*xcp3 +512*e4e1*e4e2*amel2^2*x5*xcp2 +128*e4e1*e4e2*amel2^2*x5*xcp1 -32*e4e1*e4e2*amel2^2*x5^2*xcp3 -32*e4e1*e4e2*amel2^2*x5^2*xcp1 +32*e4e1*e4e2*amel2^2*x5^3*xcp3 +32*e4e1*e4e2*amel2^2*x5^3*xcp1 +64*e4e1*e4e2*amel2^2*x4*xcp3 +640*e4e1*e4e2*amel2^2*x4*xcp2 +64*e4e1*e4e2*amel2^2*x4*xcp1 -128*e4e1*e4e2*amel2^2*x4*x5*xcp3 -192*e4e1*e4e2*amel2^2*x4*x5*xcp2 -128*e4e1*e4e2*amel2^2*x4*x5*xcp1 +64*e4e1*e4e2*amel2^2*x4*x5^2*xcp3 -128*e4e1*e4e2*amel2^2*x4*x5^2*xcp2 +64*e4e1*e4e2*amel2^2*x4*x5^2*xcp1 -128*e4e1*e4e2*amel2^2*x4^2*xcp3 -128*e4e1*e4e2*amel2^2*x4^2*xcp1 +64*e4e1*e4e2*amel2^2*x4^2*x5*xcp3 -128*e4e1*e4e2*amel2^2*x4^2*x5*xcp2 +64*e4e1*e4e2*amel2^2*x4^2*x5*xcp1 +256*e4e1*e4e2*amel2^2*x3*xcp3 +128*e4e1*e4e2*amel2^2*x3*xcp2 +256*e4e1*e4e2*amel2^2*x3*xcp1 -192*e4e1*e4e2*amel2^2*x3*x5*xcp3 -704*e4e1*e4e2*amel2^2*x3*x5*xcp2 -192*e4e1*e4e2*amel2^2*x3*x5*xcp1 -128*e4e1*e4e2*amel2^2*x3*x5^2*xcp2 -192*e4e1*e4e2*amel2^2*x3*x4*xcp3 -448*e4e1*e4e2*amel2^2*x3*x4*xcp2 -192*e4e1*e4e2*amel2^2*x3*x4*xcp1 +64*e4e1*e4e2*amel2^2*x3*x4*x5*xcp3 +64*e4e1*e4e2*amel2^2*x3*x4*x5*xcp1 +128*e4e1*e4e2*amel2^2*x3*x4^2*xcp2 -96*e4e1*e4e2*amel2^2*x3^2*xcp3 +64*e4e1*e4e2*amel2^2*x3^2*xcp2 -96*e4e1*e4e2*amel2^2*x3^2*xcp1 +32*e4e1*e4e2*amel2^2*x3^2*x5*xcp3 +128*e4e1*e4e2*amel2^2*x3^2*x5*xcp2 +32*e4e1*e4e2*amel2^2*x3^2*x5*xcp1 +128*e4e1*e4e2*amel2^2*x3^2*x4*xcp2 +192*e4e1*e4e2*amel2^2*x1*xcp3 +192*e4e1*e4e2*amel2^2*x1*xcp1 -256*e4e1*e4e2*amel2^2*x1*x5*xcp3 -384*e4e1*e4e2*amel2^2*x1*x5*xcp2 -256*e4e1*e4e2*amel2^2*x1*x5*xcp1 +96*e4e1*e4e2*amel2^2*x1*x5^2*xcp3 +128*e4e1*e4e2*amel2^2*x1*x5^2*xcp2 +96*e4e1*e4e2*amel2^2*x1*x5^2*xcp1 -64*e4e1*e4e2*amel2^2*x1*x4*xcp3 -576*e4e1*e4e2*amel2^2*x1*x4*xcp2 -64*e4e1*e4e2*amel2^2*x1*x4*xcp1 +128*e4e1*e4e2*amel2^2*x1*x4*x5*xcp3 +384*e4e1*e4e2*amel2^2*x1*x4*x5*xcp2 +128*e4e1*e4e2*amel2^2*x1*x4*x5*xcp1 +64*e4e1*e4e2*amel2^2*x1*x4^2*xcp3 -128*e4e1*e4e2*amel2^2*x1*x4^2*xcp2 +64*e4e1*e4e2*amel2^2*x1*x4^2*xcp1 -64*e4e1*e4e2*amel2^2*x1*x3*xcp3 -192*e4e1*e4e2*amel2^2*x1*x3*xcp2 -64*e4e1*e4e2*amel2^2*x1*x3*xcp1 +128*e4e1*e4e2*amel2^2*x1*x3*x5*xcp3 +640*e4e1*e4e2*amel2^2*x1*x3*x5*xcp2 +128*e4e1*e4e2*amel2^2*x1*x3*x5*xcp1 -64*e4e1*e4e2*amel2^2*x1*x3*x4*xcp3 -64*e4e1*e4e2*amel2^2*x1*x3*x4*xcp1 +32*e4e1*e4e2*amel2^2*x1*x3^2*xcp3 -256*e4e1*e4e2*amel2^2*x1*x3^2*xcp2 +32*e4e1*e4e2*amel2^2*x1*x3^2*xcp1 +32*e4e1*e4e2*amel2^2*x1^2*xcp3 +384*e4e1*e4e2*amel2^2*x1^2*xcp2 +32*e4e1*e4e2*amel2^2*x1^2*xcp1 +96*e4e1*e4e2*amel2^2*x1^2*x5*xcp3 +96*e4e1*e4e2*amel2^2*x1^2*x5*xcp1 +64*e4e1*e4e2*amel2^2*x1^2*x4*xcp3 -256*e4e1*e4e2*amel2^2*x1^2*x4*xcp2 +64*e4e1*e4e2*amel2^2*x1^2*x4*xcp1 -512*e4e1*e4e2*amel2^2*x1^2*x3*xcp2 +32*e4e1*e4e2*amel2^2*x1^3*xcp3 -128*e4e1*e4e2*amel2^2*x1^3*xcp2 +32*e4e1*e4e2*amel2^2*x1^3*xcp1 -128*e4e1*e4e2*e2e1*zk^2*xcp2 +192*e4e1*e4e2*e2e1*zk^2*x5*xcp2 +32*e4e1*e4e2*e2e1*zk^2*x4*xcp2 +96*e4e1*e4e2*e2e1*zk^2*x3*xcp2 -32*e4e1*e4e2*e2e1*zk^2*x1*xcp2 -128*e4e1*e4e2*e2e1*amel2*xcp3 -512*e4e1*e4e2*e2e1*amel2*xcp2 -128*e4e1*e4e2*e2e1*amel2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x5*xcp3 +1408*e4e1*e4e2*e2e1*amel2*x5*xcp2 -128*e4e1*e4e2*e2e1*amel2*x5*xcp1 +96*e4e1*e4e2*e2e1*amel2*x5^2*xcp3 -64*e4e1*e4e2*e2e1*amel2*x5^2*xcp2 +96*e4e1*e4e2*e2e1*amel2*x5^2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x5^3*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4*xcp3 +1408*e4e1*e4e2*e2e1*amel2*x4*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4*xcp1 -128*e4e1*e4e2*e2e1*amel2*x4*x5*xcp3 -192*e4e1*e4e2*e2e1*amel2*x4*x5*xcp2 -128*e4e1*e4e2*e2e1*amel2*x4*x5*xcp1 +64*e4e1*e4e2*e2e1*amel2*x4*x5^2*xcp3 -512*e4e1*e4e2*e2e1*amel2*x4*x5^2*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4*x5^2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x4^2*xcp3 -256*e4e1*e4e2*e2e1*amel2*x4^2*xcp2 -128*e4e1*e4e2*e2e1*amel2*x4^2*xcp1 +64*e4e1*e4e2*e2e1*amel2*x4^2*x5*xcp3 -256*e4e1*e4e2*e2e1*amel2*x4^2*x5*xcp2 +64*e4e1*e4e2*e2e1*amel2*x4^2*x5*xcp1 +192*e4e1*e4e2*e2e1*amel2*x3*xcp3 +1024*e4e1*e4e2*e2e1*amel2*x3*xcp2 +192*e4e1*e4e2*e2e1*amel2*x3*xcp1 +128*e4e1*e4e2*e2e1*amel2*x3*x5*xcp3 -960*e4e1*e4e2*e2e1*amel2*x3*x5*xcp2 +128*e4e1*e4e2*e2e1*amel2*x3*x5*xcp1 -64*e4e1*e4e2*e2e1*amel2*x3*x5^2*xcp3 -640*e4e1*e4e2*e2e1*amel2*x3*x5^2*xcp2 -64*e4e1*e4e2*e2e1*amel2*x3*x5^2*xcp1 -192*e4e1*e4e2*e2e1*amel2*x3*x4*xcp3 -1216*e4e1*e4e2*e2e1*amel2*x3*x4*xcp2 -192*e4e1*e4e2*e2e1*amel2*x3*x4*xcp1 +64*e4e1*e4e2*e2e1*amel2*x3*x4*x5*xcp3 -256*e4e1*e4e2*e2e1*amel2*x3*x4*x5*xcp2 +64*e4e1*e4e2*e2e1*amel2*x3*x4*x5*xcp1 +256*e4e1*e4e2*e2e1*amel2*x3*x4^2*xcp2 -32*e4e1*e4e2*e2e1*amel2*x3^2*xcp3 -640*e4e1*e4e2*e2e1*amel2*x3^2*xcp2 -32*e4e1*e4e2*e2e1*amel2*x3^2*xcp1 +128*e4e1*e4e2*e2e1*amel2*x3^2*x5*xcp2 +256*e4e1*e4e2*e2e1*amel2*x3^2*x4*xcp2 +128*e4e1*e4e2*e2e1*amel2*x3^3*xcp2 +128*e4e1*e4e2*e2e1*amel2*x1*xcp3 +896*e4e1*e4e2*e2e1*amel2*x1*xcp2 +128*e4e1*e4e2*e2e1*amel2*x1*xcp1 -64*e4e1*e4e2*e2e1*amel2*x1*x5*xcp3 -2176*e4e1*e4e2*e2e1*amel2*x1*x5*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x5*xcp1 +896*e4e1*e4e2*e2e1*amel2*x1*x5^2*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x4*xcp3 -832*e4e1*e4e2*e2e1*amel2*x1*x4*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x4*xcp1 +128*e4e1*e4e2*e2e1*amel2*x1*x4*x5*xcp3 +1024*e4e1*e4e2*e2e1*amel2*x1*x4*x5*xcp2 +128*e4e1*e4e2*e2e1*amel2*x1*x4*x5*xcp1 +64*e4e1*e4e2*e2e1*amel2*x1*x4^2*xcp3 +64*e4e1*e4e2*e2e1*amel2*x1*x4^2*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1*x3*xcp3 -832*e4e1*e4e2*e2e1*amel2*x1*x3*xcp2 -128*e4e1*e4e2*e2e1*amel2*x1*x3*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1*x3*x5*xcp3 +1408*e4e1*e4e2*e2e1*amel2*x1*x3*x5*xcp2 -128*e4e1*e4e2*e2e1*amel2*x1*x3*x5*xcp1 -64*e4e1*e4e2*e2e1*amel2*x1*x3*x4*xcp3 +128*e4e1*e4e2*e2e1*amel2*x1*x3*x4*xcp2 -64*e4e1*e4e2*e2e1*amel2*x1*x3*x4*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1*x3^2*xcp3 +128*e4e1*e4e2*e2e1*amel2*x1*x3^2*xcp2 -128*e4e1*e4e2*e2e1*amel2*x1*x3^2*xcp1 -32*e4e1*e4e2*e2e1*amel2*x1^2*xcp3 +192*e4e1*e4e2*e2e1*amel2*x1^2*xcp2 -32*e4e1*e4e2*e2e1*amel2*x1^2*xcp1 +128*e4e1*e4e2*e2e1*amel2*x1^2*x5*xcp2 +64*e4e1*e4e2*e2e1*amel2*x1^2*x4*xcp3 -256*e4e1*e4e2*e2e1*amel2*x1^2*x4*xcp2 +64*e4e1*e4e2*e2e1*amel2*x1^2*x4*xcp1 +64*e4e1*e4e2*e2e1*amel2*x1^2*x3*xcp3 -512*e4e1*e4e2*e2e1*amel2*x1^2*x3*xcp2 +64*e4e1*e4e2*e2e1*amel2*x1^2*x3*xcp1 -128*e4e1*e4e2*e2e1*amel2*x1^3*xcp2 -512*e4e1*e4e2*e2e1^2*xcp2 +256*e4e1*e4e2*e2e1^2*x5*xcp2 +512*e4e1*e4e2*e2e1^2*x5^2*xcp2 -256*e4e1*e4e2*e2e1^2*x5^3*xcp2 +768*e4e1*e4e2*e2e1^2*x4*xcp2 -384*e4e1*e4e2*e2e1^2*x4*x5^2*xcp2 -256*e4e1*e4e2*e2e1^2*x4^2*xcp2 -128*e4e1*e4e2*e2e1^2*x4^2*x5*xcp2 +768*e4e1*e4e2*e2e1^2*x3*xcp2 +256*e4e1*e4e2*e2e1^2*x3*x5*xcp2 -640*e4e1*e4e2*e2e1^2*x3*x5^2*xcp2 -768*e4e1*e4e2*e2e1^2*x3*x4*xcp2 -256*e4e1*e4e2*e2e1^2*x3*x4*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x3*x4^2*xcp2 -256*e4e1*e4e2*e2e1^2*x3^2*xcp2 -384*e4e1*e4e2*e2e1^2*x3^2*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x3^2*x4*xcp2 +512*e4e1*e4e2*e2e1^2*x1*xcp2 -1024*e4e1*e4e2*e2e1^2*x1*x5*xcp2 +512*e4e1*e4e2*e2e1^2*x1*x5^2*xcp2 -256*e4e1*e4e2*e2e1^2*x1*x4*xcp2 +640*e4e1*e4e2*e2e1^2*x1*x4*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x1*x4^2*xcp2 -768*e4e1*e4e2*e2e1^2*x1*x3*xcp2 +896*e4e1*e4e2*e2e1^2*x1*x3*x5*xcp2 +128*e4e1*e4e2*e2e1^2*x1*x3*x4*xcp2 +256*e4e1*e4e2*e2e1^2*x1*x3^2*xcp2 +160*e4e1*e4e2*e3e2*zk^2*xcp2 -192*e4e1*e4e2*e3e2*zk^2*x5*xcp2 -32*e4e1*e4e2*e3e2*zk^2*x4*xcp2 -96*e4e1*e4e2*e3e2*zk^2*x3*xcp2 +512*e4e1*e4e2*e3e2*amel2*xcp2 +192*e4e1*e4e2*e3e2*amel2*x5*xcp3 -1152*e4e1*e4e2*e3e2*amel2*x5*xcp2 +192*e4e1*e4e2*e3e2*amel2*x5*xcp1 -96*e4e1*e4e2*e3e2*amel2*x5^2*xcp3 -64*e4e1*e4e2*e3e2*amel2*x5^2*xcp2 -96*e4e1*e4e2*e3e2*amel2*x5^2*xcp1 +128*e4e1*e4e2*e3e2*amel2*x5^3*xcp2 -1152*e4e1*e4e2*e3e2*amel2*x4*xcp2 +128*e4e1*e4e2*e3e2*amel2*x4*x5*xcp3 -64*e4e1*e4e2*e3e2*amel2*x4*x5*xcp2 +128*e4e1*e4e2*e3e2*amel2*x4*x5*xcp1 -64*e4e1*e4e2*e3e2*amel2*x4*x5^2*xcp3 +512*e4e1*e4e2*e3e2*amel2*x4*x5^2*xcp2 -64*e4e1*e4e2*e3e2*amel2*x4*x5^2*xcp1 +128*e4e1*e4e2*e3e2*amel2*x4^2*xcp3 +128*e4e1*e4e2*e3e2*amel2*x4^2*xcp2 +128*e4e1*e4e2*e3e2*amel2*x4^2*xcp1 -64*e4e1*e4e2*e3e2*amel2*x4^2*x5*xcp3 +256*e4e1*e4e2*e3e2*amel2*x4^2*x5*xcp2 -64*e4e1*e4e2*e3e2*amel2*x4^2*x5*xcp1 -64*e4e1*e4e2*e3e2*amel2*x3*xcp3 -1024*e4e1*e4e2*e3e2*amel2*x3*xcp2 -64*e4e1*e4e2*e3e2*amel2*x3*xcp1 -128*e4e1*e4e2*e3e2*amel2*x3*x5*xcp3 +704*e4e1*e4e2*e3e2*amel2*x3*x5*xcp2 -128*e4e1*e4e2*e3e2*amel2*x3*x5*xcp1 +64*e4e1*e4e2*e3e2*amel2*x3*x5^2*xcp3 +640*e4e1*e4e2*e3e2*amel2*x3*x5^2*xcp2 +64*e4e1*e4e2*e3e2*amel2*x3*x5^2*xcp1 +192*e4e1*e4e2*e3e2*amel2*x3*x4*xcp3 +960*e4e1*e4e2*e3e2*amel2*x3*x4*xcp2 +192*e4e1*e4e2*e3e2*amel2*x3*x4*xcp1 -64*e4e1*e4e2*e3e2*amel2*x3*x4*x5*xcp3 +256*e4e1*e4e2*e3e2*amel2*x3*x4*x5*xcp2 -64*e4e1*e4e2*e3e2*amel2*x3*x4*x5*xcp1 -256*e4e1*e4e2*e3e2*amel2*x3*x4^2*xcp2 +32*e4e1*e4e2*e3e2*amel2*x3^2*xcp3 +640*e4e1*e4e2*e3e2*amel2*x3^2*xcp2 +32*e4e1*e4e2*e3e2*amel2*x3^2*xcp1 -128*e4e1*e4e2*e3e2*amel2*x3^2*x5*xcp2 -256*e4e1*e4e2*e3e2*amel2*x3^2*x4*xcp2 -128*e4e1*e4e2*e3e2*amel2*x3^3*xcp2 -1024*e4e1*e4e2*e3e2*amel2*x1*xcp2 -32*e4e1*e4e2*e3e2*amel2*x1*x5*xcp3 +1856*e4e1*e4e2*e3e2*amel2*x1*x5*xcp2 -32*e4e1*e4e2*e3e2*amel2*x1*x5*xcp1 -640*e4e1*e4e2*e3e2*amel2*x1*x5^2*xcp2 +768*e4e1*e4e2*e3e2*amel2*x1*x4*xcp2 -64*e4e1*e4e2*e3e2*amel2*x1*x4*x5*xcp3 -512*e4e1*e4e2*e3e2*amel2*x1*x4*x5*xcp2 -64*e4e1*e4e2*e3e2*amel2*x1*x4*x5*xcp1 -64*e4e1*e4e2*e3e2*amel2*x1*x4^2*xcp3 +128*e4e1*e4e2*e3e2*amel2*x1*x4^2*xcp2 -64*e4e1*e4e2*e3e2*amel2*x1*x4^2*xcp1 -32*e4e1*e4e2*e3e2*amel2*x1*x3*xcp3 +1216*e4e1*e4e2*e3e2*amel2*x1*x3*xcp2 -32*e4e1*e4e2*e3e2*amel2*x1*x3*xcp1 +192*e4e1*e4e2*e3e2*amel2*x1*x3*x5*xcp3 -1152*e4e1*e4e2*e3e2*amel2*x1*x3*x5*xcp2 +192*e4e1*e4e2*e3e2*amel2*x1*x3*x5*xcp1 -128*e4e1*e4e2*e3e2*amel2*x1*x3*x4*xcp2 +64*e4e1*e4e2*e3e2*amel2*x1*x3^2*xcp3 -256*e4e1*e4e2*e3e2*amel2*x1*x3^2*xcp2 +64*e4e1*e4e2*e3e2*amel2*x1*x3^2*xcp1 -256*e4e1*e4e2*e3e2*amel2*x1^2*x5*xcp2 +128*e4e1*e4e2*e3e2*amel2*x1^2*x4*xcp2 +128*e4e1*e4e2*e3e2*amel2*x1^2*x3*xcp2 +512*e4e1*e4e2*e3e2*e2e1*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x5*xcp2 -1280*e4e1*e4e2*e3e2*e2e1*x5^2*xcp2 +512*e4e1*e4e2*e3e2*e2e1*x5^3*xcp2 -1024*e4e1*e4e2*e3e2*e2e1*x4*xcp2 -384*e4e1*e4e2*e3e2*e2e1*x4*x5*xcp2 +768*e4e1*e4e2*e3e2*e2e1*x4*x5^2*xcp2 +384*e4e1*e4e2*e3e2*e2e1*x4^2*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x4^2*x5*xcp2 -768*e4e1*e4e2*e3e2*e2e1*x3*xcp2 -1152*e4e1*e4e2*e3e2*e2e1*x3*x5*xcp2 +1280*e4e1*e4e2*e3e2*e2e1*x3*x5^2*xcp2 +1152*e4e1*e4e2*e3e2*e2e1*x3*x4*xcp2 +512*e4e1*e4e2*e3e2*e2e1*x3*x4*x5*xcp2 -256*e4e1*e4e2*e3e2*e2e1*x3*x4^2*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x3^2*xcp2 +768*e4e1*e4e2*e3e2*e2e1*x3^2*x5*xcp2 -256*e4e1*e4e2*e3e2*e2e1*x3^2*x4*xcp2 -512*e4e1*e4e2*e3e2*e2e1*x1*xcp2 +1024*e4e1*e4e2*e3e2*e2e1*x1*x5*xcp2 -512*e4e1*e4e2*e3e2*e2e1*x1*x5^2*xcp2 +256*e4e1*e4e2*e3e2*e2e1*x1*x4*xcp2 -640*e4e1*e4e2*e3e2*e2e1*x1*x4*x5*xcp2 -128*e4e1*e4e2*e3e2*e2e1*x1*x4^2*xcp2 +768*e4e1*e4e2*e3e2*e2e1*x1*x3*xcp2 -896*e4e1*e4e2*e3e2*e2e1*x1*x3*x5*xcp2 -128*e4e1*e4e2*e3e2*e2e1*x1*x3*x4*xcp2 -256*e4e1*e4e2*e3e2*e2e1*x1*x3^2*xcp2 -512*e4e1*e4e2*e3e2^2*x5*xcp2 +768*e4e1*e4e2*e3e2^2*x5^2*xcp2 -256*e4e1*e4e2*e3e2^2*x5^3*xcp2 +256*e4e1*e4e2*e3e2^2*x4*xcp2 +384*e4e1*e4e2*e3e2^2*x4*x5*xcp2 -384*e4e1*e4e2*e3e2^2*x4*x5^2*xcp2 -128*e4e1*e4e2*e3e2^2*x4^2*xcp2 -128*e4e1*e4e2*e3e2^2*x4^2*x5*xcp2 +896*e4e1*e4e2*e3e2^2*x3*x5*xcp2 -640*e4e1*e4e2*e3e2^2*x3*x5^2*xcp2 -384*e4e1*e4e2*e3e2^2*x3*x4*xcp2 -256*e4e1*e4e2*e3e2^2*x3*x4*x5*xcp2 +128*e4e1*e4e2*e3e2^2*x3*x4^2*xcp2 -384*e4e1*e4e2*e3e2^2*x3^2*x5*xcp2 +128*e4e1*e4e2*e3e2^2*x3^2*x4*xcp2 +32*e4e1*e4e2*e3e1*zk^2*xcp2 -128*e4e1*e4e2*e3e1*zk^2*x3*xcp2 +160*e4e1*e4e2*e3e1*zk^2*x1*xcp2 +192*e4e1*e4e2*e3e1*amel2*xcp3 +512*e4e1*e4e2*e3e1*amel2*xcp2 +192*e4e1*e4e2*e3e1*amel2*xcp1 -256*e4e1*e4e2*e3e1*amel2*x5*xcp3 -1280*e4e1*e4e2*e3e1*amel2*x5*xcp2 -256*e4e1*e4e2*e3e1*amel2*x5*xcp1 +192*e4e1*e4e2*e3e1*amel2*x5^2*xcp3 +256*e4e1*e4e2*e3e1*amel2*x5^2*xcp2 +192*e4e1*e4e2*e3e1*amel2*x5^2*xcp1 -64*e4e1*e4e2*e3e1*amel2*x5^3*xcp3 -64*e4e1*e4e2*e3e1*amel2*x5^3*xcp1 -64*e4e1*e4e2*e3e1*amel2*x4*xcp3 -1664*e4e1*e4e2*e3e1*amel2*x4*xcp2 -64*e4e1*e4e2*e3e1*amel2*x4*xcp1 +320*e4e1*e4e2*e3e1*amel2*x4*x5*xcp3 +896*e4e1*e4e2*e3e1*amel2*x4*x5*xcp2 +320*e4e1*e4e2*e3e1*amel2*x4*x5*xcp1 -128*e4e1*e4e2*e3e1*amel2*x4*x5^2*xcp3 -128*e4e1*e4e2*e3e1*amel2*x4*x5^2*xcp1 +128*e4e1*e4e2*e3e1*amel2*x4^2*xcp3 +512*e4e1*e4e2*e3e1*amel2*x4^2*xcp2 +128*e4e1*e4e2*e3e1*amel2*x4^2*xcp1 -64*e4e1*e4e2*e3e1*amel2*x4^2*x5*xcp3 -64*e4e1*e4e2*e3e1*amel2*x4^2*x5*xcp1 -256*e4e1*e4e2*e3e1*amel2*x3*xcp3 -1408*e4e1*e4e2*e3e1*amel2*x3*xcp2 -256*e4e1*e4e2*e3e1*amel2*x3*xcp1 +384*e4e1*e4e2*e3e1*amel2*x3*x5*xcp3 +1664*e4e1*e4e2*e3e1*amel2*x3*x5*xcp2 +384*e4e1*e4e2*e3e1*amel2*x3*x5*xcp1 -128*e4e1*e4e2*e3e1*amel2*x3*x5^2*xcp3 -256*e4e1*e4e2*e3e1*amel2*x3*x5^2*xcp2 -128*e4e1*e4e2*e3e1*amel2*x3*x5^2*xcp1 +192*e4e1*e4e2*e3e1*amel2*x3*x4*xcp3 +1792*e4e1*e4e2*e3e1*amel2*x3*x4*xcp2 +192*e4e1*e4e2*e3e1*amel2*x3*x4*xcp1 -128*e4e1*e4e2*e3e1*amel2*x3*x4*x5*xcp3 -512*e4e1*e4e2*e3e1*amel2*x3*x4*x5*xcp2 -128*e4e1*e4e2*e3e1*amel2*x3*x4*x5*xcp1 -384*e4e1*e4e2*e3e1*amel2*x3*x4^2*xcp2 +768*e4e1*e4e2*e3e1*amel2*x3^2*xcp2 -256*e4e1*e4e2*e3e1*amel2*x3^2*x4*xcp2 -128*e4e1*e4e2*e3e1*amel2*x3^3*xcp2 -128*e4e1*e4e2*e3e1*amel2*x1*xcp3 -384*e4e1*e4e2*e3e1*amel2*x1*xcp2 -128*e4e1*e4e2*e3e1*amel2*x1*xcp1 +288*e4e1*e4e2*e3e1*amel2*x1*x5*xcp3 +576*e4e1*e4e2*e3e1*amel2*x1*x5*xcp2 +288*e4e1*e4e2*e3e1*amel2*x1*x5*xcp1 -128*e4e1*e4e2*e3e1*amel2*x1*x5^2*xcp3 -128*e4e1*e4e2*e3e1*amel2*x1*x5^2*xcp2 -128*e4e1*e4e2*e3e1*amel2*x1*x5^2*xcp1 +704*e4e1*e4e2*e3e1*amel2*x1*x4*xcp2 -192*e4e1*e4e2*e3e1*amel2*x1*x4*x5*xcp3 -384*e4e1*e4e2*e3e1*amel2*x1*x4*x5*xcp2 -192*e4e1*e4e2*e3e1*amel2*x1*x4*x5*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1*x4^2*xcp3 +128*e4e1*e4e2*e3e1*amel2*x1*x4^2*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1*x4^2*xcp1 +96*e4e1*e4e2*e3e1*amel2*x1*x3*xcp3 +1024*e4e1*e4e2*e3e1*amel2*x1*x3*xcp2 +96*e4e1*e4e2*e3e1*amel2*x1*x3*xcp1 -192*e4e1*e4e2*e3e1*amel2*x1*x3*x5*xcp3 -1024*e4e1*e4e2*e3e1*amel2*x1*x3*x5*xcp2 -192*e4e1*e4e2*e3e1*amel2*x1*x3*x5*xcp1 +64*e4e1*e4e2*e3e1*amel2*x1*x3*x4*xcp3 -512*e4e1*e4e2*e3e1*amel2*x1*x3*x4*xcp2 +64*e4e1*e4e2*e3e1*amel2*x1*x3*x4*xcp1 +64*e4e1*e4e2*e3e1*amel2*x1*x3^2*xcp3 -384*e4e1*e4e2*e3e1*amel2*x1*x3^2*xcp2 +64*e4e1*e4e2*e3e1*amel2*x1*x3^2*xcp1 -32*e4e1*e4e2*e3e1*amel2*x1^2*xcp3 -576*e4e1*e4e2*e3e1*amel2*x1^2*xcp2 -32*e4e1*e4e2*e3e1*amel2*x1^2*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1^2*x5*xcp3 +256*e4e1*e4e2*e3e1*amel2*x1^2*x5*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1^2*x5*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1^2*x4*xcp3 +256*e4e1*e4e2*e3e1*amel2*x1^2*x4*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1^2*x4*xcp1 -64*e4e1*e4e2*e3e1*amel2*x1^2*x3*xcp3 +384*e4e1*e4e2*e3e1*amel2*x1^2*x3*xcp2 -64*e4e1*e4e2*e3e1*amel2*x1^2*x3*xcp1 +128*e4e1*e4e2*e3e1*amel2*x1^3*xcp2 +1280*e4e1*e4e2*e3e1*e2e1*xcp2 -1920*e4e1*e4e2*e3e1*e2e1*x5*xcp2 +640*e4e1*e4e2*e3e1*e2e1*x5^2*xcp2 -1920*e4e1*e4e2*e3e1*e2e1*x4*xcp2 +1408*e4e1*e4e2*e3e1*e2e1*x4*x5*xcp2 +768*e4e1*e4e2*e3e1*e2e1*x4^2*xcp2 -2048*e4e1*e4e2*e3e1*e2e1*x3*xcp2 +1536*e4e1*e4e2*e3e1*e2e1*x3*x5*xcp2 +2048*e4e1*e4e2*e3e1*e2e1*x3*x4*xcp2 -384*e4e1*e4e2*e3e1*e2e1*x3*x4*x5*xcp2 -384*e4e1*e4e2*e3e1*e2e1*x3*x4^2*xcp2 +768*e4e1*e4e2*e3e1*e2e1*x3^2*xcp2 +128*e4e1*e4e2*e3e1*e2e1*x3^2*x5*xcp2 -384*e4e1*e4e2*e3e1*e2e1*x3^2*x4*xcp2 -1024*e4e1*e4e2*e3e1*e2e1*x1*xcp2 +1664*e4e1*e4e2*e3e1*e2e1*x1*x5*xcp2 -640*e4e1*e4e2*e3e1*e2e1*x1*x5^2*xcp2 +640*e4e1*e4e2*e3e1*e2e1*x1*x4*xcp2 -768*e4e1*e4e2*e3e1*e2e1*x1*x4*x5*xcp2 -128*e4e1*e4e2*e3e1*e2e1*x1*x4^2*xcp2 +1792*e4e1*e4e2*e3e1*e2e1*x1*x3*xcp2 -1536*e4e1*e4e2*e3e1*e2e1*x1*x3*x5*xcp2 -512*e4e1*e4e2*e3e1*e2e1*x1*x3*x4*xcp2 -768*e4e1*e4e2*e3e1*e2e1*x1*x3^2*xcp2 -256*e4e1*e4e2*e3e1*e2e1*x1^2*xcp2 +128*e4e1*e4e2*e3e1*e2e1*x1^2*x5*xcp2 +128*e4e1*e4e2*e3e1*e2e1*x1^2*x4*xcp2 +256*e4e1*e4e2*e3e1*e2e1*x1^2*x3*xcp2 -1024*e4e1*e4e2*e3e1*e3e2*xcp2 +1664*e4e1*e4e2*e3e1*e3e2*x5*xcp2 -640*e4e1*e4e2*e3e1*e3e2*x5^2*xcp2 +1664*e4e1*e4e2*e3e1*e3e2*x4*xcp2 -1280*e4e1*e4e2*e3e1*e3e2*x4*x5*xcp2 -640*e4e1*e4e2*e3e1*e3e2*x4^2*xcp2 +1536*e4e1*e4e2*e3e1*e3e2*x3*xcp2 -1152*e4e1*e4e2*e3e1*e3e2*x3*x5*xcp2 -1664*e4e1*e4e2*e3e1*e3e2*x3*x4*xcp2 +384*e4e1*e4e2*e3e1*e3e2*x3*x4*x5*xcp2 +384*e4e1*e4e2*e3e1*e3e2*x3*x4^2*xcp2 -512*e4e1*e4e2*e3e1*e3e2*x3^2*xcp2 -128*e4e1*e4e2*e3e1*e3e2*x3^2*x5*xcp2 +384*e4e1*e4e2*e3e1*e3e2*x3^2*x4*xcp2 +1024*e4e1*e4e2*e3e1*e3e2*x1*xcp2 -1664*e4e1*e4e2*e3e1*e3e2*x1*x5*xcp2 +640*e4e1*e4e2*e3e1*e3e2*x1*x5^2*xcp2 -640*e4e1*e4e2*e3e1*e3e2*x1*x4*xcp2 +512*e4e1*e4e2*e3e1*e3e2*x1*x4*x5*xcp2 -128*e4e1*e4e2*e3e1*e3e2*x1*x4^2*xcp2 -1536*e4e1*e4e2*e3e1*e3e2*x1*x3*xcp2 +1280*e4e1*e4e2*e3e1*e3e2*x1*x3*x5*xcp2 +256*e4e1*e4e2*e3e1*e3e2*x1*x3*x4*xcp2 +512*e4e1*e4e2*e3e1*e3e2*x1*x3^2*xcp2 -512*e4e1*e4e2*e3e1^2*xcp2 +896*e4e1*e4e2*e3e1^2*x5*xcp2 -384*e4e1*e4e2*e3e1^2*x5^2*xcp2 +896*e4e1*e4e2*e3e1^2*x4*xcp2 -768*e4e1*e4e2*e3e1^2*x4*x5*xcp2 -384*e4e1*e4e2*e3e1^2*x4^2*xcp2 +1024*e4e1*e4e2*e3e1^2*x3*xcp2 -1152*e4e1*e4e2*e3e1^2*x3*x5*xcp2 +256*e4e1*e4e2*e3e1^2*x3*x5^2*xcp2 -1152*e4e1*e4e2*e3e1^2*x3*x4*xcp2 +512*e4e1*e4e2*e3e1^2*x3*x4*x5*xcp2 +256*e4e1*e4e2*e3e1^2*x3*x4^2*xcp2 -512*e4e1*e4e2*e3e1^2*x3^2*xcp2 +256*e4e1*e4e2*e3e1^2*x3^2*x5*xcp2 +256*e4e1*e4e2*e3e1^2*x3^2*x4*xcp2 +256*e4e1*e4e2*e3e1^2*x1*xcp2 -256*e4e1*e4e2*e3e1^2*x1*x5*xcp2 -256*e4e1*e4e2*e3e1^2*x1*x4*xcp2 -768*e4e1*e4e2*e3e1^2*x1*x3*xcp2 +384*e4e1*e4e2*e3e1^2*x1*x3*x5*xcp2 +384*e4e1*e4e2*e3e1^2*x1*x3*x4*xcp2 +512*e4e1*e4e2*e3e1^2*x1*x3^2*xcp2 +256*e4e1*e4e2*e3e1^2*x1^2*xcp2 -128*e4e1*e4e2*e3e1^2*x1^2*x5*xcp2 -128*e4e1*e4e2*e3e1^2*x1^2*x4*xcp2 -256*e4e1*e4e2*e3e1^2*x1^2*x3*xcp2 +64*e4e1*e4e2^2*zk^2*xcp2 -128*e4e1*e4e2^2*zk^2*x5*xcp2 +256*e4e1*e4e2^2*amel2*xcp2 +128*e4e1*e4e2^2*amel2*x5*xcp3 -512*e4e1*e4e2^2*amel2*x5*xcp2 +128*e4e1*e4e2^2*amel2*x5*xcp1 -64*e4e1*e4e2^2*amel2*x5^2*xcp3 -128*e4e1*e4e2^2*amel2*x5^2*xcp2 -64*e4e1*e4e2^2*amel2*x5^2*xcp1 -256*e4e1*e4e2^2*amel2*x4*xcp2 -128*e4e1*e4e2^2*amel2*x4*x5*xcp2 +128*e4e1*e4e2^2*amel2*x4*x5^2*xcp2 -64*e4e1*e4e2^2*amel2*x3*xcp3 -256*e4e1*e4e2^2*amel2*x3*xcp2 -64*e4e1*e4e2^2*amel2*x3*xcp1 -128*e4e1*e4e2^2*amel2*x3*x5*xcp3 +384*e4e1*e4e2^2*amel2*x3*x5*xcp2 -128*e4e1*e4e2^2*amel2*x3*x5*xcp1 +64*e4e1*e4e2^2*amel2*x3*x5^2*xcp3 +384*e4e1*e4e2^2*amel2*x3*x5^2*xcp2 +64*e4e1*e4e2^2*amel2*x3*x5^2*xcp1 +128*e4e1*e4e2^2*amel2*x3*x4*xcp2 +128*e4e1*e4e2^2*amel2*x3*x4*x5*xcp2 -128*e4e1*e4e2^2*amel2*x3^2*x5*xcp2 -512*e4e1*e4e2^2*amel2*x1*xcp2 +896*e4e1*e4e2^2*amel2*x1*x5*xcp2 -256*e4e1*e4e2^2*amel2*x1*x5^2*xcp2 -256*e4e1*e4e2^2*amel2*x1*x4*x5*xcp2 +256*e4e1*e4e2^2*amel2*x1*x3*xcp2 +128*e4e1*e4e2^2*amel2*x1*x3*x5*xcp3 -640*e4e1*e4e2^2*amel2*x1*x3*x5*xcp2 +128*e4e1*e4e2^2*amel2*x1*x3*x5*xcp1 +128*e4e1*e4e2^2*amel2*x1*x3*x4*xcp2 +128*e4e1*e4e2^2*amel2*x1*x3^2*xcp2 -256*e4e1*e4e2^2*amel2*x1^2*x5*xcp2 +128*e4e1*e4e2^2*amel2*x1^2*x3*xcp2 +256*e4e1*e4e2^2*e2e1*xcp2 +256*e4e1*e4e2^2*e2e1*x5*xcp2 -640*e4e1*e4e2^2*e2e1*x5^2*xcp2 +128*e4e1*e4e2^2*e2e1*x5^3*xcp2 -256*e4e1*e4e2^2*e2e1*x4*xcp2 -128*e4e1*e4e2^2*e2e1*x4*x5*xcp2 +128*e4e1*e4e2^2*e2e1*x4*x5^2*xcp2 -256*e4e1*e4e2^2*e2e1*x3*xcp2 -640*e4e1*e4e2^2*e2e1*x3*x5*xcp2 +640*e4e1*e4e2^2*e2e1*x3*x5^2*xcp2 +128*e4e1*e4e2^2*e2e1*x3*x4*xcp2 +128*e4e1*e4e2^2*e2e1*x3*x4*x5*xcp2 +256*e4e1*e4e2^2*e2e1*x3^2*x5*xcp2 -256*e4e1*e4e2^2*e2e1*x1*xcp2 +512*e4e1*e4e2^2*e2e1*x1*x5*xcp2 -256*e4e1*e4e2^2*e2e1*x1*x5^2*xcp2 -256*e4e1*e4e2^2*e2e1*x1*x4*x5*xcp2 +256*e4e1*e4e2^2*e2e1*x1*x3*xcp2 -384*e4e1*e4e2^2*e2e1*x1*x3*x5*xcp2 +128*e4e1*e4e2^2*e2e1*x1*x3*x4*xcp2 -640*e4e1*e4e2^2*e3e2*x5*xcp2 +768*e4e1*e4e2^2*e3e2*x5^2*xcp2 -128*e4e1*e4e2^2*e3e2*x5^3*xcp2 +128*e4e1*e4e2^2*e3e2*x4*xcp2 +256*e4e1*e4e2^2*e3e2*x4*x5*xcp2 -128*e4e1*e4e2^2*e3e2*x4*x5^2*xcp2 +896*e4e1*e4e2^2*e3e2*x3*x5*xcp2 -640*e4e1*e4e2^2*e3e2*x3*x5^2*xcp2 -128*e4e1*e4e2^2*e3e2*x3*x4*xcp2 -128*e4e1*e4e2^2*e3e2*x3*x4*x5*xcp2 -256*e4e1*e4e2^2*e3e2*x3^2*x5*xcp2 -512*e4e1*e4e2^2*e3e1*xcp2 +640*e4e1*e4e2^2*e3e1*x5*xcp2 -128*e4e1*e4e2^2*e3e1*x5^2*xcp2 +384*e4e1*e4e2^2*e3e1*x4*xcp2 -128*e4e1*e4e2^2*e3e1*x4*x5*xcp2 +512*e4e1*e4e2^2*e3e1*x3*xcp2 -256*e4e1*e4e2^2*e3e1*x3*x5*xcp2 -256*e4e1*e4e2^2*e3e1*x3*x4*xcp2 -256*e4e1*e4e2^2*e3e1*x3^2*x5*xcp2 +512*e4e1*e4e2^2*e3e1*x1*xcp2 -768*e4e1*e4e2^2*e3e1*x1*x5*xcp2 +256*e4e1*e4e2^2*e3e1*x1*x5^2*xcp2 +256*e4e1*e4e2^2*e3e1*x1*x4*x5*xcp2 -512*e4e1*e4e2^2*e3e1*x1*x3*xcp2 +640*e4e1*e4e2^2*e3e1*x1*x3*x5*xcp2 -128*e4e1*e4e2^2*e3e1*x1*x3*x4*xcp2 -256*e4e1*e4e2^3*x5*xcp2 +256*e4e1*e4e2^3*x5^2*xcp2 +256*e4e1*e4e2^3*x3*x5*xcp2 -256*e4e1*e4e2^3*x3*x5^2*xcp2 +32*e4e1^2*amel2*zk^2*xcp3 +32*e4e1^2*amel2*zk^2*xcp1 -48*e4e1^2*amel2*zk^2*x1*xcp3 -48*e4e1^2*amel2*zk^2*x1*xcp1 +32*e4e1^2*amel2^2*x5^2*xcp3 +32*e4e1^2*amel2^2*x5^2*xcp1 +64*e4e1^2*amel2^2*x4*x5*xcp3 -128*e4e1^2*amel2^2*x4*x5*xcp2 +64*e4e1^2*amel2^2*x4*x5*xcp1 +64*e4e1^2*amel2^2*x4^2*xcp3 -128*e4e1^2*amel2^2*x4^2*xcp2 +64*e4e1^2*amel2^2*x4^2*xcp1 -128*e4e1^2*amel2^2*x3*x5*xcp2 +64*e4e1^2*amel2^2*x3*x4*xcp3 -128*e4e1^2*amel2^2*x3*x4*xcp2 +64*e4e1^2*amel2^2*x3*x4*xcp1 +32*e4e1^2*amel2^2*x3^2*xcp3 +32*e4e1^2*amel2^2*x3^2*xcp1 -192*e4e1^2*amel2^2*x1*xcp3 -192*e4e1^2*amel2^2*x1*xcp1 +32*e4e1^2*amel2^2*x1*x5*xcp3 +32*e4e1^2*amel2^2*x1*x5*xcp1 -32*e4e1^2*amel2^2*x1*x5^2*xcp3 -32*e4e1^2*amel2^2*x1*x5^2*xcp1 +64*e4e1^2*amel2^2*x1*x4*xcp3 +64*e4e1^2*amel2^2*x1*x4*xcp2 +64*e4e1^2*amel2^2*x1*x4*xcp1 -64*e4e1^2*amel2^2*x1*x4*x5*xcp3 +128*e4e1^2*amel2^2*x1*x4*x5*xcp2 -64*e4e1^2*amel2^2*x1*x4*x5*xcp1 -64*e4e1^2*amel2^2*x1*x4^2*xcp3 +128*e4e1^2*amel2^2*x1*x4^2*xcp2 -64*e4e1^2*amel2^2*x1*x4^2*xcp1 +224*e4e1^2*amel2^2*x1*x3*xcp3 +64*e4e1^2*amel2^2*x1*x3*xcp2 +224*e4e1^2*amel2^2*x1*x3*xcp1 +128*e4e1^2*amel2^2*x1*x3*x5*xcp2 -64*e4e1^2*amel2^2*x1*x3*x4*xcp3 +128*e4e1^2*amel2^2*x1*x3*x4*xcp2 -64*e4e1^2*amel2^2*x1*x3*x4*xcp1 -32*e4e1^2*amel2^2*x1*x3^2*xcp3 -32*e4e1^2*amel2^2*x1*x3^2*xcp1 +192*e4e1^2*amel2^2*x1^2*xcp3 +192*e4e1^2*amel2^2*x1^2*xcp1 -64*e4e1^2*amel2^2*x1^2*x5*xcp3 -64*e4e1^2*amel2^2*x1^2*x5*xcp1 -64*e4e1^2*amel2^2*x1^2*x4*xcp3 -256*e4e1^2*amel2^2*x1^2*x4*xcp2 -64*e4e1^2*amel2^2*x1^2*x4*xcp1 -192*e4e1^2*amel2^2*x1^2*x3*xcp3 -256*e4e1^2*amel2^2*x1^2*x3*xcp2 -192*e4e1^2*amel2^2*x1^2*x3*xcp1 -32*e4e1^2*amel2^2*x1^3*xcp3 -32*e4e1^2*amel2^2*x1^3*xcp1 +32*e4e1^2*e2e1*zk^2*xcp2 -96*e4e1^2*e2e1*zk^2*x1*xcp2 -128*e4e1^2*e2e1*amel2*xcp3 -128*e4e1^2*e2e1*amel2*xcp1 +64*e4e1^2*e2e1*amel2*x5*xcp3 +256*e4e1^2*e2e1*amel2*x5*xcp2 +64*e4e1^2*e2e1*amel2*x5*xcp1 -128*e4e1^2*e2e1*amel2*x5^2*xcp2 +384*e4e1^2*e2e1*amel2*x4*xcp2 +64*e4e1^2*e2e1*amel2*x4*x5*xcp3 -384*e4e1^2*e2e1*amel2*x4*x5*xcp2 +64*e4e1^2*e2e1*amel2*x4*x5*xcp1 +64*e4e1^2*e2e1*amel2*x4^2*xcp3 -256*e4e1^2*e2e1*amel2*x4^2*xcp2 +64*e4e1^2*e2e1*amel2*x4^2*xcp1 +128*e4e1^2*e2e1*amel2*x3*xcp3 +128*e4e1^2*e2e1*amel2*x3*xcp2 +128*e4e1^2*e2e1*amel2*x3*xcp1 -384*e4e1^2*e2e1*amel2*x3*x5*xcp2 +64*e4e1^2*e2e1*amel2*x3*x4*xcp3 -512*e4e1^2*e2e1*amel2*x3*x4*xcp2 +64*e4e1^2*e2e1*amel2*x3*x4*xcp1 -128*e4e1^2*e2e1*amel2*x3^2*xcp2 +64*e4e1^2*e2e1*amel2*x1*xcp3 -384*e4e1^2*e2e1*amel2*x1*xcp2 +64*e4e1^2*e2e1*amel2*x1*xcp1 -96*e4e1^2*e2e1*amel2*x1*x5*xcp3 -64*e4e1^2*e2e1*amel2*x1*x5*xcp2 -96*e4e1^2*e2e1*amel2*x1*x5*xcp1 +128*e4e1^2*e2e1*amel2*x1*x5^2*xcp2 +64*e4e1^2*e2e1*amel2*x1*x4*xcp3 -64*e4e1^2*e2e1*amel2*x1*x4*xcp2 +64*e4e1^2*e2e1*amel2*x1*x4*xcp1 -64*e4e1^2*e2e1*amel2*x1*x4*x5*xcp3 +512*e4e1^2*e2e1*amel2*x1*x4*x5*xcp2 -64*e4e1^2*e2e1*amel2*x1*x4*x5*xcp1 -64*e4e1^2*e2e1*amel2*x1*x4^2*xcp3 +256*e4e1^2*e2e1*amel2*x1*x4^2*xcp2 -64*e4e1^2*e2e1*amel2*x1*x4^2*xcp1 -96*e4e1^2*e2e1*amel2*x1*x3*xcp3 +384*e4e1^2*e2e1*amel2*x1*x3*xcp2 -96*e4e1^2*e2e1*amel2*x1*x3*xcp1 +64*e4e1^2*e2e1*amel2*x1*x3*x5*xcp3 +512*e4e1^2*e2e1*amel2*x1*x3*x5*xcp2 +64*e4e1^2*e2e1*amel2*x1*x3*x5*xcp1 -64*e4e1^2*e2e1*amel2*x1*x3*x4*xcp3 +384*e4e1^2*e2e1*amel2*x1*x3*x4*xcp2 -64*e4e1^2*e2e1*amel2*x1*x3*x4*xcp1 +32*e4e1^2*e2e1*amel2*x1^2*xcp3 +576*e4e1^2*e2e1*amel2*x1^2*xcp2 +32*e4e1^2*e2e1*amel2*x1^2*xcp1 -384*e4e1^2*e2e1*amel2*x1^2*x5*xcp2 -64*e4e1^2*e2e1*amel2*x1^2*x4*xcp3 -384*e4e1^2*e2e1*amel2*x1^2*x4*xcp2 -64*e4e1^2*e2e1*amel2*x1^2*x4*xcp1 -512*e4e1^2*e2e1*amel2*x1^2*x3*xcp2 -128*e4e1^2*e2e1*amel2*x1^3*xcp2 -256*e4e1^2*e2e1^2*xcp2 +384*e4e1^2*e2e1^2*x5*xcp2 -128*e4e1^2*e2e1^2*x5^2*xcp2 +384*e4e1^2*e2e1^2*x4*xcp2 -256*e4e1^2*e2e1^2*x4*x5*xcp2 -128*e4e1^2*e2e1^2*x4^2*xcp2 +512*e4e1^2*e2e1^2*x3*xcp2 -384*e4e1^2*e2e1^2*x3*x5*xcp2 -384*e4e1^2*e2e1^2*x3*x4*xcp2 -256*e4e1^2*e2e1^2*x3^2*xcp2 -384*e4e1^2*e2e1^2*x1*x5*xcp2 +256*e4e1^2*e2e1^2*x1*x5^2*xcp2 -128*e4e1^2*e2e1^2*x1*x4*xcp2 +384*e4e1^2*e2e1^2*x1*x4*x5*xcp2 +128*e4e1^2*e2e1^2*x1*x4^2*xcp2 -256*e4e1^2*e2e1^2*x1*x3*xcp2 +512*e4e1^2*e2e1^2*x1*x3*x5*xcp2 +256*e4e1^2*e2e1^2*x1*x3*x4*xcp2 +256*e4e1^2*e2e1^2*x1*x3^2*xcp2 +256*e4e1^2*e2e1^2*x1^2*xcp2 -128*e4e1^2*e2e1^2*x1^2*x5*xcp2 -128*e4e1^2*e2e1^2*x1^2*x4*xcp2 -256*e4e1^2*e2e1^2*x1^2*x3*xcp2 -32*e4e1^2*e3e2*zk^2*xcp2 +96*e4e1^2*e3e2*zk^2*x1*xcp2 +128*e4e1^2*e3e2*amel2*xcp3 +128*e4e1^2*e3e2*amel2*xcp1 -64*e4e1^2*e3e2*amel2*x5*xcp3 -256*e4e1^2*e3e2*amel2*x5*xcp2 -64*e4e1^2*e3e2*amel2*x5*xcp1 +128*e4e1^2*e3e2*amel2*x5^2*xcp2 -384*e4e1^2*e3e2*amel2*x4*xcp2 -64*e4e1^2*e3e2*amel2*x4*x5*xcp3 +384*e4e1^2*e3e2*amel2*x4*x5*xcp2 -64*e4e1^2*e3e2*amel2*x4*x5*xcp1 -64*e4e1^2*e3e2*amel2*x4^2*xcp3 +256*e4e1^2*e3e2*amel2*x4^2*xcp2 -64*e4e1^2*e3e2*amel2*x4^2*xcp1 -128*e4e1^2*e3e2*amel2*x3*xcp3 -128*e4e1^2*e3e2*amel2*x3*xcp2 -128*e4e1^2*e3e2*amel2*x3*xcp1 +384*e4e1^2*e3e2*amel2*x3*x5*xcp2 -64*e4e1^2*e3e2*amel2*x3*x4*xcp3 +512*e4e1^2*e3e2*amel2*x3*x4*xcp2 -64*e4e1^2*e3e2*amel2*x3*x4*xcp1 +128*e4e1^2*e3e2*amel2*x3^2*xcp2 -128*e4e1^2*e3e2*amel2*x1*xcp3 +384*e4e1^2*e3e2*amel2*x1*xcp2 -128*e4e1^2*e3e2*amel2*x1*xcp1 +96*e4e1^2*e3e2*amel2*x1*x5*xcp3 +64*e4e1^2*e3e2*amel2*x1*x5*xcp2 +96*e4e1^2*e3e2*amel2*x1*x5*xcp1 -128*e4e1^2*e3e2*amel2*x1*x5^2*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4*x5*xcp3 -512*e4e1^2*e3e2*amel2*x1*x4*x5*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4*x5*xcp1 +64*e4e1^2*e3e2*amel2*x1*x4^2*xcp3 -256*e4e1^2*e3e2*amel2*x1*x4^2*xcp2 +64*e4e1^2*e3e2*amel2*x1*x4^2*xcp1 +160*e4e1^2*e3e2*amel2*x1*x3*xcp3 -384*e4e1^2*e3e2*amel2*x1*x3*xcp2 +160*e4e1^2*e3e2*amel2*x1*x3*xcp1 -64*e4e1^2*e3e2*amel2*x1*x3*x5*xcp3 -512*e4e1^2*e3e2*amel2*x1*x3*x5*xcp2 -64*e4e1^2*e3e2*amel2*x1*x3*x5*xcp1 +64*e4e1^2*e3e2*amel2*x1*x3*x4*xcp3 -384*e4e1^2*e3e2*amel2*x1*x3*x4*xcp2 +64*e4e1^2*e3e2*amel2*x1*x3*x4*xcp1 +32*e4e1^2*e3e2*amel2*x1^2*xcp3 -576*e4e1^2*e3e2*amel2*x1^2*xcp2 +32*e4e1^2*e3e2*amel2*x1^2*xcp1 +384*e4e1^2*e3e2*amel2*x1^2*x5*xcp2 +384*e4e1^2*e3e2*amel2*x1^2*x4*xcp2 -64*e4e1^2*e3e2*amel2*x1^2*x3*xcp3 +512*e4e1^2*e3e2*amel2*x1^2*x3*xcp2 -64*e4e1^2*e3e2*amel2*x1^2*x3*xcp1 +128*e4e1^2*e3e2*amel2*x1^3*xcp2 +512*e4e1^2*e3e2*e2e1*xcp2 -768*e4e1^2*e3e2*e2e1*x5*xcp2 +256*e4e1^2*e3e2*e2e1*x5^2*xcp2 -768*e4e1^2*e3e2*e2e1*x4*xcp2 +512*e4e1^2*e3e2*e2e1*x4*x5*xcp2 +256*e4e1^2*e3e2*e2e1*x4^2*xcp2 -1024*e4e1^2*e3e2*e2e1*x3*xcp2 +768*e4e1^2*e3e2*e2e1*x3*x5*xcp2 +768*e4e1^2*e3e2*e2e1*x3*x4*xcp2 +512*e4e1^2*e3e2*e2e1*x3^2*xcp2 -256*e4e1^2*e3e2*e2e1*x1*xcp2 +896*e4e1^2*e3e2*e2e1*x1*x5*xcp2 -512*e4e1^2*e3e2*e2e1*x1*x5^2*xcp2 +384*e4e1^2*e3e2*e2e1*x1*x4*xcp2 -768*e4e1^2*e3e2*e2e1*x1*x4*x5*xcp2 -256*e4e1^2*e3e2*e2e1*x1*x4^2*xcp2 +768*e4e1^2*e3e2*e2e1*x1*x3*xcp2 -1024*e4e1^2*e3e2*e2e1*x1*x3*x5*xcp2 -512*e4e1^2*e3e2*e2e1*x1*x3*x4*xcp2 -512*e4e1^2*e3e2*e2e1*x1*x3^2*xcp2 -256*e4e1^2*e3e2*e2e1*x1^2*xcp2 +128*e4e1^2*e3e2*e2e1*x1^2*x5*xcp2 +128*e4e1^2*e3e2*e2e1*x1^2*x4*xcp2 +256*e4e1^2*e3e2*e2e1*x1^2*x3*xcp2 -256*e4e1^2*e3e2^2*xcp2 +384*e4e1^2*e3e2^2*x5*xcp2 -128*e4e1^2*e3e2^2*x5^2*xcp2 +384*e4e1^2*e3e2^2*x4*xcp2 -256*e4e1^2*e3e2^2*x4*x5*xcp2 -128*e4e1^2*e3e2^2*x4^2*xcp2 +512*e4e1^2*e3e2^2*x3*xcp2 -384*e4e1^2*e3e2^2*x3*x5*xcp2 -384*e4e1^2*e3e2^2*x3*x4*xcp2 -256*e4e1^2*e3e2^2*x3^2*xcp2 +256*e4e1^2*e3e2^2*x1*xcp2 -512*e4e1^2*e3e2^2*x1*x5*xcp2 +256*e4e1^2*e3e2^2*x1*x5^2*xcp2 -256*e4e1^2*e3e2^2*x1*x4*xcp2 +384*e4e1^2*e3e2^2*x1*x4*x5*xcp2 +128*e4e1^2*e3e2^2*x1*x4^2*xcp2 -512*e4e1^2*e3e2^2*x1*x3*xcp2 +512*e4e1^2*e3e2^2*x1*x3*x5*xcp2 +256*e4e1^2*e3e2^2*x1*x3*x4*xcp2 +256*e4e1^2*e3e2^2*x1*x3^2*xcp2 +64*e4e1^2*e3e1*amel2*x5*xcp3 +64*e4e1^2*e3e1*amel2*x5*xcp1 -64*e4e1^2*e3e1*amel2*x5^2*xcp3 -64*e4e1^2*e3e1*amel2*x5^2*xcp1 +64*e4e1^2*e3e1*amel2*x4*xcp3 -128*e4e1^2*e3e1*amel2*x4*xcp2 +64*e4e1^2*e3e1*amel2*x4*xcp1 -128*e4e1^2*e3e1*amel2*x4*x5*xcp3 +128*e4e1^2*e3e1*amel2*x4*x5*xcp2 -128*e4e1^2*e3e1*amel2*x4*x5*xcp1 -64*e4e1^2*e3e1*amel2*x4^2*xcp3 +128*e4e1^2*e3e1*amel2*x4^2*xcp2 -64*e4e1^2*e3e1*amel2*x4^2*xcp1 -128*e4e1^2*e3e1*amel2*x3*xcp2 -64*e4e1^2*e3e1*amel2*x3*x5*xcp3 +128*e4e1^2*e3e1*amel2*x3*x5*xcp2 -64*e4e1^2*e3e1*amel2*x3*x5*xcp1 -64*e4e1^2*e3e1*amel2*x3*x4*xcp3 +256*e4e1^2*e3e1*amel2*x3*x4*xcp2 -64*e4e1^2*e3e1*amel2*x3*x4*xcp1 +128*e4e1^2*e3e1*amel2*x3^2*xcp2 +256*e4e1^2*e3e1*amel2*x1*xcp3 +256*e4e1^2*e3e1*amel2*x1*xcp1 -128*e4e1^2*e3e1*amel2*x1*x5*xcp3 -128*e4e1^2*e3e1*amel2*x1*x5*xcp1 +64*e4e1^2*e3e1*amel2*x1*x5^2*xcp3 +64*e4e1^2*e3e1*amel2*x1*x5^2*xcp1 -128*e4e1^2*e3e1*amel2*x1*x4*xcp3 -128*e4e1^2*e3e1*amel2*x1*x4*xcp2 -128*e4e1^2*e3e1*amel2*x1*x4*xcp1 +128*e4e1^2*e3e1*amel2*x1*x4*x5*xcp3 +128*e4e1^2*e3e1*amel2*x1*x4*x5*xcp1 +64*e4e1^2*e3e1*amel2*x1*x4^2*xcp3 +64*e4e1^2*e3e1*amel2*x1*x4^2*xcp1 -256*e4e1^2*e3e1*amel2*x1*x3*xcp3 -128*e4e1^2*e3e1*amel2*x1*x3*xcp2 -256*e4e1^2*e3e1*amel2*x1*x3*xcp1 +128*e4e1^2*e3e1*amel2*x1*x3*x5*xcp3 +128*e4e1^2*e3e1*amel2*x1*x3*x5*xcp1 +128*e4e1^2*e3e1*amel2*x1*x3*x4*xcp3 -128*e4e1^2*e3e1*amel2*x1*x3*x4*xcp2 +128*e4e1^2*e3e1*amel2*x1*x3*x4*xcp1 -128*e4e1^2*e3e1*amel2*x1*x3^2*xcp2 -192*e4e1^2*e3e1*amel2*x1^2*xcp3 -192*e4e1^2*e3e1*amel2*x1^2*xcp1 +64*e4e1^2*e3e1*amel2*x1^2*x5*xcp3 +64*e4e1^2*e3e1*amel2*x1^2*x5*xcp1 +64*e4e1^2*e3e1*amel2*x1^2*x4*xcp3 +256*e4e1^2*e3e1*amel2*x1^2*x4*xcp2 +64*e4e1^2*e3e1*amel2*x1^2*x4*xcp1 +192*e4e1^2*e3e1*amel2*x1^2*x3*xcp3 +256*e4e1^2*e3e1*amel2*x1^2*x3*xcp2 +192*e4e1^2*e3e1*amel2*x1^2*x3*xcp1 +256*e4e1^2*e3e1*e2e1*xcp2 -384*e4e1^2*e3e1*e2e1*x5*xcp2 +128*e4e1^2*e3e1*e2e1*x5^2*xcp2 -384*e4e1^2*e3e1*e2e1*x4*xcp2 +256*e4e1^2*e3e1*e2e1*x4*x5*xcp2 +128*e4e1^2*e3e1*e2e1*x4^2*xcp2 -512*e4e1^2*e3e1*e2e1*x3*xcp2 +384*e4e1^2*e3e1*e2e1*x3*x5*xcp2 +384*e4e1^2*e3e1*e2e1*x3*x4*xcp2 +256*e4e1^2*e3e1*e2e1*x3^2*xcp2 +256*e4e1^2*e3e1*e2e1*x1*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x5*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x4*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x3*x5*xcp2 -128*e4e1^2*e3e1*e2e1*x1*x3*x4*xcp2 -256*e4e1^2*e3e1*e2e1*x1*x3^2*xcp2 -512*e4e1^2*e3e1*e2e1*x1^2*xcp2 +256*e4e1^2*e3e1*e2e1*x1^2*x5*xcp2 +256*e4e1^2*e3e1*e2e1*x1^2*x4*xcp2 +512*e4e1^2*e3e1*e2e1*x1^2*x3*xcp2 -256*e4e1^2*e3e1*e3e2*xcp2 +384*e4e1^2*e3e1*e3e2*x5*xcp2 -128*e4e1^2*e3e1*e3e2*x5^2*xcp2 +384*e4e1^2*e3e1*e3e2*x4*xcp2 -256*e4e1^2*e3e1*e3e2*x4*x5*xcp2 -128*e4e1^2*e3e1*e3e2*x4^2*xcp2 +512*e4e1^2*e3e1*e3e2*x3*xcp2 -384*e4e1^2*e3e1*e3e2*x3*x5*xcp2 -384*e4e1^2*e3e1*e3e2*x3*x4*xcp2 -256*e4e1^2*e3e1*e3e2*x3^2*xcp2 -256*e4e1^2*e3e1*e3e2*x1*xcp2 +256*e4e1^2*e3e1*e3e2*x1*x5*xcp2 +256*e4e1^2*e3e1*e3e2*x1*x4*xcp2 +128*e4e1^2*e3e1*e3e2*x1*x3*x5*xcp2 +128*e4e1^2*e3e1*e3e2*x1*x3*x4*xcp2 +256*e4e1^2*e3e1*e3e2*x1*x3^2*xcp2 +512*e4e1^2*e3e1*e3e2*x1^2*xcp2 -384*e4e1^2*e3e1*e3e2*x1^2*x5*xcp2 -384*e4e1^2*e3e1*e3e2*x1^2*x4*xcp2 -512*e4e1^2*e3e1*e3e2*x1^2*x3*xcp2 -64*e4e1^2*e4e2*zk^2*xcp2 +128*e4e1^2*e4e2*zk^2*x1*xcp2 +128*e4e1^2*e4e2*amel2*xcp3 +128*e4e1^2*e4e2*amel2*xcp1 -64*e4e1^2*e4e2*amel2*x5*xcp3 -256*e4e1^2*e4e2*amel2*x5*xcp2 -64*e4e1^2*e4e2*amel2*x5*xcp1 -384*e4e1^2*e4e2*amel2*x4*xcp2 +128*e4e1^2*e4e2*amel2*x4*x5*xcp2 -128*e4e1^2*e4e2*amel2*x3*xcp3 -128*e4e1^2*e4e2*amel2*x3*xcp2 -128*e4e1^2*e4e2*amel2*x3*xcp1 +64*e4e1^2*e4e2*amel2*x3*x5*xcp3 +384*e4e1^2*e4e2*amel2*x3*x5*xcp2 +64*e4e1^2*e4e2*amel2*x3*x5*xcp1 +256*e4e1^2*e4e2*amel2*x3*x4*xcp2 -128*e4e1^2*e4e2*amel2*x1*xcp3 +384*e4e1^2*e4e2*amel2*x1*xcp2 -128*e4e1^2*e4e2*amel2*x1*xcp1 +128*e4e1^2*e4e2*amel2*x1*x5*xcp3 +128*e4e1^2*e4e2*amel2*x1*x5*xcp2 +128*e4e1^2*e4e2*amel2*x1*x5*xcp1 +128*e4e1^2*e4e2*amel2*x1*x4*xcp2 -256*e4e1^2*e4e2*amel2*x1*x4*x5*xcp2 +128*e4e1^2*e4e2*amel2*x1*x3*xcp3 -384*e4e1^2*e4e2*amel2*x1*x3*xcp2 +128*e4e1^2*e4e2*amel2*x1*x3*xcp1 -128*e4e1^2*e4e2*amel2*x1*x3*x5*xcp3 -512*e4e1^2*e4e2*amel2*x1*x3*x5*xcp2 -128*e4e1^2*e4e2*amel2*x1*x3*x5*xcp1 -128*e4e1^2*e4e2*amel2*x1*x3*x4*xcp2 +128*e4e1^2*e4e2*amel2*x1*x3^2*xcp2 -640*e4e1^2*e4e2*amel2*x1^2*xcp2 +128*e4e1^2*e4e2*amel2*x1^2*x5*xcp2 +128*e4e1^2*e4e2*amel2*x1^2*x4*xcp2 -64*e4e1^2*e4e2*amel2*x1^2*x3*xcp3 +512*e4e1^2*e4e2*amel2*x1^2*x3*xcp2 -64*e4e1^2*e4e2*amel2*x1^2*x3*xcp1 +128*e4e1^2*e4e2*amel2*x1^3*xcp2 +512*e4e1^2*e4e2*e2e1*xcp2 -640*e4e1^2*e4e2*e2e1*x5*xcp2 +128*e4e1^2*e4e2*e2e1*x5^2*xcp2 -384*e4e1^2*e4e2*e2e1*x4*xcp2 +128*e4e1^2*e4e2*e2e1*x4*x5*xcp2 -768*e4e1^2*e4e2*e2e1*x3*xcp2 +512*e4e1^2*e4e2*e2e1*x3*x5*xcp2 +256*e4e1^2*e4e2*e2e1*x3*x4*xcp2 +256*e4e1^2*e4e2*e2e1*x3^2*xcp2 -256*e4e1^2*e4e2*e2e1*x1*xcp2 +896*e4e1^2*e4e2*e2e1*x1*x5*xcp2 -256*e4e1^2*e4e2*e2e1*x1*x5^2*xcp2 +128*e4e1^2*e4e2*e2e1*x1*x4*xcp2 -256*e4e1^2*e4e2*e2e1*x1*x4*x5*xcp2 +512*e4e1^2*e4e2*e2e1*x1*x3*xcp2 -896*e4e1^2*e4e2*e2e1*x1*x3*x5*xcp2 -128*e4e1^2*e4e2*e2e1*x1*x3*x4*xcp2 -256*e4e1^2*e4e2*e2e1*x1*x3^2*xcp2 -256*e4e1^2*e4e2*e2e1*x1^2*xcp2 +128*e4e1^2*e4e2*e2e1*x1^2*x5*xcp2 +128*e4e1^2*e4e2*e2e1*x1^2*x4*xcp2 +256*e4e1^2*e4e2*e2e1*x1^2*x3*xcp2 -512*e4e1^2*e4e2*e3e2*xcp2 +640*e4e1^2*e4e2*e3e2*x5*xcp2 -128*e4e1^2*e4e2*e3e2*x5^2*xcp2 +384*e4e1^2*e4e2*e3e2*x4*xcp2 -128*e4e1^2*e4e2*e3e2*x4*x5*xcp2 +768*e4e1^2*e4e2*e3e2*x3*xcp2 -512*e4e1^2*e4e2*e3e2*x3*x5*xcp2 -256*e4e1^2*e4e2*e3e2*x3*x4*xcp2 -256*e4e1^2*e4e2*e3e2*x3^2*xcp2 +512*e4e1^2*e4e2*e3e2*x1*xcp2 -1024*e4e1^2*e4e2*e3e2*x1*x5*xcp2 +256*e4e1^2*e4e2*e3e2*x1*x5^2*xcp2 -256*e4e1^2*e4e2*e3e2*x1*x4*xcp2 +256*e4e1^2*e4e2*e3e2*x1*x4*x5*xcp2 -768*e4e1^2*e4e2*e3e2*x1*x3*xcp2 +896*e4e1^2*e4e2*e3e2*x1*x3*x5*xcp2 +128*e4e1^2*e4e2*e3e2*x1*x3*x4*xcp2 +256*e4e1^2*e4e2*e3e2*x1*x3^2*xcp2 -256*e4e1^2*e4e2*e3e1*xcp2 +256*e4e1^2*e4e2*e3e1*x5*xcp2 +256*e4e1^2*e4e2*e3e1*x4*xcp2 +512*e4e1^2*e4e2*e3e1*x3*xcp2 -256*e4e1^2*e4e2*e3e1*x3*x5*xcp2 -256*e4e1^2*e4e2*e3e1*x3*x4*xcp2 -256*e4e1^2*e4e2*e3e1*x3^2*xcp2 -256*e4e1^2*e4e2*e3e1*x1*xcp2 +128*e4e1^2*e4e2*e3e1*x1*x5*xcp2 +128*e4e1^2*e4e2*e3e1*x1*x4*xcp2 +256*e4e1^2*e4e2*e3e1*x1*x3^2*xcp2 +512*e4e1^2*e4e2*e3e1*x1^2*xcp2 -128*e4e1^2*e4e2*e3e1*x1^2*x5*xcp2 -128*e4e1^2*e4e2*e3e1*x1^2*x4*xcp2 -512*e4e1^2*e4e2*e3e1*x1^2*x3*xcp2 -256*e4e1^2*e4e2^2*xcp2 +256*e4e1^2*e4e2^2*x5*xcp2 +256*e4e1^2*e4e2^2*x3*xcp2 -256*e4e1^2*e4e2^2*x3*x5*xcp2 +256*e4e1^2*e4e2^2*x1*xcp2 -512*e4e1^2*e4e2^2*x1*x5*xcp2 -256*e4e1^2*e4e2^2*x1*x3*xcp2 +512*e4e1^2*e4e2^2*x1*x3*x5*xcp2 +64*e4e1^3*amel2*x1*xcp3 +64*e4e1^3*amel2*x1*xcp1 -128*e4e1^3*amel2*x1*x4*xcp2 -64*e4e1^3*amel2*x1*x3*xcp3 -128*e4e1^3*amel2*x1*x3*xcp2 -64*e4e1^3*amel2*x1*x3*xcp1 -64*e4e1^3*amel2*x1^2*xcp3 -64*e4e1^3*amel2*x1^2*xcp1 +128*e4e1^3*amel2*x1^2*x4*xcp2 +64*e4e1^3*amel2*x1^2*x3*xcp3 +128*e4e1^3*amel2*x1^2*x3*xcp2 +64*e4e1^3*amel2*x1^2*x3*xcp1 +256*e4e1^3*e2e1*x1*xcp2 -128*e4e1^3*e2e1*x1*x5*xcp2 -128*e4e1^3*e2e1*x1*x4*xcp2 -256*e4e1^3*e2e1*x1*x3*xcp2 -256*e4e1^3*e2e1*x1^2*xcp2 +128*e4e1^3*e2e1*x1^2*x5*xcp2 +128*e4e1^3*e2e1*x1^2*x4*xcp2 +256*e4e1^3*e2e1*x1^2*x3*xcp2 -256*e4e1^3*e3e2*x1*xcp2 +128*e4e1^3*e3e2*x1*x5*xcp2 +128*e4e1^3*e3e2*x1*x4*xcp2 +256*e4e1^3*e3e2*x1*x3*xcp2 +256*e4e1^3*e3e2*x1^2*xcp2 -128*e4e1^3*e3e2*x1^2*x5*xcp2 -128*e4e1^3*e3e2*x1^2*x4*xcp2 -256*e4e1^3*e3e2*x1^2*x3*xcp2 -256*e4e1^3*e4e2*x1*xcp2 +256*e4e1^3*e4e2*x1*x3*xcp2 +256*e4e1^3*e4e2*x1^2*xcp2 -256*e4e1^3*e4e2*x1^2*x3*xcp2 -32*EFUN*amel2^2*x1*x5*xcp3 +32*EFUN*amel2^2*x1*x5*xcp1 -64*EFUN*amel2^2*x1*x4*xcp3 +64*EFUN*amel2^2*x1*x4*xcp1 -32*EFUN*amel2^2*x1*x3*xcp3 +32*EFUN*amel2^2*x1*x3*xcp1 -32*EFUN*amel2^2*x1^2*xcp3 +32*EFUN*amel2^2*x1^2*xcp1 +32*EFUN*e2e1*amel2*x5^2*xcp3 -32*EFUN*e2e1*amel2*x5^2*xcp1 +64*EFUN*e2e1*amel2*x4*x5*xcp3 -64*EFUN*e2e1*amel2*x4*x5*xcp1 +64*EFUN*e2e1*amel2*x3*x5*xcp3 -64*EFUN*e2e1*amel2*x3*x5*xcp1 +64*EFUN*e2e1*amel2*x3*x4*xcp3 -64*EFUN*e2e1*amel2*x3*x4*xcp1 +32*EFUN*e2e1*amel2*x3^2*xcp3 -32*EFUN*e2e1*amel2*x3^2*xcp1 +32*EFUN*e2e1*amel2*x1*x5*xcp3 -32*EFUN*e2e1*amel2*x1*x5*xcp1 +32*EFUN*e2e1*amel2*x1*x3*xcp3 -32*EFUN*e2e1*amel2*x1*x3*xcp1 -32*EFUN*e3e2*amel2*x5^2*xcp3 +32*EFUN*e3e2*amel2*x5^2*xcp1 -64*EFUN*e3e2*amel2*x4*x5*xcp3 +64*EFUN*e3e2*amel2*x4*x5*xcp1 -64*EFUN*e3e2*amel2*x3*x5*xcp3 +64*EFUN*e3e2*amel2*x3*x5*xcp1 -64*EFUN*e3e2*amel2*x3*x4*xcp3 +64*EFUN*e3e2*amel2*x3*x4*xcp1 -32*EFUN*e3e2*amel2*x3^2*xcp3 +32*EFUN*e3e2*amel2*x3^2*xcp1 -32*EFUN*e3e2*amel2*x1*x5*xcp3 +32*EFUN*e3e2*amel2*x1*x5*xcp1 -32*EFUN*e3e2*amel2*x1*x3*xcp3 +32*EFUN*e3e2*amel2*x1*x3*xcp1 -64*EFUN*e3e1*amel2*x5*xcp3 +64*EFUN*e3e1*amel2*x5*xcp1 +32*EFUN*e3e1*amel2*x5^2*xcp3 -32*EFUN*e3e1*amel2*x5^2*xcp1 -32*EFUN*e3e1*amel2*x4*xcp3 +32*EFUN*e3e1*amel2*x4*xcp1 +96*EFUN*e3e1*amel2*x4*x5*xcp3 -96*EFUN*e3e1*amel2*x4*x5*xcp1 +64*EFUN*e3e1*amel2*x4^2*xcp3 -64*EFUN*e3e1*amel2*x4^2*xcp1 +32*EFUN*e3e1*amel2*x3*xcp3 -32*EFUN*e3e1*amel2*x3*xcp1 +32*EFUN*e3e1*amel2*x3*x5*xcp3 -32*EFUN*e3e1*amel2*x3*x5*xcp1 +32*EFUN*e3e1*amel2*x3*x4*xcp3 -32*EFUN*e3e1*amel2*x3*x4*xcp1 -32*EFUN*e3e1*amel2*x1*xcp3 +32*EFUN*e3e1*amel2*x1*xcp1 +64*EFUN*e3e1*amel2*x1*x5*xcp3 -64*EFUN*e3e1*amel2*x1*x5*xcp1 +96*EFUN*e3e1*amel2*x1*x4*xcp3 -96*EFUN*e3e1*amel2*x1*x4*xcp1 +32*EFUN*e3e1*amel2*x1*x3*xcp3 -32*EFUN*e3e1*amel2*x1*x3*xcp1 +32*EFUN*e3e1*amel2*x1^2*xcp3 -32*EFUN*e3e1*amel2*x1^2*xcp1 -32*EFUN*e4e2*amel2*x5^2*xcp3 +32*EFUN*e4e2*amel2*x5^2*xcp1 -64*EFUN*e4e2*amel2*x4*x5*xcp3 +64*EFUN*e4e2*amel2*x4*x5*xcp1 -64*EFUN*e4e2*amel2*x3*x5*xcp3 +64*EFUN*e4e2*amel2*x3*x5*xcp1 -64*EFUN*e4e2*amel2*x3*x4*xcp3 +64*EFUN*e4e2*amel2*x3*x4*xcp1 -32*EFUN*e4e2*amel2*x3^2*xcp3 +32*EFUN*e4e2*amel2*x3^2*xcp1 -32*EFUN*e4e2*amel2*x1*x5*xcp3 +32*EFUN*e4e2*amel2*x1*x5*xcp1 -32*EFUN*e4e2*amel2*x1*x3*xcp3 +32*EFUN*e4e2*amel2*x1*x3*xcp1 +32*EFUN*e4e1*amel2*x1*x5*xcp3 -32*EFUN*e4e1*amel2*x1*x5*xcp1 +64*EFUN*e4e1*amel2*x1*x4*xcp3 -64*EFUN*e4e1*amel2*x1*x4*xcp1 +32*EFUN*e4e1*amel2*x1*x3*xcp3 -32*EFUN*e4e1*amel2*x1*x3*xcp1 +32*EFUN*e4e1*amel2*x1^2*xcp3 -32*EFUN*e4e1*amel2*x1^2*xcp1";
 
 fn main() {
-    let poly: MultivariatePolynomial<_, u8> = Atom::parse(SIGMA)
-        .unwrap()
-        .as_view()
-        .to_polynomial(&RationalField::new(), None)
-        .unwrap();
+    let poly: MultivariatePolynomial<_, u8> = Atom::parse(SIGMA).unwrap().to_polynomial(&Q, None);
 
     // optimize SIGMA and SIGMA + 5 at the same time
     let mut poly2 = poly.clone();
-    poly2 = poly2.add_monomial(Rational::Natural(5, 1));
+    poly2 = poly2.add_constant(Rational::Natural(5, 1));
 
     let (h, score, scheme) = HornerScheme::optimize_multiple(&[&poly, &poly2], 1000);
 
-    let mut i = HornerScheme::to_instr_multiple(&h, poly.nvars);
+    let mut i = HornerScheme::to_instr_multiple(&h, poly.nvars());
 
     println!("Number of operations={}, with scheme={:?}", score, scheme,);
 
     i.fuse_operations();
 
     for _ in 0..100_000 {
         if !i.common_pair_elimination() {
             break;
         }
         i.fuse_operations();
     }
 
     let op_count = i.op_count();
-    let o = i.to_output(poly.var_map.as_ref().unwrap().to_vec(), true);
+    let o = i.to_output(poly.variables.as_ref().to_vec(), true);
     let o_f64 = o.convert::<f64>();
 
     println!("Writing output to evaluate_multiple.cpp");
     std::fs::write(
         "evaluate_multiple.cpp",
         format!(
             "{}",
@@ -58,10 +54,11 @@
     .unwrap();
 
     let mut evaluator = o_f64.evaluator();
 
     println!("Final number of operations={}", op_count);
     println!(
         "Evaluation = {:?}",
-        evaluator.evaluate_with_input(&(0..poly.nvars).map(|x| x as f64 + 1.).collect::<Vec<_>>())
+        evaluator
+            .evaluate_with_input(&(0..poly.nvars()).map(|x| x as f64 + 1.).collect::<Vec<_>>())
     );
 }
```

### Comparing `symbolica-0.3.0/examples/partial_fraction.rs` & `symbolica-0.4.0/examples/partial_fraction.rs`

 * *Files 17% similar despite different names*

```diff
@@ -1,54 +1,50 @@
 use std::sync::Arc;
 
 use symbolica::{
     domains::{
-        factorized_rational_polynomial::FactorizedRationalPolynomial, integer::IntegerRing,
+        factorized_rational_polynomial::FactorizedRationalPolynomial, integer::Z,
         rational_polynomial::RationalPolynomial,
     },
     parser::Token,
     state::State,
 };
 
 fn univariate() {
     let var_names = vec!["x".into(), "y".into()];
     let var_map = Arc::new(
         var_names
             .iter()
-            .map(|n| State::get_or_insert_var(n).into())
+            .map(|n| State::get_symbol(n).into())
             .collect(),
     );
 
-    let field = IntegerRing::new();
-
     let rat: RationalPolynomial<_, u8> = Token::parse("1/((x+1)*(x+2)(x^3+2x+1))")
         .unwrap()
-        .to_rational_polynomial(&field, &field, &var_map, &var_names)
+        .to_rational_polynomial(&Z, &Z, &var_map, &var_names)
         .unwrap();
 
     println!("Partial fraction {}:", rat);
     for x in rat.apart(0) {
         println!("\t{}", x);
     }
 }
 
 fn multivariate() {
     let var_names = vec!["x".into(), "y".into()];
     let var_map = Arc::new(
         var_names
             .iter()
-            .map(|n| State::get_or_insert_var(n).into())
+            .map(|n| State::get_symbol(n).into())
             .collect(),
     );
 
-    let field = IntegerRing::new();
-
     let rat: FactorizedRationalPolynomial<_, u8> = Token::parse("1/((x+y)*(x^2+x*y+1)(x+1))")
         .unwrap()
-        .to_factorized_rational_polynomial(&field, &field, &var_map, &var_names)
+        .to_factorized_rational_polynomial(&Z, &Z, &var_map, &var_names)
         .unwrap();
 
     println!("Partial fraction {} in x:", rat);
     for x in rat.apart(0) {
         println!("\t{}", x);
     }
 }
```

### Comparing `symbolica-0.3.0/examples/pattern_match.rs` & `symbolica-0.4.0/examples/tree_replace.rs`

 * *Files 19% similar despite different names*

```diff
@@ -1,31 +1,26 @@
 use symbolica::{
-    id::{Match, MatchSettings, PatternRestriction},
-    representations::Atom,
+    atom::Atom,
+    id::{Condition, Match, MatchSettings, PatternAtomTreeIterator},
     state::State,
 };
 
 fn main() {
-    let expr = Atom::parse("x*y*w*z*f(x,y,x*y,z)").unwrap();
-
-    let pat_expr = Atom::parse("z*x_*y_*g_(z_,x_,w_)").unwrap();
+    let expr = Atom::parse("f(z)*f(f(x))*f(y)").unwrap();
+    let pat_expr = Atom::parse("f(x_)").unwrap();
 
     let pattern = pat_expr.as_view().into_pattern();
-    let restrictions = (
-        State::get_or_insert_var("x_"),
-        PatternRestriction::Length(1, Some(100)),
-    )
-        .into();
+    let restrictions = Condition::default();
     let settings = MatchSettings::default();
 
-    println!("> Matching pattern {} to {}:", pat_expr, expr.as_view());
+    println!("> Matching pattern {} to {}:", pat_expr, expr);
 
-    let mut it = pattern.pattern_match(expr.as_view(), &restrictions, &settings);
+    let mut it = PatternAtomTreeIterator::new(&pattern, expr.as_view(), &restrictions, &settings);
     while let Some((location, used_flags, _atom, match_stack)) = it.next() {
-        println!("\t Match at location {:?} - {:?}:", location, used_flags);
+        println!("\tMatch at location {:?} - {:?}:", location, used_flags);
         for (id, v) in match_stack {
             print!("\t\t{} = ", State::get_name(*id));
             match v {
                 Match::Single(s) => {
                     print!("{}", s)
                 }
                 Match::Multiple(slice_type, mm) => {
```

### Comparing `symbolica-0.3.0/examples/pattern_restrictions.rs` & `symbolica-0.4.0/examples/pattern_restrictions.rs`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 use symbolica::{
+    atom::{Atom, AtomView},
     coefficient::CoefficientView,
     domains::finite_field,
     id::{Condition, Match, MatchSettings, PatternRestriction},
-    representations::{Atom, AtomView},
     state::State,
 };
 fn main() {
     let expr = Atom::parse("f(1,2,3,4,5,6,7)").unwrap();
     let pat_expr = Atom::parse("f(x__,y__,z__,w__)").unwrap();
 
     let pattern = pat_expr.as_view().into_pattern();
 
-    let x = State::get_or_insert_var("x__");
-    let y = State::get_or_insert_var("y__");
-    let z = State::get_or_insert_var("z__");
-    let w = State::get_or_insert_var("w__");
+    let x = State::get_symbol("x__");
+    let y = State::get_symbol("y__");
+    let z = State::get_symbol("z__");
+    let w = State::get_symbol("w__");
 
     let conditions = Condition::from((x, PatternRestriction::Length(0, Some(2))))
         & (y, PatternRestriction::Length(0, Some(4)))
         & (
             y,
             PatternRestriction::Cmp(
                 x,
```

### Comparing `symbolica-0.3.0/examples/rational_reconstruction.rs` & `symbolica-0.4.0/examples/rational_reconstruction.rs`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,24 @@
 use symbolica::domains::{
-    finite_field::{FiniteField, FiniteFieldCore},
-    rational::{Rational, RationalField},
+    finite_field::{FiniteFieldCore, Zp},
+    rational::{Rational, Q},
     Field, Ring,
 };
 
 /// An arbitrarily complicated black-box function.
-fn black_box(
-    field: &FiniteField<u32>,
-    eval: &[<FiniteField<u32> as Ring>::Element],
-) -> <FiniteField<u32> as Ring>::Element {
+fn black_box(field: &Zp, eval: &[<Zp as Ring>::Element]) -> <Zp as Ring>::Element {
     // eval -(x^2+y/3)
     field.neg(&field.add(
         &field.mul(&eval[0], &eval[0]),
         &field.div(&eval[1], &field.to_element(3)),
     ))
 }
 
 fn main() {
-    let r = Rational::rational_reconstruction::<_, RationalField>(
+    let r = Rational::rational_reconstruction::<_, Q>(
         black_box,
         &[Rational::Natural(1, 2), Rational::Natural(3, 1)],
         None,
     );
 
     assert_eq!(r, Ok(Rational::Natural(-5, 4)));
     println!("Reconstructed f(1/2,3)={}", r.unwrap());
```

### Comparing `symbolica-0.3.0/examples/replace_once.rs` & `symbolica-0.4.0/examples/replace_once.rs`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 use symbolica::{
+    atom::Atom,
     id::{Condition, MatchSettings},
-    representations::Atom,
 };
 
 fn main() {
     let expr = Atom::parse("f(z)*f(f(x))*f(y)").unwrap();
     let pat_expr = Atom::parse("f(x_)").unwrap();
 
     let rhs_expr = Atom::parse("g(x_)").unwrap();
```

### Comparing `symbolica-0.3.0/examples/solve_linear_system.rs` & `symbolica-0.4.0/examples/solve_linear_system.rs`

 * *Files 17% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 use std::sync::Arc;
 
 use symbolica::{
+    atom::{Atom, AtomView},
     domains::{
-        integer::IntegerRing,
-        linear_system::Matrix,
-        rational::RationalField,
+        integer::Z,
+        rational::Q,
         rational_polynomial::{RationalPolynomial, RationalPolynomialField},
     },
     poly::Variable,
-    representations::{Atom, AtomView},
     state::State,
+    tensors::matrix::Matrix,
 };
 
 fn solve() {
-    let x = State::get_or_insert_var("x");
-    let y = State::get_or_insert_var("y");
-    let z = State::get_or_insert_var("z");
+    let x = State::get_symbol("x");
+    let y = State::get_symbol("y");
+    let z = State::get_symbol("z");
     let eqs = ["c*x + f(c)*y + z - 1", "x + c*y + z/c - 2", "(c-1)x + c*z"];
 
     let atoms: Vec<_> = eqs.iter().map(|e| Atom::parse(e).unwrap()).collect();
     let system: Vec<_> = atoms.iter().map(|x| x.as_view()).collect();
 
     let sol = AtomView::solve_linear_system::<u8>(&system, &[x, y, z]).unwrap();
 
@@ -33,56 +33,51 @@
     let rhs = ["1", "2", "-1"];
 
     println!("Solve linear system in x\u{20D7}:");
     for (r, v) in system.iter().zip(&rhs) {
         println!("\t ({}).x\u{20D7} = {}", r.join(","), v);
     }
 
-    let var_map = Arc::new(vec![Variable::Symbol(State::get_or_insert_var("c"))]);
+    let var_map = Arc::new(vec![Variable::Symbol(State::get_symbol("c"))]);
 
-    let system_rat: Vec<RationalPolynomial<IntegerRing, u8>> = system
+    let system_rat: Vec<RationalPolynomial<_, u8>> = system
         .iter()
         .flatten()
         .map(|s| {
             Atom::parse(s)
                 .unwrap()
-                .as_view()
-                .to_rational_polynomial(&RationalField::new(), &IntegerRing::new(), Some(&var_map))
-                .unwrap()
+                .to_rational_polynomial(&Q, &Z, Some(var_map.clone()))
         })
         .collect();
 
-    let rhs_rat: Vec<RationalPolynomial<IntegerRing, u8>> = rhs
+    let rhs_rat: Vec<RationalPolynomial<_, u8>> = rhs
         .iter()
         .map(|s| {
             Atom::parse(s)
                 .unwrap()
-                .as_view()
-                .to_rational_polynomial(&RationalField::new(), &IntegerRing::new(), Some(&var_map))
-                .unwrap()
+                .to_rational_polynomial(&Q, &Z, Some(var_map.clone()))
         })
         .collect();
 
-    let m = Matrix {
-        shape: (system.len() as u32, system.len() as u32),
-        data: system_rat.into(),
-        field: RationalPolynomialField::new_from_poly(&rhs_rat[0].numerator),
-    };
-    let b = Matrix {
-        shape: (rhs.len() as u32, 1),
-        field: RationalPolynomialField::new_from_poly(&rhs_rat[0].numerator),
-        data: rhs_rat.into(),
-    };
+    let field = RationalPolynomialField::new_from_poly(&rhs_rat[0].numerator);
+    let m = Matrix::from_linear(
+        system_rat,
+        system.len() as u32,
+        system.len() as u32,
+        field.clone(),
+    )
+    .unwrap();
+    let b = Matrix::new_vec(rhs_rat, field);
 
     match m.solve(&b) {
         Ok(sol) => {
             println!(
                 "x\u{20D7} = {{{}}}",
-                sol.data
-                    .iter()
+                sol.row_iter()
+                    .flatten()
                     .map(|r| format!("{}", r))
                     .collect::<Vec<_>>()
                     .join(", ")
             )
         }
         Err(e) => panic!("Could not solve {:?}", e),
     }
```

### Comparing `symbolica-0.3.0/examples/streaming.rs` & `symbolica-0.4.0/examples/streaming.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-use symbolica::{id::Pattern, representations::Atom, streaming::TermStreamer};
+use symbolica::{atom::Atom, id::Pattern, streaming::TermStreamer};
 
 fn main() {
     let input = Atom::parse("x+ f(x) + 2*f(y) + 7*f(z)").unwrap();
     let pattern = Pattern::parse("f(x_)").unwrap();
     let rhs = Pattern::parse("f(x) + x").unwrap();
 
     let mut stream = TermStreamer::new_from(input);
```

### Comparing `symbolica-0.3.0/examples/tree_replace.rs` & `symbolica-0.4.0/examples/pattern_match.rs`

 * *Files 11% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 use symbolica::{
-    id::{Condition, Match, MatchSettings, PatternAtomTreeIterator},
-    representations::Atom,
+    atom::Atom,
+    id::{Condition, Match, MatchSettings},
     state::State,
 };
 
 fn main() {
-    let expr = Atom::parse("f(z)*f(f(x))*f(y)").unwrap();
-    let pat_expr = Atom::parse("f(x_)").unwrap();
+    let expr = Atom::parse("x*y*w*z*f(x,y,x*y,z)").unwrap();
+
+    let pat_expr = Atom::parse("z*x_*y___*g___(z___,x_,w___)").unwrap();
 
     let pattern = pat_expr.as_view().into_pattern();
-    let restrictions = Condition::default();
+    let conditions = Condition::default();
     let settings = MatchSettings::default();
 
-    println!("> Matching pattern {} to {}:", pat_expr, expr);
+    println!("> Matching pattern {} to {}:", pat_expr, expr.as_view());
 
-    let mut it = PatternAtomTreeIterator::new(&pattern, expr.as_view(), &restrictions, &settings);
+    let mut it = pattern.pattern_match(expr.as_view(), &conditions, &settings);
     while let Some((location, used_flags, _atom, match_stack)) = it.next() {
-        println!("\tMatch at location {:?} - {:?}:", location, used_flags);
+        println!("\t Match at location {:?} - {:?}:", location, used_flags);
         for (id, v) in match_stack {
             print!("\t\t{} = ", State::get_name(*id));
             match v {
                 Match::Single(s) => {
                     print!("{}", s)
                 }
                 Match::Multiple(slice_type, mm) => {
```

### Comparing `symbolica-0.3.0/pyproject.toml` & `symbolica-0.4.0/pyproject.toml`

 * *Files 9% similar despite different names*

```diff
@@ -3,20 +3,21 @@
 requires = ["maturin>=1.0,<2.0"]
 
 [project]
 authors = [
   {email = "benruyl@gmail.com"},
   {name = "Ben Ruijl"},
 ]
+summary = "Symbolica is a blazing fast computer algebra system"
 description = "Symbolica is a blazing fast computer algebra system"
 keywords = ["math", "algebra", "polynomial", "expression", "manipulation"]
 license = {file = "License.md"}
 name = "symbolica"
 readme = "Readme.md"
-version = "0.3.0"
+version = "0.4.0"
 
 classifiers = [
   "Development Status :: 3 - Alpha",
   "Programming Language :: Rust",
   "Topic :: Scientific/Engineering :: Mathematics",
 ]
```

### Comparing `symbolica-0.3.0/src/api/mathematica.rs` & `symbolica-0.4.0/src/api/mathematica.rs`

 * *Files 15% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 use wolfram_library_link::{self as wll};
 
 use std::borrow::BorrowMut;
 use std::sync::{Arc, RwLock};
 
 use smartstring::{LazyCompact, SmartString};
 
-use crate::domains::finite_field::{FiniteField, FiniteFieldCore};
-use crate::domains::integer::IntegerRing;
+use crate::domains::finite_field::{FiniteFieldCore, Zp, Zp64};
+use crate::domains::integer::{IntegerRing, Z};
 use crate::domains::rational::RationalField;
 use crate::parser::Token;
 use crate::poly::Variable;
 use crate::{
     domains::rational_polynomial::RationalPolynomial,
     printer::{PrintOptions, RationalPolynomialPrinter},
     state::{State, Workspace},
@@ -44,15 +44,15 @@
 
 #[wll::export(name = "SymbolicaSetVariables")]
 fn set_vars(vars: String) {
     let mut symbolica = STATE.write().unwrap();
 
     let mut var_map = vec![];
     for var in vars.split(',') {
-        let v = State::get_or_insert_var(var);
+        let v = State::get_symbol(var);
         var_map.push(v.into());
         symbolica.var_name_map.push(var.into());
     }
 
     symbolica.var_map = Arc::new(var_map);
 }
 
@@ -66,104 +66,99 @@
 
     macro_rules! to_rational {
         ($in_field: ty, $exp_size: ty) => {
             if prime == 0 {
                 let r: RationalPolynomial<IntegerRing, $exp_size> = Workspace::get_local()
                     .with(|workspace| {
                         token.to_rational_polynomial(
-                            &workspace,
                             &<$in_field>::new(),
-                            &IntegerRing::new(),
+                            &Z,
                             &symbolica.var_map,
                             &symbolica.var_name_map,
                         )
                     })
                     .unwrap();
 
                 format!(
                     "{}",
                     RationalPolynomialPrinter {
                         poly: &r,
                         opts: PrintOptions {
                             terms_on_new_line: false,
                             color_top_level_sum: false,
-                            color_builtin_functions: false,
+                            color_builtin_symbols: false,
                             print_finite_field: false,
                             explicit_rational_polynomial,
                             symmetric_representation_for_finite_field: false,
                             number_thousands_separator: None,
                             multiplication_operator: '*',
                             square_brackets_for_function: false,
                             num_exp_as_superscript: false,
                             latex: false,
                         },
                         add_parentheses: false
                     }
                 )
             } else {
                 if prime >= 0 && prime <= u32::MAX as i64 {
-                    let field = FiniteField::<u32>::new(prime as u32);
-                    let rf: RationalPolynomial<FiniteField<u32>, $exp_size> =
-                        Workspace::get_local()
-                            .with(|workspace| {
-                                token.to_rational_polynomial(
-                                    &workspace,
-                                    &field,
-                                    &field,
-                                    &symbolica.var_map,
-                                    &symbolica.var_name_map,
-                                )
-                            })
-                            .unwrap();
+                    let field = Zp::new(prime as u32);
+                    let rf: RationalPolynomial<Zp, $exp_size> = Workspace::get_local()
+                        .with(|workspace| {
+                            token.to_rational_polynomial(
+                                &field,
+                                &field,
+                                &symbolica.var_map,
+                                &symbolica.var_name_map,
+                            )
+                        })
+                        .unwrap();
 
                     symbolica.buffer.clear();
                     format!(
                         "{}",
                         RationalPolynomialPrinter {
                             poly: &rf,
                             opts: PrintOptions {
                                 terms_on_new_line: false,
                                 color_top_level_sum: false,
-                                color_builtin_functions: false,
+                                color_builtin_symbols: false,
                                 print_finite_field: false,
                                 explicit_rational_polynomial,
                                 symmetric_representation_for_finite_field: false,
                                 number_thousands_separator: None,
                                 multiplication_operator: '*',
                                 square_brackets_for_function: false,
                                 num_exp_as_superscript: false,
                                 latex: false,
                             },
                             add_parentheses: false
                         }
                     )
                 } else {
-                    let field = FiniteField::<u64>::new(prime as u64);
-                    let rf: RationalPolynomial<FiniteField<u64>, $exp_size> =
-                        Workspace::get_local()
-                            .with(|workspace| {
-                                token.to_rational_polynomial(
-                                    &workspace,
-                                    &field,
-                                    &field,
-                                    &symbolica.var_map,
-                                    &symbolica.var_name_map,
-                                )
-                            })
-                            .unwrap();
+                    let field = Zp64::new(prime as u64);
+                    let rf: RationalPolynomial<Zp64, $exp_size> = Workspace::get_local()
+                        .with(|workspace| {
+                            token.to_rational_polynomial(
+                                &field,
+                                &field,
+                                &symbolica.var_map,
+                                &symbolica.var_name_map,
+                            )
+                        })
+                        .unwrap();
 
                     symbolica.buffer.clear();
                     format!(
                         "{}",
                         RationalPolynomialPrinter {
                             poly: &rf,
                             opts: PrintOptions {
                                 terms_on_new_line: false,
                                 color_top_level_sum: false,
-                                color_builtin_functions: false,
+                                color_builtin_symbols: false,
                                 print_finite_field: false,
                                 explicit_rational_polynomial,
                                 symmetric_representation_for_finite_field: false,
                                 number_thousands_separator: None,
                                 multiplication_operator: '*',
                                 square_brackets_for_function: false,
                                 num_exp_as_superscript: false,
```

### Comparing `symbolica-0.3.0/src/api/python.rs` & `symbolica-0.4.0/src/api/python.rs`

 * *Files 2% similar despite different names*

```diff
@@ -16,19 +16,20 @@
 };
 use rug::Complete;
 use self_cell::self_cell;
 use smallvec::SmallVec;
 use smartstring::{LazyCompact, SmartString};
 
 use crate::{
+    atom::{Atom, AtomView, ListIterator, Symbol},
     domains::{
-        finite_field::{FiniteField, FiniteFieldCore, ToFiniteField},
+        finite_field::{ToFiniteField, Zp},
         float::Complex,
-        integer::{Integer, IntegerRing},
-        rational::RationalField,
+        integer::{Integer, IntegerRing, Z},
+        rational::{Rational, RationalField, Q},
         rational_polynomial::{
             FromNumeratorAndDenominator, RationalPolynomial, RationalPolynomialField,
         },
         Ring,
     },
     evaluate::EvaluationFn,
     id::{
@@ -46,15 +47,14 @@
         groebner::GroebnerBasis,
         polynomial::MultivariatePolynomial,
         GrevLexOrder, LexOrder, Variable, INLINED_EXPONENTS,
     },
     printer::{
         AtomPrinter, MatrixPrinter, PolynomialPrinter, PrintOptions, RationalPolynomialPrinter,
     },
-    representations::{Atom, AtomView, FunctionBuilder, ListIterator, Symbol},
     state::{FunctionAttribute, RecycledAtom, State, Workspace},
     streaming::TermStreamer,
     tensors::matrix::Matrix,
     transformer::{StatsOptions, Transformer, TransformerError},
     LicenseManager,
 };
 
@@ -81,14 +81,16 @@
     m.add_function(wrap_pyfunction!(is_licensed, m)?)?;
     m.add_function(wrap_pyfunction!(set_license_key, m)?)?;
     m.add_function(wrap_pyfunction!(request_hobbyist_license, m)?)?;
     m.add_function(wrap_pyfunction!(request_trial_license, m)?)?;
     m.add_function(wrap_pyfunction!(request_sublicense, m)?)?;
     m.add_function(wrap_pyfunction!(get_offline_license_key, m)?)?;
 
+    m.add("__version__", env!("CARGO_PKG_VERSION"))?;
+
     Ok(())
 }
 
 /// Get the current Symbolica version.
 #[pyfunction]
 fn get_version() -> String {
     LicenseManager::get_version().to_string()
@@ -258,17 +260,21 @@
         if let Pattern::Transformer(b) = $self.expr.borrow() {
             let mut t = b.clone();
             t.1.push($t);
             Ok(PythonPattern {
                 expr: Arc::new(Pattern::Transformer(t)),
             })
         } else {
-            return Err(exceptions::PyValueError::new_err(
-                "Pattern must be a transformer",
-            ));
+            // pattern is not a transformer yet (but may have subtransformers)
+            Ok(PythonPattern {
+                expr: Arc::new(Pattern::Transformer(Box::new((
+                    Some($self.expr.as_ref().clone()),
+                    vec![$t],
+                )))),
+            })
         }
     };
 }
 
 #[pymethods]
 impl PythonPattern {
     /// Create a new transformer for a term provided by `Expression.map`.
@@ -520,14 +526,48 @@
                 Err(e) => Err(e),
             }
         }));
 
         return append_transformer!(self, transformer);
     }
 
+    /// Create a transformer that applies a transformer chain to every argument of the `arg()` function.
+    /// If the input is not `arg()`, the transformer is applied to the input.
+    ///
+    /// Examples
+    /// --------
+    /// >>> from symbolica import Expression
+    /// >>> x = Expression.var('x')
+    /// >>> f = Expression.fun('f')
+    /// >>> e = (1+x).transform().split().for_each(Transformer().map(f)).execute()
+    #[pyo3(signature = (*transformers))]
+    pub fn for_each(&self, transformers: &PyTuple) -> PyResult<PythonPattern> {
+        let mut rep_chain = vec![];
+        // fuse all sub-transformers into one chain
+        for r in transformers {
+            let p = r.extract::<PythonPattern>()?;
+
+            let Pattern::Transformer(t) = p.expr.borrow() else {
+                return Err(exceptions::PyValueError::new_err(
+                    "Argument must be a transformer",
+                ));
+            };
+
+            if t.0.is_some() {
+                return Err(exceptions::PyValueError::new_err(
+                    "Transformers in a for_each must be unbound. Use Transformer() to create it.",
+                ));
+            }
+
+            rep_chain.extend_from_slice(&t.1);
+        }
+
+        return append_transformer!(self, Transformer::ForEach(rep_chain));
+    }
+
     /// Create a transformer that checks for a Python interrupt,
     /// such as ctrl-c and aborts the current transformer.
     ///
     /// Examples
     /// --------
     /// >>> from symbolica import *
     /// >>> x_ = Expression.var('x_')
@@ -701,102 +741,113 @@
         );
     }
 
     /// Create a transformer that replaces all patterns matching the left-hand side `self` by the right-hand side `rhs`.
     /// Restrictions on pattern can be supplied through `cond`. The settings `non_greedy_wildcards` can be used to specify
     /// wildcards that try to match as little as possible.
     ///
+    /// The `level_range` specifies the `[min,max]` level at which the pattern is allowed to match.
+    /// The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree,
+    /// depending on `level_is_tree_depth`.
+    ///
     /// Examples
     /// --------
     ///
     /// >>> x, w1_, w2_ = Expression.vars('x','w1_','w2_')
     /// >>> f = Expression.fun('f')
     /// >>> e = f(3,x)
     /// >>> r = e.transform().replace_all(f(w1_,w2_), f(w1_ - 1, w2_**2), (w1_ >= 1) & w2_.is_var())
     /// >>> print(r)
     pub fn replace_all(
         &self,
         lhs: ConvertibleToPattern,
         rhs: ConvertibleToPattern,
         cond: Option<PythonPatternRestriction>,
         non_greedy_wildcards: Option<Vec<PythonExpression>>,
+        level_range: Option<(usize, Option<usize>)>,
+        level_is_tree_depth: Option<bool>,
     ) -> PyResult<PythonPattern> {
-        let settings = if let Some(ngw) = non_greedy_wildcards {
-            Some(MatchSettings {
-                non_greedy_wildcards: ngw
-                    .iter()
-                    .map(|x| match x.expr.as_view() {
-                        AtomView::Var(v) => {
-                            let name = v.get_symbol();
-                            if v.get_wildcard_level() == 0 {
-                                return Err(exceptions::PyTypeError::new_err(
-                                    "Only wildcards can be restricted.",
-                                ));
-                            }
-                            Ok(name)
+        let mut settings = MatchSettings::default();
+
+        if let Some(ngw) = non_greedy_wildcards {
+            settings.non_greedy_wildcards = ngw
+                .iter()
+                .map(|x| match x.expr.as_view() {
+                    AtomView::Var(v) => {
+                        let name = v.get_symbol();
+                        if v.get_wildcard_level() == 0 {
+                            return Err(exceptions::PyTypeError::new_err(
+                                "Only wildcards can be restricted.",
+                            ));
                         }
-                        _ => Err(exceptions::PyTypeError::new_err(
-                            "Only wildcards can be restricted.",
-                        )),
-                    })
-                    .collect::<Result<_, _>>()?,
-            })
-        } else {
-            None
-        };
+                        Ok(name)
+                    }
+                    _ => Err(exceptions::PyTypeError::new_err(
+                        "Only wildcards can be restricted.",
+                    )),
+                })
+                .collect::<Result<_, _>>()?;
+        }
+        if let Some(level_range) = level_range {
+            settings.level_range = level_range;
+        }
+        if let Some(level_is_tree_depth) = level_is_tree_depth {
+            settings.level_is_tree_depth = level_is_tree_depth;
+        }
 
         return append_transformer!(
             self,
             Transformer::ReplaceAll(
                 (*lhs.to_pattern()?.expr).clone(),
                 (*rhs.to_pattern()?.expr).clone(),
-                cond.map(|r| r.condition.as_ref().clone()),
+                cond.map(|r| r.condition.as_ref().clone())
+                    .unwrap_or_default(),
                 settings,
             )
         );
     }
 
     /// Create a transformer that prints the expression.
     ///
     /// Examples
     /// --------
     /// >>> Expression.parse('f(10)').transform().print(terms_on_new_line = True).execute()
     #[pyo3(signature =
         (terms_on_new_line = false,
             color_top_level_sum = true,
-            color_builtin_functions = true,
+            color_builtin_symbols = true,
             print_finite_field = true,
             symmetric_representation_for_finite_field = false,
             explicit_rational_polynomial = false,
             number_thousands_separator = None,
             multiplication_operator = '*',
             square_brackets_for_function = false,
             num_exp_as_superscript = true,
             latex = false)
         )]
     pub fn print(
         &self,
         terms_on_new_line: bool,
         color_top_level_sum: bool,
-        color_builtin_functions: bool,
+        color_builtin_symbols: bool,
         print_finite_field: bool,
         symmetric_representation_for_finite_field: bool,
         explicit_rational_polynomial: bool,
         number_thousands_separator: Option<char>,
         multiplication_operator: char,
         square_brackets_for_function: bool,
         num_exp_as_superscript: bool,
         latex: bool,
     ) -> PyResult<PythonPattern> {
         return append_transformer!(
             self,
             Transformer::Print(PrintOptions {
                 terms_on_new_line,
                 color_top_level_sum,
-                color_builtin_functions,
+                color_builtin_symbols,
                 print_finite_field,
                 symmetric_representation_for_finite_field,
                 explicit_rational_polynomial,
                 number_thousands_separator,
                 multiplication_operator,
                 square_brackets_for_function,
                 num_exp_as_superscript,
@@ -1039,15 +1090,15 @@
 
 impl<'a> FromPyObject<'a> for Symbol {
     fn extract(ob: &'a pyo3::PyAny) -> PyResult<Self> {
         if let Ok(a) = ob.extract::<PythonExpression>() {
             match a.expr.as_view() {
                 AtomView::Var(v) => Ok(v.get_symbol()),
                 e => Err(exceptions::PyValueError::new_err(format!(
-                    "Expected variable instead of {:?}",
+                    "Expected variable instead of {}",
                     e
                 ))),
             }
         } else if let Ok(a) = ob.extract::<PythonFunction>() {
             Ok(a.id)
         } else {
             Err(exceptions::PyValueError::new_err("Not a valid variable"))
@@ -1208,15 +1259,15 @@
     /// >>> var_x = Expression.var('x')
     /// >>> print(var_x)
     /// x
     ///
     #[classmethod]
     pub fn var(_cls: &PyType, name: &str) -> PyResult<PythonExpression> {
         // TODO: check if the name meets the requirements
-        let id = State::get_or_insert_var(name);
+        let id = State::get_symbol(name);
         let var = Atom::new_var(id);
 
         Ok(PythonExpression {
             expr: Arc::new(var),
         })
     }
 
@@ -1225,15 +1276,15 @@
     #[classmethod]
     pub fn vars(_cls: &PyType, args: &PyTuple) -> PyResult<Vec<PythonExpression>> {
         let mut result = Vec::with_capacity(args.len());
 
         for a in args {
             // TODO: check if the name meets the requirements
             let name = a.extract::<&str>()?;
-            let id = State::get_or_insert_var(name);
+            let id = State::get_symbol(name);
             let var = Atom::new_var(id);
 
             result.push(PythonExpression {
                 expr: Arc::new(var),
             });
         }
 
@@ -1280,30 +1331,57 @@
             let name = a.extract::<&str>()?;
             result.push(PythonFunction::__new__(name, None, None, None)?);
         }
 
         Ok(result)
     }
 
-    /// Create a new Symbolica number.
+    /// Create a new Symbolica number from an int or a float.
+    /// A floating point number is converted to its rational number equivalent,
+    /// but it can also be truncated by specifying the maximal denominator value.
     ///
     /// Examples
     /// --------
     /// >>> e = Expression.num(1) / 2
     /// >>> print(e)
     /// 1/2
+    ///
+    /// >>> print(Expression.num(0.33))
+    /// >>> print(Expression.num(0.33, 5))
+    /// 5944751508129055/18014398509481984
+    /// 1/3
     #[classmethod]
-    pub fn num(_cls: &PyType, num: &PyLong) -> PyResult<PythonExpression> {
-        if let Ok(num) = num.extract::<i64>() {
+    pub fn num(
+        _cls: &PyType,
+        py: Python,
+        num: PyObject,
+        max_denom: Option<usize>,
+    ) -> PyResult<PythonExpression> {
+        if let Ok(num) = num.extract::<i64>(py) {
             Ok(PythonExpression {
                 expr: Arc::new(Atom::new_num(num)),
             })
-        } else {
+        } else if let Ok(num) = num.extract::<&PyLong>(py) {
             let a = format!("{}", num);
             PythonExpression::parse(_cls, &a)
+        } else if let Ok(f) = num.extract::<f64>(py) {
+            if !f.is_finite() {
+                return Err(exceptions::PyValueError::new_err("Number must be finite"));
+            }
+
+            let mut r: Rational = f.into();
+            if let Some(max_denom) = max_denom {
+                r = r.truncate_denominator(&(max_denom as u64).into())
+            }
+
+            Ok(PythonExpression {
+                expr: Arc::new(Atom::new_num(r)),
+            })
+        } else {
+            Err(exceptions::PyValueError::new_err("Not a valid number"))
         }
     }
 
     /// Euler's number `e`.
     #[classattr]
     #[pyo3(name = "E")]
     pub fn e() -> PythonExpression {
@@ -1384,29 +1462,29 @@
     /// Examples
     /// --------
     /// >>> a = Expression.parse('128378127123 z^(2/3)*w^2/x/y + y^4 + z^34 + x^(x+2)+3/5+f(x,x^2)')
     /// >>> print(a.pretty_str(number_thousands_separator='_', multiplication_operator=' '))
     #[pyo3(signature =
     (terms_on_new_line = false,
         color_top_level_sum = true,
-        color_builtin_functions = true,
+        color_builtin_symbols = true,
         print_finite_field = true,
         symmetric_representation_for_finite_field = false,
         explicit_rational_polynomial = false,
         number_thousands_separator = None,
         multiplication_operator = '*',
         square_brackets_for_function = false,
         num_exp_as_superscript = true,
         latex = false)
     )]
     pub fn pretty_str(
         &self,
         terms_on_new_line: bool,
         color_top_level_sum: bool,
-        color_builtin_functions: bool,
+        color_builtin_symbols: bool,
         print_finite_field: bool,
         symmetric_representation_for_finite_field: bool,
         explicit_rational_polynomial: bool,
         number_thousands_separator: Option<char>,
         multiplication_operator: char,
         square_brackets_for_function: bool,
         num_exp_as_superscript: bool,
@@ -1415,15 +1493,15 @@
         Ok(format!(
             "{}",
             AtomPrinter::new_with_options(
                 self.expr.as_view(),
                 PrintOptions {
                     terms_on_new_line,
                     color_top_level_sum,
-                    color_builtin_functions,
+                    color_builtin_symbols,
                     print_finite_field,
                     symmetric_representation_for_finite_field,
                     explicit_rational_polynomial,
                     number_thousands_separator,
                     multiplication_operator,
                     square_brackets_for_function,
                     num_exp_as_superscript,
@@ -1473,20 +1551,16 @@
         self.expr.as_view().into()
     }
 
     /// Get the name of a variable or function if the current atom
     /// is a variable or function.
     pub fn get_name(&self) -> PyResult<Option<String>> {
         match self.expr.as_ref() {
-            Atom::Var(v) => Ok(Some(
-                State::get_name(v.to_var_view().get_symbol()).to_string(),
-            )),
-            Atom::Fun(f) => Ok(Some(
-                State::get_name(f.to_fun_view().get_symbol()).to_string(),
-            )),
+            Atom::Var(v) => Ok(Some(State::get_name(v.get_symbol()).to_string())),
+            Atom::Fun(f) => Ok(Some(State::get_name(f.get_symbol()).to_string())),
             _ => Ok(None),
         }
     }
 
     /// Add this expression to `other`, returning the result.
     pub fn __add__(&self, rhs: ConvertibleToExpression) -> PyResult<PythonExpression> {
         let rhs = rhs.to_expression();
@@ -1609,14 +1683,15 @@
 
     /// Get the `idx`th component of the expression.
     fn __getitem__(&self, idx: isize) -> PyResult<PythonExpression> {
         let slice = match self.expr.as_view() {
             AtomView::Add(a) => a.to_slice(),
             AtomView::Mul(m) => m.to_slice(),
             AtomView::Fun(f) => f.to_slice(),
+            AtomView::Pow(p) => p.to_slice(),
             _ => Err(PyIndexError::new_err("Cannot access child of leaf node"))?,
         };
 
         if idx.unsigned_abs() < slice.len() {
             Ok(PythonExpression {
                 expr: Arc::new(if idx < 0 {
                     slice.get(slice.len() - idx.abs() as usize).to_owned()
@@ -2090,18 +2165,18 @@
             ),
         })
     }
 
     /// Create an iterator over all atoms in the expression.
     fn __iter__(&self) -> PyResult<PythonAtomIterator> {
         match self.expr.as_view() {
-            AtomView::Add(_) | AtomView::Mul(_) | AtomView::Fun(_) => {}
+            AtomView::Add(_) | AtomView::Mul(_) | AtomView::Fun(_) | AtomView::Pow(_) => {}
             x => {
                 return Err(exceptions::PyValueError::new_err(format!(
-                    "Non-iterable type: {:?}",
+                    "Non-iterable type: {}",
                     x
                 )));
             }
         };
 
         Ok(PythonAtomIterator::from_expr(self.clone()))
     }
@@ -2168,15 +2243,15 @@
     pub fn set_coefficient_ring(&self, vars: Vec<PythonExpression>) -> PyResult<PythonExpression> {
         let mut var_map = vec![];
         for v in vars {
             match v.expr.as_view() {
                 AtomView::Var(v) => var_map.push(v.get_symbol().into()),
                 e => {
                     Err(exceptions::PyValueError::new_err(format!(
-                        "Expected variable instead of {:?}",
+                        "Expected variable instead of {}",
                         e
                     )))?;
                 }
             }
         }
 
         let b = self.expr.as_view().set_coefficient_ring(&Arc::new(var_map));
@@ -2274,14 +2349,35 @@
                 None
             },
         );
 
         Ok(PythonExpression { expr: Arc::new(b) })
     }
 
+    /// Collect terms involving the literal occurrence of `x`.
+    ///
+    /// Examples
+    /// --------
+    ///
+    /// from symbolica import Expression
+    /// >>>
+    /// >>> x, y = Expression.vars('x', 'y')
+    /// >>> e = 5*x + x * y + x**2 + y*x**2
+    /// >>> print(e.coefficient(x**2))
+    ///
+    /// yields
+    ///
+    /// ```
+    /// y + 1
+    /// ```
+    pub fn coefficient(&self, x: ConvertibleToExpression) -> PythonExpression {
+        let r = self.expr.coefficient(x.to_expression().expr.as_view());
+        PythonExpression { expr: Arc::new(r) }
+    }
+
     /// Collect terms involving the same power of `x`, where `x` is a variable or function name.
     /// Return the list of key-coefficient pairs and the remainder that matched no key.
     ///
     /// Examples
     /// --------
     ///
     /// from symbolica import Expression
@@ -2391,65 +2487,104 @@
         let b = self
             .expr
             .taylor_series(id, expansion_point.to_expression().expr.as_view(), depth);
 
         Ok(PythonExpression { expr: Arc::new(b) })
     }
 
+    /// Compute the partial fraction decomposition in `x`.
+    ///
+    /// Examples
+    /// --------
+    ///
+    /// >>> from symbolica import Expression
+    /// >>> x = Expression.var('x')
+    /// >>> p = Expression.parse('1/((x+y)*(x^2+x*y+1)(x+1))')
+    /// >>> print(p.apart(x))
+    pub fn apart(&self, x: PythonExpression) -> PyResult<PythonExpression> {
+        let poly = self.expr.to_rational_polynomial::<_, _, u32>(&Q, &Z, None);
+        let x = poly
+            .get_variables()
+            .iter()
+            .position(|v| match (v, x.expr.as_view()) {
+                (Variable::Symbol(y), AtomView::Var(vv)) => *y == vv.get_symbol(),
+                (Variable::Function(_, f) | Variable::Other(f), a) => f.as_view() == a,
+                _ => false,
+            })
+            .ok_or(exceptions::PyValueError::new_err(format!(
+                "Variable {} not found in polynomial",
+                x.__str__()?
+            )))?;
+
+        let fs = poly.apart(x);
+
+        let mut rn = Atom::new();
+        Workspace::get_local().with(|ws| {
+            let mut res = ws.new_atom();
+            let a = res.to_add();
+            for f in fs {
+                a.extend(f.to_expression().as_view());
+            }
+
+            res.as_view().normalize(ws, &mut rn);
+        });
+
+        Ok(PythonExpression { expr: Arc::new(rn) })
+    }
+
+    /// Write the expression over a common denominator.
+    ///
+    /// Examples
+    /// --------
+    ///
+    /// >>> from symbolica import Expression
+    /// >>> p = Expression.parse('v1^2/2+v1^3/v4*v2+v3/(1+v4)')
+    /// >>> print(p.together())
+    pub fn together(&self) -> PyResult<PythonExpression> {
+        let poly = self.expr.to_rational_polynomial::<_, _, u32>(&Q, &Z, None);
+        Ok(PythonExpression {
+            expr: Arc::new(poly.to_expression()),
+        })
+    }
+
     /// Convert the expression to a polynomial, optionally, with the variables and the ordering specified in `vars`.
+    /// All non-polynomial elements will be converted to new independent variables.
     pub fn to_polynomial(&self, vars: Option<Vec<PythonExpression>>) -> PyResult<PythonPolynomial> {
         let mut var_map = vec![];
         if let Some(vm) = vars {
             for v in vm {
                 match v.expr.as_view() {
                     AtomView::Var(v) => var_map.push(v.get_symbol().into()),
                     e => {
                         Err(exceptions::PyValueError::new_err(format!(
-                            "Expected variable instead of {:?}",
+                            "Expected variable instead of {}",
                             e
                         )))?;
                     }
                 }
             }
         }
 
         let var_map = if var_map.is_empty() {
             None
         } else {
             Some(Arc::new(var_map))
         };
 
-        self.expr
-            .as_view()
-            .to_polynomial(&RationalField::new(), var_map.as_ref())
-            .map(|x| PythonPolynomial { poly: Arc::new(x) })
-            .map_err(|e| {
-                exceptions::PyValueError::new_err(format!(
-                    "Could not convert to polynomial: {:?}",
-                    e
-                ))
-            })
-    }
-
-    /// Convert the expression to a polynomial, converting all non-polynomial elements to
-    /// new independent variables.
-    pub fn to_polynomial_with_conversion(&self) -> PythonPolynomial {
-        PythonPolynomial {
-            poly: Arc::new(
-                self.expr
-                    .as_view()
-                    .to_polynomial_with_conversion(&RationalField::new()),
-            ),
-        }
+        Ok(PythonPolynomial {
+            poly: Arc::new(self.expr.to_polynomial(&Q, var_map)),
+        })
     }
 
-    /// Convert the expression to a rational polynomial, optionally, with the variables and the ordering specified in `vars`.
+    /// Convert the expression to a rational polynomial, optionally, with the variable ordering specified in `vars`.
     /// The latter is useful if it is known in advance that more variables may be added in the future to the
     /// rational polynomial through composition with other rational polynomials.
     ///
+    /// All non-rational polynomial parts will automatically be converted to new independent variables.
+    ///
     /// Examples
     /// --------
     /// >>> a = Expression.parse('(1 + 3*x1 + 5*x2 + 7*x3 + 9*x4 + 11*x5 + 13*x6 + 15*x7)^2 - 1').to_rational_polynomial()
     /// >>> print(a)
     pub fn to_rational_polynomial(
         &self,
         vars: Option<Vec<PythonExpression>>,
@@ -2457,87 +2592,62 @@
         let mut var_map = vec![];
         if let Some(vm) = vars {
             for v in vm {
                 match v.expr.as_view() {
                     AtomView::Var(v) => var_map.push(v.get_symbol().into()),
                     e => {
                         Err(exceptions::PyValueError::new_err(format!(
-                            "Expected variable instead of {:?}",
+                            "Expected variable instead of {}",
                             e
                         )))?;
                     }
                 }
             }
         }
 
         let var_map = if var_map.is_empty() {
             None
         } else {
             Some(Arc::new(var_map))
         };
 
-        self.expr
-            .as_view()
-            .to_rational_polynomial(&RationalField::new(), &IntegerRing::new(), var_map.as_ref())
-            .map(|x| PythonRationalPolynomial { poly: Arc::new(x) })
-            .map_err(|e| {
-                exceptions::PyValueError::new_err(format!(
-                    "Could not convert to polynomial: {:?}",
-                    e
-                ))
-            })
+        Ok(PythonRationalPolynomial {
+            poly: Arc::new(self.expr.to_rational_polynomial(&Q, &Z, var_map)),
+        })
     }
 
     /// Similar to [PythonExpression::to_rational_polynomial()], but the power of each variable limited to 255.
     pub fn to_rational_polynomial_small_exponent(
         &self,
         vars: Option<Vec<PythonExpression>>,
     ) -> PyResult<PythonRationalPolynomialSmallExponent> {
         let mut var_map = vec![];
         if let Some(vm) = vars {
             for v in vm {
                 match v.expr.as_view() {
                     AtomView::Var(v) => var_map.push(v.get_symbol().into()),
                     e => {
                         Err(exceptions::PyValueError::new_err(format!(
-                            "Expected variable instead of {:?}",
+                            "Expected variable instead of {}",
                             e
                         )))?;
                     }
                 }
             }
         }
 
         let var_map = if var_map.is_empty() {
             None
         } else {
             Some(Arc::new(var_map))
         };
 
-        self.expr
-            .as_view()
-            .to_rational_polynomial(&RationalField::new(), &IntegerRing::new(), var_map.as_ref())
-            .map(|x| PythonRationalPolynomialSmallExponent { poly: Arc::new(x) })
-            .map_err(|e| {
-                exceptions::PyValueError::new_err(format!(
-                    "Could not convert to polynomial: {:?}",
-                    e
-                ))
-            })
-    }
-
-    /// Convert the expression to a rational polynomial, converting all non-polynomial elements to
-    /// new independent variables.
-    pub fn to_rational_polynomial_with_conversion(&self) -> PyResult<PythonRationalPolynomial> {
-        let p = self
-            .expr
-            .as_view()
-            .to_rational_polynomial_with_conversion(&RationalField::new(), &IntegerRing::new());
-
-        Ok(PythonRationalPolynomial { poly: Arc::new(p) })
+        Ok(PythonRationalPolynomialSmallExponent {
+            poly: Arc::new(self.expr.to_rational_polynomial(&Q, &Z, var_map)),
+        })
     }
 
     /// Return an iterator over the pattern `self` matching to `lhs`.
     /// Restrictions on pattern can be supplied through `cond`.
     ///
     /// Examples
     /// --------
@@ -2549,19 +2659,25 @@
     /// >>>    for map in match:
     /// >>>        print(map[0],'=', map[1])
     #[pyo3(name = "r#match")]
     pub fn pattern_match(
         &self,
         lhs: ConvertibleToPattern,
         cond: Option<PythonPatternRestriction>,
+        level_range: Option<(usize, Option<usize>)>,
+        level_is_tree_depth: Option<bool>,
     ) -> PyResult<PythonMatchIterator> {
         let conditions = cond
             .map(|r| r.condition.clone())
             .unwrap_or(Arc::new(Condition::default()));
-        let settings = Arc::new(MatchSettings::default());
+        let settings = Arc::new(MatchSettings {
+            level_range: level_range.unwrap_or((0, None)),
+            level_is_tree_depth: level_is_tree_depth.unwrap_or(false),
+            ..MatchSettings::default()
+        });
         Ok(PythonMatchIterator::new(
             (
                 lhs.to_pattern()?.expr,
                 self.expr.clone(),
                 conditions,
                 settings,
             ),
@@ -2570,14 +2686,18 @@
             },
         ))
     }
 
     /// Return an iterator over the replacement of the pattern `self` on `lhs` by `rhs`.
     /// Restrictions on pattern can be supplied through `cond`.
     ///
+    /// The `level_range` specifies the `[min,max]` level at which the pattern is allowed to match.
+    /// The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree,
+    /// depending on `level_is_tree_depth`.
+    ///
     /// Examples
     /// --------
     ///
     /// >>> from symbolica import Expression
     /// >>> x_ = Expression.var('x_')
     /// >>> f = Expression.fun('f')
     /// >>> e = f(1)*f(2)*f(3)
@@ -2591,19 +2711,25 @@
     /// f(1)*f(2)*f(4)
     /// ```
     pub fn replace(
         &self,
         lhs: ConvertibleToPattern,
         rhs: ConvertibleToPattern,
         cond: Option<PythonPatternRestriction>,
+        level_range: Option<(usize, Option<usize>)>,
+        level_is_tree_depth: Option<bool>,
     ) -> PyResult<PythonReplaceIterator> {
         let conditions = cond
             .map(|r| r.condition.clone())
             .unwrap_or(Arc::new(Condition::default()));
-        let settings = Arc::new(MatchSettings::default());
+        let settings = Arc::new(MatchSettings {
+            level_range: level_range.unwrap_or((0, None)),
+            level_is_tree_depth: level_is_tree_depth.unwrap_or(false),
+            ..MatchSettings::default()
+        });
 
         Ok(PythonReplaceIterator::new(
             (
                 lhs.to_pattern()?.expr,
                 self.expr.clone(),
                 rhs.to_pattern()?.expr,
                 conditions,
@@ -2614,14 +2740,18 @@
             },
         ))
     }
 
     /// Replace all atoms matching the pattern `pattern` by the right-hand side `rhs`.
     /// Restrictions on pattern can be supplied through `cond`.
     ///
+    /// The `level_range` specifies the `[min,max]` level at which the pattern is allowed to match.
+    /// The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree,
+    /// depending on `level_is_tree_depth`.
+    ///
     /// The entire operation can be repeated until there are no more matches using `repeat=True`.
     ///
     /// Examples
     /// --------
     ///
     /// >>> x, w1_, w2_ = Expression.vars('x','w1_','w2_')
     /// >>> f = Expression.fun('f')
@@ -2630,52 +2760,58 @@
     /// >>> print(r)
     pub fn replace_all(
         &self,
         pattern: ConvertibleToPattern,
         rhs: ConvertibleToPattern,
         cond: Option<PythonPatternRestriction>,
         non_greedy_wildcards: Option<Vec<PythonExpression>>,
+        level_range: Option<(usize, Option<usize>)>,
+        level_is_tree_depth: Option<bool>,
         repeat: Option<bool>,
     ) -> PyResult<PythonExpression> {
         let pattern = &pattern.to_pattern()?.expr;
         let rhs = &rhs.to_pattern()?.expr;
 
-        let settings = if let Some(ngw) = non_greedy_wildcards {
-            Some(MatchSettings {
-                non_greedy_wildcards: ngw
-                    .iter()
-                    .map(|x| match x.expr.as_view() {
-                        AtomView::Var(v) => {
-                            let name = v.get_symbol();
-                            if v.get_wildcard_level() == 0 {
-                                return Err(exceptions::PyTypeError::new_err(
-                                    "Only wildcards can be restricted.",
-                                ));
-                            }
-                            Ok(name)
+        let mut settings = MatchSettings::default();
+
+        if let Some(ngw) = non_greedy_wildcards {
+            settings.non_greedy_wildcards = ngw
+                .iter()
+                .map(|x| match x.expr.as_view() {
+                    AtomView::Var(v) => {
+                        let name = v.get_symbol();
+                        if v.get_wildcard_level() == 0 {
+                            return Err(exceptions::PyTypeError::new_err(
+                                "Only wildcards can be restricted.",
+                            ));
                         }
-                        _ => Err(exceptions::PyTypeError::new_err(
-                            "Only wildcards can be restricted.",
-                        )),
-                    })
-                    .collect::<Result<_, _>>()?,
-            })
-        } else {
-            None
-        };
+                        Ok(name)
+                    }
+                    _ => Err(exceptions::PyTypeError::new_err(
+                        "Only wildcards can be restricted.",
+                    )),
+                })
+                .collect::<Result<_, _>>()?;
+        }
+        if let Some(level_range) = level_range {
+            settings.level_range = level_range;
+        }
+        if let Some(level_is_tree_depth) = level_is_tree_depth {
+            settings.level_is_tree_depth = level_is_tree_depth;
+        }
 
         let mut expr_ref = self.expr.as_view();
 
         let mut out = RecycledAtom::new();
         let mut out2 = RecycledAtom::new();
         while pattern.replace_all_into(
             expr_ref,
             rhs,
             cond.as_ref().map(|r| r.condition.as_ref()),
-            settings.as_ref(),
+            Some(&settings),
             &mut out,
         ) {
             if !repeat.unwrap_or(false) {
                 break;
             }
 
             std::mem::swap(&mut out, &mut out2);
@@ -2708,23 +2844,23 @@
 
         let mut vars = vec![];
         for v in variables {
             match v.expr.as_view() {
                 AtomView::Var(v) => vars.push(v.get_symbol().into()),
                 e => {
                     Err(exceptions::PyValueError::new_err(format!(
-                        "Expected variable instead of {:?}",
+                        "Expected variable instead of {}",
                         e
                     )))?;
                 }
             }
         }
 
         let res = AtomView::solve_linear_system::<u16>(&system_b, &vars).map_err(|e| {
-            exceptions::PyValueError::new_err(format!("Could not solve system: {:?}", e))
+            exceptions::PyValueError::new_err(format!("Could not solve system: {}", e))
         })?;
 
         Ok(res
             .into_iter()
             .map(|x| PythonExpression { expr: Arc::new(x) })
             .collect())
     }
@@ -2738,32 +2874,32 @@
     /// >>> x = Expression.var('x')
     /// >>> f = Expression.fun('f')
     /// >>> e = Expression.parse('cos(x)')*3 + f(x,2)
     /// >>> print(e.evaluate({x: 1}, {f: lambda args: args[0]+args[1]}))
     pub fn evaluate(
         &self,
         constants: HashMap<PythonExpression, f64>,
-        functions: HashMap<PythonExpression, PyObject>,
+        functions: HashMap<Variable, PyObject>,
     ) -> PyResult<f64> {
         let mut cache = HashMap::default();
 
         let constants = constants
             .iter()
             .map(|(k, v)| (k.expr.as_view(), *v))
             .collect();
 
         let functions = functions
             .into_iter()
             .map(|(k, v)| {
-                let id = if let AtomView::Var(v) = k.expr.as_view() {
-                    v.get_symbol()
+                let id = if let Variable::Symbol(v) = k {
+                    v
                 } else {
                     Err(exceptions::PyValueError::new_err(format!(
                         "Expected function name instead of {:?}",
-                        k.expr
+                        k
                     )))?
                 };
 
                 Ok((
                     id,
                     EvaluationFn::new(Box::new(move |args, _, _, _| {
                         Python::with_gil(|py| {
@@ -2792,32 +2928,32 @@
     /// >>> x, y = Expression.vars('x', 'y')
     /// >>> e = Expression.parse('sqrt(x)')*y
     /// >>> print(e.evaluate_complex({x: 1 + 2j, y: 4 + 3j}, {}))
     pub fn evaluate_complex<'py>(
         &self,
         py: Python<'py>,
         constants: HashMap<PythonExpression, Complex<f64>>,
-        functions: HashMap<PythonExpression, PyObject>,
+        functions: HashMap<Variable, PyObject>,
     ) -> PyResult<&'py PyComplex> {
         let mut cache = HashMap::default();
 
         let constants = constants
             .iter()
             .map(|(k, v)| (k.expr.as_view(), *v))
             .collect();
 
         let functions = functions
             .into_iter()
             .map(|(k, v)| {
-                let id = if let AtomView::Var(v) = k.expr.as_view() {
-                    v.get_symbol()
+                let id = if let Variable::Symbol(v) = k {
+                    v
                 } else {
                     Err(exceptions::PyValueError::new_err(format!(
                         "Expected function name instead of {:?}",
-                        k.expr
+                        k
                     )))?
                 };
 
                 Ok((
                     id,
                     EvaluationFn::new(Box::new(move |args: &[Complex<f64>], _, _, _| {
                         Python::with_gil(|py| {
@@ -2868,41 +3004,41 @@
     #[new]
     pub fn __new__(
         name: &str,
         is_symmetric: Option<bool>,
         is_antisymmetric: Option<bool>,
         is_linear: Option<bool>,
     ) -> PyResult<Self> {
-        let mut opts = match (is_symmetric, is_antisymmetric) {
-            (Some(true), Some(true)) => Err(exceptions::PyValueError::new_err(
+        if is_symmetric.is_none() && is_antisymmetric.is_none() && is_linear.is_none() {
+            return Ok(PythonFunction {
+                id: State::get_symbol(name),
+            });
+        }
+
+        if is_symmetric == Some(true) && is_antisymmetric == Some(true) {
+            Err(exceptions::PyValueError::new_err(
                 "Function cannot be both symmetric and antisymmetric",
-            ))?,
-            (Some(true), _) => Some(vec![FunctionAttribute::Symmetric]),
-            (_, Some(true)) => Some(vec![FunctionAttribute::Antisymmetric]),
-            (Some(false), _) | (_, Some(false)) => Some(vec![]),
-            (None, None) => None,
-        };
+            ))?;
+        }
 
-        match is_linear {
-            Some(true) => {
-                if let Some(opts) = &mut opts {
-                    opts.push(FunctionAttribute::Linear);
-                } else {
-                    opts = Some(vec![FunctionAttribute::Linear]);
-                }
-            }
-            Some(false) => {
-                if opts.is_none() {
-                    opts = Some(vec![]);
-                }
-            }
-            None => {}
+        let mut opts = vec![];
+
+        if let Some(true) = is_symmetric {
+            opts.push(FunctionAttribute::Symmetric);
         }
 
-        let id = State::get_or_insert_fn(name, opts)
+        if let Some(true) = is_antisymmetric {
+            opts.push(FunctionAttribute::Antisymmetric);
+        }
+
+        if let Some(true) = is_linear {
+            opts.push(FunctionAttribute::Linear);
+        }
+
+        let id = State::get_symbol_with_attributes(name, &opts)
             .map_err(|e| exceptions::PyTypeError::new_err(e.to_string()))?;
 
         Ok(PythonFunction { id })
     }
 
     /// The built-in function that converts a rational polynomial to a coefficient.
     #[classattr]
@@ -3171,35 +3307,31 @@
     #[classmethod]
     pub fn parse(_cls: &PyType, arg: &str, vars: Vec<&str>) -> PyResult<Self> {
         let mut var_map = vec![];
         let mut var_name_map: SmallVec<[SmartString<LazyCompact>; INLINED_EXPONENTS]> =
             SmallVec::new();
 
         for v in vars {
-            let id = State::get_or_insert_var(v);
+            let id = State::get_symbol(v);
             var_map.push(id.into());
             var_name_map.push(v.into());
         }
 
         let e = Token::parse(arg)
             .map_err(exceptions::PyValueError::new_err)?
-            .to_polynomial(&RationalField::new(), &Arc::new(var_map), &var_name_map)
+            .to_polynomial(&Q, &Arc::new(var_map), &var_name_map)
             .map_err(exceptions::PyValueError::new_err)?;
 
         Ok(Self { poly: Arc::new(e) })
     }
 
     /// Convert the polynomial to a polynomial with integer coefficients, if possible.
     pub fn to_integer_polynomial(&self) -> PyResult<PythonIntegerPolynomial> {
-        let mut poly_int = MultivariatePolynomial::new(
-            self.poly.nvars,
-            &IntegerRing::new(),
-            Some(self.poly.nterms()),
-            self.poly.var_map.clone(),
-        );
+        let mut poly_int =
+            MultivariatePolynomial::new(&Z, Some(self.poly.nterms()), self.poly.variables.clone());
 
         let mut new_exponent = SmallVec::<[u8; 5]>::new();
 
         for t in self.poly.into_iter() {
             if !t.coefficient.is_integer() {
                 Err(exceptions::PyValueError::new_err(format!(
                     "Coefficient {} is not an integer",
@@ -3224,15 +3356,15 @@
         Ok(PythonIntegerPolynomial {
             poly: Arc::new(poly_int),
         })
     }
 
     /// Convert the coefficients of the polynomial to a finite field with prime `prime`.
     pub fn to_finite_field(&self, prime: u32) -> PythonFiniteFieldPolynomial {
-        let f = FiniteField::<u32>::new(prime);
+        let f = Zp::new(prime);
         PythonFiniteFieldPolynomial {
             poly: Arc::new(self.poly.map_coeff(|c| c.to_finite_field(&f), f.clone())),
         }
     }
 
     /// Optimize the polynomial for evaluation using `iterations` number of iterations.
     /// The optimized output can be exported in a C++ format using `to_file`.
@@ -3315,14 +3447,43 @@
             gb.system
                 .into_iter()
                 .map(|p| Self { poly: Arc::new(p) })
                 .collect()
         }
     }
 
+    /// Integrate the polynomial in `x`.
+    ///
+    /// Examples
+    /// --------
+    ///
+    /// >>> from symbolica import Expression
+    /// >>> x = Expression.var('x')
+    /// >>> p = Expression.parse('x^2+2').to_polynomial()
+    /// >>> print(p.integrate(x))
+    pub fn integrate(&self, x: PythonExpression) -> PyResult<Self> {
+        let x = self
+            .poly
+            .get_vars_ref()
+            .iter()
+            .position(|v| match (v, x.expr.as_view()) {
+                (Variable::Symbol(y), AtomView::Var(vv)) => *y == vv.get_symbol(),
+                (Variable::Function(_, f) | Variable::Other(f), a) => f.as_view() == a,
+                _ => false,
+            })
+            .ok_or(exceptions::PyValueError::new_err(format!(
+                "Variable {} not found in polynomial",
+                x.__str__()?
+            )))?;
+
+        Ok(Self {
+            poly: Arc::new(self.poly.integrate(x)),
+        })
+    }
+
     /// Convert the polynomial to an expression.
     ///
     /// Examples
     /// --------
     ///
     /// >>> from symbolica import Expression
     /// >>> x = Expression.var('x')
@@ -3380,22 +3541,22 @@
     ///     If the input is not a valid Symbolica polynomial.
     #[classmethod]
     pub fn parse(_cls: &PyType, arg: &str, vars: Vec<&str>) -> PyResult<Self> {
         let mut var_map = vec![];
         let mut var_name_map = vec![];
 
         for v in vars {
-            let id = State::get_or_insert_var(v);
+            let id = State::get_symbol(v);
             var_map.push(id.into());
             var_name_map.push(v.into());
         }
 
         let e = Token::parse(arg)
             .map_err(exceptions::PyValueError::new_err)?
-            .to_polynomial(&IntegerRing::new(), &Arc::new(var_map), &var_name_map)
+            .to_polynomial(&Z, &Arc::new(var_map), &var_name_map)
             .map_err(exceptions::PyValueError::new_err)?;
 
         Ok(Self { poly: Arc::new(e) })
     }
 
     /// Convert the polynomial to an expression.
     ///
@@ -3413,15 +3574,15 @@
     }
 }
 
 /// A Symbolica polynomial over finite fields.
 #[pyclass(name = "FiniteFieldPolynomial")]
 #[derive(Clone)]
 pub struct PythonFiniteFieldPolynomial {
-    pub poly: Arc<MultivariatePolynomial<FiniteField<u32>, u16>>,
+    pub poly: Arc<MultivariatePolynomial<Zp, u16>>,
 }
 
 #[pymethods]
 impl PythonFiniteFieldPolynomial {
     /// Parse a polynomial with integer coefficients from a string.
     /// The input must be written in an expanded format and a list of all
     /// the variables must be provided.
@@ -3439,26 +3600,22 @@
     ///     If the input is not a valid Symbolica polynomial.
     #[classmethod]
     pub fn parse(_cls: &PyType, arg: &str, vars: Vec<&str>, prime: u32) -> PyResult<Self> {
         let mut var_map = vec![];
         let mut var_name_map = vec![];
 
         for v in vars {
-            let id = State::get_or_insert_var(v);
+            let id = State::get_symbol(v);
             var_map.push(id.into());
             var_name_map.push(v.into());
         }
 
         let e = Token::parse(arg)
             .map_err(exceptions::PyValueError::new_err)?
-            .to_polynomial(
-                &FiniteField::<u32>::new(prime),
-                &Arc::new(var_map),
-                &var_name_map,
-            )
+            .to_polynomial(&Zp::new(prime), &Arc::new(var_map), &var_name_map)
             .map_err(exceptions::PyValueError::new_err)?;
 
         Ok(Self { poly: Arc::new(e) })
     }
 
     /// Compute the Groebner basis of a polynomial system.
     ///
@@ -3492,14 +3649,43 @@
             let gb = GroebnerBasis::new(&ideal, print_stats);
             gb.system
                 .into_iter()
                 .map(|p| Self { poly: Arc::new(p) })
                 .collect()
         }
     }
+
+    /// Integrate the polynomial in `x`.
+    ///
+    /// Examples
+    /// --------
+    ///
+    /// >>> from symbolica import Expression
+    /// >>> x = Expression.var('x')
+    /// >>> p = Expression.parse('x^2+2').to_polynomial()
+    /// >>> print(p.integrate(x))
+    pub fn integrate(&self, x: PythonExpression) -> PyResult<Self> {
+        let x = self
+            .poly
+            .get_vars_ref()
+            .iter()
+            .position(|v| match (v, x.expr.as_view()) {
+                (Variable::Symbol(y), AtomView::Var(vv)) => *y == vv.get_symbol(),
+                (Variable::Function(_, f) | Variable::Other(f), a) => f.as_view() == a,
+                _ => false,
+            })
+            .ok_or(exceptions::PyValueError::new_err(format!(
+                "Variable {} not found in polynomial",
+                x.__str__()?
+            )))?;
+
+        Ok(Self {
+            poly: Arc::new(self.poly.integrate(x)),
+        })
+    }
 }
 
 macro_rules! generate_methods {
     ($type:ty, $exp_type:ty) => {
         #[pymethods]
         impl $type {
             /// Compare two polynomials.
@@ -3549,29 +3735,29 @@
             /// Examples
             /// --------
             /// >>> p = FiniteFieldPolynomial.parse("3*x^2+2*x+7*x^3", ['x'], 11)
             /// >>> print(p.pretty_str(symmetric_representation_for_finite_field=True))
             #[pyo3(signature =
                 (terms_on_new_line = false,
                     color_top_level_sum = true,
-                    color_builtin_functions = true,
+                    color_builtin_symbols = true,
                     print_finite_field = true,
                     symmetric_representation_for_finite_field = false,
                     explicit_rational_polynomial = false,
                     number_thousands_separator = None,
                     multiplication_operator = '*',
                     square_brackets_for_function = false,
                     num_exp_as_superscript = true,
                     latex = false)
                 )]
                 pub fn pretty_str(
                     &self,
                     terms_on_new_line: bool,
                     color_top_level_sum: bool,
-                    color_builtin_functions: bool,
+                    color_builtin_symbols: bool,
                     print_finite_field: bool,
                     symmetric_representation_for_finite_field: bool,
                     explicit_rational_polynomial: bool,
                     number_thousands_separator: Option<char>,
                     multiplication_operator: char,
                     square_brackets_for_function: bool,
                     num_exp_as_superscript: bool,
@@ -3580,15 +3766,15 @@
                     Ok(format!(
                         "{}",
                         PolynomialPrinter::new_with_options(
                             &self.poly,
                             PrintOptions {
                                 terms_on_new_line,
                                 color_top_level_sum,
-                                color_builtin_functions,
+                                color_builtin_symbols,
                                 print_finite_field,
                                 symmetric_representation_for_finite_field,
                                 explicit_rational_polynomial,
                                 number_thousands_separator,
                                 multiplication_operator,
                                 square_brackets_for_function,
                                 num_exp_as_superscript,
@@ -3625,37 +3811,21 @@
                 self.poly.nterms()
             }
 
             /// Get the list of variables in the internal ordering of the polynomial.
             pub fn get_var_list(&self) -> PyResult<Vec<PythonExpression>> {
                 let mut var_list = vec![];
 
-                let vars = self
-                    .poly
-                    .var_map
-                    .as_ref()
-                    .ok_or(exceptions::PyValueError::new_err(format!(
-                        "Variable map missing",
-                    )))?;
-
-                for x in vars.as_ref() {
+                for x in self.poly.get_vars_ref() {
                     match x {
                         Variable::Symbol(x) => {
                             var_list.push(PythonExpression {
                                 expr: Arc::new(Atom::new_var(*x)),
                             });
                         }
-                        Variable::Array(x, arg) => {
-                            let mut f = FunctionBuilder::new(*x);
-                            f = f.add_arg(Atom::new_num(Integer::from(*arg as u64)).as_view());
-
-                            var_list.push(PythonExpression {
-                                expr: Arc::new(f.finish()),
-                            });
-                        }
                         Variable::Temporary(_) => {
                             Err(exceptions::PyValueError::new_err(format!(
                                 "Temporary variable in polynomial",
                             )))?;
                         }
                         Variable::Function(_, a) | Variable::Other(a) => {
                             var_list.push(PythonExpression {
@@ -3666,57 +3836,57 @@
                 }
 
                 Ok(var_list)
             }
 
             /// Add two polynomials `self and `rhs`, returning the result.
             pub fn __add__(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_vars_ref() == rhs.poly.get_vars_ref() {
                     Self {
                         poly: Arc::new((*self.poly).clone() + (*rhs.poly).clone()),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(new_self + new_rhs),
                     }
                 }
             }
 
             /// Subtract polynomials `rhs` from `self`, returning the result.
             pub fn __sub__(&self, rhs: Self) -> Self {
                 self.__add__(rhs.__neg__())
             }
 
             /// Multiply two polynomials `self and `rhs`, returning the result.
             pub fn __mul__(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_vars_ref() == rhs.poly.get_vars_ref() {
                     Self {
                         poly: Arc::new(&*self.poly * &*rhs.poly),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(new_self * &new_rhs),
                     }
                 }
             }
 
             /// Divide the polynomial `self` by `rhs` if possible, returning the result.
             pub fn __truediv__(&self, rhs: Self) -> PyResult<Self> {
-                let (q, r) = if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                let (q, r) = if self.poly.get_vars_ref() == rhs.poly.get_vars_ref() {
                     self.poly.quot_rem(&rhs.poly, false)
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
 
                     new_self.quot_rem(&new_rhs, false)
                 };
 
                 if r.is_zero() {
                     Ok(Self { poly: Arc::new(q) })
                 } else {
@@ -3725,22 +3895,22 @@
                         r
                     )))
                 }
             }
 
             /// Divide `self` by `rhs`, returning the quotient and remainder.
             pub fn quot_rem(&self, rhs: Self) -> (Self, Self) {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_vars_ref() == rhs.poly.get_vars_ref() {
                     let (q, r) = self.poly.quot_rem(&rhs.poly, false);
 
                     (Self { poly: Arc::new(q) }, Self { poly: Arc::new(r) })
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
 
                     let (q, r) = new_self.quot_rem(&new_rhs, false);
 
                     (Self { poly: Arc::new(q) }, Self { poly: Arc::new(r) })
                 }
             }
 
@@ -3749,28 +3919,61 @@
                 Self {
                     poly: Arc::new((*self.poly).clone().neg()),
                 }
             }
 
             /// Compute the greatest common divisor (GCD) of two polynomials.
             pub fn gcd(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_vars_ref() == rhs.poly.get_vars_ref() {
                     Self {
                         poly: Arc::new(self.poly.gcd(&rhs.poly)),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(new_self.gcd(&new_rhs)),
                     }
                 }
             }
 
+            /// Compute the resultant of two polynomials with respect to the variable `var`.
+            pub fn resultant(&self, rhs: Self, var: PythonExpression) -> PyResult<Self> {
+                let x = self.poly.get_vars_ref().iter().position(|v| match (v, var.expr.as_view()) {
+                    (Variable::Symbol(y), AtomView::Var(vv)) => *y == vv.get_symbol(),
+                    (Variable::Function(_, f) | Variable::Other(f), a) => f.as_view() == a,
+                    _ => false,
+                }).ok_or(exceptions::PyValueError::new_err(format!(
+                    "Variable {} not found in polynomial",
+                    var.__str__()?
+                )))?;
+
+
+                if self.poly.get_vars_ref() == rhs.poly.get_vars_ref() {
+                    let self_uni = self.poly.to_univariate(x);
+                    let rhs_uni = rhs.poly.to_univariate(x);
+
+                    Ok(Self {
+                        poly: Arc::new(self_uni.resultant_prs(&rhs_uni)),
+                    })
+                } else {
+                    let mut new_self = (*self.poly).clone();
+                    let mut new_rhs = (*rhs.poly).clone();
+                    new_self.unify_variables(&mut new_rhs);
+
+                    let self_uni = new_self.to_univariate(x);
+                    let rhs_uni = new_rhs.to_univariate(x);
+
+                    Ok(Self {
+                        poly: Arc::new(self_uni.resultant_prs(&rhs_uni)),
+                    })
+                }
+            }
+
             /// Compute the square-free factorization of the polynomial.
             ///
             /// Examples
             /// --------
             ///
             /// >>> from symbolica import Expression
             /// >>> p = Expression.parse('3*(2*x^2+y)(x^3+y)^2(1+4*y)^2(1+x)').expand().to_polynomial()
@@ -3809,29 +4012,17 @@
             /// --------
             ///
             /// >>> from symbolica import Expression
             /// >>> x = Expression.var('x')
             /// >>> p = Expression.parse('x^2+2').to_polynomial()
             /// >>> print(p.derivative(x))
             pub fn derivative(&self, x: PythonExpression) -> PyResult<Self> {
-                let id = match x.expr.as_view() {
-                    AtomView::Var(x) => {
-                        x.get_symbol()
-                    }
-                    _ => {
-                        return Err(exceptions::PyValueError::new_err(
-                            "Derivative must be taken wrt a variable",
-                        ))
-                    }
-                };
-
-                let x = self.poly.get_var_map().as_ref().ok_or(
-                    exceptions::PyValueError::new_err("Variable map missing"),
-                )?.iter().position(|x| match x {
-                    Variable::Symbol(y) => *y == id,
+                let x = self.poly.get_vars_ref().iter().position(|v| match (v, x.expr.as_view()) {
+                    (Variable::Symbol(y), AtomView::Var(vv)) => *y == vv.get_symbol(),
+                    (Variable::Function(_, f) | Variable::Other(f), a) => f.as_view() == a,
                     _ => false,
                 }).ok_or(exceptions::PyValueError::new_err(format!(
                     "Variable {} not found in polynomial",
                     x.__str__()?
                 )))?;
 
                 Ok(Self { poly: Arc::new(self.poly.derivative(x))})
@@ -3855,34 +4046,22 @@
             /// --------
             ///
             /// >>> from symbolica import Expression
             /// >>> x = Expression.var('x')
             /// >>> p = Expression.parse('x*y+2*x+x^2').to_polynomial()
             /// >>> for n, pp in p.coefficient_list(x):
             /// >>>     print(n, pp)
-            pub fn coefficient_list(&self, x: PythonExpression) -> PyResult<Vec<(usize, Self)>> {
-                let id = match x.expr.as_view() {
-                    AtomView::Var(x) => {
-                        x.get_symbol()
-                    }
-                    _ => {
-                        return Err(exceptions::PyValueError::new_err(
-                            "Derivative must be taken wrt a variable",
-                        ))
-                    }
-                };
-
-                let x = self.poly.get_var_map().as_ref().ok_or(
-                    exceptions::PyValueError::new_err("Variable map missing"),
-                )?.iter().position(|x| match x {
-                    Variable::Symbol(y) => *y == id,
+            pub fn coefficient_list(&self, var: PythonExpression) -> PyResult<Vec<(usize, Self)>> {
+                let x = self.poly.get_vars_ref().iter().position(|v| match (v, var.expr.as_view()) {
+                    (Variable::Symbol(y), AtomView::Var(vv)) => *y == vv.get_symbol(),
+                    (Variable::Function(_, f) | Variable::Other(f), a) => f.as_view() == a,
                     _ => false,
                 }).ok_or(exceptions::PyValueError::new_err(format!(
                     "Variable {} not found in polynomial",
-                    x.__str__()?
+                    var.__str__()?
                 )))?;
 
                 Ok(self.poly.to_univariate_polynomial_list(x).into_iter()
                     .map(|(f, p)| (p as usize, Self { poly: Arc::new(f) })).collect())
             }
 
             /// Replace the variable `x` with a polynomial `v`.
@@ -3903,32 +4082,30 @@
                     _ => {
                         return Err(exceptions::PyValueError::new_err(
                             "Derivative must be taken wrt a variable",
                         ))
                     }
                 };
 
-                let x = self.poly.get_var_map().as_ref().ok_or(
-                    exceptions::PyValueError::new_err("Variable map missing"),
-                )?.iter().position(|x| match x {
+                let x = self.poly.get_vars_ref().iter().position(|x| match x {
                     Variable::Symbol(y) => *y == id,
                     _ => false,
                 }).ok_or(exceptions::PyValueError::new_err(format!(
                     "Variable {} not found in polynomial",
                     x.__str__()?
                 )))?;
 
-                if self.poly.get_var_map() == v.poly.get_var_map() {
+                if self.poly.get_vars_ref() == v.poly.get_vars_ref() {
                     Ok(Self {
                         poly: Arc::new(self.poly.replace_with_poly(x, &v.poly))
                     })
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*v.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Ok(Self {
                         poly: Arc::new(new_self.replace_with_poly(x, &new_rhs))
                     })
                 }
             }
         }
     };
@@ -3950,24 +4127,24 @@
     /// Create a new rational polynomial from a numerator and denominator polynomial.
     #[new]
     pub fn __new__(num: &PythonPolynomial, den: &PythonPolynomial) -> Self {
         Self {
             poly: Arc::new(RationalPolynomial::from_num_den(
                 (*num.poly).clone(),
                 (*den.poly).clone(),
-                &IntegerRing::new(),
+                &Z,
                 true,
             )),
         }
     }
 
     /// Convert the coefficients to finite fields with prime `prime`.
     pub fn to_finite_field(&self, prime: u32) -> PythonFiniteFieldRationalPolynomial {
         PythonFiniteFieldRationalPolynomial {
-            poly: Arc::new(self.poly.to_finite_field(&FiniteField::<u32>::new(prime))),
+            poly: Arc::new(self.poly.to_finite_field(&Zp::new(prime))),
         }
     }
 
     /// Get the numerator.
     pub fn numerator(&self) -> PythonPolynomial {
         PythonPolynomial {
             poly: Arc::new((&self.poly.numerator).into()),
@@ -4009,27 +4186,22 @@
             ///     If the input is not a valid Symbolica rational polynomial.
             #[classmethod]
             pub fn parse(_cls: &PyType, arg: &str, vars: Vec<&str>) -> PyResult<Self> {
                 let mut var_map = vec![];
                 let mut var_name_map = vec![];
 
                 for v in vars {
-                    let id = State::get_or_insert_var(v);
+                    let id = State::get_symbol(v);
                     var_map.push(id.into());
                     var_name_map.push(v.into());
                 }
 
                 let e = Token::parse(arg)
                     .map_err(exceptions::PyValueError::new_err)?
-                    .to_rational_polynomial(
-                        &RationalField::new(),
-                        &IntegerRing::new(),
-                        &Arc::new(var_map),
-                        &var_name_map,
-                    )
+                    .to_rational_polynomial(&Q, &Z, &Arc::new(var_map), &var_name_map)
                     .map_err(exceptions::PyValueError::new_err)?;
 
                 Ok(Self { poly: Arc::new(e) })
             }
 
             /// Convert the rational polynomial to an expression.
             ///
@@ -4052,15 +4224,15 @@
 generate_rat_parse!(PythonRationalPolynomial);
 generate_rat_parse!(PythonRationalPolynomialSmallExponent);
 
 /// A Symbolica rational polynomial over finite fields.
 #[pyclass(name = "FiniteFieldRationalPolynomial")]
 #[derive(Clone)]
 pub struct PythonFiniteFieldRationalPolynomial {
-    pub poly: Arc<RationalPolynomial<FiniteField<u32>, u16>>,
+    pub poly: Arc<RationalPolynomial<Zp, u16>>,
 }
 
 #[pymethods]
 impl PythonFiniteFieldRationalPolynomial {
     /// Parse a rational polynomial from a string.
     /// The list of all the variables must be provided.
     ///
@@ -4077,20 +4249,20 @@
     ///     If the input is not a valid Symbolica rational polynomial.
     #[classmethod]
     pub fn parse(_cls: &PyType, arg: &str, vars: Vec<&str>, prime: u32) -> PyResult<Self> {
         let mut var_map = vec![];
         let mut var_name_map = vec![];
 
         for v in vars {
-            let id = State::get_or_insert_var(v);
+            let id = State::get_symbol(v);
             var_map.push(id.into());
             var_name_map.push(v.into());
         }
 
-        let field = FiniteField::<u32>::new(prime);
+        let field = Zp::new(prime);
         let e = Token::parse(arg)
             .map_err(exceptions::PyValueError::new_err)?
             .to_rational_polynomial(&field, &field, &Arc::new(var_map), &var_name_map)
             .map_err(exceptions::PyValueError::new_err)?;
 
         Ok(Self { poly: Arc::new(e) })
     }
@@ -4132,33 +4304,21 @@
                 }
             }
 
             /// Get the list of variables in the internal ordering of the polynomial.
             pub fn get_var_list(&self) -> PyResult<Vec<PythonExpression>> {
                 let mut var_list = vec![];
 
-                let vars = self.poly.numerator.var_map.as_ref().ok_or(
-                    exceptions::PyValueError::new_err(format!("Variable map missing",)),
-                )?;
-
-                for x in vars.as_ref() {
+                for x in self.poly.get_variables().iter() {
                     match x {
                         Variable::Symbol(x) => {
                             var_list.push(PythonExpression {
                                 expr: Arc::new(Atom::new_var(*x)),
                             });
                         }
-                        Variable::Array(x, arg) => {
-                            let mut f = FunctionBuilder::new(*x);
-                            f = f.add_arg(Atom::new_num(Integer::from(*arg as u64)).as_view());
-
-                            var_list.push(PythonExpression {
-                                expr: Arc::new(f.finish()),
-                            });
-                        }
                         Variable::Temporary(_) => {
                             Err(exceptions::PyValueError::new_err(format!(
                                 "Temporary variable in polynomial",
                             )))?;
                         }
                         Variable::Function(_, a) | Variable::Other(a) => {
                             var_list.push(PythonExpression {
@@ -4192,70 +4352,70 @@
                         PrintOptions::latex(),
                     )
                 ))
             }
 
             /// Add two rational polynomials `self and `rhs`, returning the result.
             pub fn __add__(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_variables() == rhs.poly.get_variables() {
                     Self {
                         poly: Arc::new(&*self.poly + &*rhs.poly),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(&new_self + &new_rhs),
                     }
                 }
             }
 
             /// Subtract rational polynomials `rhs` from `self`, returning the result.
             pub fn __sub__(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_variables() == rhs.poly.get_variables() {
                     Self {
                         poly: Arc::new(&*self.poly - &*rhs.poly),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(&new_self - &new_rhs),
                     }
                 }
             }
 
             /// Multiply two rational polynomials `self and `rhs`, returning the result.
             pub fn __mul__(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_variables() == rhs.poly.get_variables() {
                     Self {
                         poly: Arc::new(&*self.poly * &*rhs.poly),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(&new_self * &new_rhs),
                     }
                 }
             }
 
             /// Divide the rational polynomial `self` by `rhs` if possible, returning the result.
             pub fn __truediv__(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_variables() == rhs.poly.get_variables() {
                     Self {
                         poly: Arc::new(&*self.poly * &*rhs.poly),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(&new_self / &new_rhs),
                     }
                 }
             }
 
             /// Negate the rational polynomial.
@@ -4263,22 +4423,22 @@
                 Self {
                     poly: Arc::new((*self.poly).clone().neg()),
                 }
             }
 
             /// Compute the greatest common divisor (GCD) of two rational polynomials.
             pub fn gcd(&self, rhs: Self) -> Self {
-                if self.poly.get_var_map() == rhs.poly.get_var_map() {
+                if self.poly.get_variables() == rhs.poly.get_variables() {
                     Self {
                         poly: Arc::new(self.poly.gcd(&rhs.poly)),
                     }
                 } else {
                     let mut new_self = (*self.poly).clone();
                     let mut new_rhs = (*rhs.poly).clone();
-                    new_self.unify_var_map(&mut new_rhs);
+                    new_self.unify_variables(&mut new_rhs);
                     Self {
                         poly: Arc::new(new_self.gcd(&new_rhs)),
                     }
                 }
             }
 
             /// Compute the partial fraction decomposition in `x`.
@@ -4299,17 +4459,15 @@
                     _ => {
                         return Err(exceptions::PyValueError::new_err(
                             "Invalid variable specified.",
                         ))
                     }
                 };
 
-                let x = self.poly.get_var_map().as_ref().ok_or(
-                    exceptions::PyValueError::new_err("Variable map missing"),
-                )?.iter().position(|x| match x {
+                let x = self.poly.get_variables().iter().position(|x| match x {
                     Variable::Symbol(y) => *y == id,
                     _ => false,
                 }).ok_or(exceptions::PyValueError::new_err(format!(
                     "Variable {} not found in polynomial",
                     x.__str__()?
                 )))?;
 
@@ -4333,18 +4491,15 @@
 impl ConvertibleToRationalPolynomial {
     pub fn to_rational_polynomial(self) -> PyResult<PythonRationalPolynomial> {
         match self {
             Self::Literal(l) => Ok(l),
             Self::Expression(e) => {
                 let expr = &e.to_expression().expr;
 
-                let poly = expr.as_view().to_rational_polynomial_with_conversion(
-                    &RationalField::new(),
-                    &IntegerRing::new(),
-                );
+                let poly = expr.to_rational_polynomial(&Q, &Z, None);
 
                 Ok(PythonRationalPolynomial {
                     poly: Arc::new(poly),
                 })
             }
         }
     }
@@ -4370,28 +4525,24 @@
         }
 
         let mut new_self = self.matrix.as_ref().clone();
         let mut new_rhs = rhs.matrix.as_ref().clone();
 
         let mut zero = self.matrix.field.zero();
 
-        zero.unify_var_map(&mut new_rhs[(0, 0)]);
-        new_self.field = RationalPolynomialField::new(
-            IntegerRing::new(),
-            zero.numerator.nvars,
-            zero.numerator.var_map.clone(),
-        );
+        zero.unify_variables(&mut new_rhs[(0, 0)]);
+        new_self.field = RationalPolynomialField::new(Z, zero.numerator.get_vars());
         new_rhs.field = new_self.field.clone();
 
         // now update every element
         for e in &mut new_self.data {
-            zero.unify_var_map(e);
+            zero.unify_variables(e);
         }
         for e in &mut new_rhs.data {
-            zero.unify_var_map(e);
+            zero.unify_variables(e);
         }
 
         (
             PythonMatrix {
                 matrix: Arc::new(new_self),
             },
             PythonMatrix {
@@ -4400,39 +4551,29 @@
         )
     }
 
     fn unify_scalar(
         &self,
         rhs: &PythonRationalPolynomial,
     ) -> (PythonMatrix, PythonRationalPolynomial) {
-        if self.matrix.field
-            == RationalPolynomialField::new(
-                IntegerRing::new(),
-                rhs.poly.numerator.nvars,
-                rhs.poly.numerator.var_map.clone(),
-            )
-        {
+        if self.matrix.field == RationalPolynomialField::new(Z, rhs.poly.numerator.get_vars()) {
             return (self.clone(), rhs.clone());
         }
 
         let mut new_self = self.matrix.as_ref().clone();
         let mut new_rhs = rhs.poly.as_ref().clone();
 
         let mut zero = self.matrix.field.zero();
 
-        zero.unify_var_map(&mut new_rhs);
-        new_self.field = RationalPolynomialField::new(
-            IntegerRing::new(),
-            zero.numerator.nvars,
-            zero.numerator.var_map.clone(),
-        );
+        zero.unify_variables(&mut new_rhs);
+        new_self.field = RationalPolynomialField::new(Z, zero.numerator.get_vars());
 
         // now update every element
         for e in &mut new_self.data {
-            zero.unify_var_map(e);
+            zero.unify_variables(e);
         }
 
         (
             PythonMatrix {
                 matrix: Arc::new(new_self),
             },
             PythonRationalPolynomial {
@@ -4453,15 +4594,15 @@
             ));
         }
 
         Ok(PythonMatrix {
             matrix: Arc::new(Matrix::new(
                 nrows,
                 ncols,
-                RationalPolynomialField::new(IntegerRing::new(), 0, None),
+                RationalPolynomialField::new(Z, Arc::new(vec![])),
             )),
         })
     }
 
     /// Create a new square matrix with `nrows` rows and ones on the main diagonal and zeroes elsewhere.
     #[classmethod]
     pub fn identity(_cls: &PyType, nrows: u32) -> PyResult<PythonMatrix> {
@@ -4470,15 +4611,15 @@
                 "The matrix must have at least one row and one column",
             ));
         }
 
         Ok(PythonMatrix {
             matrix: Arc::new(Matrix::identity(
                 nrows,
-                RationalPolynomialField::new(IntegerRing::new(), 0, None),
+                RationalPolynomialField::new(Z, Arc::new(vec![])),
             )),
         })
     }
 
     /// Create a new matrix with the scalars `diag` on the main diagonal and zeroes elsewhere.
     #[classmethod]
     pub fn eye(
@@ -4496,23 +4637,19 @@
             .map(|x| Ok(x.to_rational_polynomial()?.poly.as_ref().clone()))
             .collect::<PyResult<_>>()?;
 
         // unify the entries
         let (first, rest) = diag.split_first_mut().unwrap();
         for _ in 0..2 {
             for x in &mut *rest {
-                first.unify_var_map(x);
+                first.unify_variables(x);
             }
         }
 
-        let field = RationalPolynomialField::new(
-            IntegerRing::new(),
-            first.numerator.nvars,
-            first.numerator.var_map.clone(),
-        );
+        let field = RationalPolynomialField::new(Z, first.numerator.get_vars());
 
         Ok(PythonMatrix {
             matrix: Arc::new(Matrix::eye(&diag, field)),
         })
     }
 
     /// Create a new row vector from a list of scalars.
@@ -4532,23 +4669,19 @@
             .map(|x| Ok(x.to_rational_polynomial()?.poly.as_ref().clone()))
             .collect::<PyResult<_>>()?;
 
         // unify the entries
         let (first, rest) = entries.split_first_mut().unwrap();
         for _ in 0..2 {
             for x in &mut *rest {
-                first.unify_var_map(x);
+                first.unify_variables(x);
             }
         }
 
-        let field = RationalPolynomialField::new(
-            IntegerRing::new(),
-            first.numerator.nvars,
-            first.numerator.var_map.clone(),
-        );
+        let field = RationalPolynomialField::new(Z, first.numerator.get_vars());
 
         Ok(PythonMatrix {
             matrix: Arc::new(Matrix::new_vec(entries, field)),
         })
     }
 
     /// Create a new row vector from a list of scalars.
@@ -4570,23 +4703,19 @@
             .map(|x| Ok(x.to_rational_polynomial()?.poly.as_ref().clone()))
             .collect::<PyResult<_>>()?;
 
         // unify the entries
         let (first, rest) = entries.split_first_mut().unwrap();
         for _ in 0..2 {
             for x in &mut *rest {
-                first.unify_var_map(x);
+                first.unify_variables(x);
             }
         }
 
-        let field = RationalPolynomialField::new(
-            IntegerRing::new(),
-            first.numerator.nvars,
-            first.numerator.var_map.clone(),
-        );
+        let field = RationalPolynomialField::new(Z, first.numerator.get_vars());
 
         Ok(PythonMatrix {
             matrix: Arc::new(
                 Matrix::from_linear(entries, nrows, ncols, field).map_err(|e| {
                     exceptions::PyValueError::new_err(format!("Invalid matrix: {}", e))
                 })?,
             ),
```

### Comparing `symbolica-0.3.0/src/coefficient.rs` & `symbolica-0.4.0/src/coefficient.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,25 +9,25 @@
     integer::Order,
     ops::{NegAssign, Pow as RPow},
     Integer as MultiPrecisionInteger, Rational as MultiPrecisionRational,
 };
 use smallvec::{smallvec, SmallVec};
 
 use crate::{
+    atom::{Atom, AtomView},
     domains::{
         finite_field::{
             FiniteField, FiniteFieldCore, FiniteFieldElement, FiniteFieldWorkspace, ToFiniteField,
         },
-        integer::{Integer, IntegerRing},
+        integer::{Integer, IntegerRing, Z},
         rational::{Rational, RationalField},
         rational_polynomial::RationalPolynomial,
         EuclideanDomain, Field, Ring,
     },
     poly::{polynomial::MultivariatePolynomial, Variable, INLINED_EXPONENTS},
-    representations::{Atom, AtomView},
     state::{FiniteFieldIndex, State, Workspace},
 };
 
 pub trait ConvertToRing: Ring {
     /// Convert from an `Integer` to a Ring.
     fn element_from_integer(&self, number: Integer) -> Self::Element;
 
@@ -155,16 +155,16 @@
                 let r2 = RationalPolynomial {
                     numerator: rp.numerator.constant(r.numerator()),
                     denominator: rp.denominator.constant(r.denominator()),
                 };
                 Coefficient::RationalPolynomial(&rp + &r2)
             }
             (Coefficient::RationalPolynomial(mut p1), Coefficient::RationalPolynomial(mut p2)) => {
-                if p1.get_var_map() != p2.get_var_map() {
-                    p1.unify_var_map(&mut p2);
+                if p1.get_variables() != p2.get_variables() {
+                    p1.unify_variables(&mut p2);
                 };
 
                 let r = &p1 + &p2;
 
                 if r.is_constant() {
                     (r.numerator.lcoeff(), r.denominator.lcoeff()).into()
                 } else {
@@ -198,29 +198,29 @@
                 panic!("Cannot multiply finite field to non-finite number. Convert other number first?");
             }
             (_, Coefficient::FiniteField(_, _)) => {
                 panic!("Cannot multiply finite field to non-finite number. Convert other number first?");
             }
             (Coefficient::Rational(r), Coefficient::RationalPolynomial(mut rp))
             | (Coefficient::RationalPolynomial(mut rp), Coefficient::Rational(r)) => {
-                let gcd1 = IntegerRing::new().gcd(&r.numerator(), &rp.denominator.content());
-                let gcd2 = IntegerRing::new().gcd(&r.denominator(), &rp.numerator.content());
+                let gcd1 = Z.gcd(&r.numerator(), &rp.denominator.content());
+                let gcd2 = Z.gcd(&r.denominator(), &rp.numerator.content());
                 rp.numerator = rp
                     .numerator
                     .div_coeff(&gcd2)
                     .mul_coeff(r.numerator().div(&gcd1));
                 rp.denominator = rp
                     .denominator
                     .div_coeff(&gcd1)
                     .mul_coeff(r.denominator().div(&gcd2));
                 Coefficient::RationalPolynomial(rp)
             }
             (Coefficient::RationalPolynomial(mut p1), Coefficient::RationalPolynomial(mut p2)) => {
-                if p1.get_var_map() != p2.get_var_map() {
-                    p1.unify_var_map(&mut p2);
+                if p1.get_variables() != p2.get_variables() {
+                    p1.unify_variables(&mut p2);
                 };
 
                 let r = &p1 * &p2;
 
                 if r.is_constant() {
                     (r.numerator.lcoeff(), r.denominator.lcoeff()).into()
                 } else {
@@ -586,18 +586,18 @@
                 let r2 = RationalPolynomial {
                     numerator: p.numerator.constant(Integer::from_large(n)),
                     denominator: p.denominator.constant(Integer::from_large(d)),
                 };
                 Coefficient::RationalPolynomial(&r + &r2)
             }
             (CoefficientView::RationalPolynomial(p1), CoefficientView::RationalPolynomial(p2)) => {
-                let r = if p1.get_var_map() != p2.get_var_map() {
+                let r = if p1.get_variables() != p2.get_variables() {
                     let mut p1 = (*p1).clone();
                     let mut p2 = (*p2).clone();
-                    p1.unify_var_map(&mut p2);
+                    p1.unify_variables(&mut p2);
                     &p1 + &p2
                 } else {
                     p1 + p2
                 };
 
                 if r.is_constant() {
                     (r.numerator.lcoeff(), r.denominator.lcoeff()).into()
@@ -642,37 +642,37 @@
                 panic!("Cannot multiply finite field to non-finite number. Convert other number first?");
             }
             (CoefficientView::Natural(n, d), CoefficientView::RationalPolynomial(p))
             | (CoefficientView::RationalPolynomial(p), CoefficientView::Natural(n, d)) => {
                 let mut r = (*p).clone();
                 let (n, d) = (Integer::Natural(n), Integer::Natural(d));
 
-                let gcd1 = IntegerRing::new().gcd(&n, &r.denominator.content());
-                let gcd2 = IntegerRing::new().gcd(&d, &r.numerator.content());
+                let gcd1 = Z.gcd(&n, &r.denominator.content());
+                let gcd2 = Z.gcd(&d, &r.numerator.content());
                 r.numerator = r.numerator.div_coeff(&gcd2).mul_coeff(n.div(&gcd1));
                 r.denominator = r.denominator.div_coeff(&gcd1).mul_coeff(d.div(&gcd2));
                 Coefficient::RationalPolynomial(r)
             }
             (CoefficientView::Large(l), CoefficientView::RationalPolynomial(p))
             | (CoefficientView::RationalPolynomial(p), CoefficientView::Large(l)) => {
                 let mut r = (*p).clone();
                 let (n, d) = l.to_rat().into_numer_denom();
                 let (n, d) = (Integer::from_large(n), Integer::from_large(d));
 
-                let gcd1 = IntegerRing::new().gcd(&n, &r.denominator.content());
-                let gcd2 = IntegerRing::new().gcd(&d, &r.numerator.content());
+                let gcd1 = Z.gcd(&n, &r.denominator.content());
+                let gcd2 = Z.gcd(&d, &r.numerator.content());
                 r.numerator = r.numerator.div_coeff(&gcd2).mul_coeff(n.div(&gcd1));
                 r.denominator = r.denominator.div_coeff(&gcd1).mul_coeff(d.div(&gcd2));
                 Coefficient::RationalPolynomial(r)
             }
             (CoefficientView::RationalPolynomial(p1), CoefficientView::RationalPolynomial(p2)) => {
-                let r = if p1.get_var_map() != p2.get_var_map() {
+                let r = if p1.get_variables() != p2.get_variables() {
                     let mut p1 = (*p1).clone();
                     let mut p2 = (*p2).clone();
-                    p1.unify_var_map(&mut p2);
+                    p1.unify_variables(&mut p2);
                     &p1 * &p2
                 } else {
                     p1 * p2
                 };
 
                 if r.is_constant() {
                     (r.numerator.lcoeff(), r.denominator.lcoeff()).into()
@@ -729,28 +729,28 @@
         vars: &Arc<Vec<Variable>>,
         workspace: &Workspace,
         out: &mut Atom,
     ) -> bool {
         match self {
             AtomView::Num(n) => {
                 if let CoefficientView::RationalPolynomial(r) = n.get_coeff_view() {
-                    let old_var_map = r.get_var_map().unwrap();
+                    let old_var_map = r.get_variables();
                     if old_var_map != vars {
                         if old_var_map.iter().all(|x| vars.contains(x)) {
                             // upgrade the polynomial if no variables got removed
                             let mut r = r.clone();
                             let order: SmallVec<[Option<usize>; INLINED_EXPONENTS]> = vars
                                 .iter()
                                 .map(|x| old_var_map.iter().position(|xx| xx == x))
                                 .collect();
 
                             r.numerator = r.numerator.rearrange_with_growth(&order);
                             r.denominator = r.denominator.rearrange_with_growth(&order);
-                            r.numerator.var_map = Some(vars.clone());
-                            r.denominator.var_map = r.numerator.var_map.clone();
+                            r.numerator.variables = vars.clone();
+                            r.denominator.variables = r.numerator.variables.clone();
                             out.to_num(Coefficient::RationalPolynomial(r));
                             true
                         } else {
                             let mut n1 = workspace.new_atom();
                             r.numerator.to_expression_with_map(
                                 workspace,
                                 &HashMap::default(),
@@ -800,20 +800,15 @@
                     false
                 }
             }
             AtomView::Var(v) => {
                 let id = v.get_symbol();
                 if vars.contains(&id.into()) {
                     // change variable into coefficient
-                    let mut poly = MultivariatePolynomial::new(
-                        vars.len(),
-                        &IntegerRing::new(),
-                        None,
-                        Some(vars.clone()),
-                    );
+                    let mut poly = MultivariatePolynomial::new(&Z, None, vars.clone());
                     let mut e: SmallVec<[u16; INLINED_EXPONENTS]> = smallvec![0; vars.len()];
                     e[vars.iter().position(|x| *x == id.into()).unwrap()] = 1;
                     poly.append_monomial(Integer::one(), &e);
                     let den = poly.one();
 
                     out.to_num(Coefficient::RationalPolynomial(RationalPolynomial {
                         numerator: poly,
@@ -888,7 +883,44 @@
                 // do not propagate into functions
                 out.set_from_view(self);
                 false
             }
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use std::sync::Arc;
+
+    use crate::{atom::Atom, domains::rational::Rational, state::State};
+
+    #[test]
+    fn coefficient_ring() {
+        let expr = Atom::parse("v1*v3+v1*(v2+2)^-1*(v2+v3+1)").unwrap();
+
+        let v2 = State::get_symbol("v2");
+        let expr_yz =
+            expr.set_coefficient_ring(&Arc::new(vec![v2.into(), State::get_symbol("v3").into()]));
+
+        let a = ((&expr_yz + &Atom::new_num(Rational::new(1, 2)))
+            * &Atom::new_num(Rational::new(3, 4)))
+            .expand();
+
+        let a = (a / &Atom::new_num(Rational::new(3, 4)) - &Atom::new_num(Rational::new(1, 2)))
+            .expand();
+
+        let a = a.set_coefficient_ring(&Arc::new(vec![]));
+
+        let expr = Atom::new_var(v2)
+            .into_pattern()
+            .replace_all(expr.as_view(), &Atom::new_num(3).into_pattern(), None, None)
+            .expand();
+
+        let a = Atom::new_var(v2)
+            .into_pattern()
+            .replace_all(a.as_view(), &Atom::new_num(3).into_pattern(), None, None)
+            .expand();
+
+        assert_eq!(a, expr);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/combinatorics.rs` & `symbolica-0.4.0/src/combinatorics.rs`

 * *Files 8% similar despite different names*

```diff
@@ -52,22 +52,14 @@
             None
         } else {
             Some(&self.indices)
         }
     }
 }
 
-#[test]
-fn test() {
-    let mut c = CombinationIterator::new(10, 5);
-    while let Some(a) = c.next() {
-        println!("{:?}", a);
-    }
-}
-
 /// An iterator for combinations with replacement.
 pub struct CombinationWithReplacementIterator {
     indices: SmallVec<[u32; 10]>,
     k: u32,
     init: bool,
 }
 
@@ -358,7 +350,60 @@
         for (_, p) in bin_goups.drain() {
             *pref /= &Integer::new(p as i64);
         }
     }
 
     res
 }
+
+#[cfg(test)]
+mod test {
+    use super::{partitions, CombinationIterator};
+
+    #[test]
+    fn combinations() {
+        let mut c = CombinationIterator::new(4, 3);
+        let mut combinations = vec![];
+        while let Some(a) = c.next() {
+            combinations.push(a.to_vec());
+        }
+
+        let ans = vec![[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]];
+
+        assert_eq!(combinations, ans);
+    }
+
+    #[test]
+    fn partitions_no_fill() {
+        let p = partitions(
+            &[1, 1, 1, 2, 2],
+            &[('f', 2), ('g', 2), ('f', 1)],
+            false,
+            false,
+        );
+
+        let res = vec![
+            (
+                3.into(),
+                vec![('f', vec![1]), ('f', vec![1, 1]), ('g', vec![2, 2])],
+            ),
+            (
+                12.into(),
+                vec![('f', vec![1]), ('f', vec![1, 2]), ('g', vec![1, 2])],
+            ),
+            (
+                3.into(),
+                vec![('f', vec![1]), ('f', vec![2, 2]), ('g', vec![1, 1])],
+            ),
+            (
+                6.into(),
+                vec![('f', vec![2]), ('f', vec![1, 1]), ('g', vec![1, 2])],
+            ),
+            (
+                6.into(),
+                vec![('f', vec![2]), ('f', vec![1, 2]), ('g', vec![1, 1])],
+            ),
+        ];
+
+        assert_eq!(p, res);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/derivative.rs` & `symbolica-0.4.0/src/derivative.rs`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 use std::ops::DerefMut;
 
 use crate::{
+    atom::{Atom, AtomView, Symbol},
     coefficient::Coefficient,
     domains::integer::Integer,
-    representations::{Atom, AtomView, Symbol},
     state::{State, Workspace},
 };
 
 impl Atom {
     /// Take a derivative of the expression with respect to `x`.
     pub fn derivative(&self, x: Symbol) -> Atom {
         self.as_view().derivative(x)
@@ -446,7 +446,44 @@
         }
 
         series.as_view().normalize(workspace, out);
 
         true
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{atom::Atom, state::State};
+
+    #[test]
+    fn derivative() {
+        let x = State::get_symbol("x");
+        let inputs = [
+            "(1+2*x)^(5+x)",
+            "log(2*x) + exp(3*x) + sin(4*x) + cos(y*x)",
+            "f(x^2,x)",
+            "der(0,1,f(x,x^3))",
+        ];
+        let r = inputs.map(|input| Atom::parse(input).unwrap().derivative(x));
+
+        let res = [
+            "(2*x+1)^(x+5)*log(2*x+1)+2*(x+5)*(2*x+1)^(x+4)",
+            "2*(2*x)^-1+3*exp(3*x)+4*cos(4*x)-y*sin(x*y)",
+            "der(0,1,f(x^2,x))+2*x*der(1,0,f(x^2,x))",
+            "der(1,1,f(x,x^3))+3*x^2*der(0,2,f(x,x^3))",
+        ];
+        let res = res.map(|input| Atom::parse(input).unwrap());
+
+        assert_eq!(r, res);
+    }
+
+    #[test]
+    fn taylor_series() {
+        let x = State::get_symbol("x");
+        let input = Atom::parse("cos(x^2+1)*(x+3)").unwrap();
+        let t = input.taylor_series(x, Atom::new_num(0).as_view(), 2);
+
+        let res = Atom::parse("3*cos(1)+x*cos(1)-3*x^2*sin(1)").unwrap();
+        assert_eq!(t, res);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/domains/factorized_rational_polynomial.rs` & `symbolica-0.4.0/src/domains/factorized_rational_polynomial.rs`

 * *Files 3% similar despite different names*

```diff
@@ -13,48 +13,44 @@
         Variable,
     },
     printer::{FactorizedRationalPolynomialPrinter, PrintOptions},
 };
 
 use super::{
     finite_field::{FiniteField, FiniteFieldCore, FiniteFieldWorkspace, ToFiniteField},
-    integer::IntegerRing,
+    integer::{IntegerRing, Z},
     rational::RationalField,
     EuclideanDomain, Field, Ring,
 };
 
-#[derive(Clone, PartialEq, Debug)]
+#[derive(Clone, PartialEq, Eq, Hash, Debug)]
 pub struct FactorizedRationalPolynomialField<R: Ring, E: Exponent> {
     ring: R,
-    nvars: usize,
-    var_map: Option<Arc<Vec<Variable>>>,
+    var_map: Arc<Vec<Variable>>,
     _phantom_exp: PhantomData<E>,
 }
 
 impl<R: Ring, E: Exponent> FactorizedRationalPolynomialField<R, E> {
     pub fn new(
         coeff_ring: R,
-        nvars: usize,
-        var_map: Option<Arc<Vec<Variable>>>,
+        var_map: Arc<Vec<Variable>>,
     ) -> FactorizedRationalPolynomialField<R, E> {
         FactorizedRationalPolynomialField {
             ring: coeff_ring,
-            nvars,
             var_map,
             _phantom_exp: PhantomData,
         }
     }
 
     pub fn new_from_poly(
         poly: &MultivariatePolynomial<R, E>,
     ) -> FactorizedRationalPolynomialField<R, E> {
         FactorizedRationalPolynomialField {
             ring: poly.field.clone(),
-            nvars: poly.nvars,
-            var_map: poly.var_map.clone(),
+            var_map: poly.variables.clone(),
             _phantom_exp: PhantomData,
         }
     }
 }
 
 pub trait FromNumeratorAndFactorizedDenominator<R: Ring, OR: Ring, E: Exponent> {
     /// Construct a rational polynomial from a numerator and a factorized denominator.
@@ -63,15 +59,15 @@
         num: MultivariatePolynomial<R, E>,
         dens: Vec<(MultivariatePolynomial<R, E>, usize)>,
         field: &OR,
         do_factor: bool,
     ) -> FactorizedRationalPolynomial<OR, E>;
 }
 
-#[derive(Clone, PartialEq, Eq, Debug)]
+#[derive(Clone, PartialEq, Eq, Hash, Debug)]
 pub struct FactorizedRationalPolynomial<R: Ring, E: Exponent> {
     pub numerator: MultivariatePolynomial<R, E>,
     pub numer_coeff: R::Element,
     pub denom_coeff: R::Element,
     pub denominators: Vec<(MultivariatePolynomial<R, E>, usize)>, // TODO: sort factors?
 }
 
@@ -79,42 +75,34 @@
     /// An ordering of rational polynomials that has no intuitive meaning.
     fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {
         todo!()
     }
 }
 
 impl<R: Ring, E: Exponent> FactorizedRationalPolynomial<R, E> {
-    pub fn new(
-        field: &R,
-        var_map: Option<Arc<Vec<Variable>>>,
-    ) -> FactorizedRationalPolynomial<R, E> {
-        let num = MultivariatePolynomial::new(
-            var_map.as_ref().map(|x| x.len()).unwrap_or(0),
-            field,
-            None,
-            var_map,
-        );
+    pub fn new(field: &R, var_map: Arc<Vec<Variable>>) -> FactorizedRationalPolynomial<R, E> {
+        let num = MultivariatePolynomial::new(field, None, var_map);
 
         FactorizedRationalPolynomial {
             numerator: num,
             numer_coeff: field.zero(),
             denom_coeff: field.one(),
             denominators: vec![],
         }
     }
 
-    pub fn get_var_map(&self) -> Option<&[Variable]> {
-        self.numerator.var_map.as_ref().map(|x| x.as_slice())
+    pub fn get_variables(&self) -> &[Variable] {
+        self.numerator.get_vars_ref()
     }
 
-    pub fn unify_var_map(&mut self, other: &mut Self) {
-        self.numerator.unify_var_map(&mut other.numerator);
+    pub fn unify_variables(&mut self, other: &mut Self) {
+        self.numerator.unify_variables(&mut other.numerator);
 
         for d in &mut self.denominators {
-            d.0.unify_var_map(&mut other.numerator);
+            d.0.unify_variables(&mut other.numerator);
         }
     }
 
     pub fn is_constant(&self) -> bool {
         self.numerator.is_constant() && self.denominators.is_empty()
     }
 
@@ -143,19 +131,19 @@
                 .map(|(f, p)| (f.map_coeff(|c| c.to_finite_field(field), field.clone()), *p))
                 .collect(),
             field,
             true,
         )
     }
 
-    fn is_zero(&self) -> bool {
+    pub fn is_zero(&self) -> bool {
         self.numerator.is_zero()
     }
 
-    fn is_one(&self) -> bool {
+    pub fn is_one(&self) -> bool {
         self.numerator.is_one()
             && self.denominators.is_empty()
             && self.numerator.field.is_one(&self.numer_coeff)
             && self.numerator.field.is_one(&self.denom_coeff)
     }
 }
 
@@ -171,32 +159,26 @@
         let mut content = num.content();
         for (d, _) in &dens {
             content = d.field.gcd(&content, &d.content());
         }
 
         let (num_int, dens_int) = if num.field.is_one(&content) {
             (
-                num.map_coeff(|c| c.numerator(), IntegerRing::new()),
+                num.map_coeff(|c| c.numerator(), Z),
                 dens.iter()
-                    .map(|(d, p)| (d.map_coeff(|c| c.numerator(), IntegerRing::new()), *p))
+                    .map(|(d, p)| (d.map_coeff(|c| c.numerator(), Z), *p))
                     .collect(),
             )
         } else {
             (
-                num.map_coeff(
-                    |c| num.field.div(c, &content).numerator(),
-                    IntegerRing::new(),
-                ),
+                num.map_coeff(|c| num.field.div(c, &content).numerator(), Z),
                 dens.iter()
                     .map(|(d, p)| {
                         (
-                            d.map_coeff(
-                                |c| num.field.div(c, &content).numerator(),
-                                IntegerRing::new(),
-                            ),
+                            d.map_coeff(|c| num.field.div(c, &content).numerator(), Z),
                             *p,
                         )
                     })
                     .collect(),
             )
         };
 
@@ -215,15 +197,15 @@
         mut num: MultivariatePolynomial<IntegerRing, E>,
         mut dens: Vec<(MultivariatePolynomial<IntegerRing, E>, usize)>,
         _field: &IntegerRing,
         do_factor: bool,
     ) -> Self {
         for _ in 0..2 {
             for (d, _) in &mut dens {
-                num.unify_var_map(d);
+                num.unify_variables(d);
             }
         }
 
         let mut num_const = num.field.one();
         let mut den_const = num.field.one();
 
         if dens.is_empty() {
@@ -325,15 +307,15 @@
         mut num: MultivariatePolynomial<FiniteField<UField>, E>,
         mut dens: Vec<(MultivariatePolynomial<FiniteField<UField>, E>, usize)>,
         field: &FiniteField<UField>,
         do_factor: bool,
     ) -> Self {
         for _ in 0..2 {
             for (d, _) in &mut dens {
-                num.unify_var_map(d);
+                num.unify_variables(d);
             }
         }
 
         let mut constant = num.field.one();
 
         if dens.is_empty() {
             return FactorizedRationalPolynomial {
@@ -555,35 +537,25 @@
 
     fn neg(&self, a: &Self::Element) -> Self::Element {
         a.clone().neg()
     }
 
     fn zero(&self) -> Self::Element {
         FactorizedRationalPolynomial {
-            numerator: MultivariatePolynomial::new(
-                self.nvars,
-                &self.ring,
-                None,
-                self.var_map.clone(),
-            ),
+            numerator: MultivariatePolynomial::new(&self.ring, None, self.var_map.clone().into()),
             numer_coeff: self.ring.zero(),
             denom_coeff: self.ring.one(),
             denominators: vec![],
         }
     }
 
     fn one(&self) -> Self::Element {
         FactorizedRationalPolynomial {
-            numerator: MultivariatePolynomial::new(
-                self.nvars,
-                &self.ring,
-                None,
-                self.var_map.clone(),
-            )
-            .one(),
+            numerator: MultivariatePolynomial::new(&self.ring, None, self.var_map.clone().into())
+                .one(),
             numer_coeff: self.ring.one(),
             denom_coeff: self.ring.one(),
             denominators: vec![],
         }
     }
 
     fn nth(&self, n: u64) -> Self::Element {
@@ -1042,21 +1014,20 @@
 
         let mut poly_univ = vec![];
         for (f, p) in &self.denominators {
             let f = f.clone().pow(*p);
 
             let l = f.to_univariate_polynomial_list(var);
             let mut res: MultivariatePolynomial<_, E> = MultivariatePolynomial::new(
-                self.numerator.nvars,
                 &rat_field,
                 Some(l.len()),
-                self.numerator.var_map.clone(),
+                self.numerator.variables.clone().into(),
             );
 
-            let mut exp = vec![E::zero(); self.numerator.nvars];
+            let mut exp = vec![E::zero(); self.numerator.nvars()];
             for (p, e) in l {
                 exp[var] = e;
                 res.append_monomial(
                     FactorizedRationalPolynomial::from_num_den(
                         p,
                         vec![],
                         &self.numerator.field,
@@ -1073,15 +1044,15 @@
 
         let mut factors = Vec::with_capacity(deltas.len());
         for (d, (p, pe)) in deltas.into_iter().zip(&self.denominators) {
             let mut unfold = rat_field.zero();
             for (c, e) in d
                 .coefficients
                 .into_iter()
-                .zip(d.exponents.chunks(self.numerator.nvars))
+                .zip(d.exponents.chunks(self.numerator.nvars()))
             {
                 unfold = &unfold
                     + &(&c
                         * &FactorizedRationalPolynomial::from_num_den(
                             unfold
                                 .numerator
                                 .monomial(self.numerator.field.one(), e.to_vec()),
```

### Comparing `symbolica-0.3.0/src/domains/finite_field.rs` & `symbolica-0.4.0/src/domains/finite_field.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,33 @@
 use rand::Rng;
 use std::fmt::{Display, Error, Formatter};
 use std::hash::Hash;
 use std::ops::Neg;
 
-use crate::domains::integer::{Integer, IntegerRing};
+use crate::domains::integer::Integer;
 use crate::printer::PrintOptions;
 
+use super::integer::Z;
 use super::{EuclideanDomain, Field, Ring};
 
 const HENSEL_LIFTING_MASK: [u8; 128] = [
     255, 85, 51, 73, 199, 93, 59, 17, 15, 229, 195, 89, 215, 237, 203, 33, 31, 117, 83, 105, 231,
     125, 91, 49, 47, 5, 227, 121, 247, 13, 235, 65, 63, 149, 115, 137, 7, 157, 123, 81, 79, 37, 3,
     153, 23, 45, 11, 97, 95, 181, 147, 169, 39, 189, 155, 113, 111, 69, 35, 185, 55, 77, 43, 129,
     127, 213, 179, 201, 71, 221, 187, 145, 143, 101, 67, 217, 87, 109, 75, 161, 159, 245, 211, 233,
     103, 253, 219, 177, 175, 133, 99, 249, 119, 141, 107, 193, 191, 21, 243, 9, 135, 29, 251, 209,
     207, 165, 131, 25, 151, 173, 139, 225, 223, 53, 19, 41, 167, 61, 27, 241, 239, 197, 163, 57,
     183, 205, 171, 1,
 ];
 
+/// A 32-bit integer finite field.
+pub type Zp = FiniteField<u32>;
+/// A 64-bit integer finite field.
+pub type Zp64 = FiniteField<u64>;
+
 pub trait ToFiniteField<UField: FiniteFieldWorkspace>
 where
     FiniteField<UField>: FiniteFieldCore<UField>,
 {
     fn to_finite_field(
         &self,
         field: &FiniteField<UField>,
@@ -47,29 +53,40 @@
     /// Convert a number from the finite field to symmetric form `[-p/2,p/2]`.
     fn to_symmetric_integer(&self, a: &Self::Element) -> Integer;
 }
 
 /// The modular ring `Z / mZ`, where `m` can be any positive integer. In most cases,
 /// `m` will be a prime, and the domain will be a field.
 ///
-/// `FiniteField<u32>` and `FiniteField<u64>` use Montgomery modular arithmetic
+/// `Zp` and `Zp64` use Montgomery modular arithmetic
 /// to increase the performance of the multiplication operator.
 ///
 /// For `m` larger than `2^64`, use `FiniteField<Integer>`.
 ///
 /// The special field `FiniteField<Mersenne64>` can be used to have even faster arithmetic
 /// for a field with Mersenne prime `2^61-1`.
-#[derive(Debug, Clone, PartialEq, Eq)]
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct FiniteField<UField> {
     p: UField,
     m: UField,
     one: FiniteFieldElement<UField>,
 }
 
-impl FiniteField<u32> {
+impl Zp {
+    /// Create a new finite field. `n` must be a prime larger than 2.
+    pub fn new(p: u32) -> Zp {
+        assert!(p % 2 != 0);
+
+        FiniteField {
+            p,
+            m: Self::inv_2_32(p),
+            one: FiniteFieldElement(Self::get_one(p)),
+        }
+    }
+
     /// Returns the unit element in Montgomory form, ie.e 1 + 2^32 mod a.
     fn get_one(a: u32) -> u32 {
         if a as u64 <= 1u64 << 31 {
             let res = (((1u64 << 31) % a as u64) << 1) as u32;
 
             if res < a {
                 res
@@ -92,24 +109,18 @@
 
 impl FiniteFieldWorkspace for u32 {
     fn to_u64(&self) -> u64 {
         *self as u64
     }
 }
 
-impl FiniteFieldCore<u32> for FiniteField<u32> {
+impl FiniteFieldCore<u32> for Zp {
     /// Create a new finite field. `n` must be a prime larger than 2.
-    fn new(p: u32) -> FiniteField<u32> {
-        assert!(p % 2 != 0);
-
-        FiniteField {
-            p,
-            m: Self::inv_2_32(p),
-            one: FiniteFieldElement(Self::get_one(p)),
-        }
+    fn new(p: u32) -> Zp {
+        Self::new(p)
     }
 
     fn get_prime(&self) -> u32 {
         self.p
     }
 
     /// Convert a number in a prime field a % n to Montgomory form.
@@ -134,15 +145,15 @@
             &Integer::from(i) - &Integer::from(self.get_prime() as u64)
         } else {
             i.into()
         }
     }
 }
 
-impl Ring for FiniteField<u32> {
+impl Ring for Zp {
     type Element = FiniteFieldElement<u32>;
 
     /// Add two numbers in Montgomory form.
     #[inline(always)]
     fn add(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         let mut t = a.0 as u64 + b.0 as u64;
 
@@ -285,15 +296,15 @@
             self.to_symmetric_integer(element).fmt(f)
         } else {
             self.from_element(element).fmt(f)
         }
     }
 }
 
-impl EuclideanDomain for FiniteField<u32> {
+impl EuclideanDomain for Zp {
     #[inline]
     fn rem(&self, _: &Self::Element, _: &Self::Element) -> Self::Element {
         FiniteFieldElement(0)
     }
 
     #[inline]
     fn quot_rem(&self, a: &Self::Element, b: &Self::Element) -> (Self::Element, Self::Element) {
@@ -302,15 +313,15 @@
 
     #[inline]
     fn gcd(&self, _: &Self::Element, _: &Self::Element) -> Self::Element {
         self.one()
     }
 }
 
-impl Field for FiniteField<u32> {
+impl Field for Zp {
     #[inline]
     fn div(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         self.mul(a, &self.inv(b))
     }
 
     #[inline]
     fn div_assign(&self, a: &mut Self::Element, b: &Self::Element) {
@@ -357,15 +368,26 @@
 impl FiniteFieldWorkspace for u64 {
     #[inline]
     fn to_u64(&self) -> u64 {
         *self
     }
 }
 
-impl FiniteField<u64> {
+impl Zp64 {
+    /// Create a new finite field. `n` must be a prime larger than 2.
+    fn new(p: u64) -> Zp64 {
+        assert!(p % 2 != 0);
+
+        FiniteField {
+            p,
+            m: Self::inv_2_64(p),
+            one: FiniteFieldElement(Self::get_one(p)),
+        }
+    }
+
     /// Returns the unit element in Montgomory form, ie.e 1 + 2^64 mod a.
     fn get_one(a: u64) -> u64 {
         if a as u128 <= 1u128 << 63 {
             let res = (((1u128 << 63) % a as u128) << 1) as u64;
 
             if res < a {
                 res
@@ -383,24 +405,18 @@
         ret = ret.wrapping_mul(a.wrapping_mul(ret).wrapping_add(2));
         ret = ret.wrapping_mul(a.wrapping_mul(ret).wrapping_add(2));
         ret = ret.wrapping_mul(a.wrapping_mul(ret).wrapping_add(2));
         ret
     }
 }
 
-impl FiniteFieldCore<u64> for FiniteField<u64> {
+impl FiniteFieldCore<u64> for Zp64 {
     /// Create a new finite field. `n` must be a prime larger than 2.
-    fn new(p: u64) -> FiniteField<u64> {
-        assert!(p % 2 != 0);
-
-        FiniteField {
-            p,
-            m: Self::inv_2_64(p),
-            one: FiniteFieldElement(Self::get_one(p)),
-        }
+    fn new(p: u64) -> Zp64 {
+        Self::new(p)
     }
 
     fn get_prime(&self) -> u64 {
         self.p
     }
 
     /// Convert a number in a prime field a % n to Montgomory form.
@@ -431,15 +447,15 @@
 
 impl<UField: Display> Display for FiniteField<UField> {
     fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
         write!(f, " % {}", self.p)
     }
 }
 
-impl Ring for FiniteField<u64> {
+impl Ring for Zp64 {
     type Element = FiniteFieldElement<u64>;
     /// Add two numbers in Montgomory form.
     #[inline(always)]
     fn add(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         // avoid f128 arithmetic
         let (r, overflow) = a.0.overflowing_add(b.0);
         if overflow || r >= self.p {
@@ -576,15 +592,15 @@
             self.to_symmetric_integer(element).fmt(f)
         } else {
             self.from_element(element).fmt(f)
         }
     }
 }
 
-impl EuclideanDomain for FiniteField<u64> {
+impl EuclideanDomain for Zp64 {
     #[inline]
     fn rem(&self, _: &Self::Element, _: &Self::Element) -> Self::Element {
         FiniteFieldElement(0)
     }
 
     #[inline]
     fn quot_rem(&self, a: &Self::Element, b: &Self::Element) -> (Self::Element, Self::Element) {
@@ -593,15 +609,15 @@
 
     #[inline]
     fn gcd(&self, _: &Self::Element, _: &Self::Element) -> Self::Element {
         self.one()
     }
 }
 
-impl Field for FiniteField<u64> {
+impl Field for Zp64 {
     #[inline]
     fn div(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         self.mul(a, &self.inv(b))
     }
 
     #[inline]
     fn div_assign(&self, a: &mut Self::Element, b: &Self::Element) {
@@ -665,21 +681,21 @@
 
     const SHIFT: u8 = 61;
     pub const PRIME: u64 = (1 << Mersenne64::SHIFT) - 1;
 }
 
 impl std::fmt::Debug for Mersenne64 {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        f.write_fmt(format_args!("{}", Self::PRIME))
+        std::fmt::Debug::fmt(&self.0, f)
     }
 }
 
 impl Display for Mersenne64 {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        f.write_fmt(format_args!("{}", Self::PRIME))
+        self.0.fmt(f)
     }
 }
 
 impl FiniteFieldWorkspace for Mersenne64 {
     fn to_u64(&self) -> u64 {
         Self::PRIME
     }
@@ -1031,15 +1047,15 @@
     }
 
     fn is_characteristic_zero(&self) -> bool {
         false
     }
 
     fn sample(&self, rng: &mut impl rand::RngCore, range: (i64, i64)) -> Self::Element {
-        IntegerRing::new().sample(rng, range).symmetric_mod(&self.p)
+        Z.sample(rng, range).symmetric_mod(&self.p)
     }
 
     fn fmt_display(
         &self,
         element: &Self::Element,
         opts: &PrintOptions,
         _in_product: bool,
@@ -1086,15 +1102,15 @@
         let mut u1 = Integer::one();
         let mut u3 = a.clone();
         let mut v1 = Integer::zero();
         let mut v3 = self.get_prime();
         let mut even_iter: bool = true;
 
         while !v3.is_zero() {
-            let (q, t3) = IntegerRing::new().quot_rem(&u3, &v3);
+            let (q, t3) = Z.quot_rem(&u3, &v3);
             let t1 = &u1 + &(&q * &v1);
             u1 = v1;
             v1 = t1;
             u3 = v3;
             v3 = t3;
             even_iter = !even_iter;
         }
@@ -1127,15 +1143,15 @@
     let mut s = 0;
     let mut d = n - 1;
     while d % 2 == 0 {
         d /= 2;
         s += 1;
     }
 
-    let f = FiniteField::<u64>::new(n);
+    let f = Zp64::new(n);
     let neg_one = FiniteFieldElement(n.wrapping_sub(f.one().0));
 
     'test: for a in witnesses {
         let a = f.to_element(a);
 
         if a.0 == 0 {
             continue;
```

### Comparing `symbolica-0.3.0/src/domains/float.rs` & `symbolica-0.4.0/src/domains/float.rs`

 * *Files 12% similar despite different names*

```diff
@@ -497,14 +497,22 @@
 impl<T: Real> Complex<T> {
     #[inline]
     pub fn new(re: T, im: T) -> Complex<T> {
         Complex { re, im }
     }
 
     #[inline]
+    pub fn i() -> Complex<T> {
+        Complex {
+            re: T::zero(),
+            im: T::one(),
+        }
+    }
+
+    #[inline]
     pub fn norm_squared(&self) -> T {
         self.re * self.re + self.im * self.im
     }
 
     #[inline]
     pub fn arg(&self) -> T {
         self.im.atan2(&self.re)
@@ -753,92 +761,171 @@
         Complex {
             re: T::sample_unit(rng),
             im: T::zero(),
         }
     }
 }
 
+/// Following the same conventions and formulas as num::Complex.
 impl<T: Real> Real for Complex<T> {
+    #[inline]
     fn sqrt(&self) -> Self {
         let (r, phi) = self.to_polar_coordinates();
         Complex::from_polar_coordinates(r.sqrt(), phi / T::from_usize(2))
     }
 
+    #[inline]
     fn log(&self) -> Self {
         Complex::new(self.norm().re.log(), self.arg())
     }
 
+    #[inline]
     fn exp(&self) -> Self {
         let r = self.re.exp();
         Complex::new(r * self.im.cos(), r * self.im.sin())
     }
 
+    #[inline]
     fn sin(&self) -> Self {
         Complex::new(
             self.re.sin() * self.im.cosh(),
             self.re.cos() * self.im.sinh(),
         )
     }
 
+    #[inline]
     fn cos(&self) -> Self {
         Complex::new(
             self.re.cos() * self.im.cosh(),
             -self.re.sin() * self.im.sinh(),
         )
     }
 
+    #[inline]
     fn tan(&self) -> Self {
-        todo!("tan on complex numbers are not implemented yet")
+        let (r, i) = (self.re + self.re, self.im + self.im);
+        let m = r.cos() + i.cosh();
+        Self::new(r.sin() / m, i.sinh() / m)
     }
 
+    #[inline]
     fn asin(&self) -> Self {
-        todo!("asin on complex numbers are not implemented yet")
+        let i = Self::i();
+        -i * ((Self::one() - self.clone() * self).sqrt() + i * self).log()
     }
 
+    #[inline]
     fn acos(&self) -> Self {
-        todo!("asin on complex numbers are not implemented yet")
+        let i = Self::i();
+        -i * (i * (Self::one() - self.clone() * self).sqrt() + self).log()
     }
 
-    fn atan2(&self, _x: &Self) -> Self {
-        todo!("Atan2 on complex numbers are not implemented yet")
+    #[inline]
+    fn atan2(&self, x: &Self) -> Self {
+        // TODO: pick proper branch
+        let r = self.clone() / x;
+        let i = Self::i();
+        let one = Self::one();
+        let two = one + one;
+        // TODO: add edge cases
+        ((one + i * r).log() - (one - i * r).log()) / (two * i)
     }
 
+    #[inline]
     fn sinh(&self) -> Self {
         Complex::new(
             self.re.sinh() * self.im.cos(),
             self.re.cosh() * self.im.sin(),
         )
     }
 
+    #[inline]
     fn cosh(&self) -> Self {
         Complex::new(
             self.re.cosh() * self.im.cos(),
             self.re.sinh() * self.im.sin(),
         )
     }
 
+    #[inline]
     fn tanh(&self) -> Self {
-        todo!("tanh on complex numbers are not implemented yet");
+        let (two_re, two_im) = (self.re + self.re, self.im + self.im);
+        let m = two_re.cosh() + two_im.cos();
+        Self::new(two_re.sinh() / m, two_im.sin() / m)
     }
 
+    #[inline]
     fn asinh(&self) -> Self {
-        todo!("asinh on complex numbers are not implemented yet");
+        let one = Self::one();
+        (self.clone() + (one + self.clone() * self).sqrt()).log()
     }
 
+    #[inline]
     fn acosh(&self) -> Self {
-        todo!("acosh on complex numbers are not implemented yet");
+        let one = Self::one();
+        let two = one + one;
+        two * (((self.clone() + one) / two).sqrt() + ((self.clone() - one) / two).sqrt()).log()
     }
 
+    #[inline]
     fn atanh(&self) -> Self {
-        todo!("atanh on complex numbers are not implemented yet");
+        let one = Self::one();
+        let two = one + one;
+        // TODO: add edge cases
+        ((one + self).log() - (one - self).log()) / two
     }
 
-    fn powf(&self, _e: Self) -> Self {
-        todo!("Float exponentiation on complex numbers are not implemented yet")
+    #[inline]
+    fn powf(&self, e: Self) -> Self {
+        if e.re == T::zero() && e.im == T::zero() {
+            return Complex::one();
+        } else if e.im == T::zero() {
+            let (r, phi) = self.to_polar_coordinates();
+            Self::from_polar_coordinates(r.powf(e.re), phi * e.re)
+        } else {
+            (e * self.log()).exp()
+        }
     }
 }
 
 impl<'a, T: Real + From<&'a Rational>> From<&'a Rational> for Complex<T> {
     fn from(value: &'a Rational) -> Self {
         Complex::new(value.into(), T::zero())
     }
 }
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    #[test]
+    fn double() {
+        let a = 5.;
+        let b = 7.;
+
+        let r = a.sqrt() + b.log() + b.sin() - a.cos() + b.tan() - 0.3.asin() + 0.5.acos()
+            - a.atan2(b)
+            + b.sinh()
+            - a.cosh()
+            + b.tanh()
+            - 0.7.asinh()
+            + b.acosh() / 0.4.atanh()
+            + b.powf(a);
+        assert_eq!(r, 17293.219725825093);
+    }
+
+    #[test]
+    fn complex() {
+        let a = Complex::new(1., 2.);
+        let b: Complex<f64> = Complex::new(3., 4.);
+
+        let r = a.sqrt() + b.log() - a.exp() + b.sin() - a.cos() + b.tan() - a.asin() + b.acos()
+            - a.atan2(&b)
+            + b.sinh()
+            - a.cosh()
+            + b.tanh()
+            - a.asinh()
+            + b.acosh() / a.atanh()
+            + b.powf(a);
+        assert_eq!(r, Complex::new(0.1924131450685842, -39.83285329561913));
+    }
+}
```

### Comparing `symbolica-0.3.0/src/domains/integer.rs` & `symbolica-0.4.0/src/domains/integer.rs`

 * *Files 2% similar despite different names*

```diff
@@ -11,38 +11,46 @@
     ops::{Pow, RemRounding},
     Complete, Integer as MultiPrecisionInteger,
 };
 
 use crate::{printer::PrintOptions, utils};
 
 use super::{
-    finite_field::{FiniteField, FiniteFieldCore, FiniteFieldWorkspace, Mersenne64, ToFiniteField},
+    finite_field::{
+        FiniteField, FiniteFieldCore, FiniteFieldWorkspace, Mersenne64, ToFiniteField, Zp, Zp64,
+    },
     rational::Rational,
     EuclideanDomain, Ring,
 };
 
 pub const SMALL_PRIMES: [i64; 100] = [
     2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
     101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
     197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,
     311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,
     431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
 ];
 
-#[derive(Clone, Copy, PartialEq, Eq, Debug)]
+/// The integer ring.
+pub type Z = IntegerRing;
+/// The integer ring.
+pub const Z: IntegerRing = IntegerRing::new();
+
+/// The integer ring.
+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
 pub struct IntegerRing;
 
 impl Default for IntegerRing {
     fn default() -> Self {
         Self::new()
     }
 }
 
 impl IntegerRing {
-    pub fn new() -> IntegerRing {
+    pub const fn new() -> IntegerRing {
         IntegerRing
     }
 }
 
 #[derive(Clone, PartialEq, Eq, Hash)]
 pub enum Integer {
     Natural(i64),
@@ -60,25 +68,50 @@
 impl From<i64> for Integer {
     #[inline]
     fn from(value: i64) -> Self {
         Integer::Natural(value)
     }
 }
 
+impl From<i128> for Integer {
+    #[inline]
+    fn from(value: i128) -> Self {
+        Integer::from_double(value)
+    }
+}
+
+impl From<u32> for Integer {
+    #[inline]
+    fn from(value: u32) -> Self {
+        Integer::Natural(value as i64)
+    }
+}
+
 impl From<u64> for Integer {
     #[inline]
     fn from(value: u64) -> Self {
         if value <= i64::MAX as u64 {
             Integer::Natural(value as i64)
         } else {
             Integer::Double(value as i128)
         }
     }
 }
 
+impl From<u128> for Integer {
+    #[inline]
+    fn from(value: u128) -> Self {
+        if value <= i128::MAX as u128 {
+            Integer::from_double(value as i128)
+        } else {
+            Integer::Large(value.into())
+        }
+    }
+}
+
 impl FromStr for Integer {
     type Err = &'static str;
 
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         if s.len() <= 20 {
             if let Ok(n) = s.parse::<i64>() {
                 return Ok(Integer::Natural(n));
@@ -106,25 +139,25 @@
             Self::Double(n) => std::fmt::Display::fmt(n, f),
             Self::Large(n) => std::fmt::Display::fmt(n, f),
         }
     }
 }
 
 impl ToFiniteField<u32> for Integer {
-    fn to_finite_field(&self, field: &FiniteField<u32>) -> <FiniteField<u32> as Ring>::Element {
+    fn to_finite_field(&self, field: &Zp) -> <Zp as Ring>::Element {
         match self {
             &Integer::Natural(n) => field.to_element(n.rem_euclid(field.get_prime() as i64) as u32),
             &Integer::Double(n) => field.to_element(n.rem_euclid(field.get_prime() as i128) as u32),
             Integer::Large(r) => field.to_element(r.mod_u(field.get_prime())),
         }
     }
 }
 
 impl ToFiniteField<u64> for Integer {
-    fn to_finite_field(&self, field: &FiniteField<u64>) -> <FiniteField<u64> as Ring>::Element {
+    fn to_finite_field(&self, field: &Zp64) -> <Zp64 as Ring>::Element {
         match self {
             &Integer::Natural(n) => {
                 if field.get_prime() > i64::MAX as u64 {
                     field.to_element((n as i128).rem_euclid(field.get_prime() as i128) as u64)
                 } else {
                     field.to_element(n.rem_euclid(field.get_prime() as i64) as u64)
                 }
@@ -165,40 +198,34 @@
         field: &FiniteField<UField>,
         element: <FiniteField<UField> as Ring>::Element,
     ) -> Self;
     fn from_prime(field: &FiniteField<UField>) -> Self;
 }
 
 impl FromFiniteField<u32> for Integer {
-    fn from_finite_field(
-        field: &FiniteField<u32>,
-        element: <FiniteField<u32> as Ring>::Element,
-    ) -> Self {
+    fn from_finite_field(field: &Zp, element: <Zp as Ring>::Element) -> Self {
         Integer::Natural(field.from_element(&element) as i64)
     }
 
-    fn from_prime(field: &FiniteField<u32>) -> Self {
+    fn from_prime(field: &Zp) -> Self {
         Integer::Natural(field.get_prime() as i64)
     }
 }
 
 impl FromFiniteField<u64> for Integer {
-    fn from_finite_field(
-        field: &FiniteField<u64>,
-        element: <FiniteField<u64> as Ring>::Element,
-    ) -> Self {
+    fn from_finite_field(field: &Zp64, element: <Zp64 as Ring>::Element) -> Self {
         let r = field.from_element(&element);
         if r <= i64::MAX as u64 {
             Integer::Natural(r as i64)
         } else {
             Integer::Double(r as i128)
         }
     }
 
-    fn from_prime(field: &FiniteField<u64>) -> Self {
+    fn from_prime(field: &Zp64) -> Self {
         let r = field.get_prime();
         if r <= i64::MAX as u64 {
             Integer::Natural(r as i64)
         } else {
             Integer::Double(r as i128)
         }
     }
@@ -507,15 +534,15 @@
     pub fn mod_inverse(&self, n: &Integer) -> Integer {
         let mut t0 = Integer::zero();
         let mut t1 = Integer::one();
         let mut r0 = n.clone();
         let mut r1 = self.clone();
 
         while !r1.is_zero() {
-            let (q, r) = IntegerRing::new().quot_rem(&r0, &r1);
+            let (q, r) = Z.quot_rem(&r0, &r1);
             (t1, t0) = (&t0 - &(&q * &t1), t1);
             (r1, r0) = (r, r1);
         }
 
         if r0 > Integer::one() {
             panic!("{} is not invertible in ring {}", self, n);
         }
@@ -1375,15 +1402,15 @@
                 Integer::from_large(a.rem_euc(MultiPrecisionInteger::from(*b)))
             }
             (Integer::Large(a), Integer::Large(b)) => Integer::from_large(a.rem_euc(b).into()),
         }
     }
 }
 
-#[derive(Clone, Copy, PartialEq, Eq, Debug)]
+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
 pub struct MultiPrecisionIntegerRing;
 
 impl Display for MultiPrecisionIntegerRing {
     fn fmt(&self, _: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         Ok(())
     }
 }
```

### Comparing `symbolica-0.3.0/src/domains/rational.rs` & `symbolica-0.4.0/src/domains/rational.rs`

 * *Files 10% similar despite different names*

```diff
@@ -8,30 +8,36 @@
     integer::IntegerExt64, ops::Pow, Integer as MultiPrecisionInteger,
     Rational as MultiPrecisionRational,
 };
 
 use crate::{poly::gcd::LARGE_U32_PRIMES, printer::PrintOptions, utils};
 
 use super::{
-    finite_field::{FiniteField, FiniteFieldCore, FiniteFieldWorkspace, ToFiniteField},
-    integer::{Integer, IntegerRing},
+    finite_field::{FiniteField, FiniteFieldCore, FiniteFieldWorkspace, ToFiniteField, Zp},
+    integer::{Integer, Z},
     EuclideanDomain, Field, Ring,
 };
 
-#[derive(Clone, Copy, PartialEq, Debug)]
+/// The field of rational numbers.
+pub type Q = RationalField;
+/// The field of rational numbers.
+pub const Q: RationalField = RationalField::new();
+
+/// The field of rational numbers.
+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
 pub struct RationalField;
 
 impl Default for RationalField {
     fn default() -> Self {
         Self::new()
     }
 }
 
 impl RationalField {
-    pub fn new() -> RationalField {
+    pub const fn new() -> RationalField {
         RationalField
     }
 }
 
 /// A rational number.
 ///
 /// Explicit construction of `Rational::Natural`
@@ -56,14 +62,21 @@
 impl From<i64> for Rational {
     #[inline]
     fn from(value: i64) -> Self {
         Rational::Natural(value, 1)
     }
 }
 
+impl From<f64> for Rational {
+    #[inline]
+    fn from(value: f64) -> Self {
+        Rational::from_f64(value)
+    }
+}
+
 impl From<u64> for Rational {
     #[inline]
     fn from(value: u64) -> Self {
         if value <= i64::MAX as u64 {
             Rational::Natural(value as i64, 1)
         } else {
             Rational::Large(value.into())
@@ -139,15 +152,15 @@
 impl From<MultiPrecisionRational> for Rational {
     fn from(value: MultiPrecisionRational) -> Self {
         Rational::from_large(value)
     }
 }
 
 impl ToFiniteField<u32> for Rational {
-    fn to_finite_field(&self, field: &FiniteField<u32>) -> <FiniteField<u32> as Ring>::Element {
+    fn to_finite_field(&self, field: &Zp) -> <Zp as Ring>::Element {
         match self {
             &Rational::Natural(n, d) => {
                 let mut ff = field.to_element(n.rem_euclid(field.get_prime() as i64) as u32);
 
                 if d != 1 {
                     let df = field.to_element(d.rem_euclid(field.get_prime() as i64) as u32);
                     field.div_assign(&mut ff, &df);
@@ -198,18 +211,15 @@
                 return Rational::Natural(n, d);
             }
         }
 
         Rational::Large(r)
     }
 
-    pub fn from_finite_field_u32(
-        field: FiniteField<u32>,
-        element: &<FiniteField<u32> as Ring>::Element,
-    ) -> Rational {
+    pub fn from_finite_field_u32(field: Zp, element: &<Zp as Ring>::Element) -> Rational {
         Rational::Natural(field.from_element(element) as i64, 1)
     }
 
     pub fn is_negative(&self) -> bool {
         match self {
             Rational::Natural(n, _) => *n < 0,
             Rational::Large(r) => MultiPrecisionInteger::from(r.numer().signum_ref()) == -1,
@@ -307,14 +317,92 @@
                     Rational::Large(MultiPrecisionRational::from((*n, *d)).neg())
                 }
             }
             Rational::Large(r) => Rational::from_large(r.neg().into()),
         }
     }
 
+    /// Convert a floating point number to its exact rational number equivalent.
+    /// Use [`Rational::truncate_denominator`] to get an approximation with a smaller denominator.
+    pub fn from_f64(f: f64) -> Rational {
+        assert!(f.is_finite());
+
+        // taken from num-traits
+        let bits: u64 = f.to_bits();
+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
+        let mantissa = if exponent == 0 {
+            (bits & 0xfffffffffffff) << 1
+        } else {
+            (bits & 0xfffffffffffff) | 0x10000000000000
+        };
+        // Exponent bias + mantissa shift
+        exponent -= 1023 + 52;
+
+        // superfluous factors of 2 will be divided out in the conversion to rational
+        if exponent < 0 {
+            (
+                (sign as i64 * mantissa as i64).into(),
+                Integer::from(2).pow(-exponent as u64),
+            )
+                .into()
+        } else {
+            (
+                &Integer::from(sign as i64 * mantissa as i64)
+                    * &Integer::from(2).pow(exponent as u64),
+                1.into(),
+            )
+                .into()
+        }
+    }
+
+    /// Return a best approximation of the rational number where the denominator
+    /// is less than or equal to `max_denominator`.
+    pub fn truncate_denominator(&self, max_denominator: &Integer) -> Rational {
+        assert!(!max_denominator.is_zero() && !max_denominator.is_negative());
+
+        if &self.denominator() < max_denominator {
+            return self.clone();
+        }
+
+        let (mut p0, mut q0, mut p1, mut q1) = (
+            Integer::zero(),
+            Integer::one(),
+            Integer::one(),
+            Integer::zero(),
+        );
+
+        let (mut n, mut d) = (self.numerator().abs(), self.denominator());
+        loop {
+            let a = &n / &d;
+            let q2 = &q0 + &(&a * &q1);
+            if &q2 > max_denominator {
+                break;
+            }
+            (p1, p0, q0, q1) = (p0 + &(&a * &p1), p1, q1, q2);
+            (d, n) = (&n - &a * &d, d);
+        }
+
+        let k = &(max_denominator - &q0) / &q1;
+        let bound1: Rational = (p0 + &(&k * &p1), &q0 + &(&k * &q1)).into();
+        let bound2: Rational = (p1, q1).into();
+
+        let res = if (&bound2 - self).abs() <= (&bound1 - self).abs() {
+            bound2
+        } else {
+            bound1
+        };
+
+        if self.is_negative() {
+            res.neg()
+        } else {
+            res
+        }
+    }
+
     /// Reconstruct a rational number `q` from a value `v` in a prime field `p`,
     /// such that `q  v mod p`.
     ///
     /// From "Maximal Quotient Rational Reconstruction: An Almost
     /// Optimal Algorithm for Rational Reconstruction" by Monagan.
     pub fn maximal_quotient_reconstruction(
         v: &Integer,
@@ -351,28 +439,28 @@
                 Err("Could not reconstruct: u=0 and t <= m")
             };
         }
 
         let mut n = Integer::zero();
         let mut d = Integer::zero();
         let (mut t, mut old_t) = (Integer::one(), Integer::zero());
-        let (mut r, mut old_r) = (v.clone(), p.clone());
+        let (mut r, mut old_r) = (if v.is_negative() { v + p } else { v.clone() }, p.clone());
 
-        while !r.is_one() && old_r > acceptance_scale {
+        while !r.is_zero() && old_r > acceptance_scale {
             let q = &old_r / &r;
             if q > acceptance_scale {
                 n = r.clone();
                 d = t.clone();
                 acceptance_scale = q.clone();
             }
             (r, old_r) = (&old_r - &(&q * &r), r);
             (t, old_t) = (&old_t - &(&q * &t), t);
         }
 
-        if d.is_zero() || !IntegerRing::new().gcd(&n, &d).is_one() {
+        if d.is_zero() || !Z.gcd(&n, &d).is_one() {
             return Err("Reconstruction failed");
         }
         if d < Integer::zero() {
             n = n.neg();
             d = d.neg();
         }
 
@@ -381,26 +469,23 @@
 
     /// Return the rational number that corresponds to `f` evaluated at sample point `sample`,
     /// i.e. `f(sample)`, if such a number exists and if the evaluations were not unlucky.
     ///
     /// The procedure can be repeated with a different starting prime, by setting `prime_start`
     /// to a non-zero value.
     pub fn rational_reconstruction<
-        F: Fn(
-            &FiniteField<u32>,
-            &[<FiniteField<u32> as Ring>::Element],
-        ) -> <FiniteField<u32> as Ring>::Element,
+        F: Fn(&Zp, &[<Zp as Ring>::Element]) -> <Zp as Ring>::Element,
         R: Ring,
     >(
         f: F,
         sample: &[R::Element],
         prime_start: Option<usize>,
     ) -> Result<Rational, &'static str>
     where
-        FiniteField<u32>: FiniteFieldCore<u32>,
+        Zp: FiniteFieldCore<u32>,
         R::Element: ToFiniteField<u32>,
     {
         let mut cur_result = Integer::one();
         let mut prime_accum = Integer::one();
         let mut prime_sample_point = vec![];
         let mut prime_start = prime_start.unwrap_or(0);
 
@@ -721,15 +806,15 @@
     }
 }
 
 impl Add<Rational> for Rational {
     type Output = Rational;
 
     fn add(self, other: Rational) -> Self::Output {
-        RationalField::new().add(&self, &other)
+        Q.add(&self, &other)
     }
 }
 
 impl Sub<Rational> for Rational {
     type Output = Rational;
 
     fn sub(self, other: Rational) -> Self::Output {
@@ -737,31 +822,31 @@
     }
 }
 
 impl Mul<Rational> for Rational {
     type Output = Rational;
 
     fn mul(self, other: Rational) -> Self::Output {
-        RationalField::new().mul(&self, &other)
+        Q.mul(&self, &other)
     }
 }
 
 impl Div<Rational> for Rational {
     type Output = Rational;
 
     fn div(self, other: Rational) -> Self::Output {
-        RationalField::new().div(&self, &other)
+        Q.div(&self, &other)
     }
 }
 
 impl<'a> Add<&'a Rational> for Rational {
     type Output = Rational;
 
     fn add(self, other: &'a Rational) -> Self::Output {
-        RationalField::new().add(&self, other)
+        Q.add(&self, other)
     }
 }
 
 impl<'a> Sub<&'a Rational> for Rational {
     type Output = Rational;
 
     fn sub(self, other: &'a Rational) -> Self::Output {
@@ -769,110 +854,110 @@
     }
 }
 
 impl<'a> Mul<&'a Rational> for Rational {
     type Output = Rational;
 
     fn mul(self, other: &'a Rational) -> Self::Output {
-        RationalField::new().mul(&self, other)
+        Q.mul(&self, other)
     }
 }
 
 impl<'a> Div<&'a Rational> for Rational {
     type Output = Rational;
 
     fn div(self, other: &'a Rational) -> Self::Output {
-        RationalField::new().div(&self, other)
+        Q.div(&self, other)
     }
 }
 
 impl<'a, 'b> Add<&'a Rational> for &'b Rational {
     type Output = Rational;
 
     fn add(self, other: &'a Rational) -> Self::Output {
-        RationalField::new().add(self, other)
+        Q.add(self, other)
     }
 }
 
 impl<'a, 'b> Sub<&'a Rational> for &'b Rational {
     type Output = Rational;
 
     fn sub(self, other: &'a Rational) -> Self::Output {
         self.add(&other.neg())
     }
 }
 
 impl Neg for Rational {
     type Output = Self;
     fn neg(self) -> Self::Output {
-        RationalField::new().neg(&self)
+        Q.neg(&self)
     }
 }
 
 impl<'a, 'b> Mul<&'a Rational> for &'b Rational {
     type Output = Rational;
 
     fn mul(self, other: &'a Rational) -> Self::Output {
-        RationalField::new().mul(self, other)
+        Q.mul(self, other)
     }
 }
 
 impl<'a, 'b> Div<&'a Rational> for &'b Rational {
     type Output = Rational;
 
     fn div(self, other: &'a Rational) -> Self::Output {
-        RationalField::new().div(self, other)
+        Q.div(self, other)
     }
 }
 
 impl<'a> AddAssign<&'a Rational> for Rational {
     fn add_assign(&mut self, other: &'a Rational) {
-        RationalField::new().add_assign(self, other)
+        Q.add_assign(self, other)
     }
 }
 
 impl<'a> SubAssign<&'a Rational> for Rational {
     fn sub_assign(&mut self, other: &'a Rational) {
         self.add_assign(&other.neg())
     }
 }
 
 impl<'a> MulAssign<&'a Rational> for Rational {
     fn mul_assign(&mut self, other: &'a Rational) {
-        RationalField::new().mul_assign(self, other)
+        Q.mul_assign(self, other)
     }
 }
 
 impl<'a> DivAssign<&'a Rational> for Rational {
     fn div_assign(&mut self, other: &'a Rational) {
-        RationalField::new().div_assign(self, other)
+        Q.div_assign(self, other)
     }
 }
 
 impl AddAssign<Rational> for Rational {
     fn add_assign(&mut self, other: Rational) {
-        RationalField::new().add_assign(self, &other)
+        Q.add_assign(self, &other)
     }
 }
 
 impl SubAssign<Rational> for Rational {
     fn sub_assign(&mut self, other: Rational) {
         self.add_assign(&other.neg())
     }
 }
 
 impl MulAssign<Rational> for Rational {
     fn mul_assign(&mut self, other: Rational) {
-        RationalField::new().mul_assign(self, &other)
+        Q.mul_assign(self, &other)
     }
 }
 
 impl DivAssign<Rational> for Rational {
     fn div_assign(&mut self, other: Rational) {
-        RationalField::new().div_assign(self, &other)
+        Q.div_assign(self, &other)
     }
 }
 
 impl<'a> std::iter::Sum<&'a Self> for Rational {
     fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {
         iter.fold(Rational::zero(), |a, b| a + b)
     }
```

### Comparing `symbolica-0.3.0/src/domains.rs` & `symbolica-0.4.0/src/domains.rs`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,22 @@
+pub mod algebraic_number;
 pub mod factorized_rational_polynomial;
 pub mod finite_field;
 pub mod float;
 pub mod integer;
-pub mod linear_system;
 pub mod rational;
 pub mod rational_polynomial;
 
 use std::fmt::{Debug, Display, Error, Formatter};
+use std::hash::Hash;
 
 use crate::printer::PrintOptions;
 
-pub trait Ring: Clone + PartialEq + Debug + Display {
-    type Element: Clone + PartialEq + PartialOrd + Debug;
+pub trait Ring: Clone + PartialEq + Eq + Hash + Debug + Display {
+    type Element: Clone + PartialEq + Eq + Hash + PartialOrd + Debug;
 
     fn add(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
     fn sub(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
     fn mul(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
     fn add_assign(&self, a: &mut Self::Element, b: &Self::Element);
     fn sub_assign(&self, a: &mut Self::Element, b: &Self::Element);
     fn mul_assign(&self, a: &mut Self::Element, b: &Self::Element);
```

### Comparing `symbolica-0.3.0/src/evaluate.rs` & `symbolica-0.4.0/src/evaluate.rs`

 * *Files 17% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 use ahash::HashMap;
 
 use crate::{
+    atom::{Atom, AtomView, Symbol},
     coefficient::CoefficientView,
     domains::{float::Real, rational::Rational},
-    representations::{Atom, AtomView, Symbol},
     state::State,
 };
 
 type EvalFnType<T> = Box<
     dyn Fn(
         &[T],
         &HashMap<AtomView<'_>, T>,
@@ -68,15 +68,18 @@
                 CoefficientView::FiniteField(_, _) => {
                     unimplemented!("Finite field not yet supported for evaluation")
                 }
                 CoefficientView::RationalPolynomial(_) => unimplemented!(
                     "Rational polynomial coefficient not yet supported for evaluation"
                 ),
             },
-            AtomView::Var(v) => panic!("Variable id {:?} not in constant map", v.get_symbol()),
+            AtomView::Var(v) => panic!(
+                "Variable {} not in constant map",
+                State::get_name(v.get_symbol())
+            ),
             AtomView::Fun(f) => {
                 let name = f.get_symbol();
                 if [State::EXP, State::LOG, State::SIN, State::COS, State::SQRT].contains(&name) {
                     assert!(f.get_nargs() == 1);
                     let arg = f.iter().next().unwrap();
                     let arg_eval = arg.evaluate(const_map, function_map, cache);
 
@@ -96,15 +99,15 @@
 
                 let mut args = Vec::with_capacity(f.get_nargs());
                 for arg in f.iter() {
                     args.push(arg.evaluate(const_map, function_map, cache));
                 }
 
                 let Some(fun) = function_map.get(&f.get_symbol()) else {
-                    panic!("Missing function with id {:?}", f.get_symbol()); // TODO: use state to get name
+                    panic!("Missing function {}", State::get_name(f.get_symbol()));
                 };
                 let eval = fun.get()(&args, const_map, function_map, cache);
 
                 cache.insert(*self, eval);
                 eval
             }
             AtomView::Pow(p) => {
@@ -139,7 +142,51 @@
                     r += arg.evaluate(const_map, function_map, cache);
                 }
                 r
             }
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use ahash::HashMap;
+
+    use crate::{atom::Atom, evaluate::EvaluationFn, state::State};
+
+    #[test]
+    fn evaluate() {
+        let x = State::get_symbol("v1");
+        let f = State::get_symbol("f1");
+        let g = State::get_symbol("f2");
+        let p0 = Atom::parse("v2(0)").unwrap();
+        let a = Atom::parse("v1*cos(v1) + f1(v1, 1)^2 + f2(f2(v1)) + v2(0)").unwrap();
+
+        let mut const_map = HashMap::default();
+        let mut fn_map: HashMap<_, EvaluationFn<_>> = HashMap::default();
+        let mut cache = HashMap::default();
+
+        // x = 6 and p(0) = 7
+        let v = Atom::new_var(x);
+        const_map.insert(v.as_view(), 6.);
+        const_map.insert(p0.as_view(), 7.);
+
+        // f(x, y) = x^2 + y
+        fn_map.insert(
+            f,
+            EvaluationFn::new(Box::new(|args: &[f64], _, _, _| {
+                args[0] * args[0] + args[1]
+            })),
+        );
+
+        // g(x) = f(x, 3)
+        fn_map.insert(
+            g,
+            EvaluationFn::new(Box::new(move |args: &[f64], var_map, fn_map, cache| {
+                fn_map.get(&f).unwrap().get()(&[args[0], 3.], var_map, fn_map, cache)
+            })),
+        );
+
+        let r = a.evaluate::<f64>(&const_map, &fn_map, &mut cache);
+        assert_eq!(r, 2905.761021719902);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/expand.rs` & `symbolica-0.4.0/src/expand.rs`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 use std::ops::DerefMut;
 
 use smallvec::SmallVec;
 
 use crate::{
+    atom::{Atom, AtomView},
     coefficient::CoefficientView,
     combinatorics::CombinationWithReplacementIterator,
     domains::integer::Integer,
-    representations::{Atom, AtomView},
     state::{RecycledAtom, Workspace},
 };
 
 impl Atom {
     /// Expand an expression.
     pub fn expand(&self) -> Atom {
         self.as_view().expand()
@@ -146,32 +146,28 @@
 
                     true
                 } else if let AtomView::Mul(m) = new_base.as_view() {
                     let mut mul_h = workspace.new_atom();
                     let mul = mul_h.to_mul();
 
                     let mut exp_h = workspace.new_atom();
-                    exp_h.to_num((num as i64).into());
+                    if negative {
+                        exp_h.to_num((-(num as i64)).into());
+                    } else {
+                        exp_h.to_num((num as i64).into());
+                    }
 
                     for arg in m.iter() {
                         let mut pow_h = workspace.new_atom();
                         pow_h.to_pow(arg, exp_h.as_view());
                         mul.extend(pow_h.as_view());
                     }
 
-                    if negative {
-                        let mut num_h = workspace.new_atom();
-                        num_h.to_num((-1).into());
+                    mul_h.as_view().normalize(workspace, out);
 
-                        let mut pow_h = workspace.new_atom();
-                        pow_h.to_pow(mul_h.as_view(), num_h.as_view());
-                        pow_h.as_view().normalize(workspace, out);
-                    } else {
-                        mul_h.as_view().normalize(workspace, out);
-                    }
                     true
                 } else {
                     let mut pow_h = workspace.new_atom();
                     let pow = pow_h.to_pow(new_base.as_view(), new_exp.as_view());
                     pow.set_normalized(!changed);
                     pow_h.as_view().normalize(workspace, out);
                     changed
@@ -269,7 +265,40 @@
             _ => {
                 out.set_from_view(self);
                 false
             }
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::atom::Atom;
+
+    #[test]
+    fn exponent() {
+        let exp = Atom::parse("(1+v1+v2)^4").unwrap().expand();
+        let res = Atom::parse("4*v1+4*v2+6*v1^2+4*v1^3+v1^4+6*v2^2+4*v2^3+v2^4+12*v1*v2+12*v1*v2^2+4*v1*v2^3+12*v1^2*v2+6*v1^2*v2^2+4*v1^3*v2+1").unwrap();
+        assert_eq!(exp, res);
+    }
+
+    #[test]
+    fn association() {
+        let exp = Atom::parse("(1+v1)*(2+v2)*(3+v1)").unwrap().expand();
+        let res = Atom::parse("8*v1+3*v2+2*v1^2+4*v1*v2+v1^2*v2+6").unwrap();
+        assert_eq!(exp, res);
+    }
+
+    #[test]
+    fn mul_pow() {
+        let exp = Atom::parse("(v1*v2*2)^3*2").unwrap().expand();
+        let res = Atom::parse("v1^3*v2^3*16").unwrap();
+        assert_eq!(exp, res);
+    }
+
+    #[test]
+    fn mul_pow_neg() {
+        let exp = Atom::parse("(v1*v2*2)^-3").unwrap().expand();
+        let res = Atom::parse("8^-1*v1^-3*v2^-3").unwrap();
+        assert_eq!(exp, res);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/id.rs` & `symbolica-0.4.0/src/id.rs`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,12 @@
+use ahash::HashSet;
 use dyn_clone::DynClone;
 
 use crate::{
-    representations::{default::ListSlice, Atom, AtomView, Num, SliceType, Symbol},
+    atom::{representation::ListSlice, Atom, AtomView, Num, SliceType, Symbol},
     state::{State, Workspace},
     transformer::{Transformer, TransformerError},
 };
 
 #[derive(Clone)]
 pub enum Pattern {
     Literal(Atom),
@@ -17,28 +18,176 @@
     Transformer(Box<(Option<Pattern>, Vec<Transformer>)>),
 }
 
 impl Atom {
     pub fn into_pattern(&self) -> Pattern {
         Pattern::from_view(self.as_view(), true)
     }
+
+    /// Get all symbols in the expression, optionally including function symbols.
+    pub fn get_all_symbols(&self, include_function_symbols: bool) -> HashSet<Symbol> {
+        let mut out = HashSet::default();
+        self.as_view()
+            .get_all_symbols_impl(include_function_symbols, &mut out);
+        out
+    }
+
+    /// Returns true iff `self` contains the symbol `s`.
+    pub fn contains_symbol(&self, s: Symbol) -> bool {
+        self.as_view().contains_symbol(s)
+    }
 }
 
 impl<'a> AtomView<'a> {
     pub fn into_pattern(self) -> Pattern {
         Pattern::from_view(self, true)
     }
+
+    /// Get all symbols in the expression, optionally including function symbols.
+    pub fn get_all_symbols(&self, include_function_symbols: bool) -> HashSet<Symbol> {
+        let mut out = HashSet::default();
+        self.get_all_symbols_impl(include_function_symbols, &mut out);
+        out
+    }
+
+    fn get_all_symbols_impl(&self, include_function_symbols: bool, out: &mut HashSet<Symbol>) {
+        match self {
+            AtomView::Num(_) => {}
+            AtomView::Var(v) => {
+                out.insert(v.get_symbol());
+            }
+            AtomView::Fun(f) => {
+                if include_function_symbols {
+                    out.insert(f.get_symbol());
+                }
+                for arg in f.iter() {
+                    arg.get_all_symbols_impl(include_function_symbols, out);
+                }
+            }
+            AtomView::Pow(p) => {
+                let (base, exp) = p.get_base_exp();
+                base.get_all_symbols_impl(include_function_symbols, out);
+                exp.get_all_symbols_impl(include_function_symbols, out);
+            }
+            AtomView::Mul(m) => {
+                for child in m.iter() {
+                    child.get_all_symbols_impl(include_function_symbols, out);
+                }
+            }
+            AtomView::Add(a) => {
+                for child in a.iter() {
+                    child.get_all_symbols_impl(include_function_symbols, out);
+                }
+            }
+        }
+    }
+
+    /// Returns true iff `self` contains the symbol `s`.
+    pub fn contains_symbol(&self, s: Symbol) -> bool {
+        match self {
+            AtomView::Num(_) => false,
+            AtomView::Var(v) => v.get_symbol() == s,
+            AtomView::Fun(f) => {
+                if f.get_symbol() == s {
+                    return true;
+                }
+
+                for arg in f.iter() {
+                    if arg.contains_symbol(s) {
+                        return true;
+                    }
+                }
+                false
+            }
+            AtomView::Pow(p) => {
+                let (base, exp) = p.get_base_exp();
+                base.contains_symbol(s) || exp.contains_symbol(s)
+            }
+            AtomView::Mul(m) => m.iter().any(|x| x.contains_symbol(s)),
+            AtomView::Add(a) => a.iter().any(|x| x.contains_symbol(s)),
+        }
+    }
 }
 
 impl Pattern {
     pub fn parse(input: &str) -> Result<Pattern, String> {
         // TODO: use workspace instead of owned atom
         Ok(Atom::parse(input)?.into_pattern())
     }
 
+    /// Convert the pattern to an atom, if there are not transformers present.
+    pub fn to_atom(&self) -> Result<Atom, &'static str> {
+        Workspace::get_local().with(|ws| {
+            let mut out = Atom::new();
+            self.to_atom_impl(ws, &mut out)?;
+            Ok(out)
+        })
+    }
+
+    fn to_atom_impl(&self, ws: &Workspace, out: &mut Atom) -> Result<(), &'static str> {
+        match self {
+            Pattern::Literal(a) => {
+                out.set_from_view(&a.as_view());
+            }
+            Pattern::Wildcard(s) => {
+                out.to_var(*s);
+            }
+            Pattern::Fn(s, a) => {
+                let mut f = ws.new_atom();
+                let fun = f.to_fun(*s);
+
+                for arg in a {
+                    let mut arg_h = ws.new_atom();
+                    arg.to_atom_impl(ws, &mut arg_h)?;
+                    fun.add_arg(arg_h.as_view());
+                }
+
+                f.as_view().normalize(ws, out);
+            }
+            Pattern::Pow(p) => {
+                let mut base = ws.new_atom();
+                p[0].to_atom_impl(ws, &mut base)?;
+
+                let mut exp = ws.new_atom();
+                p[1].to_atom_impl(ws, &mut exp)?;
+
+                let mut pow_h = ws.new_atom();
+                pow_h.to_pow(base.as_view(), exp.as_view());
+                pow_h.as_view().normalize(ws, out);
+            }
+            Pattern::Mul(m) => {
+                let mut mul_h = ws.new_atom();
+                let mul = mul_h.to_mul();
+
+                for arg in m {
+                    let mut arg_h = ws.new_atom();
+                    arg.to_atom_impl(ws, &mut arg_h)?;
+                    mul.extend(arg_h.as_view());
+                }
+
+                mul_h.as_view().normalize(ws, out);
+            }
+            Pattern::Add(a) => {
+                let mut add_h = ws.new_atom();
+                let add = add_h.to_add();
+
+                for arg in a {
+                    let mut arg_h = ws.new_atom();
+                    arg.to_atom_impl(ws, &mut arg_h)?;
+                    add.extend(arg_h.as_view());
+                }
+
+                add_h.as_view().normalize(ws, out);
+            }
+            Pattern::Transformer(_) => Err("Cannot convert transformer to atom")?,
+        }
+
+        Ok(())
+    }
+
     pub fn add(&self, rhs: &Self, workspace: &Workspace) -> Self {
         if let Pattern::Literal(l1) = self {
             if let Pattern::Literal(l2) = rhs {
                 // create new literal
                 let mut e = workspace.new_atom();
                 let a = e.to_add();
 
@@ -299,15 +448,14 @@
             Pattern::Literal(oa)
         }
     }
 
     /// Substitute the wildcards in the pattern with the values in the match stack.
     pub fn substitute_wildcards(
         &self,
-
         workspace: &Workspace,
         out: &mut Atom,
         match_stack: &MatchStack,
     ) -> Result<(), TransformerError> {
         match self {
             Pattern::Wildcard(name) => {
                 if let Some(w) = match_stack.get(*name) {
@@ -500,15 +648,14 @@
     }
 
     /// Return an iterator that replaces the pattern in the target once.
     pub fn replace_iter<'a>(
         &'a self,
         target: AtomView<'a>,
         rhs: &'a Pattern,
-
         conditions: &'a Condition<WildcardAndRestriction>,
         settings: &'a MatchSettings,
     ) -> ReplaceIterator<'a, 'a> {
         ReplaceIterator::new(self, target, rhs, conditions, settings)
     }
 
     /// Replace all occurrences of the pattern in the target
@@ -554,14 +701,15 @@
     ) -> bool {
         let matched = self.replace_all_no_norm(
             target,
             rhs,
             workspace,
             conditions.unwrap_or(&Condition::default()),
             settings.unwrap_or(&MatchSettings::default()),
+            0,
             out,
         );
 
         if matched {
             let mut norm = workspace.new_atom();
             out.as_view().normalize(workspace, &mut norm);
             std::mem::swap(out, &mut norm);
@@ -574,19 +722,27 @@
     fn replace_all_no_norm(
         &self,
         target: AtomView<'_>,
         rhs: &Pattern,
         workspace: &Workspace,
         conditions: &Condition<WildcardAndRestriction>,
         settings: &MatchSettings,
+        level: usize,
         out: &mut Atom,
     ) -> bool {
-        let mut match_stack = MatchStack::new(conditions, settings);
+        if let Some(max_level) = settings.level_range.1 {
+            if level > max_level {
+                out.set_from_view(&target);
+                return false;
+            }
+        }
+
+        if level >= settings.level_range.0 && self.could_match(target) {
+            let mut match_stack = MatchStack::new(conditions, settings);
 
-        if self.could_match(target) {
             let mut it = AtomMatchIterator::new(self, target);
             //let mut it = SubSliceIterator::new(self, target, &match_stack, true);
             if let Some((_, used_flags)) = it.next(&mut match_stack) {
                 let mut rhs_subs = workspace.new_atom();
                 rhs.substitute_wildcards(workspace, &mut rhs_subs, &match_stack)
                     .unwrap(); // TODO: escalate?
 
@@ -640,14 +796,15 @@
 
                     submatch |= self.replace_all_no_norm(
                         child,
                         rhs,
                         workspace,
                         conditions,
                         settings,
+                        level + 1,
                         &mut child_buf,
                     );
 
                     out.add_arg(child_buf.as_view());
                 }
 
                 out.set_normalized(!submatch && f.is_normalized());
@@ -659,24 +816,34 @@
                 let mut base_out = workspace.new_atom();
                 let mut submatch = self.replace_all_no_norm(
                     base,
                     rhs,
                     workspace,
                     conditions,
                     settings,
+                    if settings.level_is_tree_depth {
+                        level + 1
+                    } else {
+                        level
+                    },
                     &mut base_out,
                 );
 
                 let mut exp_out = workspace.new_atom();
                 submatch |= self.replace_all_no_norm(
                     exp,
                     rhs,
                     workspace,
                     conditions,
                     settings,
+                    if settings.level_is_tree_depth {
+                        level + 1
+                    } else {
+                        level
+                    },
                     &mut exp_out,
                 );
 
                 let out = out.to_pow(base_out.as_view(), exp_out.as_view());
                 out.set_normalized(!submatch && p.is_normalized());
                 submatch
             }
@@ -689,14 +856,19 @@
 
                     submatch |= self.replace_all_no_norm(
                         child,
                         rhs,
                         workspace,
                         conditions,
                         settings,
+                        if settings.level_is_tree_depth {
+                            level + 1
+                        } else {
+                            level
+                        },
                         &mut child_buf,
                     );
 
                     mul.extend(child_buf.as_view());
                 }
 
                 mul.set_has_coefficient(m.has_coefficient());
@@ -711,14 +883,19 @@
 
                     submatch |= self.replace_all_no_norm(
                         child,
                         rhs,
                         workspace,
                         conditions,
                         settings,
+                        if settings.level_is_tree_depth {
+                            level + 1
+                        } else {
+                            level
+                        },
                         &mut child_buf,
                     );
 
                     out.extend(child_buf.as_view());
                 }
                 out.set_normalized(!submatch && a.is_normalized());
                 submatch
@@ -731,15 +908,14 @@
 
         submatch
     }
 
     pub fn pattern_match<'a>(
         &'a self,
         target: AtomView<'a>,
-
         conditions: &'a Condition<WildcardAndRestriction>,
         settings: &'a MatchSettings,
     ) -> PatternAtomTreeIterator<'a, 'a> {
         PatternAtomTreeIterator::new(self, target, conditions, settings)
     }
 }
 
@@ -1129,17 +1305,25 @@
                 let f = out.to_fun(*n);
                 f.set_normalized(true);
             }
         }
     }
 }
 
+/// Settings related to pattern matching.
 #[derive(Default, Clone)]
 pub struct MatchSettings {
+    /// Specifies wildcards that try to match as little as possible.
     pub non_greedy_wildcards: Vec<Symbol>,
+    /// Specifies the `[min,max]` level at which the pattern is allowed to match.
+    /// The first level is 0 and the level is increased when entering a function, or going one level deeper in the expression tree,
+    /// depending on `level_is_tree_depth`.
+    pub level_range: (usize, Option<usize>),
+    /// Determine whether a level reflects the expression tree depth or the function depth.
+    pub level_is_tree_depth: bool,
 }
 
 /// An insertion-ordered map of wildcard identifiers to a subexpressions.
 /// It keeps track of all conditions on wildcards and will check them
 /// before inserting.
 pub struct MatchStack<'a, 'b> {
     stack: Vec<(Symbol, Match<'a>)>,
@@ -1944,90 +2128,107 @@
             self.iterators.pop();
         }
     }
 }
 
 /// Iterator over the atoms of an expression tree.
 pub struct AtomTreeIterator<'a> {
-    stack: Vec<(Option<usize>, AtomView<'a>)>,
+    stack: Vec<(Option<usize>, usize, AtomView<'a>)>,
+    settings: MatchSettings,
 }
 
 impl<'a> AtomTreeIterator<'a> {
-    pub fn new(target: AtomView<'a>) -> AtomTreeIterator<'a> {
+    pub fn new(target: AtomView<'a>, settings: MatchSettings) -> AtomTreeIterator<'a> {
         AtomTreeIterator {
-            stack: vec![(None, target)],
+            stack: vec![(None, 0, target)],
+            settings,
         }
     }
 }
 
 impl<'a> Iterator for AtomTreeIterator<'a> {
     type Item = (Vec<usize>, AtomView<'a>);
 
     /// Return the next position and atom in the tree.
     fn next(&mut self) -> Option<Self::Item> {
-        while let Some((ind, atom)) = self.stack.pop() {
+        while let Some((ind, level, atom)) = self.stack.pop() {
+            if let Some(max_level) = self.settings.level_range.1 {
+                if level > max_level {
+                    continue;
+                }
+            }
+
             if let Some(ind) = ind {
                 let slice = match atom {
                     AtomView::Fun(f) => f.to_slice(),
                     AtomView::Pow(p) => p.to_slice(),
                     AtomView::Mul(m) => m.to_slice(),
                     AtomView::Add(a) => a.to_slice(),
                     _ => {
                         continue; // not iterable
                     }
                 };
 
                 if ind < slice.len() {
                     let new_atom = slice.get(ind);
 
-                    self.stack.push((Some(ind + 1), atom));
-                    self.stack.push((None, new_atom)); // push the new element on the stack
+                    self.stack.push((Some(ind + 1), level, atom));
+                    self.stack.push((None, level, new_atom)); // push the new element on the stack
                 }
             } else {
                 // return full match and set the position to the first sub element
                 let location = self
                     .stack
                     .iter()
-                    .map(|(ind, _)| ind.unwrap() - 1)
+                    .map(|(ind, _, _)| ind.unwrap() - 1)
                     .collect::<Vec<_>>();
-                self.stack.push((Some(0), atom));
-                return Some((location, atom));
+
+                let new_level = if let AtomView::Fun(_) = atom {
+                    level + 1
+                } else if self.settings.level_is_tree_depth {
+                    level + 1
+                } else {
+                    level
+                };
+
+                self.stack.push((Some(0), new_level, atom));
+
+                if level >= self.settings.level_range.0 {
+                    return Some((location, atom));
+                }
             }
         }
 
         None
     }
 }
 
 /// Match a pattern to any subexpression of a target expression.
 pub struct PatternAtomTreeIterator<'a, 'b> {
     pattern: &'b Pattern,
     atom_tree_iterator: AtomTreeIterator<'a>,
     current_target: Option<AtomView<'a>>,
     pattern_iter: Option<AtomMatchIterator<'a, 'b>>,
-
     match_stack: MatchStack<'a, 'b>,
     tree_pos: Vec<usize>,
     first_match: bool,
 }
 
 impl<'a: 'b, 'b> PatternAtomTreeIterator<'a, 'b> {
     pub fn new(
         pattern: &'b Pattern,
         target: AtomView<'a>,
-
         conditions: &'a Condition<WildcardAndRestriction>,
         settings: &'a MatchSettings,
     ) -> PatternAtomTreeIterator<'a, 'b> {
         PatternAtomTreeIterator {
             pattern,
-            atom_tree_iterator: AtomTreeIterator::new(target),
+            atom_tree_iterator: AtomTreeIterator::new(target, settings.clone()),
             current_target: None,
             pattern_iter: None,
-
             match_stack: MatchStack::new(conditions, settings),
             tree_pos: Vec::new(),
             first_match: false,
         }
     }
 
     pub fn next(&mut self) -> Option<(&[usize], Vec<bool>, AtomView<'a>, &MatchStack<'a, 'b>)> {
@@ -2073,15 +2274,14 @@
 }
 
 impl<'a: 'b, 'b> ReplaceIterator<'a, 'b> {
     pub fn new(
         pattern: &'b Pattern,
         target: AtomView<'a>,
         rhs: &'b Pattern,
-
         conditions: &'a Condition<WildcardAndRestriction>,
         settings: &'a MatchSettings,
     ) -> ReplaceIterator<'a, 'b> {
         ReplaceIterator {
             pattern_tree_iterator: PatternAtomTreeIterator::new(
                 pattern, target, conditions, settings,
             ),
@@ -2216,23 +2416,43 @@
             Workspace::get_local().with(|ws| {
                 let mut new_rhs = ws.new_atom();
 
                 self.rhs
                     .substitute_wildcards(ws, &mut new_rhs, match_stack)
                     .unwrap(); // TODO: escalate?
 
+                let mut h = ws.new_atom();
                 ReplaceIterator::copy_and_replace(
-                    out,
+                    &mut h,
                     position,
                     &used_flags,
                     self.target,
                     new_rhs.as_view(),
                     ws,
                 );
+                h.as_view().normalize(&ws, out);
             });
 
             Some(())
         } else {
             None
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::atom::Atom;
+
+    use super::Pattern;
+
+    #[test]
+    fn overlap() {
+        let a = Atom::parse("(x*(y+y^2+1)+y^2 + y)").unwrap();
+        let p = Pattern::parse("y+y^x_").unwrap();
+        let rhs = Pattern::parse("y*(1+y^(x_-1))").unwrap();
+
+        let r = p.replace_all(a.as_view(), &rhs, None, None);
+        let res = Atom::parse("x*(y+y^2+1)+y*(y+1)").unwrap();
+        assert_eq!(r, res);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/lib.rs` & `symbolica-0.4.0/src/lib.rs`

 * *Files 10% similar despite different names*

```diff
@@ -1,7 +1,28 @@
+//! Symbolica is a blazing fast computer algebra system.
+//!
+//! It can be used to perform mathematical operations,
+//! such as symbolic differentiation, integration, simplification,
+//! pattern matching and solving equations.
+//!
+//! For example:
+//!
+//! ```
+//! use symbolica::{atom::Atom, state::State};
+//!
+//! fn main() {
+//!     let input = Atom::parse("x^2*log(2*x + y) + exp(3*x)").unwrap();
+//!     let a = input.derivative(State::get_symbol("x"));
+//!     println!("d({})/dx = {}:", input, a);
+//! }
+//! ```
+//!
+//! Check out the [guide](https://symbolica.io/docs/get_started.html) for more information, examples,
+//! and additional documentation.
+
 use std::{
     collections::HashMap,
     env,
     io::{Read, Write},
     net::{TcpListener, TcpStream},
     process::abort,
     thread::ThreadId,
@@ -9,28 +30,28 @@
 };
 
 use colored::Colorize;
 use once_cell::sync::OnceCell;
 use tinyjson::JsonValue;
 
 pub mod api;
+pub mod atom;
 pub mod coefficient;
 pub mod collect;
 pub mod combinatorics;
 pub mod derivative;
 pub mod domains;
 pub mod evaluate;
 pub mod expand;
 pub mod id;
 pub mod normalize;
 pub mod numerical_integration;
 pub mod parser;
 pub mod poly;
 pub mod printer;
-pub mod representations;
 pub mod solve;
 pub mod state;
 pub mod streaming;
 pub mod tensors;
 pub mod transformer;
 pub mod utils;
```

### Comparing `symbolica-0.3.0/src/normalize.rs` & `symbolica-0.4.0/src/normalize.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 use std::{cmp::Ordering, ops::DerefMut};
 
 use smallvec::SmallVec;
 
 use crate::{
+    atom::{Atom, AtomView, Fun, Symbol},
     coefficient::{Coefficient, CoefficientView},
-    domains::{integer::IntegerRing, rational::RationalField},
+    domains::{integer::Z, rational::Q},
     poly::Variable,
-    representations::{Atom, AtomView, Fun, Symbol},
     state::{RecycledAtom, State, Workspace},
 };
 
 impl<'a> AtomView<'a> {
     /// Compare two atoms.
     pub fn cmp(&self, other: &AtomView<'_>) -> Ordering {
         if self == other {
@@ -303,24 +303,26 @@
                             self.to_num(1.into());
                         } else if new_exp.to_num_view().is_one() {
                             self.set_from_view(&base2);
                         } else {
                             p1.set_from_base_and_exp(base2, helper.as_view());
                         }
 
+                        self.set_normalized(true);
                         return true;
                     }
                 }
 
                 let new_exp = helper.to_add();
                 new_exp.extend(exp1);
                 new_exp.extend(exp2);
                 let mut helper2 = workspace.new_atom();
                 helper.as_view().normalize(workspace, &mut helper2);
                 p1.set_from_base_and_exp(base2, helper2.as_view());
+                p1.set_normalized(true);
                 return true;
             }
         }
 
         // x * x^n = x^(n+1)
         if let Atom::Pow(p) = other {
             let pv = p.to_pow_view();
@@ -345,14 +347,15 @@
                     new_exp.extend(self.as_view());
                     new_exp.extend(exp);
                     let mut helper2 = workspace.new_atom();
                     helper.as_view().normalize(workspace, &mut helper2);
                     self.to_pow(base, helper2.as_view());
                 }
 
+                self.set_normalized(true);
                 return true;
             } else {
                 return false;
             }
         }
 
         // simplify num1 * num2
@@ -373,14 +376,15 @@
                     return true;
                 }
             }
 
             // add powers
             let exp = other.to_num(2.into());
             helper.to_pow(self.as_view(), AtomView::Num(exp.to_num_view()));
+            helper.set_normalized(true);
 
             // overwrite self with the new power view
             std::mem::swap(self, helper);
 
             return true;
         }
 
@@ -466,14 +470,16 @@
 
                     if has_coeff {
                         m.replace_last(on.to_num_view().as_view());
                     } else {
                         m.extend(on.to_num_view().as_view());
                     }
 
+                    m.set_has_coefficient(true);
+                    m.set_normalized(true);
                     return true;
                 }
             } else {
                 if non_coeff1.len() != 1 || other != slice.get(0) {
                     return false;
                 }
 
@@ -488,14 +494,15 @@
                     self.to_num(new_coeff);
                     return true;
                 }
 
                 let on = helper.to_num(new_coeff);
 
                 m.replace_last(on.to_num_view().as_view());
+                m.set_normalized(true);
 
                 return true;
             }
         } else if let AtomView::Mul(m) = other {
             let slice = m.to_slice();
 
             if slice.len() != 2 {
@@ -523,16 +530,19 @@
 
                 if let Atom::Mul(m) = self {
                     if has_num {
                         m.replace_last(on.to_num_view().as_view());
                     } else {
                         m.extend(on.to_num_view().as_view());
                     }
+
+                    m.set_has_coefficient(true);
                 }
 
+                self.set_normalized(true);
                 return true;
             }
         } else if self.as_view() == other {
             let mul = helper.to_mul();
             mul.extend(self.as_view());
             self.to_num((2, 1).into());
             mul.extend(self.as_view());
@@ -758,32 +768,27 @@
                 if id == State::COEFF && out_f.to_fun_view().get_nargs() == 1 {
                     let arg = out_f.to_fun_view().iter().next().unwrap();
                     if let AtomView::Num(_) = arg {
                         let mut buffer = workspace.new_atom();
                         buffer.set_from_view(&arg);
                         out.set_from_view(&buffer.as_view());
                         return;
-                    } else if let Ok(r) = arg.to_rational_polynomial_with_ws(
-                        workspace,
-                        &RationalField::new(),
-                        &IntegerRing::new(),
-                        None, // TODO: get a compatible one from the state?
-                    ) {
-                        // disallow wildcards in the variable map
-                        if let Some(v) = r.numerator.var_map.as_ref() {
-                            if v.iter().all(|v| {
-                                if let Variable::Symbol(v) = v {
-                                    v.get_wildcard_level() == 0
-                                } else {
-                                    false
-                                }
-                            }) {
-                                out.to_num(Coefficient::RationalPolynomial(r));
-                                return;
+                    } else {
+                        let r = arg.to_rational_polynomial(&Q, &Z, None);
+
+                        // disallow wildcards as variables
+                        if r.numerator.get_vars_ref().iter().all(|v| {
+                            if let Variable::Symbol(v) = v {
+                                v.get_wildcard_level() == 0
+                            } else {
+                                false
                             }
+                        }) {
+                            out.to_num(Coefficient::RationalPolynomial(r));
+                            return;
                         }
                     }
                 }
 
                 if id.is_linear() {
                     // linearize sums
                     if out_f
@@ -844,16 +849,14 @@
                                         if let AtomView::Num(n) = a {
                                             coeff = coeff * n.get_coeff_view().to_owned();
                                         } else {
                                             mul.extend(a);
                                         }
                                     }
 
-                                    mul.set_has_coefficient(false);
-                                    mul.set_normalized(true);
                                     nf.add_arg(stripped.as_view());
                                 } else {
                                     nf.add_arg(a);
                                 }
                             } else {
                                 nf.add_arg(a);
                             }
@@ -1051,15 +1054,15 @@
                         for c in new_add.iter() {
                             if let AtomView::Num(n) = c {
                                 if n.is_zero() {
                                     continue;
                                 }
                             }
 
-                            ns.extend(r);
+                            ns.extend(c);
                         }
                     } else {
                         if let AtomView::Num(n) = r {
                             if n.is_zero() {
                                 continue;
                             }
                         }
@@ -1123,7 +1126,28 @@
                         out_add.set_normalized(true);
                     }
                 }
             }
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{atom::Atom, state::State};
+
+    #[test]
+    fn linear_symmetric() {
+        let res = Atom::parse("fsl1(v2+2*v3,v1+3*v2-v3)").unwrap();
+        let refr =
+            Atom::parse("fsl1(v1,v2)+2*fsl1(v1,v3)+3*fsl1(v2,v2)+5*fsl1(v2,v3)-2*fsl1(v3,v3)")
+                .unwrap();
+        assert_eq!(res, refr);
+    }
+
+    #[test]
+    fn mul_complex_i() {
+        let res = Atom::new_var(State::I) * &Atom::new_var(State::E) * &Atom::new_var(State::I);
+        let refr = -Atom::new_var(State::E);
+        assert_eq!(res, refr);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/numerical_integration.rs` & `symbolica-0.4.0/src/numerical_integration.rs`

 * *Files 1% similar despite different names*

```diff
@@ -1068,7 +1068,57 @@
         for _ in 0..stream_id {
             state.jump();
         }
 
         Self { state }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use std::f64::consts::PI;
+
+    use super::{ContinuousGrid, DiscreteGrid, Grid, MonteCarloRng, Sample};
+
+    #[test]
+    fn multichannel() {
+        // Integrate x*pi + x^2 using multi-channeling:
+        // x*pi and x^2 will have their own Vegas grid
+        let fs = [|x: f64| (x * PI).sin(), |x: f64| x * x];
+
+        let mut grid = DiscreteGrid::new(
+            vec![
+                Some(Grid::Continuous(ContinuousGrid::new(
+                    1, 10, 1000, None, false,
+                ))),
+                Some(Grid::Continuous(ContinuousGrid::new(
+                    1, 10, 1000, None, false,
+                ))),
+            ],
+            0.01,
+            false,
+        );
+
+        let mut rng = MonteCarloRng::new(0, 0);
+
+        let mut sample = Sample::new();
+        for _ in 1..20 {
+            // sample 10_000 times per iteration
+            for _ in 0..10_000 {
+                grid.sample(&mut rng, &mut sample);
+
+                if let Sample::Discrete(_weight, i, cont_sample) = &sample {
+                    if let Sample::Continuous(_cont_weight, xs) =
+                        cont_sample.as_ref().unwrap().as_ref()
+                    {
+                        grid.add_training_sample(&sample, fs[*i](xs[0])).unwrap();
+                    }
+                }
+            }
+
+            grid.update(1.5);
+        }
+
+        assert_eq!(grid.accumulator.avg, 0.9713543844460519);
+        assert_eq!(grid.accumulator.err, 0.0009026050146732183)
+    }
+}
```

### Comparing `symbolica-0.3.0/src/parser.rs` & `symbolica-0.4.0/src/parser.rs`

 * *Files 6% similar despite different names*

```diff
@@ -3,18 +3,18 @@
 use bytes::Buf;
 use rug::Integer as MultiPrecisionInteger;
 
 use smallvec::SmallVec;
 use smartstring::{LazyCompact, SmartString};
 
 use crate::{
+    atom::Atom,
     coefficient::ConvertToRing,
     domains::{integer::Integer, Ring},
     poly::{polynomial::MultivariatePolynomial, Exponent, Variable},
-    representations::Atom,
     state::{State, Workspace},
 };
 
 const HEX_DIGIT_MASK: [bool; 255] = [
     false, false, false, false, false, false, false, false, false, false, false, false, false,
     false, false, false, false, false, false, false, false, false, false, false, false, false,
     false, false, false, false, false, false, false, false, false, false, false, false, false,
@@ -113,24 +113,36 @@
             Operator::Argument => 6,
             Operator::Neg => 10,
             Operator::Inv => 9,
         }
     }
 
     #[inline]
-    pub fn right_associative(&self) -> bool {
+    pub fn left_associative(&self) -> bool {
         match self {
             Operator::Mul => true,
             Operator::Add => true,
             Operator::Pow => false,
             Operator::Argument => true,
             Operator::Neg => true,
             Operator::Inv => true,
         }
     }
+
+    #[inline]
+    pub fn right_associative(&self) -> bool {
+        match self {
+            Operator::Mul => true,
+            Operator::Add => true,
+            Operator::Pow => true,
+            Operator::Argument => true,
+            Operator::Neg => true,
+            Operator::Inv => true,
+        }
+    }
 }
 
 pub struct Position {
     pub line_number: usize,
     pub char_pos: usize,
 }
 
@@ -240,15 +252,15 @@
     fn add_left(&mut self, other: Token) -> Result<(), String> {
         if let Token::Op(ml, _, o1, args) = self {
             debug_assert!(*ml);
             *ml = false;
 
             if let Token::Op(ml, mr, o2, mut args2) = other {
                 debug_assert!(!ml && !mr);
-                if *o1 == o2 {
+                if *o1 == o2 && o2.left_associative() {
                     // add from the left by swapping and then extending from the right
                     std::mem::swap(args, &mut args2);
                     args.append(&mut args2);
                 } else {
                     args.insert(0, Token::Op(false, false, o2, args2));
                 }
             } else {
@@ -273,14 +285,21 @@
                 args2[0].distribute_neg();
             }
             Token::Op(_, _, Operator::Add, args2) => {
                 for a in args2 {
                     a.distribute_neg();
                 }
             }
+            Token::Number(n) => {
+                if n.starts_with('-') {
+                    n.remove(0);
+                } else {
+                    n.insert(0, '-');
+                }
+            }
             _ => {
                 let t = std::mem::replace(self, Token::EOF);
                 *self = Token::Op(false, false, Operator::Neg, vec![t]);
             }
         }
     }
 
@@ -288,15 +307,23 @@
     #[inline]
     fn add_right(&mut self, mut other: Token) -> Result<(), String> {
         if let Token::Op(_, mr, o1, args) = self {
             debug_assert!(*mr);
             *mr = false;
 
             if *o1 == Operator::Neg {
-                other.distribute_neg();
+                if let Token::Number(n) = &mut other {
+                    if n.starts_with('-') {
+                        n.remove(0);
+                    } else {
+                        n.insert(0, '-');
+                    }
+                } else {
+                    other.distribute_neg();
+                }
                 *self = other;
                 return Ok(());
             }
 
             if let Token::Op(ml, mr, o2, mut args2) = other {
                 debug_assert!(!ml && !mr);
                 if *o1 == o2 && o2.right_associative() {
@@ -344,15 +371,15 @@
             Token::Number(n) => match n.parse::<Integer>() {
                 Ok(x) => {
                     out.to_num(x.into());
                 }
                 Err(e) => return Err(format!("Could not parse number: {}", e)),
             },
             Token::ID(x) => {
-                out.to_var(state.get_or_insert_var_impl(x));
+                out.to_var(state.get_symbol_impl(x));
             }
             Token::Op(_, _, op, args) => match op {
                 Operator::Mul => {
                     let mut mul_h = workspace.new_atom();
                     let mul = mul_h.to_mul();
 
                     let mut atom = workspace.new_atom();
@@ -372,23 +399,26 @@
                         a.to_atom_with_output(state, workspace, &mut atom)?;
                         add.extend(atom.as_view());
                     }
 
                     add_h.as_view().normalize(workspace, out);
                 }
                 Operator::Pow => {
-                    let mut base = workspace.new_atom();
-                    args[0].to_atom_with_output(state, workspace, &mut base)?;
-
-                    let mut exp = workspace.new_atom();
-                    args[1].to_atom_with_output(state, workspace, &mut exp)?;
-
-                    let mut pow_h = workspace.new_atom();
-                    pow_h.to_pow(base.as_view(), exp.as_view());
-                    pow_h.as_view().normalize(workspace, out);
+                    // pow is right associative
+                    args.last()
+                        .unwrap()
+                        .to_atom_with_output(state, workspace, out)?;
+                    for a in args.iter().rev().skip(1) {
+                        let mut cur_base = workspace.new_atom();
+                        a.to_atom_with_output(state, workspace, &mut cur_base)?;
+
+                        let mut pow_h = workspace.new_atom();
+                        pow_h.to_pow(cur_base.as_view(), out.as_view());
+                        pow_h.as_view().normalize(workspace, out);
+                    }
                 }
                 Operator::Argument => return Err("Unexpected argument operator".into()),
                 Operator::Neg => {
                     debug_assert!(args.len() == 1);
 
                     let mut base = workspace.new_atom();
                     args[0].to_atom_with_output(state, workspace, &mut base)?;
@@ -417,15 +447,15 @@
             Token::Fn(_, args) => {
                 let name = match &args[0] {
                     Token::ID(s) => s,
                     _ => unreachable!(),
                 };
 
                 let mut fun_h = workspace.new_atom();
-                let fun = fun_h.to_fun(state.get_or_insert_fn_impl(name, None)?);
+                let fun = fun_h.to_fun(state.get_symbol_impl(name));
                 let mut atom = workspace.new_atom();
                 for a in args.iter().skip(1) {
                     a.to_atom_with_output(state, workspace, &mut atom)?;
                     fun.add_arg(atom.as_view());
                 }
 
                 fun_h.as_view().normalize(workspace, out);
@@ -623,24 +653,16 @@
                             "Unexpected '{}' in input at line {} and column {}",
                             c, line_counter, column_counter
                         ))?;
                     }
                 }
                 ParseState::Number => {
                     if c != '_' && c != '' && !c.is_ascii_digit() {
-                        // drag in the neg operator
-                        if let Some(Token::Op(false, true, Operator::Neg, _)) = stack.last_mut() {
-                            stack.pop();
-                            id_buffer.insert(0, '-');
-                        }
-
                         state = ParseState::Any;
-
                         stack.push(Token::Number(id_buffer.as_str().into()));
-
                         id_buffer.clear();
                     } else if c != '_' && c != '' {
                         id_buffer.push(c);
                     }
                 }
                 ParseState::RationalPolynomial => {
                     let start = char_iter.clone();
@@ -934,16 +956,15 @@
     pub fn parse_polynomial<'a, R: Ring + ConvertToRing, E: Exponent>(
         mut input: &'a [u8],
         var_map: &Arc<Vec<Variable>>,
         var_name_map: &[SmartString<LazyCompact>],
         field: &R,
     ) -> (&'a [u8], MultivariatePolynomial<R, E>) {
         let mut exponents = vec![E::zero(); var_name_map.len()];
-        let mut poly =
-            MultivariatePolynomial::new(var_name_map.len(), field, None, Some(var_map.clone()));
+        let mut poly = MultivariatePolynomial::new(field, None, var_map.clone());
 
         let mut last_pos = input;
         let mut c = input.get_u8();
 
         let mut digit_buffer = vec![];
         loop {
             if c == b'(' || c == b')' || c == b'/' {
@@ -1135,7 +1156,62 @@
         if input.is_empty() {
             (input, poly)
         } else {
             (last_pos, poly)
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use std::sync::Arc;
+
+    use crate::{atom::Atom, domains::integer::Z, parser::Token, state::State};
+
+    #[test]
+    fn pow() {
+        let input = Atom::parse("v1^v2^v3^3").unwrap();
+        assert_eq!(format!("{}", input), "v1^v2^v3^3");
+
+        let input = Atom::parse("(v1^v2)^3").unwrap();
+        assert_eq!(format!("{}", input), "(v1^v2)^3");
+    }
+
+    #[test]
+    fn unary() {
+        let input = Atom::parse("-x^z").unwrap();
+        assert_eq!(format!("{}", input), "-x^z");
+
+        let input = Atom::parse("(-x)^z").unwrap();
+        assert_eq!(format!("{}", input), "(-x)^z");
+    }
+
+    #[test]
+    fn liberal() {
+        let input = Atom::parse(
+            "89233_21837281 x   
+            ^2 / y + 5",
+        )
+        .unwrap();
+        let res = Atom::parse("8923321837281*x^2*y^-1+5").unwrap();
+        assert_eq!(input, res);
+    }
+
+    #[test]
+    fn poly() {
+        let var_names = ["v1".into(), "v2".into()];
+        let var_map = Arc::new(vec![
+            State::get_symbol("v1").into(),
+            State::get_symbol("v2").into(),
+        ]);
+        let (rest, input) =
+            Token::parse_polynomial::<_, u8>("#ABC*v1^2*v2+5".as_bytes(), &var_map, &var_names, &Z);
+
+        assert!(rest.is_empty());
+        assert_eq!(
+            input,
+            Atom::parse("5+2748*v1^2*v2")
+                .unwrap()
+                .to_polynomial(&Z, var_map.clone().into())
+        );
+    }
+}
```

### Comparing `symbolica-0.3.0/src/poly/evaluate.rs` & `symbolica-0.4.0/src/poly/evaluate.rs`

 * *Files 17% similar despite different names*

```diff
@@ -3,26 +3,27 @@
     hash::{Hash, Hasher},
 };
 
 use ahash::{AHasher, HashMap, HashSet, HashSetExt};
 use rand::{thread_rng, Rng};
 
 use crate::{
+    atom::Symbol,
+    coefficient::CoefficientView,
     domains::{
         float::NumericalFloatLike,
-        rational::{Rational, RationalField},
+        rational::{Rational, RationalField, Q},
         EuclideanDomain,
     },
-    representations::{FunctionBuilder, Symbol},
     state::Workspace,
 };
 use crate::{
+    atom::{Atom, AtomView},
     domains::{float::Real, Ring},
     evaluate::EvaluationFn,
-    representations::{Atom, AtomView},
     state::State,
 };
 
 use super::{polynomial::MultivariatePolynomial, Exponent};
 
 /// A borrowed version of a Horner node, suitable as a key in a
 /// hashmap. It uses precomputed hashes for the complete node
@@ -220,37 +221,29 @@
     }
 }
 
 impl HornerScheme<RationalField> {
     /// Evaluate a polynomial written in a Horner scheme. For faster
     /// evaluation, convert the Horner scheme into an `InstructionList`.
     pub fn evaluate(&self, samples: &[Rational]) -> Rational {
-        let field = RationalField::new();
         match self {
             HornerScheme::Node(n) => {
                 let e = match &n.content_rest.0 {
                     Some(s) => match &n.content_rest.1 {
-                        Some(s1) => field.add(
-                            &field.mul(
-                                &field.pow(&samples[n.var], n.pow as u64),
-                                &s.evaluate(samples),
-                            ),
+                        Some(s1) => Q.add(
+                            &Q.mul(&Q.pow(&samples[n.var], n.pow as u64), &s.evaluate(samples)),
                             &s1.evaluate(samples),
                         ),
-                        None => field.mul(
-                            &field.pow(&samples[n.var], n.pow as u64),
-                            &s.evaluate(samples),
-                        ),
+                        None => Q.mul(&Q.pow(&samples[n.var], n.pow as u64), &s.evaluate(samples)),
                     },
                     None => match &n.content_rest.1 {
-                        Some(s1) => field.add(
-                            &field.pow(&samples[n.var], n.pow as u64),
-                            &s1.evaluate(samples),
-                        ),
-                        None => field.pow(&samples[n.var], n.pow as u64),
+                        Some(s1) => {
+                            Q.add(&Q.pow(&samples[n.var], n.pow as u64), &s1.evaluate(samples))
+                        }
+                        None => Q.pow(&samples[n.var], n.pow as u64),
                     },
                 };
                 &e * &n.gcd
             }
             HornerScheme::Leaf(_, l) => l.clone(),
         }
     }
@@ -323,15 +316,15 @@
 }
 
 impl<E: Exponent> MultivariatePolynomial<RationalField, E> {
     /// Write the polynomial in a Horner scheme with the variable ordering
     /// defined in `order`.
     pub fn to_horner_scheme(&self, order: &[usize]) -> HornerScheme<RationalField> {
         let mut indices: Vec<_> = (0..self.nterms()).collect();
-        let mut power_sub = vec![E::zero(); self.nvars];
+        let mut power_sub = vec![E::zero(); self.nvars()];
         let mut horner_boxes = vec![];
 
         self.to_horner_scheme_impl(order, &mut indices, 0, &mut power_sub, &mut horner_boxes)
     }
 
     /// Create a Horner scheme using the variable order specified in `order`,
     /// using the terms from `self` indexed by `indices[index_start..]`.
@@ -436,15 +429,15 @@
                     Rational::Natural(-1, 1)
                 } else {
                     Rational::Natural(1, 1)
                 }
             }
         };
 
-        gcd = RationalField::new().gcd(
+        gcd = Q.gcd(
             &gcd,
             match &rest {
                 HornerScheme::Node(n) => &n.gcd,
                 HornerScheme::Leaf(_, l) => l,
             },
         );
 
@@ -529,21 +522,21 @@
             HornerScheme::optimize_multiple(std::slice::from_ref(&self), num_tries);
         (hs.pop().unwrap(), op_count, scheme)
     }
 
     /// Optimize an expression for evaluation, given `num_iter` tries.
     pub fn optimize(&self, num_iter: usize) -> InstructionListOutput<Rational> {
         let (h, _ops, _scheme) = self.optimize_horner_scheme(num_iter);
-        let mut i = h.to_instr(self.nvars);
+        let mut i = h.to_instr(self.nvars());
         i.fuse_operations();
         while i.common_pair_elimination() {
             i.fuse_operations();
         }
 
-        i.to_output(self.var_map.as_ref().unwrap().to_vec(), true)
+        i.to_output(self.variables.as_ref().to_vec(), true)
     }
 }
 
 impl HornerScheme<RationalField> {
     pub fn optimize_multiple<E: Exponent>(
         polys: &[&MultivariatePolynomial<RationalField, E>],
         num_tries: usize,
@@ -551,33 +544,33 @@
         if polys.is_empty() {
             return (vec![], 0, vec![]);
         }
 
         assert!(
             polys
                 .windows(2)
-                .all(|r| r[0].var_map == r[1].var_map && r[0].nvars == r[1].nvars),
+                .all(|r| r[0].variables == r[1].variables && r[0].nvars() == r[1].nvars()),
             "Variable maps of all polynomials must be the same"
         );
 
         // the starting scheme is the descending order of occurrence of variables
-        let mut occurrence: Vec<_> = (0..polys[0].nvars).map(|x| (x, 0)).collect();
-        for es in polys[0].exponents.chunks(polys[0].nvars) {
+        let mut occurrence: Vec<_> = (0..polys[0].nvars()).map(|x| (x, 0)).collect();
+        for es in polys[0].exponents.chunks(polys[0].nvars()) {
             for ((_, o), e) in occurrence.iter_mut().zip(es) {
                 if *e > E::zero() {
                     *o += 1;
                 }
             }
         }
         occurrence.sort_by_key(|e| Reverse(e.1));
 
         let mut scheme: Vec<_> = occurrence.into_iter().map(|(v, _)| v).collect();
 
         let mut indices: Vec<_> = vec![];
-        let mut power_sub = vec![E::zero(); polys[0].nvars];
+        let mut power_sub = vec![E::zero(); polys[0].nvars()];
 
         let mut horner_boxes = vec![];
 
         let mut best = Vec::with_capacity(polys.len());
         let mut best_score = 0;
         for x in polys {
             indices.clear();
@@ -597,16 +590,16 @@
         let mut best_scheme = scheme.clone();
         let mut rng = thread_rng();
 
         let mut new_best = Vec::with_capacity(polys.len());
 
         // TODO: for few variables, test all permutations
         for i in 0..num_tries {
-            let a = rng.gen_range(0..polys[0].nvars);
-            let b = rng.gen_range(0..polys[0].nvars);
+            let a = rng.gen_range(0..polys[0].nvars());
+            let b = rng.gen_range(0..polys[0].nvars());
             scheme.swap(a, b);
 
             let mut new_oc = 0;
 
             // use the same hash set for all polynomials
             let mut hash_set = HashSet::with_capacity(best_score * 2);
             for x in polys {
@@ -859,14 +852,31 @@
     Constant(N),
 }
 
 impl Variable<Rational> {
     fn to_pretty_string(&self, var_map: &[super::Variable], mode: InstructionSetMode) -> String {
         match self {
             Variable::Var(v, index) => {
+                // convert f(0) to f[0]
+                if let super::Variable::Function(_, f) = &var_map[*v] {
+                    if let AtomView::Fun(f) = f.as_view() {
+                        if f.get_nargs() == 1 {
+                            if let Some(a) = f.iter().next() {
+                                if let AtomView::Num(n) = a {
+                                    if let CoefficientView::Natural(n, d) = n.get_coeff_view() {
+                                        if d == 1 && n >= 0 {
+                                            return format!("{}[{}]", f.get_symbol(), a);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
                 let mut s = var_map[*v].to_string();
 
                 if let Some(index) = index {
                     s.push_str(&format!("[{}]", index));
                 }
 
                 s
@@ -1400,33 +1410,27 @@
 
 impl<N: Real + for<'b> From<&'b Rational>> InstructionEvaluator<N> {
     /// Evaluate all instructions, using a constant map and a function map for the input variables.
     /// The constant map can map any literal expression to a value, for example
     /// a variable or a function with fixed arguments.
     ///
     /// All variables and all user functions in the expression must occur in the map.
-    pub fn evaluate<'b>(
-        &'b mut self,
+    pub fn evaluate(
+        &mut self,
         const_map: &HashMap<AtomView<'_>, N>,
         function_map: &HashMap<Symbol, EvaluationFn<N>>,
     ) -> &[N] {
         Workspace::get_local().with(|ws| {
             for (input, expr) in self.eval.iter_mut().zip(&self.input_map) {
                 match expr {
                     super::Variable::Symbol(s) => {
                         *input = *const_map
                             .get(&ws.new_var(*s).as_view())
                             .expect("Variable not found");
                     }
-                    super::Variable::Array(s, index) => {
-                        *input = FunctionBuilder::new(*s)
-                            .add_arg(&ws.new_num(*index as i64))
-                            .finish()
-                            .evaluate(const_map, function_map, &mut HashMap::default());
-                    }
                     super::Variable::Function(_, o) | super::Variable::Other(o) => {
                         *input = o.evaluate(const_map, function_map, &mut HashMap::default());
                     }
                     super::Variable::Temporary(_) => panic!("Temporary variable in input"),
                 }
             }
         });
@@ -1594,15 +1598,15 @@
             f.write_fmt(format_args!(
                 "{} {}({}{}) {{\n",
                 if use_return_value { "T" } else { "void" },
                 self.name,
                 self.instr
                     .input_map
                     .iter()
-                    .filter_map(|x| if let super::Variable::Array(x, _) = x {
+                    .filter_map(|x| if let super::Variable::Function(x, _) = x {
                         if !seen_arrays.contains(x) {
                             seen_arrays.push(*x);
 
                             Some(format!("T* {}", super::Variable::Symbol(*x).to_string()))
                         } else {
                             None
                         }
@@ -1739,32 +1743,21 @@
     /// common subexpression elimination. The number of optimization iterations can be set using `n_iter`.
     ///
     pub fn new(levels: Vec<Vec<(Symbol, Vec<Atom>)>>, n_iter: usize) -> ExpressionEvaluator {
         let mut overall_ops = vec![]; // the main function that calls all levels
 
         for l in levels {
             for (id, joint) in l {
-                let mut map = HashMap::default();
-                let mut polys: Vec<MultivariatePolynomial<_, u16>> = joint
-                    .iter()
-                    .map(|a| {
-                        a.as_view()
-                            .to_polynomial_with_map(&RationalField::new(), &mut map)
-                    })
-                    .collect();
+                let mut polys: Vec<MultivariatePolynomial<_, u16>> =
+                    joint.iter().map(|a| a.to_polynomial(&Q, None)).collect();
 
                 // fuse the variable maps
-                let (first, rest) = polys.split_first_mut().unwrap();
-                for _ in 0..2 {
-                    for p in &mut *rest {
-                        first.unify_var_map(p);
-                    }
-                }
+                MultivariatePolynomial::unify_variables_list(&mut polys);
 
-                let var_map = first.var_map.clone().unwrap();
+                let var_map = polys[0].variables.clone();
 
                 let poly_ref = polys.iter().collect::<Vec<_>>();
 
                 let (h, _score, _scheme) = HornerScheme::optimize_multiple(&poly_ref, n_iter);
 
                 // TODO: support giving output names and multiple destinations?
                 let mut i = HornerScheme::to_instr_multiple(&h, var_map.len());
@@ -1774,38 +1767,21 @@
                 for _ in 0..20_000 {
                     if !i.common_pair_elimination() {
                         break;
                     }
                     i.fuse_operations();
                 }
 
-                // convert function calls
-                let requirements: HashMap<super::Variable, String> = map
-                    .iter()
-                    .filter_map(|(a, r)| {
-                        if let AtomView::Fun(f) = a {
-                            Some((r.clone(), State::get_name(f.get_symbol()).to_string()))
-                        } else {
-                            None
-                        }
-                    })
-                    .collect();
-
-                if map.len() != requirements.len() {
-                    panic!("Input contains functions that cannot be written to an array or other unsupported operations");
-                }
-
                 let o = i.to_output(var_map.as_ref().to_vec(), true);
 
                 let mut seen_arrays = vec![];
                 let call_args = var_map
-                    .as_ref()
                     .iter()
                     .filter_map(|x| {
-                        if let super::Variable::Array(x, _) = x {
+                        if let super::Variable::Function(x, _) = x {
                             if !seen_arrays.contains(x) {
                                 seen_arrays.push(*x);
 
                                 Some(super::Variable::Symbol(*x))
                             } else {
                                 None
                             }
@@ -1909,7 +1885,142 @@
 
             f.write_fmt(format_args!("\t{}({});\n", name, f_args.join(",")))?;
         }
 
         f.write_str("}")
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{
+        atom::Atom,
+        domains::{float::Complex, rational::Q},
+        poly::{
+            evaluate::{BorrowedHornerScheme, InstructionSetPrinter},
+            polynomial::MultivariatePolynomial,
+        },
+    };
+
+    use wide::f64x4;
+
+    const RES_53: &str = "-a5^3*b0^5+a4*a5^2*b0^4*b1-a4^2*a5*b0^4*b2+a4^3*b0^4*b3-a3*a5^2*
+b0^3*b1^2+2*a3*a5^2*b0^4*b2+a3*a4*a5*b0^3*b1*b2-3*a3*a4*a5*b0^4*
+b3-a3*a4^2*b0^3*b1*b3-a3^2*a5*b0^3*b2^2+2*a3^2*a5*b0^3*b1*b3+a3^2
+*a4*b0^3*b2*b3-a3^3*b0^3*b3^2+a2*a5^2*b0^2*b1^3-3*a2*a5^2*b0^3*b1
+*b2+3*a2*a5^2*b0^4*b3-a2*a4*a5*b0^2*b1^2*b2+2*a2*a4*a5*b0^3*b2^2+
+a2*a4*a5*b0^3*b1*b3+a2*a4^2*b0^2*b1^2*b3-2*a2*a4^2*b0^3*b2*b3+a2*
+a3*a5*b0^2*b1*b2^2-2*a2*a3*a5*b0^2*b1^2*b3-a2*a3*a5*b0^3*b2*b3-a2
+*a3*a4*b0^2*b1*b2*b3+3*a2*a3*a4*b0^3*b3^2+a2*a3^2*b0^2*b1*b3^2-
+a2^2*a5*b0^2*b2^3+3*a2^2*a5*b0^2*b1*b2*b3-3*a2^2*a5*b0^3*b3^2+
+a2^2*a4*b0^2*b2^2*b3-2*a2^2*a4*b0^2*b1*b3^2-a2^2*a3*b0^2*b2*b3^2+
+a2^3*b0^2*b3^3-a1*a5^2*b0*b1^4+4*a1*a5^2*b0^2*b1^2*b2-2*a1*a5^2*
+b0^3*b2^2-4*a1*a5^2*b0^3*b1*b3+a1*a4*a5*b0*b1^3*b2-3*a1*a4*a5*
+b0^2*b1*b2^2-a1*a4*a5*b0^2*b1^2*b3+5*a1*a4*a5*b0^3*b2*b3-a1*a4^2*
+b0*b1^3*b3+3*a1*a4^2*b0^2*b1*b2*b3-3*a1*a4^2*b0^3*b3^2-a1*a3*a5*
+b0*b1^2*b2^2+2*a1*a3*a5*b0*b1^3*b3+2*a1*a3*a5*b0^2*b2^3-4*a1*a3*
+a5*b0^2*b1*b2*b3+3*a1*a3*a5*b0^3*b3^2+a1*a3*a4*b0*b1^2*b2*b3-2*a1
+*a3*a4*b0^2*b2^2*b3-a1*a3*a4*b0^2*b1*b3^2-a1*a3^2*b0*b1^2*b3^2+2*
+a1*a3^2*b0^2*b2*b3^2+a1*a2*a5*b0*b1*b2^3-3*a1*a2*a5*b0*b1^2*b2*b3
+-a1*a2*a5*b0^2*b2^2*b3+5*a1*a2*a5*b0^2*b1*b3^2-a1*a2*a4*b0*b1*
+b2^2*b3+2*a1*a2*a4*b0*b1^2*b3^2+a1*a2*a4*b0^2*b2*b3^2+a1*a2*a3*b0
+*b1*b2*b3^2-3*a1*a2*a3*b0^2*b3^3-a1*a2^2*b0*b1*b3^3-a1^2*a5*b0*
+b2^4+4*a1^2*a5*b0*b1*b2^2*b3-2*a1^2*a5*b0*b1^2*b3^2-4*a1^2*a5*
+b0^2*b2*b3^2+a1^2*a4*b0*b2^3*b3-3*a1^2*a4*b0*b1*b2*b3^2+3*a1^2*a4
+*b0^2*b3^3-a1^2*a3*b0*b2^2*b3^2+2*a1^2*a3*b0*b1*b3^3+a1^2*a2*b0*
+b2*b3^3-a1^3*b0*b3^4+a0*a5^2*b1^5-5*a0*a5^2*b0*b1^3*b2+5*a0*a5^2*
+b0^2*b1*b2^2+5*a0*a5^2*b0^2*b1^2*b3-5*a0*a5^2*b0^3*b2*b3-a0*a4*a5
+*b1^4*b2+4*a0*a4*a5*b0*b1^2*b2^2+a0*a4*a5*b0*b1^3*b3-2*a0*a4*a5*
+b0^2*b2^3-7*a0*a4*a5*b0^2*b1*b2*b3+3*a0*a4*a5*b0^3*b3^2+a0*a4^2*
+b1^4*b3-4*a0*a4^2*b0*b1^2*b2*b3+2*a0*a4^2*b0^2*b2^2*b3+4*a0*a4^2*
+b0^2*b1*b3^2+a0*a3*a5*b1^3*b2^2-2*a0*a3*a5*b1^4*b3-3*a0*a3*a5*b0*
+b1*b2^3+6*a0*a3*a5*b0*b1^2*b2*b3+3*a0*a3*a5*b0^2*b2^2*b3-7*a0*a3*
+a5*b0^2*b1*b3^2-a0*a3*a4*b1^3*b2*b3+3*a0*a3*a4*b0*b1*b2^2*b3+a0*
+a3*a4*b0*b1^2*b3^2-5*a0*a3*a4*b0^2*b2*b3^2+a0*a3^2*b1^3*b3^2-3*a0
+*a3^2*b0*b1*b2*b3^2+3*a0*a3^2*b0^2*b3^3-a0*a2*a5*b1^2*b2^3+3*a0*
+a2*a5*b1^3*b2*b3+2*a0*a2*a5*b0*b2^4-6*a0*a2*a5*b0*b1*b2^2*b3-3*a0
+*a2*a5*b0*b1^2*b3^2+7*a0*a2*a5*b0^2*b2*b3^2+a0*a2*a4*b1^2*b2^2*b3
+-2*a0*a2*a4*b1^3*b3^2-2*a0*a2*a4*b0*b2^3*b3+4*a0*a2*a4*b0*b1*b2*
+b3^2-3*a0*a2*a4*b0^2*b3^3-a0*a2*a3*b1^2*b2*b3^2+2*a0*a2*a3*b0*
+b2^2*b3^2+a0*a2*a3*b0*b1*b3^3+a0*a2^2*b1^2*b3^3-2*a0*a2^2*b0*b2*
+b3^3+a0*a1*a5*b1*b2^4-4*a0*a1*a5*b1^2*b2^2*b3+2*a0*a1*a5*b1^3*
+b3^2-a0*a1*a5*b0*b2^3*b3+7*a0*a1*a5*b0*b1*b2*b3^2-3*a0*a1*a5*b0^2
+*b3^3-a0*a1*a4*b1*b2^3*b3+3*a0*a1*a4*b1^2*b2*b3^2+a0*a1*a4*b0*
+b2^2*b3^2-5*a0*a1*a4*b0*b1*b3^3+a0*a1*a3*b1*b2^2*b3^2-2*a0*a1*a3*
+b1^2*b3^3-a0*a1*a3*b0*b2*b3^3-a0*a1*a2*b1*b2*b3^3+3*a0*a1*a2*b0*
+b3^4+a0*a1^2*b1*b3^4-a0^2*a5*b2^5+5*a0^2*a5*b1*b2^3*b3-5*a0^2*a5*
+b1^2*b2*b3^2-5*a0^2*a5*b0*b2^2*b3^2+5*a0^2*a5*b0*b1*b3^3+a0^2*a4*
+b2^4*b3-4*a0^2*a4*b1*b2^2*b3^2+2*a0^2*a4*b1^2*b3^3+4*a0^2*a4*b0*
+b2*b3^3-a0^2*a3*b2^3*b3^2+3*a0^2*a3*b1*b2*b3^3-3*a0^2*a3*b0*b3^4+
+a0^2*a2*b2^2*b3^3-2*a0^2*a2*b1*b3^4-a0^2*a1*b2*b3^4+a0^3*b3^5";
+
+    #[test]
+    fn res_53() {
+        let poly: MultivariatePolynomial<_, u8> =
+            Atom::parse(RES_53).unwrap().to_polynomial(&Q, None);
+
+        let (h, _ops, scheme) = poly.optimize_horner_scheme(1000);
+        let mut i = h.to_instr(poly.nvars());
+
+        println!(
+            "Number of operations={}, with scheme={:?}",
+            BorrowedHornerScheme::from(&h).op_count_cse(),
+            scheme,
+        );
+
+        i.fuse_operations();
+
+        for _ in 0..100_000 {
+            if !i.common_pair_elimination() {
+                break;
+            }
+            i.fuse_operations();
+        }
+
+        let o = i.to_output(poly.variables.as_ref().to_vec(), true);
+        let o_f64 = o.convert::<f64>();
+
+        let _ = format!(
+            "{}",
+            InstructionSetPrinter {
+                name: "sigma".to_string(),
+                instr: &o,
+                mode: crate::poly::evaluate::InstructionSetMode::CPP(
+                    crate::poly::evaluate::InstructionSetModeCPPSettings {
+                        write_header_and_test: true,
+                        always_pass_output_array: false,
+                    }
+                )
+            }
+        );
+
+        let mut evaluator = o_f64.evaluator();
+
+        let res = evaluator
+            .evaluate_with_input(&(0..poly.nvars()).map(|x| x as f64 + 1.).collect::<Vec<_>>())[0];
+
+        assert_eq!(res, 280944.);
+
+        // evaluate with simd
+        let o_f64x4 = o.convert::<f64x4>();
+        let mut evaluator = o_f64x4.evaluator();
+
+        let res = evaluator.evaluate_with_input(
+            &(0..poly.nvars())
+                .map(|x| f64x4::new([x as f64 + 1., x as f64 + 2., x as f64 + 3., x as f64 + 4.]))
+                .collect::<Vec<_>>(),
+        )[0];
+
+        assert_eq!(res, f64x4::new([280944.0, 645000.0, 1774950.0, 4985154.0]));
+
+        // evaluate with complex numbers
+        let mut complex_evaluator = o.convert::<Complex<f64>>().evaluator();
+        let res = complex_evaluator.evaluate_with_input(
+            &(0..poly.nvars())
+                .map(|x| Complex::new(x as f64 + 0.1, x as f64 + 2.))
+                .collect::<Vec<_>>(),
+        )[0];
+        assert!(
+            (res.re - 3230756.634848104).abs() < 1e-6 && (res.im - 2522437.0904901037).abs() < 1e-6
+        );
+    }
+}
```

### Comparing `symbolica-0.3.0/src/poly/factor.rs` & `symbolica-0.4.0/src/poly/factor.rs`

 * *Files 3% similar despite different names*

```diff
@@ -12,6604 +12,6987 @@
 000000b0: 5f66 6965 6c64 3a3a 7b0a 2020 2020 2020  _field::{.      
 000000c0: 2020 2020 2020 4669 6e69 7465 4669 656c        FiniteFiel
 000000d0: 642c 2046 696e 6974 6546 6965 6c64 436f  d, FiniteFieldCo
 000000e0: 7265 2c20 4669 6e69 7465 4669 656c 6457  re, FiniteFieldW
 000000f0: 6f72 6b73 7061 6365 2c20 5072 696d 6549  orkspace, PrimeI
 00000100: 7465 7261 746f 7255 3634 2c20 546f 4669  teratorU64, ToFi
 00000110: 6e69 7465 4669 656c 642c 0a20 2020 2020  niteField,.     
-00000120: 2020 207d 2c0a 2020 2020 2020 2020 696e     },.        in
-00000130: 7465 6765 723a 3a7b 496e 7465 6765 722c  teger::{Integer,
-00000140: 2049 6e74 6567 6572 5269 6e67 7d2c 0a20   IntegerRing},. 
-00000150: 2020 2020 2020 2072 6174 696f 6e61 6c3a         rational:
-00000160: 3a52 6174 696f 6e61 6c46 6965 6c64 2c0a  :RationalField,.
-00000170: 2020 2020 2020 2020 4575 636c 6964 6561          Euclidea
-00000180: 6e44 6f6d 6169 6e2c 2046 6965 6c64 2c20  nDomain, Field, 
-00000190: 5269 6e67 2c0a 2020 2020 7d2c 0a20 2020  Ring,.    },.   
-000001a0: 2070 6f6c 793a 3a67 6364 3a3a 4c41 5247   poly::gcd::LARG
-000001b0: 455f 5533 325f 5052 494d 4553 2c0a 2020  E_U32_PRIMES,.  
-000001c0: 2020 7574 696c 732c 0a7d 3b0a 0a75 7365    utils,.};..use
-000001d0: 2073 7570 6572 3a3a 7b67 6364 3a3a 506f   super::{gcd::Po
-000001e0: 6c79 6e6f 6d69 616c 4743 442c 2070 6f6c  lynomialGCD, pol
-000001f0: 796e 6f6d 6961 6c3a 3a4d 756c 7469 7661  ynomial::Multiva
-00000200: 7269 6174 6550 6f6c 796e 6f6d 6961 6c2c  riatePolynomial,
-00000210: 2045 7870 6f6e 656e 742c 204c 6578 4f72   Exponent, LexOr
-00000220: 6465 727d 3b0a 0a70 7562 2074 7261 6974  der};..pub trait
-00000230: 2046 6163 746f 7269 7a65 3a20 5369 7a65   Factorize: Size
-00000240: 6420 7b0a 2020 2020 2f2f 2f20 5065 7266  d {.    /// Perf
-00000250: 6f72 6d20 6120 7371 7561 7265 2d66 7265  orm a square-fre
-00000260: 6520 6661 6374 6f72 697a 6174 696f 6e2e  e factorization.
-00000270: 0a20 2020 202f 2f2f 2054 6865 206f 7574  .    /// The out
-00000280: 7075 7420 6973 2060 615f 315e 6531 2a2e  put is `a_1^e1*.
-00000290: 2e2e 2a61 5f6e 5e65 5f6e 600a 2020 2020  ..*a_n^e_n`.    
-000002a0: 2f2f 2f20 7768 6572 6520 6561 6368 2060  /// where each `
-000002b0: 615f 6960 2069 7320 7265 6c61 7469 7665  a_i` is relative
-000002c0: 2070 7269 6d65 2e0a 2020 2020 666e 2073   prime..    fn s
-000002d0: 7175 6172 655f 6672 6565 5f66 6163 746f  quare_free_facto
-000002e0: 7269 7a61 7469 6f6e 2826 7365 6c66 2920  rization(&self) 
-000002f0: 2d3e 2056 6563 3c28 5365 6c66 2c20 7573  -> Vec<(Self, us
-00000300: 697a 6529 3e3b 0a20 2020 202f 2f2f 2046  ize)>;.    /// F
-00000310: 6163 746f 7220 6120 706f 6c79 6e6f 6d69  actor a polynomi
-00000320: 616c 206f 7665 7220 6974 7320 636f 6566  al over its coef
-00000330: 6669 6369 656e 7420 7269 6e67 2e0a 2020  ficient ring..  
-00000340: 2020 666e 2066 6163 746f 7228 2673 656c    fn factor(&sel
-00000350: 6629 202d 3e20 5665 633c 2853 656c 662c  f) -> Vec<(Self,
-00000360: 2075 7369 7a65 293e 3b0a 7d0a 0a69 6d70   usize)>;.}..imp
-00000370: 6c3c 463a 2045 7563 6c69 6465 616e 446f  l<F: EuclideanDo
-00000380: 6d61 696e 202b 2050 6f6c 796e 6f6d 6961  main + Polynomia
-00000390: 6c47 4344 3c45 3e2c 2045 3a20 4578 706f  lGCD<E>, E: Expo
-000003a0: 6e65 6e74 3e20 4d75 6c74 6976 6172 6961  nent> Multivaria
-000003b0: 7465 506f 6c79 6e6f 6d69 616c 3c46 2c20  tePolynomial<F, 
-000003c0: 452c 204c 6578 4f72 6465 723e 207b 0a20  E, LexOrder> {. 
-000003d0: 2020 202f 2f2f 2046 696e 6420 6661 6374     /// Find fact
-000003e0: 6f72 7320 7468 6174 2064 6f20 6e6f 7420  ors that do not 
-000003f0: 636f 6e74 6169 6e20 616c 6c20 7661 7269  contain all vari
-00000400: 6162 6c65 732e 0a20 2020 2070 7562 2066  ables..    pub f
-00000410: 6e20 6661 6374 6f72 5f73 6570 6172 6162  n factor_separab
-00000420: 6c65 2826 7365 6c66 2920 2d3e 2056 6563  le(&self) -> Vec
-00000430: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
-00000440: 206c 6574 206d 7574 2073 7472 6970 7065   let mut strippe
-00000450: 6420 3d20 7365 6c66 2e63 6c6f 6e65 2829  d = self.clone()
-00000460: 3b0a 0a20 2020 2020 2020 206c 6574 206d  ;..        let m
-00000470: 7574 2066 6163 746f 7273 203d 2076 6563  ut factors = vec
-00000480: 215b 5d3b 0a20 2020 2020 2020 2066 6f72  ![];.        for
-00000490: 2078 2069 6e20 302e 2e73 656c 662e 6e76   x in 0..self.nv
-000004a0: 6172 7320 7b0a 2020 2020 2020 2020 2020  ars {.          
-000004b0: 2020 6966 2073 656c 662e 6465 6772 6565    if self.degree
-000004c0: 2878 2920 3d3d 2045 3a3a 7a65 726f 2829  (x) == E::zero()
-000004d0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-000004e0: 2020 2063 6f6e 7469 6e75 653b 0a20 2020     continue;.   
-000004f0: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
-00000500: 2020 2020 2020 2020 6c65 7420 6320 3d20          let c = 
-00000510: 7374 7269 7070 6564 2e74 6f5f 756e 6976  stripped.to_univ
-00000520: 6172 6961 7465 5f70 6f6c 796e 6f6d 6961  ariate_polynomia
-00000530: 6c5f 6c69 7374 2878 293b 0a20 2020 2020  l_list(x);.     
-00000540: 2020 2020 2020 206c 6574 2063 7320 3d20         let cs = 
-00000550: 632e 696e 746f 5f69 7465 7228 292e 6d61  c.into_iter().ma
-00000560: 7028 7c78 7c20 782e 3029 2e63 6f6c 6c65  p(|x| x.0).colle
-00000570: 6374 2829 3b0a 0a20 2020 2020 2020 2020  ct();..         
-00000580: 2020 206c 6574 2067 6364 203d 2050 6f6c     let gcd = Pol
-00000590: 796e 6f6d 6961 6c47 4344 3a3a 6763 645f  ynomialGCD::gcd_
-000005a0: 6d75 6c74 6970 6c65 2863 7329 3b0a 0a20  multiple(cs);.. 
-000005b0: 2020 2020 2020 2020 2020 2069 6620 2167             if !g
-000005c0: 6364 2e69 735f 636f 6e73 7461 6e74 2829  cd.is_constant()
-000005d0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-000005e0: 2020 2073 7472 6970 7065 6420 3d20 7374     stripped = st
-000005f0: 7269 7070 6564 202f 2026 6763 643b 0a20  ripped / &gcd;. 
-00000600: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00000610: 6574 206d 7574 2066 7320 3d20 6763 642e  et mut fs = gcd.
-00000620: 6661 6374 6f72 5f73 6570 6172 6162 6c65  factor_separable
-00000630: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-00000640: 2020 2020 6661 6374 6f72 732e 6170 7065      factors.appe
-00000650: 6e64 2826 6d75 7420 6673 293b 0a20 2020  nd(&mut fs);.   
-00000660: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00000670: 2020 207d 0a0a 2020 2020 2020 2020 6661     }..        fa
-00000680: 6374 6f72 732e 7075 7368 2873 7472 6970  ctors.push(strip
-00000690: 7065 6429 3b0a 2020 2020 2020 2020 6661  ped);.        fa
-000006a0: 6374 6f72 730a 2020 2020 7d0a 0a20 2020  ctors.    }..   
-000006b0: 202f 2f2f 2050 6572 666f 726d 2061 2073   /// Perform a s
-000006c0: 7175 6172 6520 6672 6565 2066 6163 746f  quare free facto
-000006d0: 7269 7a61 7469 6f6e 2075 7369 6e67 2059  rization using Y
-000006e0: 756e 2773 2061 6c67 6f72 6974 686d 2e0a  un's algorithm..
-000006f0: 2020 2020 2f2f 2f0a 2020 2020 2f2f 2f20      ///.    /// 
-00000700: 5468 6520 6368 6172 6163 7465 7269 7374  The characterist
-00000710: 6963 206f 6620 7468 6520 7269 6e67 206d  ic of the ring m
-00000720: 7573 7420 6265 2030 2061 6e64 2061 6c6c  ust be 0 and all
-00000730: 2076 6172 6961 626c 6573 0a20 2020 202f   variables.    /
-00000740: 2f2f 206d 7573 7420 6f63 6375 7220 696e  // must occur in
-00000750: 2065 7665 7279 2066 6163 746f 722e 0a20   every factor.. 
-00000760: 2020 2066 6e20 7371 7561 7265 5f66 7265     fn square_fre
-00000770: 655f 6661 6374 6f72 697a 6174 696f 6e5f  e_factorization_
-00000780: 305f 6368 6172 2826 7365 6c66 2920 2d3e  0_char(&self) ->
-00000790: 2056 6563 3c28 5365 6c66 2c20 7573 697a   Vec<(Self, usiz
-000007a0: 6529 3e20 7b0a 2020 2020 2020 2020 6966  e)> {.        if
-000007b0: 2073 656c 662e 6973 5f63 6f6e 7374 616e   self.is_constan
-000007c0: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
-000007d0: 2020 6966 2073 656c 662e 6973 5f6f 6e65    if self.is_one
-000007e0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-000007f0: 2020 2020 2072 6574 7572 6e20 7665 6321       return vec!
-00000800: 5b5d 3b0a 2020 2020 2020 2020 2020 2020  [];.            
-00000810: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
-00000820: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00000830: 7665 6321 5b28 7365 6c66 2e63 6c6f 6e65  vec![(self.clone
-00000840: 2829 2c20 3129 5d3b 0a20 2020 2020 2020  (), 1)];.       
-00000850: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
-00000860: 0a0a 2020 2020 2020 2020 2f2f 2061 6e79  ..        // any
-00000870: 2076 6172 6961 626c 6520 6361 6e20 6265   variable can be
-00000880: 2073 656c 6563 7465 640a 2020 2020 2020   selected.      
-00000890: 2020 2f2f 2073 656c 6563 7420 7468 6520    // select the 
-000008a0: 6f6e 6520 7769 7468 2074 6865 206c 6f77  one with the low
-000008b0: 6573 7420 6465 6772 6565 0a20 2020 2020  est degree.     
-000008c0: 2020 206c 6574 206c 6f77 6573 745f 7261     let lowest_ra
-000008d0: 6e6b 5f76 6172 203d 2028 302e 2e73 656c  nk_var = (0..sel
-000008e0: 662e 6e76 6172 7329 0a20 2020 2020 2020  f.nvars).       
-000008f0: 2020 2020 202e 6669 6c74 6572 5f6d 6170       .filter_map
-00000900: 287c 787c 207b 0a20 2020 2020 2020 2020  (|x| {.         
-00000910: 2020 2020 2020 206c 6574 2064 203d 2073         let d = s
-00000920: 656c 662e 6465 6772 6565 2878 293b 0a20  elf.degree(x);. 
-00000930: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00000940: 6620 6420 3e20 453a 3a7a 6572 6f28 2920  f d > E::zero() 
-00000950: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00000960: 2020 2020 2020 536f 6d65 2828 782c 2064        Some((x, d
-00000970: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-00000980: 2020 207d 2065 6c73 6520 7b0a 2020 2020     } else {.    
-00000990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000009a0: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
-000009b0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-000009c0: 2020 207d 290a 2020 2020 2020 2020 2020     }).          
-000009d0: 2020 2e6d 696e 5f62 795f 6b65 7928 7c61    .min_by_key(|a
-000009e0: 7c20 612e 3129 0a20 2020 2020 2020 2020  | a.1).         
-000009f0: 2020 202e 756e 7772 6170 2829 0a20 2020     .unwrap().   
-00000a00: 2020 2020 2020 2020 202e 303b 0a0a 2020           .0;..  
-00000a10: 2020 2020 2020 6c65 7420 6220 3d20 7365        let b = se
-00000a20: 6c66 2e64 6572 6976 6174 6976 6528 6c6f  lf.derivative(lo
-00000a30: 7765 7374 5f72 616e 6b5f 7661 7229 3b0a  west_rank_var);.
-00000a40: 2020 2020 2020 2020 6c65 7420 6320 3d20          let c = 
-00000a50: 7365 6c66 2e67 6364 2826 6229 3b0a 0a20  self.gcd(&b);.. 
-00000a60: 2020 2020 2020 2069 6620 632e 6973 5f6f         if c.is_o
-00000a70: 6e65 2829 207b 0a20 2020 2020 2020 2020  ne() {.         
-00000a80: 2020 2072 6574 7572 6e20 7665 6321 5b28     return vec![(
-00000a90: 7365 6c66 2e63 6c6f 6e65 2829 2c20 3129  self.clone(), 1)
-00000aa0: 5d3b 0a20 2020 2020 2020 207d 0a0a 2020  ];.        }..  
-00000ab0: 2020 2020 2020 6c65 7420 6d75 7420 6661        let mut fa
-00000ac0: 6374 6f72 7320 3d20 7665 6321 5b5d 3b0a  ctors = vec![];.
-00000ad0: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-00000ae0: 2077 203d 2073 656c 6620 2f20 2663 3b0a   w = self / &c;.
-00000af0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-00000b00: 7920 3d20 2662 202f 2026 633b 0a0a 2020  y = &b / &c;..  
-00000b10: 2020 2020 2020 6c65 7420 6d75 7420 6920        let mut i 
-00000b20: 3d20 313b 0a20 2020 2020 2020 2077 6869  = 1;.        whi
-00000b30: 6c65 2021 772e 6973 5f63 6f6e 7374 616e  le !w.is_constan
-00000b40: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
-00000b50: 2020 6c65 7420 7a20 3d20 7920 2d20 772e    let z = y - w.
-00000b60: 6465 7269 7661 7469 7665 286c 6f77 6573  derivative(lowes
-00000b70: 745f 7261 6e6b 5f76 6172 293b 0a20 2020  t_rank_var);.   
-00000b80: 2020 2020 2020 2020 206c 6574 2067 203d           let g =
-00000b90: 2077 2e67 6364 2826 7a29 3b0a 2020 2020   w.gcd(&z);.    
-00000ba0: 2020 2020 2020 2020 7720 3d20 7720 2f20          w = w / 
-00000bb0: 2667 3b0a 2020 2020 2020 2020 2020 2020  &g;.            
-00000bc0: 7920 3d20 7a20 2f20 2667 3b0a 0a20 2020  y = z / &g;..   
-00000bd0: 2020 2020 2020 2020 2069 6620 2167 2e69           if !g.i
-00000be0: 735f 6f6e 6528 2920 7b0a 2020 2020 2020  s_one() {.      
-00000bf0: 2020 2020 2020 2020 2020 6661 6374 6f72            factor
-00000c00: 732e 7075 7368 2828 672c 2069 2929 3b0a  s.push((g, i));.
-00000c10: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00000c20: 2020 2020 2020 2020 2020 6920 2b3d 2031            i += 1
-00000c30: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-00000c40: 2020 2020 6661 6374 6f72 730a 2020 2020      factors.    
-00000c50: 7d0a 0a20 2020 202f 2f2f 2055 7365 204e  }..    /// Use N
-00000c60: 6577 746f 6e27 7320 706f 6c79 676f 6e20  ewton's polygon 
-00000c70: 6d65 7468 6f64 2074 6f20 7465 7374 2069  method to test i
-00000c80: 6620 6120 6269 7661 7269 6174 6520 706f  f a bivariate po
-00000c90: 6c79 6e6f 6d69 616c 2069 7320 6972 7265  lynomial is irre
-00000ca0: 6475 6369 626c 652e 0a20 2020 202f 2f2f  ducible..    ///
-00000cb0: 2049 6620 7468 6973 206d 6574 686f 6420   If this method 
-00000cc0: 7265 7475 726e 7320 6066 616c 7365 602c  returns `false`,
-00000cd0: 2074 6865 2074 6573 7420 6973 2069 6e63   the test is inc
-00000ce0: 6f6e 636c 7573 6976 652e 0a20 2020 202f  onclusive..    /
-00000cf0: 2f2f 0a20 2020 202f 2f2f 2054 6865 2070  //.    /// The p
-00000d00: 6f6c 796e 6f6d 6961 6c20 6d75 7374 2068  olynomial must h
-00000d10: 6176 6520 6f76 6572 616c 6c20 6661 6374  ave overall fact
-00000d20: 6f72 7320 6f66 2073 696e 676c 6520 7661  ors of single va
-00000d30: 7269 6162 6c65 7320 7265 6d6f 7665 642e  riables removed.
-00000d40: 0a20 2020 2066 6e20 6269 7661 7269 6174  .    fn bivariat
-00000d50: 655f 6972 7265 6475 6369 6269 6c69 7479  e_irreducibility
-00000d60: 5f74 6573 7428 2673 656c 6629 202d 3e20  _test(&self) -> 
-00000d70: 626f 6f6c 207b 0a20 2020 2020 2020 202f  bool {.        /
-00000d80: 2f2f 2043 6f6d 7075 7465 2074 6865 2063  // Compute the c
-00000d90: 6f6e 7665 7820 6875 6c6c 2076 6961 2074  onvex hull via t
-00000da0: 6865 204d 6f6e 6f74 6f6e 6520 6368 6169  he Monotone chai
-00000db0: 6e20 616c 676f 7269 7468 6d2e 0a20 2020  n algorithm..   
-00000dc0: 2020 2020 2066 6e20 636f 6e76 6578 5f68       fn convex_h
-00000dd0: 756c 6c28 6d75 7420 706f 696e 7473 3a20  ull(mut points: 
-00000de0: 5665 633c 2869 7369 7a65 2c20 6973 697a  Vec<(isize, isiz
-00000df0: 6529 3e29 202d 3e20 5665 633c 2869 7369  e)>) -> Vec<(isi
-00000e00: 7a65 2c20 6973 697a 6529 3e20 7b0a 2020  ze, isize)> {.  
-00000e10: 2020 2020 2020 2020 2020 706f 696e 7473            points
-00000e20: 2e73 6f72 7428 293b 0a20 2020 2020 2020  .sort();.       
-00000e30: 2020 2020 2069 6620 706f 696e 7473 2e6c       if points.l
-00000e40: 656e 2829 203c 2032 207b 0a20 2020 2020  en() < 2 {.     
-00000e50: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00000e60: 6e20 706f 696e 7473 3b0a 2020 2020 2020  n points;.      
-00000e70: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00000e80: 2020 2020 202f 2f20 4372 6f73 7320 7072       // Cross pr
-00000e90: 6f64 7563 7420 6f66 206f 2d61 2061 6e64  oduct of o-a and
-00000ea0: 206f 2d62 2076 6563 746f 7273 2c20 706f   o-b vectors, po
-00000eb0: 7369 7469 7665 206d 6561 6e73 2063 6377  sitive means ccw
-00000ec0: 2074 7572 6e2c 206e 6567 6174 6976 6520   turn, negative 
-00000ed0: 6d65 616e 7320 6377 2074 7572 6e20 616e  means cw turn an
-00000ee0: 6420 3020 6d65 616e 7320 636f 6c6c 696e  d 0 means collin
-00000ef0: 6561 722e 0a20 2020 2020 2020 2020 2020  ear..           
-00000f00: 2066 6e20 6372 6f73 7328 6f3a 2026 2869   fn cross(o: &(i
-00000f10: 7369 7a65 2c20 6973 697a 6529 2c20 613a  size, isize), a:
-00000f20: 2026 2869 7369 7a65 2c20 6973 697a 6529   &(isize, isize)
-00000f30: 2c20 623a 2026 2869 7369 7a65 2c20 6973  , b: &(isize, is
-00000f40: 697a 6529 2920 2d3e 2069 7369 7a65 207b  ize)) -> isize {
-00000f50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00000f60: 2028 612e 3020 2d20 6f2e 3029 202a 2028   (a.0 - o.0) * (
-00000f70: 622e 3120 2d20 6f2e 3129 202d 2028 612e  b.1 - o.1) - (a.
-00000f80: 3120 2d20 6f2e 3129 202a 2028 622e 3020  1 - o.1) * (b.0 
-00000f90: 2d20 6f2e 3029 0a20 2020 2020 2020 2020  - o.0).         
-00000fa0: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00000fb0: 2020 6c65 7420 6d75 7420 6c6f 7765 7220    let mut lower 
-00000fc0: 3d20 7665 6321 5b5d 3b0a 2020 2020 2020  = vec![];.      
-00000fd0: 2020 2020 2020 6c65 7420 6d75 7420 7570        let mut up
-00000fe0: 7065 7220 3d20 7665 6321 5b5d 3b0a 0a20  per = vec![];.. 
-00000ff0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-00001000: 742c 2072 6576 2920 696e 205b 2826 6d75  t, rev) in [(&mu
-00001010: 7420 6c6f 7765 722c 2066 616c 7365 292c  t lower, false),
-00001020: 2028 266d 7574 2075 7070 6572 2c20 7472   (&mut upper, tr
-00001030: 7565 295d 207b 0a20 2020 2020 2020 2020  ue)] {.         
-00001040: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
-00001050: 302e 2e70 6f69 6e74 732e 6c65 6e28 2920  0..points.len() 
-00001060: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00001070: 2020 2020 2020 6c65 7420 7020 3d20 6966        let p = if
-00001080: 2072 6576 207b 0a20 2020 2020 2020 2020   rev {.         
-00001090: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-000010a0: 6f69 6e74 735b 706f 696e 7473 2e6c 656e  oints[points.len
-000010b0: 2829 202d 2031 202d 2069 5d0a 2020 2020  () - 1 - i].    
-000010c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010d0: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+00000120: 2020 2020 2020 205a 702c 205a 7036 342c         Zp, Zp64,
+00000130: 0a20 2020 2020 2020 207d 2c0a 2020 2020  .        },.    
+00000140: 2020 2020 696e 7465 6765 723a 3a7b 496e      integer::{In
+00000150: 7465 6765 722c 2049 6e74 6567 6572 5269  teger, IntegerRi
+00000160: 6e67 2c20 5a7d 2c0a 2020 2020 2020 2020  ng, Z},.        
+00000170: 7261 7469 6f6e 616c 3a3a 7b52 6174 696f  rational::{Ratio
+00000180: 6e61 6c46 6965 6c64 2c20 517d 2c0a 2020  nalField, Q},.  
+00000190: 2020 2020 2020 4575 636c 6964 6561 6e44        EuclideanD
+000001a0: 6f6d 6169 6e2c 2046 6965 6c64 2c20 5269  omain, Field, Ri
+000001b0: 6e67 2c0a 2020 2020 7d2c 0a20 2020 2070  ng,.    },.    p
+000001c0: 6f6c 793a 3a67 6364 3a3a 4c41 5247 455f  oly::gcd::LARGE_
+000001d0: 5533 325f 5052 494d 4553 2c0a 2020 2020  U32_PRIMES,.    
+000001e0: 7574 696c 732c 0a7d 3b0a 0a75 7365 2073  utils,.};..use s
+000001f0: 7570 6572 3a3a 7b67 6364 3a3a 506f 6c79  uper::{gcd::Poly
+00000200: 6e6f 6d69 616c 4743 442c 2070 6f6c 796e  nomialGCD, polyn
+00000210: 6f6d 6961 6c3a 3a4d 756c 7469 7661 7269  omial::Multivari
+00000220: 6174 6550 6f6c 796e 6f6d 6961 6c2c 2045  atePolynomial, E
+00000230: 7870 6f6e 656e 742c 204c 6578 4f72 6465  xponent, LexOrde
+00000240: 727d 3b0a 0a70 7562 2074 7261 6974 2046  r};..pub trait F
+00000250: 6163 746f 7269 7a65 3a20 5369 7a65 6420  actorize: Sized 
+00000260: 7b0a 2020 2020 2f2f 2f20 5065 7266 6f72  {.    /// Perfor
+00000270: 6d20 6120 7371 7561 7265 2d66 7265 6520  m a square-free 
+00000280: 6661 6374 6f72 697a 6174 696f 6e2e 0a20  factorization.. 
+00000290: 2020 202f 2f2f 2054 6865 206f 7574 7075     /// The outpu
+000002a0: 7420 6973 2060 615f 315e 6531 2a2e 2e2e  t is `a_1^e1*...
+000002b0: 2a61 5f6e 5e65 5f6e 600a 2020 2020 2f2f  *a_n^e_n`.    //
+000002c0: 2f20 7768 6572 6520 6561 6368 2060 615f  / where each `a_
+000002d0: 6960 2069 7320 7265 6c61 7469 7665 2070  i` is relative p
+000002e0: 7269 6d65 2e0a 2020 2020 666e 2073 7175  rime..    fn squ
+000002f0: 6172 655f 6672 6565 5f66 6163 746f 7269  are_free_factori
+00000300: 7a61 7469 6f6e 2826 7365 6c66 2920 2d3e  zation(&self) ->
+00000310: 2056 6563 3c28 5365 6c66 2c20 7573 697a   Vec<(Self, usiz
+00000320: 6529 3e3b 0a20 2020 202f 2f2f 2046 6163  e)>;.    /// Fac
+00000330: 746f 7220 6120 706f 6c79 6e6f 6d69 616c  tor a polynomial
+00000340: 206f 7665 7220 6974 7320 636f 6566 6669   over its coeffi
+00000350: 6369 656e 7420 7269 6e67 2e0a 2020 2020  cient ring..    
+00000360: 666e 2066 6163 746f 7228 2673 656c 6629  fn factor(&self)
+00000370: 202d 3e20 5665 633c 2853 656c 662c 2075   -> Vec<(Self, u
+00000380: 7369 7a65 293e 3b0a 7d0a 0a69 6d70 6c3c  size)>;.}..impl<
+00000390: 463a 2045 7563 6c69 6465 616e 446f 6d61  F: EuclideanDoma
+000003a0: 696e 202b 2050 6f6c 796e 6f6d 6961 6c47  in + PolynomialG
+000003b0: 4344 3c45 3e2c 2045 3a20 4578 706f 6e65  CD<E>, E: Expone
+000003c0: 6e74 3e20 4d75 6c74 6976 6172 6961 7465  nt> Multivariate
+000003d0: 506f 6c79 6e6f 6d69 616c 3c46 2c20 452c  Polynomial<F, E,
+000003e0: 204c 6578 4f72 6465 723e 207b 0a20 2020   LexOrder> {.   
+000003f0: 202f 2f2f 2046 696e 6420 6661 6374 6f72   /// Find factor
+00000400: 7320 7468 6174 2064 6f20 6e6f 7420 636f  s that do not co
+00000410: 6e74 6169 6e20 616c 6c20 7661 7269 6162  ntain all variab
+00000420: 6c65 732e 0a20 2020 2070 7562 2066 6e20  les..    pub fn 
+00000430: 6661 6374 6f72 5f73 6570 6172 6162 6c65  factor_separable
+00000440: 2826 7365 6c66 2920 2d3e 2056 6563 3c53  (&self) -> Vec<S
+00000450: 656c 663e 207b 0a20 2020 2020 2020 206c  elf> {.        l
+00000460: 6574 206d 7574 2073 7472 6970 7065 6420  et mut stripped 
+00000470: 3d20 7365 6c66 2e63 6c6f 6e65 2829 3b0a  = self.clone();.
+00000480: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00000490: 2066 6163 746f 7273 203d 2076 6563 215b   factors = vec![
+000004a0: 5d3b 0a20 2020 2020 2020 2066 6f72 2078  ];.        for x
+000004b0: 2069 6e20 302e 2e73 656c 662e 6e76 6172   in 0..self.nvar
+000004c0: 7328 2920 7b0a 2020 2020 2020 2020 2020  s() {.          
+000004d0: 2020 6966 2073 656c 662e 6465 6772 6565    if self.degree
+000004e0: 2878 2920 3d3d 2045 3a3a 7a65 726f 2829  (x) == E::zero()
+000004f0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00000500: 2020 2063 6f6e 7469 6e75 653b 0a20 2020     continue;.   
+00000510: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+00000520: 2020 2020 2020 2020 6c65 7420 6320 3d20          let c = 
+00000530: 7374 7269 7070 6564 2e74 6f5f 756e 6976  stripped.to_univ
+00000540: 6172 6961 7465 5f70 6f6c 796e 6f6d 6961  ariate_polynomia
+00000550: 6c5f 6c69 7374 2878 293b 0a20 2020 2020  l_list(x);.     
+00000560: 2020 2020 2020 206c 6574 2063 7320 3d20         let cs = 
+00000570: 632e 696e 746f 5f69 7465 7228 292e 6d61  c.into_iter().ma
+00000580: 7028 7c78 7c20 782e 3029 2e63 6f6c 6c65  p(|x| x.0).colle
+00000590: 6374 2829 3b0a 0a20 2020 2020 2020 2020  ct();..         
+000005a0: 2020 206c 6574 2067 6364 203d 2050 6f6c     let gcd = Pol
+000005b0: 796e 6f6d 6961 6c47 4344 3a3a 6763 645f  ynomialGCD::gcd_
+000005c0: 6d75 6c74 6970 6c65 2863 7329 3b0a 0a20  multiple(cs);.. 
+000005d0: 2020 2020 2020 2020 2020 2069 6620 2167             if !g
+000005e0: 6364 2e69 735f 636f 6e73 7461 6e74 2829  cd.is_constant()
+000005f0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00000600: 2020 2073 7472 6970 7065 6420 3d20 7374     stripped = st
+00000610: 7269 7070 6564 202f 2026 6763 643b 0a20  ripped / &gcd;. 
+00000620: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00000630: 6574 206d 7574 2066 7320 3d20 6763 642e  et mut fs = gcd.
+00000640: 6661 6374 6f72 5f73 6570 6172 6162 6c65  factor_separable
+00000650: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
+00000660: 2020 2020 6661 6374 6f72 732e 6170 7065      factors.appe
+00000670: 6e64 2826 6d75 7420 6673 293b 0a20 2020  nd(&mut fs);.   
+00000680: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00000690: 2020 207d 0a0a 2020 2020 2020 2020 6661     }..        fa
+000006a0: 6374 6f72 732e 7075 7368 2873 7472 6970  ctors.push(strip
+000006b0: 7065 6429 3b0a 2020 2020 2020 2020 6661  ped);.        fa
+000006c0: 6374 6f72 730a 2020 2020 7d0a 0a20 2020  ctors.    }..   
+000006d0: 202f 2f2f 2050 6572 666f 726d 2061 2073   /// Perform a s
+000006e0: 7175 6172 6520 6672 6565 2066 6163 746f  quare free facto
+000006f0: 7269 7a61 7469 6f6e 2075 7369 6e67 2059  rization using Y
+00000700: 756e 2773 2061 6c67 6f72 6974 686d 2e0a  un's algorithm..
+00000710: 2020 2020 2f2f 2f0a 2020 2020 2f2f 2f20      ///.    /// 
+00000720: 5468 6520 6368 6172 6163 7465 7269 7374  The characterist
+00000730: 6963 206f 6620 7468 6520 7269 6e67 206d  ic of the ring m
+00000740: 7573 7420 6265 2030 2061 6e64 2061 6c6c  ust be 0 and all
+00000750: 2076 6172 6961 626c 6573 0a20 2020 202f   variables.    /
+00000760: 2f2f 206d 7573 7420 6f63 6375 7220 696e  // must occur in
+00000770: 2065 7665 7279 2066 6163 746f 722e 0a20   every factor.. 
+00000780: 2020 2066 6e20 7371 7561 7265 5f66 7265     fn square_fre
+00000790: 655f 6661 6374 6f72 697a 6174 696f 6e5f  e_factorization_
+000007a0: 305f 6368 6172 2826 7365 6c66 2920 2d3e  0_char(&self) ->
+000007b0: 2056 6563 3c28 5365 6c66 2c20 7573 697a   Vec<(Self, usiz
+000007c0: 6529 3e20 7b0a 2020 2020 2020 2020 6966  e)> {.        if
+000007d0: 2073 656c 662e 6973 5f63 6f6e 7374 616e   self.is_constan
+000007e0: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
+000007f0: 2020 6966 2073 656c 662e 6973 5f6f 6e65    if self.is_one
+00000800: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+00000810: 2020 2020 2072 6574 7572 6e20 7665 6321       return vec!
+00000820: 5b5d 3b0a 2020 2020 2020 2020 2020 2020  [];.            
+00000830: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+00000840: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00000850: 7665 6321 5b28 7365 6c66 2e63 6c6f 6e65  vec![(self.clone
+00000860: 2829 2c20 3129 5d3b 0a20 2020 2020 2020  (), 1)];.       
+00000870: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
+00000880: 0a0a 2020 2020 2020 2020 2f2f 2061 6e79  ..        // any
+00000890: 2076 6172 6961 626c 6520 6361 6e20 6265   variable can be
+000008a0: 2073 656c 6563 7465 640a 2020 2020 2020   selected.      
+000008b0: 2020 2f2f 2073 656c 6563 7420 7468 6520    // select the 
+000008c0: 6f6e 6520 7769 7468 2074 6865 206c 6f77  one with the low
+000008d0: 6573 7420 6465 6772 6565 0a20 2020 2020  est degree.     
+000008e0: 2020 206c 6574 206c 6f77 6573 745f 7261     let lowest_ra
+000008f0: 6e6b 5f76 6172 203d 2028 302e 2e73 656c  nk_var = (0..sel
+00000900: 662e 6e76 6172 7328 2929 0a20 2020 2020  f.nvars()).     
+00000910: 2020 2020 2020 202e 6669 6c74 6572 5f6d         .filter_m
+00000920: 6170 287c 787c 207b 0a20 2020 2020 2020  ap(|x| {.       
+00000930: 2020 2020 2020 2020 206c 6574 2064 203d           let d =
+00000940: 2073 656c 662e 6465 6772 6565 2878 293b   self.degree(x);
+00000950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00000960: 2069 6620 6420 3e20 453a 3a7a 6572 6f28   if d > E::zero(
+00000970: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00000980: 2020 2020 2020 2020 536f 6d65 2828 782c          Some((x,
+00000990: 2064 2929 0a20 2020 2020 2020 2020 2020   d)).           
+000009a0: 2020 2020 207d 2065 6c73 6520 7b0a 2020       } else {.  
+000009b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000009c0: 2020 4e6f 6e65 0a20 2020 2020 2020 2020    None.         
+000009d0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000009e0: 2020 2020 207d 290a 2020 2020 2020 2020       }).        
+000009f0: 2020 2020 2e6d 696e 5f62 795f 6b65 7928      .min_by_key(
+00000a00: 7c61 7c20 612e 3129 0a20 2020 2020 2020  |a| a.1).       
+00000a10: 2020 2020 202e 756e 7772 6170 2829 0a20       .unwrap(). 
+00000a20: 2020 2020 2020 2020 2020 202e 303b 0a0a             .0;..
+00000a30: 2020 2020 2020 2020 6c65 7420 6220 3d20          let b = 
+00000a40: 7365 6c66 2e64 6572 6976 6174 6976 6528  self.derivative(
+00000a50: 6c6f 7765 7374 5f72 616e 6b5f 7661 7229  lowest_rank_var)
+00000a60: 3b0a 2020 2020 2020 2020 6c65 7420 6320  ;.        let c 
+00000a70: 3d20 7365 6c66 2e67 6364 2826 6229 3b0a  = self.gcd(&b);.
+00000a80: 0a20 2020 2020 2020 2069 6620 632e 6973  .        if c.is
+00000a90: 5f6f 6e65 2829 207b 0a20 2020 2020 2020  _one() {.       
+00000aa0: 2020 2020 2072 6574 7572 6e20 7665 6321       return vec!
+00000ab0: 5b28 7365 6c66 2e63 6c6f 6e65 2829 2c20  [(self.clone(), 
+00000ac0: 3129 5d3b 0a20 2020 2020 2020 207d 0a0a  1)];.        }..
+00000ad0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00000ae0: 6661 6374 6f72 7320 3d20 7665 6321 5b5d  factors = vec![]
+00000af0: 3b0a 0a20 2020 2020 2020 206c 6574 206d  ;..        let m
+00000b00: 7574 2077 203d 2073 656c 6620 2f20 2663  ut w = self / &c
+00000b10: 3b0a 2020 2020 2020 2020 6c65 7420 6d75  ;.        let mu
+00000b20: 7420 7920 3d20 2662 202f 2026 633b 0a0a  t y = &b / &c;..
+00000b30: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00000b40: 6920 3d20 313b 0a20 2020 2020 2020 2077  i = 1;.        w
+00000b50: 6869 6c65 2021 772e 6973 5f63 6f6e 7374  hile !w.is_const
+00000b60: 616e 7428 2920 7b0a 2020 2020 2020 2020  ant() {.        
+00000b70: 2020 2020 6c65 7420 7a20 3d20 7920 2d20      let z = y - 
+00000b80: 772e 6465 7269 7661 7469 7665 286c 6f77  w.derivative(low
+00000b90: 6573 745f 7261 6e6b 5f76 6172 293b 0a20  est_rank_var);. 
+00000ba0: 2020 2020 2020 2020 2020 206c 6574 2067             let g
+00000bb0: 203d 2077 2e67 6364 2826 7a29 3b0a 2020   = w.gcd(&z);.  
+00000bc0: 2020 2020 2020 2020 2020 7720 3d20 7720            w = w 
+00000bd0: 2f20 2667 3b0a 2020 2020 2020 2020 2020  / &g;.          
+00000be0: 2020 7920 3d20 7a20 2f20 2667 3b0a 0a20    y = z / &g;.. 
+00000bf0: 2020 2020 2020 2020 2020 2069 6620 2167             if !g
+00000c00: 2e69 735f 6f6e 6528 2920 7b0a 2020 2020  .is_one() {.    
+00000c10: 2020 2020 2020 2020 2020 2020 6661 6374              fact
+00000c20: 6f72 732e 7075 7368 2828 672c 2069 2929  ors.push((g, i))
+00000c30: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
+00000c40: 2020 2020 2020 2020 2020 2020 6920 2b3d              i +=
+00000c50: 2031 0a20 2020 2020 2020 207d 0a0a 2020   1.        }..  
+00000c60: 2020 2020 2020 6661 6374 6f72 730a 2020        factors.  
+00000c70: 2020 7d0a 0a20 2020 202f 2f2f 2055 7365    }..    /// Use
+00000c80: 204e 6577 746f 6e27 7320 706f 6c79 676f   Newton's polygo
+00000c90: 6e20 6d65 7468 6f64 2074 6f20 7465 7374  n method to test
+00000ca0: 2069 6620 6120 6269 7661 7269 6174 6520   if a bivariate 
+00000cb0: 706f 6c79 6e6f 6d69 616c 2069 7320 6972  polynomial is ir
+00000cc0: 7265 6475 6369 626c 652e 0a20 2020 202f  reducible..    /
+00000cd0: 2f2f 2049 6620 7468 6973 206d 6574 686f  // If this metho
+00000ce0: 6420 7265 7475 726e 7320 6066 616c 7365  d returns `false
+00000cf0: 602c 2074 6865 2074 6573 7420 6973 2069  `, the test is i
+00000d00: 6e63 6f6e 636c 7573 6976 652e 0a20 2020  nconclusive..   
+00000d10: 202f 2f2f 0a20 2020 202f 2f2f 2054 6865   ///.    /// The
+00000d20: 2070 6f6c 796e 6f6d 6961 6c20 6d75 7374   polynomial must
+00000d30: 2068 6176 6520 6f76 6572 616c 6c20 6661   have overall fa
+00000d40: 6374 6f72 7320 6f66 2073 696e 676c 6520  ctors of single 
+00000d50: 7661 7269 6162 6c65 7320 7265 6d6f 7665  variables remove
+00000d60: 642e 0a20 2020 2066 6e20 6269 7661 7269  d..    fn bivari
+00000d70: 6174 655f 6972 7265 6475 6369 6269 6c69  ate_irreducibili
+00000d80: 7479 5f74 6573 7428 2673 656c 6629 202d  ty_test(&self) -
+00000d90: 3e20 626f 6f6c 207b 0a20 2020 2020 2020  > bool {.       
+00000da0: 202f 2f2f 2043 6f6d 7075 7465 2074 6865   /// Compute the
+00000db0: 2063 6f6e 7665 7820 6875 6c6c 2076 6961   convex hull via
+00000dc0: 2074 6865 204d 6f6e 6f74 6f6e 6520 6368   the Monotone ch
+00000dd0: 6169 6e20 616c 676f 7269 7468 6d2e 0a20  ain algorithm.. 
+00000de0: 2020 2020 2020 2066 6e20 636f 6e76 6578         fn convex
+00000df0: 5f68 756c 6c28 6d75 7420 706f 696e 7473  _hull(mut points
+00000e00: 3a20 5665 633c 2869 7369 7a65 2c20 6973  : Vec<(isize, is
+00000e10: 697a 6529 3e29 202d 3e20 5665 633c 2869  ize)>) -> Vec<(i
+00000e20: 7369 7a65 2c20 6973 697a 6529 3e20 7b0a  size, isize)> {.
+00000e30: 2020 2020 2020 2020 2020 2020 706f 696e              poin
+00000e40: 7473 2e73 6f72 7428 293b 0a20 2020 2020  ts.sort();.     
+00000e50: 2020 2020 2020 2069 6620 706f 696e 7473         if points
+00000e60: 2e6c 656e 2829 203c 2032 207b 0a20 2020  .len() < 2 {.   
+00000e70: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00000e80: 7572 6e20 706f 696e 7473 3b0a 2020 2020  urn points;.    
+00000e90: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00000ea0: 2020 2020 2020 202f 2f20 4372 6f73 7320         // Cross 
+00000eb0: 7072 6f64 7563 7420 6f66 206f 2d61 2061  product of o-a a
+00000ec0: 6e64 206f 2d62 2076 6563 746f 7273 2c20  nd o-b vectors, 
+00000ed0: 706f 7369 7469 7665 206d 6561 6e73 2063  positive means c
+00000ee0: 6377 2074 7572 6e2c 206e 6567 6174 6976  cw turn, negativ
+00000ef0: 6520 6d65 616e 7320 6377 2074 7572 6e20  e means cw turn 
+00000f00: 616e 6420 3020 6d65 616e 7320 636f 6c6c  and 0 means coll
+00000f10: 696e 6561 722e 0a20 2020 2020 2020 2020  inear..         
+00000f20: 2020 2066 6e20 6372 6f73 7328 6f3a 2026     fn cross(o: &
+00000f30: 2869 7369 7a65 2c20 6973 697a 6529 2c20  (isize, isize), 
+00000f40: 613a 2026 2869 7369 7a65 2c20 6973 697a  a: &(isize, isiz
+00000f50: 6529 2c20 623a 2026 2869 7369 7a65 2c20  e), b: &(isize, 
+00000f60: 6973 697a 6529 2920 2d3e 2069 7369 7a65  isize)) -> isize
+00000f70: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00000f80: 2020 2028 612e 3020 2d20 6f2e 3029 202a     (a.0 - o.0) *
+00000f90: 2028 622e 3120 2d20 6f2e 3129 202d 2028   (b.1 - o.1) - (
+00000fa0: 612e 3120 2d20 6f2e 3129 202a 2028 622e  a.1 - o.1) * (b.
+00000fb0: 3020 2d20 6f2e 3029 0a20 2020 2020 2020  0 - o.0).       
+00000fc0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00000fd0: 2020 2020 6c65 7420 6d75 7420 6c6f 7765      let mut lowe
+00000fe0: 7220 3d20 7665 6321 5b5d 3b0a 2020 2020  r = vec![];.    
+00000ff0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00001000: 7570 7065 7220 3d20 7665 6321 5b5d 3b0a  upper = vec![];.
+00001010: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00001020: 2028 742c 2072 6576 2920 696e 205b 2826   (t, rev) in [(&
+00001030: 6d75 7420 6c6f 7765 722c 2066 616c 7365  mut lower, false
+00001040: 292c 2028 266d 7574 2075 7070 6572 2c20  ), (&mut upper, 
+00001050: 7472 7565 295d 207b 0a20 2020 2020 2020  true)] {.       
+00001060: 2020 2020 2020 2020 2066 6f72 2069 2069           for i i
+00001070: 6e20 302e 2e70 6f69 6e74 732e 6c65 6e28  n 0..points.len(
+00001080: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00001090: 2020 2020 2020 2020 6c65 7420 7020 3d20          let p = 
+000010a0: 6966 2072 6576 207b 0a20 2020 2020 2020  if rev {.       
+000010b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000010c0: 2070 6f69 6e74 735b 706f 696e 7473 2e6c   points[points.l
+000010d0: 656e 2829 202d 2031 202d 2069 5d0a 2020  en() - 1 - i].  
 000010e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000010f0: 2070 6f69 6e74 735b 695d 0a20 2020 2020   points[i].     
-00001100: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00001110: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00001120: 2020 2020 2020 7768 696c 6520 742e 6c65        while t.le
-00001130: 6e28 2920 3e3d 2032 2026 2620 6372 6f73  n() >= 2 && cros
-00001140: 7328 2674 5b74 2e6c 656e 2829 202d 2032  s(&t[t.len() - 2
-00001150: 5d2c 2026 745b 742e 6c65 6e28 2920 2d20  ], &t[t.len() - 
-00001160: 315d 2c20 2670 2920 3c3d 2030 207b 0a20  1], &p) <= 0 {. 
-00001170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001180: 2020 2020 2020 2074 2e70 6f70 2829 3b0a         t.pop();.
-00001190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000011a0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-000011b0: 2020 2020 2020 2020 2020 742e 7075 7368            t.push
-000011c0: 2870 293b 0a20 2020 2020 2020 2020 2020  (p);.           
-000011d0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-000011e0: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-000011f0: 2020 6c6f 7765 722e 706f 7028 293b 0a20    lower.pop();. 
-00001200: 2020 2020 2020 2020 2020 2075 7070 6572             upper
-00001210: 2e70 6f70 2829 3b0a 2020 2020 2020 2020  .pop();.        
-00001220: 2020 2020 6c6f 7765 722e 6578 7465 6e64      lower.extend
-00001230: 2875 7070 6572 293b 0a20 2020 2020 2020  (upper);.       
-00001240: 2020 2020 206c 6f77 6572 0a20 2020 2020       lower.     
-00001250: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
-00001260: 7420 7661 7273 3a20 5665 633c 5f3e 203d  t vars: Vec<_> =
-00001270: 2028 302e 2e73 656c 662e 6e76 6172 7329   (0..self.nvars)
-00001280: 0a20 2020 2020 2020 2020 2020 202e 6669  .            .fi
-00001290: 6c74 6572 287c 767c 2073 656c 662e 6465  lter(|v| self.de
-000012a0: 6772 6565 282a 7629 203e 2045 3a3a 7a65  gree(*v) > E::ze
-000012b0: 726f 2829 290a 2020 2020 2020 2020 2020  ro()).          
-000012c0: 2020 2e63 6f6c 6c65 6374 2829 3b0a 0a20    .collect();.. 
-000012d0: 2020 2020 2020 2069 6620 7661 7273 2e6c         if vars.l
-000012e0: 656e 2829 2021 3d20 3220 7b0a 2020 2020  en() != 2 {.    
-000012f0: 2020 2020 2020 2020 7265 7475 726e 2066          return f
-00001300: 616c 7365 3b0a 2020 2020 2020 2020 7d0a  alse;.        }.
-00001310: 0a20 2020 2020 2020 206c 6574 2070 6f69  .        let poi
-00001320: 6e74 7320 3d20 7365 6c66 0a20 2020 2020  nts = self.     
-00001330: 2020 2020 2020 202e 6578 706f 6e65 6e74         .exponent
-00001340: 730a 2020 2020 2020 2020 2020 2020 2e63  s.            .c
-00001350: 6875 6e6b 7328 7365 6c66 2e6e 7661 7273  hunks(self.nvars
-00001360: 290a 2020 2020 2020 2020 2020 2020 2e6d  ).            .m
-00001370: 6170 287c 657c 2028 655b 7661 7273 5b30  ap(|e| (e[vars[0
-00001380: 5d5d 2e74 6f5f 7533 3228 2920 6173 2069  ]].to_u32() as i
-00001390: 7369 7a65 2c20 655b 7661 7273 5b31 5d5d  size, e[vars[1]]
-000013a0: 2e74 6f5f 7533 3228 2920 6173 2069 7369  .to_u32() as isi
-000013b0: 7a65 2929 0a20 2020 2020 2020 2020 2020  ze)).           
-000013c0: 202e 636f 6c6c 6563 7428 293b 0a0a 2020   .collect();..  
-000013d0: 2020 2020 2020 6c65 7420 6875 6c6c 203d        let hull =
-000013e0: 2063 6f6e 7665 785f 6875 6c6c 2870 6f69   convex_hull(poi
-000013f0: 6e74 7329 3b0a 0a20 2020 2020 2020 206d  nts);..        m
-00001400: 6174 6368 2068 756c 6c2e 6c65 6e28 2920  atch hull.len() 
-00001410: 7b0a 2020 2020 2020 2020 2020 2020 3220  {.            2 
-00001420: 3d3e 207b 0a20 2020 2020 2020 2020 2020  => {.           
-00001430: 2020 2020 206c 6574 2078 5f64 6567 203d       let x_deg =
-00001440: 2068 756c 6c5b 305d 2e30 2e61 6273 5f64   hull[0].0.abs_d
-00001450: 6966 6628 6875 6c6c 5b31 5d2e 3029 3b0a  iff(hull[1].0);.
-00001460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001470: 6c65 7420 795f 6465 6720 3d20 6875 6c6c  let y_deg = hull
-00001480: 5b30 5d2e 312e 6162 735f 6469 6666 2868  [0].1.abs_diff(h
-00001490: 756c 6c5b 315d 2e31 293b 0a20 2020 2020  ull[1].1);.     
-000014a0: 2020 2020 2020 2020 2020 2075 7469 6c73             utils
-000014b0: 3a3a 6763 645f 756e 7369 676e 6564 2878  ::gcd_unsigned(x
-000014c0: 5f64 6567 2061 7320 7536 342c 2079 5f64  _deg as u64, y_d
-000014d0: 6567 2061 7320 7536 3429 203d 3d20 310a  eg as u64) == 1.
-000014e0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-000014f0: 2020 2020 2020 2020 2020 3320 3d3e 207b            3 => {
-00001500: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001510: 202f 2f20 7468 6520 6875 6c6c 2068 6173   // the hull has
-00001520: 2074 6865 2066 6f72 6d20 286e 2c20 3029   the form (n, 0)
-00001530: 2c20 2830 2c20 6d29 2c20 2875 2c20 7629  , (0, m), (u, v)
-00001540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001550: 206c 6574 2028 6d75 7420 6e2c 206d 7574   let (mut n, mut
-00001560: 206d 2c20 6d75 7420 752c 206d 7574 2076   m, mut u, mut v
-00001570: 2920 3d20 282d 312c 202d 312c 202d 312c  ) = (-1, -1, -1,
-00001580: 202d 3129 3b0a 2020 2020 2020 2020 2020   -1);.          
-00001590: 2020 2020 2020 666f 7220 2878 2c20 7929        for (x, y)
-000015a0: 2069 6e20 6875 6c6c 207b 0a20 2020 2020   in hull {.     
-000015b0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000015c0: 6620 7820 213d 2030 2026 2620 7920 3d3d  f x != 0 && y ==
-000015d0: 2030 207b 0a20 2020 2020 2020 2020 2020   0 {.           
-000015e0: 2020 2020 2020 2020 2020 2020 206e 203d               n =
-000015f0: 2078 3b0a 2020 2020 2020 2020 2020 2020   x;.            
-00001600: 2020 2020 2020 2020 7d20 656c 7365 2069          } else i
-00001610: 6620 7920 213d 2030 2026 2620 7820 3d3d  f y != 0 && x ==
-00001620: 2030 207b 0a20 2020 2020 2020 2020 2020   0 {.           
-00001630: 2020 2020 2020 2020 2020 2020 206d 203d               m =
-00001640: 2079 3b0a 2020 2020 2020 2020 2020 2020   y;.            
-00001650: 2020 2020 2020 2020 7d20 656c 7365 207b          } else {
-00001660: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001670: 2020 2020 2020 2020 2075 203d 2078 3b0a           u = x;.
-00001680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001690: 2020 2020 2020 2020 7620 3d20 793b 0a20          v = y;. 
-000016a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000016b0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-000016c0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-000016d0: 2020 2020 2020 2020 6e20 213d 202d 310a          n != -1.
-000016e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000016f0: 2020 2020 2626 206d 2021 3d20 2d31 0a20      && m != -1. 
-00001700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001710: 2020 2026 2620 7520 213d 202d 310a 2020     && u != -1.  
-00001720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001730: 2020 2626 2076 2021 3d20 2d31 0a20 2020    && v != -1.   
-00001740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001750: 2026 2620 7574 696c 733a 3a67 6364 5f75   && utils::gcd_u
-00001760: 6e73 6967 6e65 6428 0a20 2020 2020 2020  nsigned(.       
-00001770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001780: 2075 7469 6c73 3a3a 6763 645f 756e 7369   utils::gcd_unsi
-00001790: 676e 6564 2875 7469 6c73 3a3a 6763 645f  gned(utils::gcd_
-000017a0: 756e 7369 676e 6564 286e 2061 7320 7536  unsigned(n as u6
-000017b0: 342c 206d 2061 7320 7536 3429 2c20 7520  4, m as u64), u 
-000017c0: 6173 2075 3634 292c 0a20 2020 2020 2020  as u64),.       
-000017d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000017e0: 2076 2061 7320 7536 342c 0a20 2020 2020   v as u64,.     
-000017f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00001800: 203d 3d20 310a 2020 2020 2020 2020 2020   == 1.          
-00001810: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-00001820: 5f20 3d3e 2066 616c 7365 2c0a 2020 2020  _ => false,.    
-00001830: 2020 2020 7d0a 2020 2020 7d0a 7d0a 0a69      }.    }.}..i
-00001840: 6d70 6c3c 453a 2045 7870 6f6e 656e 743e  mpl<E: Exponent>
-00001850: 2046 6163 746f 7269 7a65 2066 6f72 204d   Factorize for M
-00001860: 756c 7469 7661 7269 6174 6550 6f6c 796e  ultivariatePolyn
-00001870: 6f6d 6961 6c3c 496e 7465 6765 7252 696e  omial<IntegerRin
-00001880: 672c 2045 2c20 4c65 784f 7264 6572 3e20  g, E, LexOrder> 
-00001890: 7b0a 2020 2020 666e 2073 7175 6172 655f  {.    fn square_
-000018a0: 6672 6565 5f66 6163 746f 7269 7a61 7469  free_factorizati
-000018b0: 6f6e 2826 7365 6c66 2920 2d3e 2056 6563  on(&self) -> Vec
-000018c0: 3c28 5365 6c66 2c20 7573 697a 6529 3e20  <(Self, usize)> 
-000018d0: 7b0a 2020 2020 2020 2020 6966 2073 656c  {.        if sel
-000018e0: 662e 6973 5f7a 6572 6f28 2920 7b0a 2020  f.is_zero() {.  
-000018f0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00001900: 2076 6563 215b 5d3b 0a20 2020 2020 2020   vec![];.       
-00001910: 207d 0a0a 2020 2020 2020 2020 6c65 7420   }..        let 
-00001920: 6320 3d20 7365 6c66 2e63 6f6e 7465 6e74  c = self.content
-00001930: 2829 3b0a 2020 2020 2020 2020 6c65 7420  ();.        let 
-00001940: 7374 7269 7070 6564 203d 2073 656c 662e  stripped = self.
-00001950: 636c 6f6e 6528 292e 6469 765f 636f 6566  clone().div_coef
-00001960: 6628 2663 293b 0a0a 2020 2020 2020 2020  f(&c);..        
-00001970: 6c65 7420 6d75 7420 6661 6374 6f72 7320  let mut factors 
-00001980: 3d20 7665 6321 5b5d 3b0a 0a20 2020 2020  = vec![];..     
-00001990: 2020 2069 6620 2163 2e69 735f 6f6e 6528     if !c.is_one(
-000019a0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-000019b0: 6661 6374 6f72 732e 7075 7368 2828 7365  factors.push((se
-000019c0: 6c66 2e63 6f6e 7374 616e 7428 6329 2c20  lf.constant(c), 
-000019d0: 3129 293b 0a20 2020 2020 2020 207d 0a0a  1));.        }..
-000019e0: 2020 2020 2020 2020 6c65 7420 6673 203d          let fs =
-000019f0: 2073 7472 6970 7065 642e 6661 6374 6f72   stripped.factor
-00001a00: 5f73 6570 6172 6162 6c65 2829 3b0a 0a20  _separable();.. 
-00001a10: 2020 2020 2020 2066 6f72 2066 2069 6e20         for f in 
-00001a20: 6673 207b 0a20 2020 2020 2020 2020 2020  fs {.           
-00001a30: 206c 6574 206d 7574 206e 6620 3d20 662e   let mut nf = f.
-00001a40: 7371 7561 7265 5f66 7265 655f 6661 6374  square_free_fact
-00001a50: 6f72 697a 6174 696f 6e5f 305f 6368 6172  orization_0_char
-00001a60: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-00001a70: 6661 6374 6f72 732e 6170 7065 6e64 2826  factors.append(&
-00001a80: 6d75 7420 6e66 293b 0a20 2020 2020 2020  mut nf);.       
-00001a90: 207d 0a0a 2020 2020 2020 2020 6966 2066   }..        if f
-00001aa0: 6163 746f 7273 2e69 735f 656d 7074 7928  actors.is_empty(
-00001ab0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00001ac0: 6661 6374 6f72 732e 7075 7368 2828 7365  factors.push((se
-00001ad0: 6c66 2e6f 6e65 2829 2c20 3129 290a 2020  lf.one(), 1)).  
-00001ae0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00001af0: 2066 6163 746f 7273 0a20 2020 207d 0a0a   factors.    }..
-00001b00: 2020 2020 666e 2066 6163 746f 7228 2673      fn factor(&s
-00001b10: 656c 6629 202d 3e20 5665 633c 2853 656c  elf) -> Vec<(Sel
-00001b20: 662c 2075 7369 7a65 293e 207b 0a20 2020  f, usize)> {.   
-00001b30: 2020 2020 206c 6574 2073 6620 3d20 7365       let sf = se
-00001b40: 6c66 2e73 7175 6172 655f 6672 6565 5f66  lf.square_free_f
-00001b50: 6163 746f 7269 7a61 7469 6f6e 2829 3b0a  actorization();.
-00001b60: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-00001b70: 2066 6163 746f 7273 203d 2076 6563 215b   factors = vec![
-00001b80: 5d3b 0a20 2020 2020 2020 206c 6574 206d  ];.        let m
-00001b90: 7574 2064 6567 7265 6573 203d 2076 6563  ut degrees = vec
-00001ba0: 215b 303b 2073 656c 662e 6e76 6172 735d  ![0; self.nvars]
-00001bb0: 3b0a 2020 2020 2020 2020 666f 7220 2866  ;.        for (f
-00001bc0: 2c20 7029 2069 6e20 7366 207b 0a20 2020  , p) in sf {.   
-00001bd0: 2020 2020 2020 2020 2064 6562 7567 2128           debug!(
-00001be0: 2253 4646 207b 7d20 7b7d 222c 2066 2c20  "SFF {} {}", f, 
-00001bf0: 7029 3b0a 0a20 2020 2020 2020 2020 2020  p);..           
-00001c00: 206c 6574 206d 7574 2076 6172 5f63 6f75   let mut var_cou
-00001c10: 6e74 203d 2030 3b0a 2020 2020 2020 2020  nt = 0;.        
-00001c20: 2020 2020 666f 7220 2876 2c20 6429 2069      for (v, d) i
-00001c30: 6e20 6465 6772 6565 732e 6974 6572 5f6d  n degrees.iter_m
-00001c40: 7574 2829 2e65 6e75 6d65 7261 7465 2829  ut().enumerate()
-00001c50: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00001c60: 2020 202a 6420 3d20 662e 6465 6772 6565     *d = f.degree
-00001c70: 2876 292e 746f 5f75 3332 2829 2061 7320  (v).to_u32() as 
-00001c80: 7573 697a 653b 0a20 2020 2020 2020 2020  usize;.         
-00001c90: 2020 2020 2020 2069 6620 2a64 203e 2030         if *d > 0
-00001ca0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00001cb0: 2020 2020 2020 2076 6172 5f63 6f75 6e74         var_count
-00001cc0: 202b 3d20 313b 0a20 2020 2020 2020 2020   += 1;.         
-00001cd0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-00001ce0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-00001cf0: 2020 2020 6d61 7463 6820 7661 725f 636f      match var_co
-00001d00: 756e 7420 7b0a 2020 2020 2020 2020 2020  unt {.          
-00001d10: 2020 2020 2020 3020 7c20 3120 3d3e 2066        0 | 1 => f
-00001d20: 6163 746f 7273 2e65 7874 656e 6428 662e  actors.extend(f.
-00001d30: 6661 6374 6f72 5f72 6563 6f6e 7374 7275  factor_reconstru
-00001d40: 6374 2829 2e69 6e74 6f5f 6974 6572 2829  ct().into_iter()
-00001d50: 2e6d 6170 287c 6666 7c20 2866 662c 2070  .map(|ff| (ff, p
-00001d60: 2929 292c 0a20 2020 2020 2020 2020 2020  ))),.           
-00001d70: 2020 2020 2032 203d 3e20 7b0a 2020 2020       2 => {.    
-00001d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001d90: 6c65 7420 6d75 7420 6f72 6465 723a 2056  let mut order: V
-00001da0: 6563 3c5f 3e20 3d20 6465 6772 6565 730a  ec<_> = degrees.
-00001db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001dc0: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
-00001dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001de0: 2020 2020 2020 2020 2e65 6e75 6d65 7261          .enumera
-00001df0: 7465 2829 0a20 2020 2020 2020 2020 2020  te().           
-00001e00: 2020 2020 2020 2020 2020 2020 202e 6669               .fi
-00001e10: 6c74 6572 287c 285f 2c20 6429 7c20 2a2a  lter(|(_, d)| **
-00001e20: 6420 3e20 3029 0a20 2020 2020 2020 2020  d > 0).         
-00001e30: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00001e40: 636f 6c6c 6563 7428 293b 0a20 2020 2020  collect();.     
-00001e50: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-00001e60: 7264 6572 2e73 6f72 745f 6279 5f6b 6579  rder.sort_by_key
-00001e70: 287c 6f7c 2052 6576 6572 7365 286f 2e31  (|o| Reverse(o.1
-00001e80: 2929 3b0a 2020 2020 2020 2020 2020 2020  ));.            
-00001e90: 2020 2020 2020 2020 6c65 7420 6f72 6465          let orde
-00001ea0: 723a 2056 6563 3c5f 3e20 3d20 6f72 6465  r: Vec<_> = orde
-00001eb0: 722e 696e 746f 5f69 7465 7228 292e 6d61  r.into_iter().ma
-00001ec0: 7028 7c28 762c 205f 297c 2076 292e 636f  p(|(v, _)| v).co
-00001ed0: 6c6c 6563 7428 293b 0a0a 2020 2020 2020  llect();..      
-00001ee0: 2020 2020 2020 2020 2020 2020 2020 6661                fa
-00001ef0: 6374 6f72 732e 6578 7465 6e64 280a 2020  ctors.extend(.  
-00001f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f10: 2020 2020 2020 662e 6269 7661 7269 6174        f.bivariat
-00001f20: 655f 6661 6374 6f72 5f72 6563 6f6e 7374  e_factor_reconst
-00001f30: 7275 6374 286f 7264 6572 5b30 5d2c 206f  ruct(order[0], o
-00001f40: 7264 6572 5b31 5d29 0a20 2020 2020 2020  rder[1]).       
-00001f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f60: 2020 2020 202e 696e 746f 5f69 7465 7228       .into_iter(
-00001f70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00001f80: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
-00001f90: 6170 287c 6666 7c20 2866 662c 2070 2929  ap(|ff| (ff, p))
-00001fa0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00001fb0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00001fc0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00001fd0: 2020 2020 2020 2020 2020 5f20 3d3e 207b            _ => {
-00001fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001ff0: 2020 2020 202f 2f20 544f 444f 3a20 6669       // TODO: fi
-00002000: 6e64 2062 6574 7465 7220 6f72 6465 720a  nd better order.
-00002010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002020: 2020 2020 6c65 7420 6d75 7420 6f72 6465      let mut orde
-00002030: 723a 2056 6563 3c5f 3e20 3d20 6465 6772  r: Vec<_> = degr
-00002040: 6565 730a 2020 2020 2020 2020 2020 2020  ees.            
-00002050: 2020 2020 2020 2020 2020 2020 2e69 7465              .ite
-00002060: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-00002070: 2020 2020 2020 2020 2020 2020 2e65 6e75              .enu
-00002080: 6d65 7261 7465 2829 0a20 2020 2020 2020  merate().       
+000010f0: 2020 7d20 656c 7365 207b 0a20 2020 2020    } else {.     
+00001100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001110: 2020 2070 6f69 6e74 735b 695d 0a20 2020     points[i].   
+00001120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001130: 207d 3b0a 2020 2020 2020 2020 2020 2020   };.            
+00001140: 2020 2020 2020 2020 7768 696c 6520 742e          while t.
+00001150: 6c65 6e28 2920 3e3d 2032 2026 2620 6372  len() >= 2 && cr
+00001160: 6f73 7328 2674 5b74 2e6c 656e 2829 202d  oss(&t[t.len() -
+00001170: 2032 5d2c 2026 745b 742e 6c65 6e28 2920   2], &t[t.len() 
+00001180: 2d20 315d 2c20 2670 2920 3c3d 2030 207b  - 1], &p) <= 0 {
+00001190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000011a0: 2020 2020 2020 2020 2074 2e70 6f70 2829           t.pop()
+000011b0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+000011c0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+000011d0: 2020 2020 2020 2020 2020 2020 742e 7075              t.pu
+000011e0: 7368 2870 293b 0a20 2020 2020 2020 2020  sh(p);.         
+000011f0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00001200: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00001210: 2020 2020 6c6f 7765 722e 706f 7028 293b      lower.pop();
+00001220: 0a20 2020 2020 2020 2020 2020 2075 7070  .            upp
+00001230: 6572 2e70 6f70 2829 3b0a 2020 2020 2020  er.pop();.      
+00001240: 2020 2020 2020 6c6f 7765 722e 6578 7465        lower.exte
+00001250: 6e64 2875 7070 6572 293b 0a20 2020 2020  nd(upper);.     
+00001260: 2020 2020 2020 206c 6f77 6572 0a20 2020         lower.   
+00001270: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00001280: 6c65 7420 7661 7273 3a20 5665 633c 5f3e  let vars: Vec<_>
+00001290: 203d 2028 302e 2e73 656c 662e 6e76 6172   = (0..self.nvar
+000012a0: 7328 2929 0a20 2020 2020 2020 2020 2020  s()).           
+000012b0: 202e 6669 6c74 6572 287c 767c 2073 656c   .filter(|v| sel
+000012c0: 662e 6465 6772 6565 282a 7629 203e 2045  f.degree(*v) > E
+000012d0: 3a3a 7a65 726f 2829 290a 2020 2020 2020  ::zero()).      
+000012e0: 2020 2020 2020 2e63 6f6c 6c65 6374 2829        .collect()
+000012f0: 3b0a 0a20 2020 2020 2020 2069 6620 7661  ;..        if va
+00001300: 7273 2e6c 656e 2829 2021 3d20 3220 7b0a  rs.len() != 2 {.
+00001310: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00001320: 726e 2066 616c 7365 3b0a 2020 2020 2020  rn false;.      
+00001330: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
+00001340: 2070 6f69 6e74 7320 3d20 7365 6c66 0a20   points = self. 
+00001350: 2020 2020 2020 2020 2020 202e 6578 706f             .expo
+00001360: 6e65 6e74 730a 2020 2020 2020 2020 2020  nents.          
+00001370: 2020 2e63 6875 6e6b 7328 7365 6c66 2e6e    .chunks(self.n
+00001380: 7661 7273 2829 290a 2020 2020 2020 2020  vars()).        
+00001390: 2020 2020 2e6d 6170 287c 657c 2028 655b      .map(|e| (e[
+000013a0: 7661 7273 5b30 5d5d 2e74 6f5f 7533 3228  vars[0]].to_u32(
+000013b0: 2920 6173 2069 7369 7a65 2c20 655b 7661  ) as isize, e[va
+000013c0: 7273 5b31 5d5d 2e74 6f5f 7533 3228 2920  rs[1]].to_u32() 
+000013d0: 6173 2069 7369 7a65 2929 0a20 2020 2020  as isize)).     
+000013e0: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+000013f0: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
+00001400: 6875 6c6c 203d 2063 6f6e 7665 785f 6875  hull = convex_hu
+00001410: 6c6c 2870 6f69 6e74 7329 3b0a 0a20 2020  ll(points);..   
+00001420: 2020 2020 206d 6174 6368 2068 756c 6c2e       match hull.
+00001430: 6c65 6e28 2920 7b0a 2020 2020 2020 2020  len() {.        
+00001440: 2020 2020 3220 3d3e 207b 0a20 2020 2020      2 => {.     
+00001450: 2020 2020 2020 2020 2020 206c 6574 2078             let x
+00001460: 5f64 6567 203d 2068 756c 6c5b 305d 2e30  _deg = hull[0].0
+00001470: 2e61 6273 5f64 6966 6628 6875 6c6c 5b31  .abs_diff(hull[1
+00001480: 5d2e 3029 3b0a 2020 2020 2020 2020 2020  ].0);.          
+00001490: 2020 2020 2020 6c65 7420 795f 6465 6720        let y_deg 
+000014a0: 3d20 6875 6c6c 5b30 5d2e 312e 6162 735f  = hull[0].1.abs_
+000014b0: 6469 6666 2868 756c 6c5b 315d 2e31 293b  diff(hull[1].1);
+000014c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000014d0: 2075 7469 6c73 3a3a 6763 645f 756e 7369   utils::gcd_unsi
+000014e0: 676e 6564 2878 5f64 6567 2061 7320 7536  gned(x_deg as u6
+000014f0: 342c 2079 5f64 6567 2061 7320 7536 3429  4, y_deg as u64)
+00001500: 203d 3d20 310a 2020 2020 2020 2020 2020   == 1.          
+00001510: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
+00001520: 3320 3d3e 207b 0a20 2020 2020 2020 2020  3 => {.         
+00001530: 2020 2020 2020 202f 2f20 7468 6520 6875         // the hu
+00001540: 6c6c 2068 6173 2074 6865 2066 6f72 6d20  ll has the form 
+00001550: 286e 2c20 3029 2c20 2830 2c20 6d29 2c20  (n, 0), (0, m), 
+00001560: 2875 2c20 7629 0a20 2020 2020 2020 2020  (u, v).         
+00001570: 2020 2020 2020 206c 6574 2028 6d75 7420         let (mut 
+00001580: 6e2c 206d 7574 206d 2c20 6d75 7420 752c  n, mut m, mut u,
+00001590: 206d 7574 2076 2920 3d20 282d 312c 202d   mut v) = (-1, -
+000015a0: 312c 202d 312c 202d 3129 3b0a 2020 2020  1, -1, -1);.    
+000015b0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000015c0: 2878 2c20 7929 2069 6e20 6875 6c6c 207b  (x, y) in hull {
+000015d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000015e0: 2020 2020 2069 6620 7820 213d 2030 2026       if x != 0 &
+000015f0: 2620 7920 3d3d 2030 207b 0a20 2020 2020  & y == 0 {.     
+00001600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001610: 2020 206e 203d 2078 3b0a 2020 2020 2020     n = x;.      
+00001620: 2020 2020 2020 2020 2020 2020 2020 7d20                } 
+00001630: 656c 7365 2069 6620 7920 213d 2030 2026  else if y != 0 &
+00001640: 2620 7820 3d3d 2030 207b 0a20 2020 2020  & x == 0 {.     
+00001650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001660: 2020 206d 203d 2079 3b0a 2020 2020 2020     m = y;.      
+00001670: 2020 2020 2020 2020 2020 2020 2020 7d20                } 
+00001680: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
+00001690: 2020 2020 2020 2020 2020 2020 2020 2075                 u
+000016a0: 203d 2078 3b0a 2020 2020 2020 2020 2020   = x;.          
+000016b0: 2020 2020 2020 2020 2020 2020 2020 7620                v 
+000016c0: 3d20 793b 0a20 2020 2020 2020 2020 2020  = y;.           
+000016d0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+000016e0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+000016f0: 2020 2020 2020 2020 2020 2020 2020 6e20                n 
+00001700: 213d 202d 310a 2020 2020 2020 2020 2020  != -1.          
+00001710: 2020 2020 2020 2020 2020 2626 206d 2021            && m !
+00001720: 3d20 2d31 0a20 2020 2020 2020 2020 2020  = -1.           
+00001730: 2020 2020 2020 2020 2026 2620 7520 213d           && u !=
+00001740: 202d 310a 2020 2020 2020 2020 2020 2020   -1.            
+00001750: 2020 2020 2020 2020 2626 2076 2021 3d20          && v != 
+00001760: 2d31 0a20 2020 2020 2020 2020 2020 2020  -1.             
+00001770: 2020 2020 2020 2026 2620 7574 696c 733a         && utils:
+00001780: 3a67 6364 5f75 6e73 6967 6e65 6428 0a20  :gcd_unsigned(. 
+00001790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000017a0: 2020 2020 2020 2075 7469 6c73 3a3a 6763         utils::gc
+000017b0: 645f 756e 7369 676e 6564 2875 7469 6c73  d_unsigned(utils
+000017c0: 3a3a 6763 645f 756e 7369 676e 6564 286e  ::gcd_unsigned(n
+000017d0: 2061 7320 7536 342c 206d 2061 7320 7536   as u64, m as u6
+000017e0: 3429 2c20 7520 6173 2075 3634 292c 0a20  4), u as u64),. 
+000017f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001800: 2020 2020 2020 2076 2061 7320 7536 342c         v as u64,
+00001810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001820: 2020 2020 2029 203d 3d20 310a 2020 2020       ) == 1.    
+00001830: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00001840: 2020 2020 2020 5f20 3d3e 2066 616c 7365        _ => false
+00001850: 2c0a 2020 2020 2020 2020 7d0a 2020 2020  ,.        }.    
+00001860: 7d0a 7d0a 0a69 6d70 6c3c 453a 2045 7870  }.}..impl<E: Exp
+00001870: 6f6e 656e 743e 2046 6163 746f 7269 7a65  onent> Factorize
+00001880: 2066 6f72 204d 756c 7469 7661 7269 6174   for Multivariat
+00001890: 6550 6f6c 796e 6f6d 6961 6c3c 496e 7465  ePolynomial<Inte
+000018a0: 6765 7252 696e 672c 2045 2c20 4c65 784f  gerRing, E, LexO
+000018b0: 7264 6572 3e20 7b0a 2020 2020 666e 2073  rder> {.    fn s
+000018c0: 7175 6172 655f 6672 6565 5f66 6163 746f  quare_free_facto
+000018d0: 7269 7a61 7469 6f6e 2826 7365 6c66 2920  rization(&self) 
+000018e0: 2d3e 2056 6563 3c28 5365 6c66 2c20 7573  -> Vec<(Self, us
+000018f0: 697a 6529 3e20 7b0a 2020 2020 2020 2020  ize)> {.        
+00001900: 6966 2073 656c 662e 6973 5f7a 6572 6f28  if self.is_zero(
+00001910: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00001920: 7265 7475 726e 2076 6563 215b 5d3b 0a20  return vec![];. 
+00001930: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+00001940: 2020 6c65 7420 6320 3d20 7365 6c66 2e63    let c = self.c
+00001950: 6f6e 7465 6e74 2829 3b0a 2020 2020 2020  ontent();.      
+00001960: 2020 6c65 7420 7374 7269 7070 6564 203d    let stripped =
+00001970: 2073 656c 662e 636c 6f6e 6528 292e 6469   self.clone().di
+00001980: 765f 636f 6566 6628 2663 293b 0a0a 2020  v_coeff(&c);..  
+00001990: 2020 2020 2020 6c65 7420 6d75 7420 6661        let mut fa
+000019a0: 6374 6f72 7320 3d20 7665 6321 5b5d 3b0a  ctors = vec![];.
+000019b0: 0a20 2020 2020 2020 2069 6620 2163 2e69  .        if !c.i
+000019c0: 735f 6f6e 6528 2920 7b0a 2020 2020 2020  s_one() {.      
+000019d0: 2020 2020 2020 6661 6374 6f72 732e 7075        factors.pu
+000019e0: 7368 2828 7365 6c66 2e63 6f6e 7374 616e  sh((self.constan
+000019f0: 7428 6329 2c20 3129 293b 0a20 2020 2020  t(c), 1));.     
+00001a00: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
+00001a10: 7420 6673 203d 2073 7472 6970 7065 642e  t fs = stripped.
+00001a20: 6661 6374 6f72 5f73 6570 6172 6162 6c65  factor_separable
+00001a30: 2829 3b0a 0a20 2020 2020 2020 2066 6f72  ();..        for
+00001a40: 2066 2069 6e20 6673 207b 0a20 2020 2020   f in fs {.     
+00001a50: 2020 2020 2020 206c 6574 206d 7574 206e         let mut n
+00001a60: 6620 3d20 662e 7371 7561 7265 5f66 7265  f = f.square_fre
+00001a70: 655f 6661 6374 6f72 697a 6174 696f 6e5f  e_factorization_
+00001a80: 305f 6368 6172 2829 3b0a 2020 2020 2020  0_char();.      
+00001a90: 2020 2020 2020 6661 6374 6f72 732e 6170        factors.ap
+00001aa0: 7065 6e64 2826 6d75 7420 6e66 293b 0a20  pend(&mut nf);. 
+00001ab0: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+00001ac0: 2020 6966 2066 6163 746f 7273 2e69 735f    if factors.is_
+00001ad0: 656d 7074 7928 2920 7b0a 2020 2020 2020  empty() {.      
+00001ae0: 2020 2020 2020 6661 6374 6f72 732e 7075        factors.pu
+00001af0: 7368 2828 7365 6c66 2e6f 6e65 2829 2c20  sh((self.one(), 
+00001b00: 3129 290a 2020 2020 2020 2020 7d0a 0a20  1)).        }.. 
+00001b10: 2020 2020 2020 2066 6163 746f 7273 0a20         factors. 
+00001b20: 2020 207d 0a0a 2020 2020 666e 2066 6163     }..    fn fac
+00001b30: 746f 7228 2673 656c 6629 202d 3e20 5665  tor(&self) -> Ve
+00001b40: 633c 2853 656c 662c 2075 7369 7a65 293e  c<(Self, usize)>
+00001b50: 207b 0a20 2020 2020 2020 206c 6574 2073   {.        let s
+00001b60: 6620 3d20 7365 6c66 2e73 7175 6172 655f  f = self.square_
+00001b70: 6672 6565 5f66 6163 746f 7269 7a61 7469  free_factorizati
+00001b80: 6f6e 2829 3b0a 0a20 2020 2020 2020 206c  on();..        l
+00001b90: 6574 206d 7574 2066 6163 746f 7273 203d  et mut factors =
+00001ba0: 2076 6563 215b 5d3b 0a20 2020 2020 2020   vec![];.       
+00001bb0: 206c 6574 206d 7574 2064 6567 7265 6573   let mut degrees
+00001bc0: 203d 2076 6563 215b 303b 2073 656c 662e   = vec![0; self.
+00001bd0: 6e76 6172 7328 295d 3b0a 2020 2020 2020  nvars()];.      
+00001be0: 2020 666f 7220 2866 2c20 7029 2069 6e20    for (f, p) in 
+00001bf0: 7366 207b 0a20 2020 2020 2020 2020 2020  sf {.           
+00001c00: 2064 6562 7567 2128 2253 4646 207b 7d20   debug!("SFF {} 
+00001c10: 7b7d 222c 2066 2c20 7029 3b0a 0a20 2020  {}", f, p);..   
+00001c20: 2020 2020 2020 2020 206c 6574 206d 7574           let mut
+00001c30: 2076 6172 5f63 6f75 6e74 203d 2030 3b0a   var_count = 0;.
+00001c40: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00001c50: 2876 2c20 6429 2069 6e20 6465 6772 6565  (v, d) in degree
+00001c60: 732e 6974 6572 5f6d 7574 2829 2e65 6e75  s.iter_mut().enu
+00001c70: 6d65 7261 7465 2829 207b 0a20 2020 2020  merate() {.     
+00001c80: 2020 2020 2020 2020 2020 202a 6420 3d20             *d = 
+00001c90: 662e 6465 6772 6565 2876 292e 746f 5f75  f.degree(v).to_u
+00001ca0: 3332 2829 2061 7320 7573 697a 653b 0a20  32() as usize;. 
+00001cb0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00001cc0: 6620 2a64 203e 2030 207b 0a20 2020 2020  f *d > 0 {.     
+00001cd0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00001ce0: 6172 5f63 6f75 6e74 202b 3d20 313b 0a20  ar_count += 1;. 
+00001cf0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00001d00: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+00001d10: 2020 2020 2020 2020 2020 2020 6d61 7463              matc
+00001d20: 6820 7661 725f 636f 756e 7420 7b0a 2020  h var_count {.  
+00001d30: 2020 2020 2020 2020 2020 2020 2020 3020                0 
+00001d40: 7c20 3120 3d3e 2066 6163 746f 7273 2e65  | 1 => factors.e
+00001d50: 7874 656e 6428 662e 6661 6374 6f72 5f72  xtend(f.factor_r
+00001d60: 6563 6f6e 7374 7275 6374 2829 2e69 6e74  econstruct().int
+00001d70: 6f5f 6974 6572 2829 2e6d 6170 287c 6666  o_iter().map(|ff
+00001d80: 7c20 2866 662c 2070 2929 292c 0a20 2020  | (ff, p))),.   
+00001d90: 2020 2020 2020 2020 2020 2020 2032 203d               2 =
+00001da0: 3e20 7b0a 2020 2020 2020 2020 2020 2020  > {.            
+00001db0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00001dc0: 6f72 6465 723a 2056 6563 3c5f 3e20 3d20  order: Vec<_> = 
+00001dd0: 6465 6772 6565 730a 2020 2020 2020 2020  degrees.        
+00001de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001df0: 2e69 7465 7228 290a 2020 2020 2020 2020  .iter().        
+00001e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e10: 2e65 6e75 6d65 7261 7465 2829 0a20 2020  .enumerate().   
+00001e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e30: 2020 2020 202e 6669 6c74 6572 287c 285f       .filter(|(_
+00001e40: 2c20 6429 7c20 2a2a 6420 3e20 3029 0a20  , d)| **d > 0). 
+00001e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e60: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+00001e70: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00001e80: 2020 2020 2020 206f 7264 6572 2e73 6f72         order.sor
+00001e90: 745f 6279 5f6b 6579 287c 6f7c 2052 6576  t_by_key(|o| Rev
+00001ea0: 6572 7365 286f 2e31 2929 3b0a 2020 2020  erse(o.1));.    
+00001eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001ec0: 6c65 7420 6f72 6465 723a 2056 6563 3c5f  let order: Vec<_
+00001ed0: 3e20 3d20 6f72 6465 722e 696e 746f 5f69  > = order.into_i
+00001ee0: 7465 7228 292e 6d61 7028 7c28 762c 205f  ter().map(|(v, _
+00001ef0: 297c 2076 292e 636f 6c6c 6563 7428 293b  )| v).collect();
+00001f00: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00001f10: 2020 2020 2020 6661 6374 6f72 732e 6578        factors.ex
+00001f20: 7465 6e64 280a 2020 2020 2020 2020 2020  tend(.          
+00001f30: 2020 2020 2020 2020 2020 2020 2020 662e                f.
+00001f40: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+00001f50: 5f72 6563 6f6e 7374 7275 6374 286f 7264  _reconstruct(ord
+00001f60: 6572 5b30 5d2c 206f 7264 6572 5b31 5d29  er[0], order[1])
+00001f70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001f80: 2020 2020 2020 2020 2020 2020 202e 696e               .in
+00001f90: 746f 5f69 7465 7228 290a 2020 2020 2020  to_iter().      
+00001fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001fb0: 2020 2020 2020 2e6d 6170 287c 6666 7c20        .map(|ff| 
+00001fc0: 2866 662c 2070 2929 2c0a 2020 2020 2020  (ff, p)),.      
+00001fd0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00001fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001ff0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+00002000: 2020 5f20 3d3e 207b 0a20 2020 2020 2020    _ => {.       
+00002010: 2020 2020 2020 2020 2020 2020 202f 2f20               // 
+00002020: 544f 444f 3a20 6669 6e64 2062 6574 7465  TODO: find bette
+00002030: 7220 6f72 6465 720a 2020 2020 2020 2020  r order.        
+00002040: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+00002050: 6d75 7420 6f72 6465 723a 2056 6563 3c5f  mut order: Vec<_
+00002060: 3e20 3d20 6465 6772 6565 730a 2020 2020  > = degrees.    
+00002070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002080: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
 00002090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000020a0: 202e 6669 6c74 6572 287c 285f 2c20 6429   .filter(|(_, d)
-000020b0: 7c20 2a2a 6420 3e20 3029 0a20 2020 2020  | **d > 0).     
-000020c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000020d0: 2020 202e 636f 6c6c 6563 7428 293b 0a20     .collect();. 
-000020e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000020f0: 2020 206f 7264 6572 2e73 6f72 745f 6279     order.sort_by
-00002100: 5f6b 6579 287c 6f7c 2052 6576 6572 7365  _key(|o| Reverse
-00002110: 286f 2e31 2929 3b0a 0a20 2020 2020 2020  (o.1));..       
-00002120: 2020 2020 2020 2020 2020 2020 206c 6574               let
-00002130: 206d 7574 206f 7264 6572 3a20 5665 633c   mut order: Vec<
-00002140: 5f3e 203d 206f 7264 6572 2e69 6e74 6f5f  _> = order.into_
-00002150: 6974 6572 2829 2e6d 6170 287c 2876 2c20  iter().map(|(v, 
-00002160: 5f29 7c20 7629 2e63 6f6c 6c65 6374 2829  _)| v).collect()
-00002170: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
-00002180: 2020 2020 2020 2066 6163 746f 7273 2e65         factors.e
-00002190: 7874 656e 6428 0a20 2020 2020 2020 2020  xtend(.         
+000020a0: 2020 2020 2e65 6e75 6d65 7261 7465 2829      .enumerate()
+000020b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000020c0: 2020 2020 2020 2020 202e 6669 6c74 6572           .filter
+000020d0: 287c 285f 2c20 6429 7c20 2a2a 6420 3e20  (|(_, d)| **d > 
+000020e0: 3029 0a20 2020 2020 2020 2020 2020 2020  0).             
+000020f0: 2020 2020 2020 2020 2020 202e 636f 6c6c             .coll
+00002100: 6563 7428 293b 0a20 2020 2020 2020 2020  ect();.         
+00002110: 2020 2020 2020 2020 2020 206f 7264 6572             order
+00002120: 2e73 6f72 745f 6279 5f6b 6579 287c 6f7c  .sort_by_key(|o|
+00002130: 2052 6576 6572 7365 286f 2e31 2929 3b0a   Reverse(o.1));.
+00002140: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002150: 2020 2020 206c 6574 206d 7574 206f 7264       let mut ord
+00002160: 6572 3a20 5665 633c 5f3e 203d 206f 7264  er: Vec<_> = ord
+00002170: 6572 2e69 6e74 6f5f 6974 6572 2829 2e6d  er.into_iter().m
+00002180: 6170 287c 2876 2c20 5f29 7c20 7629 2e63  ap(|(v, _)| v).c
+00002190: 6f6c 6c65 6374 2829 3b0a 0a20 2020 2020  ollect();..     
 000021a0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000021b0: 2e6d 756c 7469 7661 7269 6174 655f 6661  .multivariate_fa
-000021c0: 6374 6f72 697a 6174 696f 6e28 266d 7574  ctorization(&mut
-000021d0: 206f 7264 6572 2c20 302c 204e 6f6e 6529   order, 0, None)
-000021e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000021f0: 2020 2020 2020 2020 2020 2020 202e 696e               .in
-00002200: 746f 5f69 7465 7228 290a 2020 2020 2020  to_iter().      
+000021b0: 6163 746f 7273 2e65 7874 656e 6428 0a20  actors.extend(. 
+000021c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000021d0: 2020 2020 2020 2066 2e6d 756c 7469 7661         f.multiva
+000021e0: 7269 6174 655f 6661 6374 6f72 697a 6174  riate_factorizat
+000021f0: 696f 6e28 266d 7574 206f 7264 6572 2c20  ion(&mut order, 
+00002200: 302c 204e 6f6e 6529 0a20 2020 2020 2020  0, None).       
 00002210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002220: 2020 2020 2020 2e6d 6170 287c 6666 7c20        .map(|ff| 
-00002230: 2866 662c 2070 2929 2c0a 2020 2020 2020  (ff, p)),.      
-00002240: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00002250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002260: 7d0a 2020 2020 2020 2020 2020 2020 7d0a  }.            }.
-00002270: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00002280: 2020 2066 6163 746f 7273 0a20 2020 207d     factors.    }
-00002290: 0a7d 0a0a 696d 706c 3c45 3a20 4578 706f  .}..impl<E: Expo
-000022a0: 6e65 6e74 3e20 4661 6374 6f72 697a 6520  nent> Factorize 
-000022b0: 666f 7220 4d75 6c74 6976 6172 6961 7465  for Multivariate
-000022c0: 506f 6c79 6e6f 6d69 616c 3c52 6174 696f  Polynomial<Ratio
-000022d0: 6e61 6c46 6965 6c64 2c20 452c 204c 6578  nalField, E, Lex
-000022e0: 4f72 6465 723e 207b 0a20 2020 2066 6e20  Order> {.    fn 
-000022f0: 7371 7561 7265 5f66 7265 655f 6661 6374  square_free_fact
-00002300: 6f72 697a 6174 696f 6e28 2673 656c 6629  orization(&self)
-00002310: 202d 3e20 5665 633c 2853 656c 662c 2075   -> Vec<(Self, u
-00002320: 7369 7a65 293e 207b 0a20 2020 2020 2020  size)> {.       
-00002330: 206c 6574 2063 203d 2073 656c 662e 636f   let c = self.co
-00002340: 6e74 656e 7428 293b 0a0a 2020 2020 2020  ntent();..      
-00002350: 2020 6c65 7420 7374 7269 7070 6564 203d    let stripped =
-00002360: 2073 656c 662e 6d61 705f 636f 6566 6628   self.map_coeff(
-00002370: 0a20 2020 2020 2020 2020 2020 207c 636f  .            |co
-00002380: 6566 667c 207b 0a20 2020 2020 2020 2020  eff| {.         
-00002390: 2020 2020 2020 206c 6574 2063 6f65 6666         let coeff
-000023a0: 203d 2073 656c 662e 6669 656c 642e 6469   = self.field.di
-000023b0: 7628 636f 6566 662c 2026 6329 3b0a 2020  v(coeff, &c);.  
-000023c0: 2020 2020 2020 2020 2020 2020 2020 6465                de
-000023d0: 6275 675f 6173 7365 7274 2128 636f 6566  bug_assert!(coef
-000023e0: 662e 6973 5f69 6e74 6567 6572 2829 293b  f.is_integer());
-000023f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002400: 2063 6f65 6666 2e6e 756d 6572 6174 6f72   coeff.numerator
-00002410: 2829 0a20 2020 2020 2020 2020 2020 207d  ().            }
-00002420: 2c0a 2020 2020 2020 2020 2020 2020 496e  ,.            In
-00002430: 7465 6765 7252 696e 673a 3a6e 6577 2829  tegerRing::new()
-00002440: 2c0a 2020 2020 2020 2020 293b 0a0a 2020  ,.        );..  
-00002450: 2020 2020 2020 6c65 7420 6673 203d 2073        let fs = s
-00002460: 7472 6970 7065 642e 7371 7561 7265 5f66  tripped.square_f
-00002470: 7265 655f 6661 6374 6f72 697a 6174 696f  ree_factorizatio
-00002480: 6e28 293b 0a0a 2020 2020 2020 2020 6c65  n();..        le
-00002490: 7420 6d75 7420 6661 6374 6f72 733a 2056  t mut factors: V
-000024a0: 6563 3c5f 3e20 3d20 6673 0a20 2020 2020  ec<_> = fs.     
-000024b0: 2020 2020 2020 202e 696e 746f 5f69 7465         .into_ite
-000024c0: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-000024d0: 2e6d 6170 287c 2866 2c20 6529 7c20 2866  .map(|(f, e)| (f
-000024e0: 2e6d 6170 5f63 6f65 6666 287c 636f 6566  .map_coeff(|coef
-000024f0: 667c 2063 6f65 6666 2e69 6e74 6f28 292c  f| coeff.into(),
-00002500: 2052 6174 696f 6e61 6c46 6965 6c64 3a3a   RationalField::
-00002510: 6e65 7728 2929 2c20 6529 290a 2020 2020  new()), e)).    
-00002520: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
-00002530: 2829 3b0a 0a20 2020 2020 2020 2069 6620  ();..        if 
-00002540: 2163 2e69 735f 6f6e 6528 2920 7b0a 2020  !c.is_one() {.  
-00002550: 2020 2020 2020 2020 2020 6661 6374 6f72            factor
-00002560: 732e 7075 7368 2828 7365 6c66 2e63 6f6e  s.push((self.con
-00002570: 7374 616e 7428 6329 2c20 3129 293b 0a20  stant(c), 1));. 
-00002580: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
-00002590: 2020 6661 6374 6f72 730a 2020 2020 7d0a    factors.    }.
-000025a0: 0a20 2020 2066 6e20 6661 6374 6f72 2826  .    fn factor(&
-000025b0: 7365 6c66 2920 2d3e 2056 6563 3c28 5365  self) -> Vec<(Se
-000025c0: 6c66 2c20 7573 697a 6529 3e20 7b0a 2020  lf, usize)> {.  
-000025d0: 2020 2020 2020 6c65 7420 6320 3d20 7365        let c = se
-000025e0: 6c66 2e63 6f6e 7465 6e74 2829 3b0a 0a20  lf.content();.. 
-000025f0: 2020 2020 2020 206c 6574 2073 7472 6970         let strip
-00002600: 7065 6420 3d20 7365 6c66 2e6d 6170 5f63  ped = self.map_c
-00002610: 6f65 6666 280a 2020 2020 2020 2020 2020  oeff(.          
-00002620: 2020 7c63 6f65 6666 7c20 7b0a 2020 2020    |coeff| {.    
-00002630: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00002640: 636f 6566 6620 3d20 7365 6c66 2e66 6965  coeff = self.fie
-00002650: 6c64 2e64 6976 2863 6f65 6666 2c20 2663  ld.div(coeff, &c
-00002660: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00002670: 2020 2064 6562 7567 5f61 7373 6572 7421     debug_assert!
-00002680: 2863 6f65 6666 2e69 735f 696e 7465 6765  (coeff.is_intege
-00002690: 7228 2929 3b0a 2020 2020 2020 2020 2020  r());.          
-000026a0: 2020 2020 2020 636f 6566 662e 6e75 6d65        coeff.nume
-000026b0: 7261 746f 7228 290a 2020 2020 2020 2020  rator().        
-000026c0: 2020 2020 7d2c 0a20 2020 2020 2020 2020      },.         
-000026d0: 2020 2049 6e74 6567 6572 5269 6e67 3a3a     IntegerRing::
-000026e0: 6e65 7728 292c 0a20 2020 2020 2020 2029  new(),.        )
-000026f0: 3b0a 0a20 2020 2020 2020 206c 6574 206d  ;..        let m
-00002700: 7574 2066 6163 746f 7273 3a20 5665 633c  ut factors: Vec<
-00002710: 5f3e 203d 2073 7472 6970 7065 640a 2020  _> = stripped.  
-00002720: 2020 2020 2020 2020 2020 2e66 6163 746f            .facto
-00002730: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-00002740: 2e69 6e74 6f5f 6974 6572 2829 0a20 2020  .into_iter().   
-00002750: 2020 2020 2020 2020 202e 6d61 7028 7c28           .map(|(
-00002760: 6666 2c20 7029 7c20 2866 662e 6d61 705f  ff, p)| (ff.map_
-00002770: 636f 6566 6628 7c63 6f65 6666 7c20 636f  coeff(|coeff| co
-00002780: 6566 662e 696e 746f 2829 2c20 5261 7469  eff.into(), Rati
-00002790: 6f6e 616c 4669 656c 643a 3a6e 6577 2829  onalField::new()
-000027a0: 292c 2070 2929 0a20 2020 2020 2020 2020  ), p)).         
-000027b0: 2020 202e 636f 6c6c 6563 7428 293b 0a0a     .collect();..
-000027c0: 2020 2020 2020 2020 6966 2021 632e 6973          if !c.is
-000027d0: 5f6f 6e65 2829 207b 0a20 2020 2020 2020  _one() {.       
-000027e0: 2020 2020 2066 6163 746f 7273 2e70 7573       factors.pus
-000027f0: 6828 2873 656c 662e 636f 6e73 7461 6e74  h((self.constant
-00002800: 2863 292c 2031 2929 3b0a 2020 2020 2020  (c), 1));.      
-00002810: 2020 7d0a 0a20 2020 2020 2020 2066 6163    }..        fac
-00002820: 746f 7273 0a20 2020 207d 0a7d 0a0a 696d  tors.    }.}..im
-00002830: 706c 3c55 4669 656c 643a 2046 696e 6974  pl<UField: Finit
-00002840: 6546 6965 6c64 576f 726b 7370 6163 652c  eFieldWorkspace,
-00002850: 2045 3a20 4578 706f 6e65 6e74 3e20 4661   E: Exponent> Fa
-00002860: 6374 6f72 697a 650a 2020 2020 666f 7220  ctorize.    for 
-00002870: 4d75 6c74 6976 6172 6961 7465 506f 6c79  MultivariatePoly
-00002880: 6e6f 6d69 616c 3c46 696e 6974 6546 6965  nomial<FiniteFie
-00002890: 6c64 3c55 4669 656c 643e 2c20 452c 204c  ld<UField>, E, L
-000028a0: 6578 4f72 6465 723e 0a77 6865 7265 0a20  exOrder>.where. 
-000028b0: 2020 2046 696e 6974 6546 6965 6c64 3c55     FiniteField<U
-000028c0: 4669 656c 643e 3a20 4669 656c 6420 2b20  Field>: Field + 
-000028d0: 506f 6c79 6e6f 6d69 616c 4743 443c 453e  PolynomialGCD<E>
-000028e0: 202b 2046 696e 6974 6546 6965 6c64 436f   + FiniteFieldCo
-000028f0: 7265 3c55 4669 656c 643e 2c0a 7b0a 2020  re<UField>,.{.  
-00002900: 2020 666e 2073 7175 6172 655f 6672 6565    fn square_free
-00002910: 5f66 6163 746f 7269 7a61 7469 6f6e 2826  _factorization(&
-00002920: 7365 6c66 2920 2d3e 2056 6563 3c28 5365  self) -> Vec<(Se
-00002930: 6c66 2c20 7573 697a 6529 3e20 7b0a 2020  lf, usize)> {.  
-00002940: 2020 2020 2020 6c65 7420 6320 3d20 7365        let c = se
-00002950: 6c66 2e63 6f6e 7465 6e74 2829 3b0a 2020  lf.content();.  
-00002960: 2020 2020 2020 6c65 7420 7374 7269 7070        let stripp
-00002970: 6564 203d 2073 656c 662e 636c 6f6e 6528  ed = self.clone(
-00002980: 292e 6469 765f 636f 6566 6628 2663 293b  ).div_coeff(&c);
-00002990: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
-000029a0: 7420 6661 6374 6f72 7320 3d20 7665 6321  t factors = vec!
-000029b0: 5b5d 3b0a 2020 2020 2020 2020 6c65 7420  [];.        let 
-000029c0: 6673 203d 2073 7472 6970 7065 642e 6661  fs = stripped.fa
-000029d0: 6374 6f72 5f73 6570 6172 6162 6c65 2829  ctor_separable()
-000029e0: 3b0a 0a20 2020 2020 2020 2066 6f72 2066  ;..        for f
-000029f0: 2069 6e20 6673 207b 0a20 2020 2020 2020   in fs {.       
-00002a00: 2020 2020 206c 6574 206d 7574 206e 6620       let mut nf 
-00002a10: 3d20 662e 7371 7561 7265 5f66 7265 655f  = f.square_free_
-00002a20: 6661 6374 6f72 697a 6174 696f 6e5f 6265  factorization_be
-00002a30: 726e 6172 6469 6e28 293b 0a20 2020 2020  rnardin();.     
-00002a40: 2020 2020 2020 2066 6163 746f 7273 2e61         factors.a
-00002a50: 7070 656e 6428 266d 7574 206e 6629 3b0a  ppend(&mut nf);.
-00002a60: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00002a70: 2020 2069 6620 6661 6374 6f72 732e 6973     if factors.is
-00002a80: 5f65 6d70 7479 2829 207c 7c20 2173 656c  _empty() || !sel
-00002a90: 662e 6669 656c 642e 6973 5f6f 6e65 2826  f.field.is_one(&
-00002aa0: 6329 207b 0a20 2020 2020 2020 2020 2020  c) {.           
-00002ab0: 2066 6163 746f 7273 2e70 7573 6828 2873   factors.push((s
-00002ac0: 656c 662e 636f 6e73 7461 6e74 2863 292c  elf.constant(c),
-00002ad0: 2031 2929 0a20 2020 2020 2020 207d 0a0a   1)).        }..
-00002ae0: 2020 2020 2020 2020 6661 6374 6f72 730a          factors.
-00002af0: 2020 2020 7d0a 0a20 2020 2066 6e20 6661      }..    fn fa
-00002b00: 6374 6f72 2826 7365 6c66 2920 2d3e 2056  ctor(&self) -> V
-00002b10: 6563 3c28 5365 6c66 2c20 7573 697a 6529  ec<(Self, usize)
-00002b20: 3e20 7b0a 2020 2020 2020 2020 6c65 7420  > {.        let 
-00002b30: 7366 203d 2073 656c 662e 7371 7561 7265  sf = self.square
-00002b40: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
-00002b50: 696f 6e28 293b 0a0a 2020 2020 2020 2020  ion();..        
-00002b60: 6c65 7420 6d75 7420 6661 6374 6f72 7320  let mut factors 
-00002b70: 3d20 7665 6321 5b5d 3b0a 2020 2020 2020  = vec![];.      
-00002b80: 2020 6c65 7420 6d75 7420 6465 6772 6565    let mut degree
-00002b90: 7320 3d20 7665 6321 5b30 3b20 7365 6c66  s = vec![0; self
-00002ba0: 2e6e 7661 7273 5d3b 0a20 2020 2020 2020  .nvars];.       
-00002bb0: 2066 6f72 2028 662c 2070 2920 696e 2073   for (f, p) in s
-00002bc0: 6620 7b0a 2020 2020 2020 2020 2020 2020  f {.            
-00002bd0: 6465 6275 6721 2822 5346 4620 7b7d 207b  debug!("SFF {} {
-00002be0: 7d22 2c20 662c 2070 293b 0a0a 2020 2020  }", f, p);..    
-00002bf0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-00002c00: 7661 725f 636f 756e 7420 3d20 303b 0a20  var_count = 0;. 
-00002c10: 2020 2020 2020 2020 2020 2066 6f72 2076             for v
-00002c20: 2069 6e20 302e 2e73 656c 662e 6e76 6172   in 0..self.nvar
-00002c30: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
-00002c40: 2020 2020 6465 6772 6565 735b 765d 203d      degrees[v] =
-00002c50: 2066 2e64 6567 7265 6528 7629 2e74 6f5f   f.degree(v).to_
-00002c60: 7533 3228 2920 6173 2075 7369 7a65 3b0a  u32() as usize;.
-00002c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c80: 6966 2064 6567 7265 6573 5b76 5d20 3e20  if degrees[v] > 
-00002c90: 3020 7b0a 2020 2020 2020 2020 2020 2020  0 {.            
-00002ca0: 2020 2020 2020 2020 7661 725f 636f 756e          var_coun
-00002cb0: 7420 2b3d 2031 3b0a 2020 2020 2020 2020  t += 1;.        
-00002cc0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00002cd0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00002ce0: 2020 2020 206d 6174 6368 2076 6172 5f63       match var_c
-00002cf0: 6f75 6e74 207b 0a20 2020 2020 2020 2020  ount {.         
-00002d00: 2020 2020 2020 2030 207c 2031 203d 3e20         0 | 1 => 
-00002d10: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00002d20: 2020 2020 2020 666f 7220 2864 322c 2066        for (d2, f
-00002d30: 3229 2069 6e20 662e 6469 7374 696e 6374  2) in f.distinct
-00002d40: 5f64 6567 7265 655f 6661 6374 6f72 697a  _degree_factoriz
-00002d50: 6174 696f 6e28 2920 7b0a 2020 2020 2020  ation() {.      
-00002d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d70: 2020 6465 6275 6721 2822 4444 4620 7b7d    debug!("DDF {}
-00002d80: 207b 7d22 2c20 6632 2c20 6432 293b 0a20   {}", f2, d2);. 
+00002220: 2020 2020 202e 696e 746f 5f69 7465 7228       .into_iter(
+00002230: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00002240: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
+00002250: 6170 287c 6666 7c20 2866 662c 2070 2929  ap(|ff| (ff, p))
+00002260: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00002270: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00002280: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00002290: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+000022a0: 7d0a 0a20 2020 2020 2020 2066 6163 746f  }..        facto
+000022b0: 7273 0a20 2020 207d 0a7d 0a0a 696d 706c  rs.    }.}..impl
+000022c0: 3c45 3a20 4578 706f 6e65 6e74 3e20 4661  <E: Exponent> Fa
+000022d0: 6374 6f72 697a 6520 666f 7220 4d75 6c74  ctorize for Mult
+000022e0: 6976 6172 6961 7465 506f 6c79 6e6f 6d69  ivariatePolynomi
+000022f0: 616c 3c52 6174 696f 6e61 6c46 6965 6c64  al<RationalField
+00002300: 2c20 452c 204c 6578 4f72 6465 723e 207b  , E, LexOrder> {
+00002310: 0a20 2020 2066 6e20 7371 7561 7265 5f66  .    fn square_f
+00002320: 7265 655f 6661 6374 6f72 697a 6174 696f  ree_factorizatio
+00002330: 6e28 2673 656c 6629 202d 3e20 5665 633c  n(&self) -> Vec<
+00002340: 2853 656c 662c 2075 7369 7a65 293e 207b  (Self, usize)> {
+00002350: 0a20 2020 2020 2020 206c 6574 2063 203d  .        let c =
+00002360: 2073 656c 662e 636f 6e74 656e 7428 293b   self.content();
+00002370: 0a0a 2020 2020 2020 2020 6c65 7420 7374  ..        let st
+00002380: 7269 7070 6564 203d 2073 656c 662e 6d61  ripped = self.ma
+00002390: 705f 636f 6566 6628 0a20 2020 2020 2020  p_coeff(.       
+000023a0: 2020 2020 207c 636f 6566 667c 207b 0a20       |coeff| {. 
+000023b0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000023c0: 6574 2063 6f65 6666 203d 2073 656c 662e  et coeff = self.
+000023d0: 6669 656c 642e 6469 7628 636f 6566 662c  field.div(coeff,
+000023e0: 2026 6329 3b0a 2020 2020 2020 2020 2020   &c);.          
+000023f0: 2020 2020 2020 6465 6275 675f 6173 7365        debug_asse
+00002400: 7274 2128 636f 6566 662e 6973 5f69 6e74  rt!(coeff.is_int
+00002410: 6567 6572 2829 293b 0a20 2020 2020 2020  eger());.       
+00002420: 2020 2020 2020 2020 2063 6f65 6666 2e6e           coeff.n
+00002430: 756d 6572 6174 6f72 2829 0a20 2020 2020  umerator().     
+00002440: 2020 2020 2020 207d 2c0a 2020 2020 2020         },.      
+00002450: 2020 2020 2020 5a2c 0a20 2020 2020 2020        Z,.       
+00002460: 2029 3b0a 0a20 2020 2020 2020 206c 6574   );..        let
+00002470: 2066 7320 3d20 7374 7269 7070 6564 2e73   fs = stripped.s
+00002480: 7175 6172 655f 6672 6565 5f66 6163 746f  quare_free_facto
+00002490: 7269 7a61 7469 6f6e 2829 3b0a 0a20 2020  rization();..   
+000024a0: 2020 2020 206c 6574 206d 7574 2066 6163       let mut fac
+000024b0: 746f 7273 3a20 5665 633c 5f3e 203d 2066  tors: Vec<_> = f
+000024c0: 730a 2020 2020 2020 2020 2020 2020 2e69  s.            .i
+000024d0: 6e74 6f5f 6974 6572 2829 0a20 2020 2020  nto_iter().     
+000024e0: 2020 2020 2020 202e 6d61 7028 7c28 662c         .map(|(f,
+000024f0: 2065 297c 2028 662e 6d61 705f 636f 6566   e)| (f.map_coef
+00002500: 6628 7c63 6f65 6666 7c20 636f 6566 662e  f(|coeff| coeff.
+00002510: 696e 746f 2829 2c20 5129 2c20 6529 290a  into(), Q), e)).
+00002520: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
+00002530: 6c65 6374 2829 3b0a 0a20 2020 2020 2020  lect();..       
+00002540: 2069 6620 2163 2e69 735f 6f6e 6528 2920   if !c.is_one() 
+00002550: 7b0a 2020 2020 2020 2020 2020 2020 6661  {.            fa
+00002560: 6374 6f72 732e 7075 7368 2828 7365 6c66  ctors.push((self
+00002570: 2e63 6f6e 7374 616e 7428 6329 2c20 3129  .constant(c), 1)
+00002580: 293b 0a20 2020 2020 2020 207d 0a0a 2020  );.        }..  
+00002590: 2020 2020 2020 6661 6374 6f72 730a 2020        factors.  
+000025a0: 2020 7d0a 0a20 2020 2066 6e20 6661 6374    }..    fn fact
+000025b0: 6f72 2826 7365 6c66 2920 2d3e 2056 6563  or(&self) -> Vec
+000025c0: 3c28 5365 6c66 2c20 7573 697a 6529 3e20  <(Self, usize)> 
+000025d0: 7b0a 2020 2020 2020 2020 6c65 7420 6320  {.        let c 
+000025e0: 3d20 7365 6c66 2e63 6f6e 7465 6e74 2829  = self.content()
+000025f0: 3b0a 0a20 2020 2020 2020 206c 6574 2073  ;..        let s
+00002600: 7472 6970 7065 6420 3d20 7365 6c66 2e6d  tripped = self.m
+00002610: 6170 5f63 6f65 6666 280a 2020 2020 2020  ap_coeff(.      
+00002620: 2020 2020 2020 7c63 6f65 6666 7c20 7b0a        |coeff| {.
+00002630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002640: 6c65 7420 636f 6566 6620 3d20 7365 6c66  let coeff = self
+00002650: 2e66 6965 6c64 2e64 6976 2863 6f65 6666  .field.div(coeff
+00002660: 2c20 2663 293b 0a20 2020 2020 2020 2020  , &c);.         
+00002670: 2020 2020 2020 2064 6562 7567 5f61 7373         debug_ass
+00002680: 6572 7421 2863 6f65 6666 2e69 735f 696e  ert!(coeff.is_in
+00002690: 7465 6765 7228 2929 3b0a 2020 2020 2020  teger());.      
+000026a0: 2020 2020 2020 2020 2020 636f 6566 662e            coeff.
+000026b0: 6e75 6d65 7261 746f 7228 290a 2020 2020  numerator().    
+000026c0: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
+000026d0: 2020 2020 2020 205a 2c0a 2020 2020 2020         Z,.      
+000026e0: 2020 293b 0a0a 2020 2020 2020 2020 6c65    );..        le
+000026f0: 7420 6d75 7420 6661 6374 6f72 733a 2056  t mut factors: V
+00002700: 6563 3c5f 3e20 3d20 7374 7269 7070 6564  ec<_> = stripped
+00002710: 0a20 2020 2020 2020 2020 2020 202e 6661  .            .fa
+00002720: 6374 6f72 2829 0a20 2020 2020 2020 2020  ctor().         
+00002730: 2020 202e 696e 746f 5f69 7465 7228 290a     .into_iter().
+00002740: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
+00002750: 287c 2866 662c 2070 297c 2028 6666 2e6d  (|(ff, p)| (ff.m
+00002760: 6170 5f63 6f65 6666 287c 636f 6566 667c  ap_coeff(|coeff|
+00002770: 2063 6f65 6666 2e69 6e74 6f28 292c 2051   coeff.into(), Q
+00002780: 292c 2070 2929 0a20 2020 2020 2020 2020  ), p)).         
+00002790: 2020 202e 636f 6c6c 6563 7428 293b 0a0a     .collect();..
+000027a0: 2020 2020 2020 2020 6966 2021 632e 6973          if !c.is
+000027b0: 5f6f 6e65 2829 207b 0a20 2020 2020 2020  _one() {.       
+000027c0: 2020 2020 2066 6163 746f 7273 2e70 7573       factors.pus
+000027d0: 6828 2873 656c 662e 636f 6e73 7461 6e74  h((self.constant
+000027e0: 2863 292c 2031 2929 3b0a 2020 2020 2020  (c), 1));.      
+000027f0: 2020 7d0a 0a20 2020 2020 2020 2066 6163    }..        fac
+00002800: 746f 7273 0a20 2020 207d 0a7d 0a0a 696d  tors.    }.}..im
+00002810: 706c 3c55 4669 656c 643a 2046 696e 6974  pl<UField: Finit
+00002820: 6546 6965 6c64 576f 726b 7370 6163 652c  eFieldWorkspace,
+00002830: 2045 3a20 4578 706f 6e65 6e74 3e20 4661   E: Exponent> Fa
+00002840: 6374 6f72 697a 650a 2020 2020 666f 7220  ctorize.    for 
+00002850: 4d75 6c74 6976 6172 6961 7465 506f 6c79  MultivariatePoly
+00002860: 6e6f 6d69 616c 3c46 696e 6974 6546 6965  nomial<FiniteFie
+00002870: 6c64 3c55 4669 656c 643e 2c20 452c 204c  ld<UField>, E, L
+00002880: 6578 4f72 6465 723e 0a77 6865 7265 0a20  exOrder>.where. 
+00002890: 2020 2046 696e 6974 6546 6965 6c64 3c55     FiniteField<U
+000028a0: 4669 656c 643e 3a20 4669 656c 6420 2b20  Field>: Field + 
+000028b0: 506f 6c79 6e6f 6d69 616c 4743 443c 453e  PolynomialGCD<E>
+000028c0: 202b 2046 696e 6974 6546 6965 6c64 436f   + FiniteFieldCo
+000028d0: 7265 3c55 4669 656c 643e 2c0a 7b0a 2020  re<UField>,.{.  
+000028e0: 2020 666e 2073 7175 6172 655f 6672 6565    fn square_free
+000028f0: 5f66 6163 746f 7269 7a61 7469 6f6e 2826  _factorization(&
+00002900: 7365 6c66 2920 2d3e 2056 6563 3c28 5365  self) -> Vec<(Se
+00002910: 6c66 2c20 7573 697a 6529 3e20 7b0a 2020  lf, usize)> {.  
+00002920: 2020 2020 2020 6c65 7420 6320 3d20 7365        let c = se
+00002930: 6c66 2e6c 636f 6566 6628 293b 0a20 2020  lf.lcoeff();.   
+00002940: 2020 2020 206c 6574 2073 7472 6970 7065       let strippe
+00002950: 6420 3d20 7365 6c66 2e63 6c6f 6e65 2829  d = self.clone()
+00002960: 2e6d 616b 655f 6d6f 6e69 6328 293b 0a0a  .make_monic();..
+00002970: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00002980: 6661 6374 6f72 7320 3d20 7665 6321 5b5d  factors = vec![]
+00002990: 3b0a 2020 2020 2020 2020 6c65 7420 6673  ;.        let fs
+000029a0: 203d 2073 7472 6970 7065 642e 6661 6374   = stripped.fact
+000029b0: 6f72 5f73 6570 6172 6162 6c65 2829 3b0a  or_separable();.
+000029c0: 0a20 2020 2020 2020 2066 6f72 2066 2069  .        for f i
+000029d0: 6e20 6673 207b 0a20 2020 2020 2020 2020  n fs {.         
+000029e0: 2020 206c 6574 206d 7574 206e 6620 3d20     let mut nf = 
+000029f0: 662e 7371 7561 7265 5f66 7265 655f 6661  f.square_free_fa
+00002a00: 6374 6f72 697a 6174 696f 6e5f 6265 726e  ctorization_bern
+00002a10: 6172 6469 6e28 293b 0a20 2020 2020 2020  ardin();.       
+00002a20: 2020 2020 2066 6163 746f 7273 2e61 7070       factors.app
+00002a30: 656e 6428 266d 7574 206e 6629 3b0a 2020  end(&mut nf);.  
+00002a40: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00002a50: 2069 6620 6661 6374 6f72 732e 6973 5f65   if factors.is_e
+00002a60: 6d70 7479 2829 207c 7c20 2173 656c 662e  mpty() || !self.
+00002a70: 6669 656c 642e 6973 5f6f 6e65 2826 6329  field.is_one(&c)
+00002a80: 207b 0a20 2020 2020 2020 2020 2020 2066   {.            f
+00002a90: 6163 746f 7273 2e70 7573 6828 2873 656c  actors.push((sel
+00002aa0: 662e 636f 6e73 7461 6e74 2863 292c 2031  f.constant(c), 1
+00002ab0: 2929 0a20 2020 2020 2020 207d 0a0a 2020  )).        }..  
+00002ac0: 2020 2020 2020 6661 6374 6f72 730a 2020        factors.  
+00002ad0: 2020 7d0a 0a20 2020 2066 6e20 6661 6374    }..    fn fact
+00002ae0: 6f72 2826 7365 6c66 2920 2d3e 2056 6563  or(&self) -> Vec
+00002af0: 3c28 5365 6c66 2c20 7573 697a 6529 3e20  <(Self, usize)> 
+00002b00: 7b0a 2020 2020 2020 2020 6c65 7420 7366  {.        let sf
+00002b10: 203d 2073 656c 662e 7371 7561 7265 5f66   = self.square_f
+00002b20: 7265 655f 6661 6374 6f72 697a 6174 696f  ree_factorizatio
+00002b30: 6e28 293b 0a0a 2020 2020 2020 2020 6c65  n();..        le
+00002b40: 7420 6d75 7420 6661 6374 6f72 7320 3d20  t mut factors = 
+00002b50: 7665 6321 5b5d 3b0a 2020 2020 2020 2020  vec![];.        
+00002b60: 6c65 7420 6d75 7420 6465 6772 6565 7320  let mut degrees 
+00002b70: 3d20 7665 6321 5b30 3b20 7365 6c66 2e6e  = vec![0; self.n
+00002b80: 7661 7273 2829 5d3b 0a20 2020 2020 2020  vars()];.       
+00002b90: 2066 6f72 2028 662c 2070 2920 696e 2073   for (f, p) in s
+00002ba0: 6620 7b0a 2020 2020 2020 2020 2020 2020  f {.            
+00002bb0: 6465 6275 6721 2822 5346 4620 7b7d 207b  debug!("SFF {} {
+00002bc0: 7d22 2c20 662c 2070 293b 0a0a 2020 2020  }", f, p);..    
+00002bd0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00002be0: 7661 725f 636f 756e 7420 3d20 303b 0a20  var_count = 0;. 
+00002bf0: 2020 2020 2020 2020 2020 2066 6f72 2076             for v
+00002c00: 2069 6e20 302e 2e73 656c 662e 6e76 6172   in 0..self.nvar
+00002c10: 7328 2920 7b0a 2020 2020 2020 2020 2020  s() {.          
+00002c20: 2020 2020 2020 6465 6772 6565 735b 765d        degrees[v]
+00002c30: 203d 2066 2e64 6567 7265 6528 7629 2e74   = f.degree(v).t
+00002c40: 6f5f 7533 3228 2920 6173 2075 7369 7a65  o_u32() as usize
+00002c50: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00002c60: 2020 6966 2064 6567 7265 6573 5b76 5d20    if degrees[v] 
+00002c70: 3e20 3020 7b0a 2020 2020 2020 2020 2020  > 0 {.          
+00002c80: 2020 2020 2020 2020 2020 7661 725f 636f            var_co
+00002c90: 756e 7420 2b3d 2031 3b0a 2020 2020 2020  unt += 1;.      
+00002ca0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00002cb0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00002cc0: 2020 2020 2020 206d 6174 6368 2076 6172         match var
+00002cd0: 5f63 6f75 6e74 207b 0a20 2020 2020 2020  _count {.       
+00002ce0: 2020 2020 2020 2020 2030 203d 3e20 7b0a           0 => {.
+00002cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d00: 2020 2020 6661 6374 6f72 732e 7075 7368      factors.push
+00002d10: 2828 662c 2070 2929 3b0a 2020 2020 2020  ((f, p));.      
+00002d20: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00002d30: 2020 2020 2020 2020 2020 2020 3120 3d3e              1 =>
+00002d40: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00002d50: 2020 2020 2020 2066 6f72 2028 6432 2c20         for (d2, 
+00002d60: 6632 2920 696e 2066 2e64 6973 7469 6e63  f2) in f.distinc
+00002d70: 745f 6465 6772 6565 5f66 6163 746f 7269  t_degree_factori
+00002d80: 7a61 7469 6f6e 2829 207b 0a20 2020 2020  zation() {.     
 00002d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002da0: 2020 2020 2020 2066 6f72 2066 3320 696e         for f3 in
-00002db0: 2066 322e 6571 7561 6c5f 6465 6772 6565   f2.equal_degree
-00002dc0: 5f66 6163 746f 7269 7a61 7469 6f6e 2864  _factorization(d
-00002dd0: 3229 207b 0a20 2020 2020 2020 2020 2020  2) {.           
-00002de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002df0: 2064 6562 7567 2128 2245 4446 207b 7d20   debug!("EDF {} 
-00002e00: 7b7d 222c 2066 332c 2070 293b 0a20 2020  {}", f3, p);.   
+00002da0: 2020 2064 6562 7567 2128 2244 4446 207b     debug!("DDF {
+00002db0: 7d20 7b7d 222c 2066 322c 2064 3229 3b0a  } {}", f2, d2);.
+00002dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002dd0: 2020 2020 2020 2020 666f 7220 6633 2069          for f3 i
+00002de0: 6e20 6632 2e65 7175 616c 5f64 6567 7265  n f2.equal_degre
+00002df0: 655f 6661 6374 6f72 697a 6174 696f 6e28  e_factorization(
+00002e00: 6432 2920 7b0a 2020 2020 2020 2020 2020  d2) {.          
 00002e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e20: 2020 2020 2020 2020 2066 6163 746f 7273           factors
-00002e30: 2e70 7573 6828 2866 332c 2070 2929 3b0a  .push((f3, p));.
+00002e20: 2020 6465 6275 6721 2822 4544 4620 7b7d    debug!("EDF {}
+00002e30: 207b 7d22 2c20 6633 2c20 7029 3b0a 2020   {}", f3, p);.  
 00002e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e50: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00002e60: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-00002e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e80: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-00002e90: 2020 3220 3d3e 207b 0a20 2020 2020 2020    2 => {.       
-00002ea0: 2020 2020 2020 2020 2020 2020 206c 6574               let
-00002eb0: 206d 7574 206f 7264 6572 3a20 5665 633c   mut order: Vec<
-00002ec0: 5f3e 203d 2064 6567 7265 6573 0a20 2020  _> = degrees.   
-00002ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ee0: 2020 2020 202e 6974 6572 2829 0a20 2020       .iter().   
-00002ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002f00: 2020 2020 202e 656e 756d 6572 6174 6528       .enumerate(
-00002f10: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00002f20: 2020 2020 2020 2020 2020 2e66 696c 7465            .filte
-00002f30: 7228 7c28 5f2c 2064 297c 202a 2a64 203e  r(|(_, d)| **d >
-00002f40: 2030 290a 2020 2020 2020 2020 2020 2020   0).            
-00002f50: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
-00002f60: 6c65 6374 2829 3b0a 2020 2020 2020 2020  lect();.        
-00002f70: 2020 2020 2020 2020 2020 2020 6f72 6465              orde
-00002f80: 722e 736f 7274 5f62 795f 6b65 7928 7c6f  r.sort_by_key(|o
-00002f90: 7c20 5265 7665 7273 6528 6f2e 3129 293b  | Reverse(o.1));
-00002fa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002fb0: 2020 2020 206c 6574 206f 7264 6572 3a20       let order: 
-00002fc0: 5665 633c 5f3e 203d 206f 7264 6572 2e69  Vec<_> = order.i
-00002fd0: 6e74 6f5f 6974 6572 2829 2e6d 6170 287c  nto_iter().map(|
-00002fe0: 2876 2c20 5f29 7c20 7629 2e63 6f6c 6c65  (v, _)| v).colle
-00002ff0: 6374 2829 3b0a 0a20 2020 2020 2020 2020  ct();..         
-00003000: 2020 2020 2020 2020 2020 2066 6163 746f             facto
-00003010: 7273 2e65 7874 656e 6428 0a20 2020 2020  rs.extend(.     
-00003020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003030: 2020 2066 2e62 6976 6172 6961 7465 5f66     f.bivariate_f
-00003040: 6163 746f 7269 7a61 7469 6f6e 286f 7264  actorization(ord
-00003050: 6572 5b30 5d2c 206f 7264 6572 5b31 5d29  er[0], order[1])
-00003060: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003070: 2020 2020 2020 2020 2020 2020 202e 696e               .in
-00003080: 746f 5f69 7465 7228 290a 2020 2020 2020  to_iter().      
-00003090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030a0: 2020 2020 2020 2e6d 6170 287c 6666 7c20        .map(|ff| 
-000030b0: 2866 662c 2070 2929 2c0a 2020 2020 2020  (ff, p)),.      
-000030c0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-000030d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030e0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-000030f0: 2020 5f20 3d3e 207b 0a20 2020 2020 2020    _ => {.       
-00003100: 2020 2020 2020 2020 2020 2020 202f 2f20               // 
-00003110: 544f 444f 3a20 6669 6e64 2062 6574 7465  TODO: find bette
-00003120: 7220 6f72 6465 720a 2020 2020 2020 2020  r order.        
-00003130: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00003140: 6d75 7420 6f72 6465 723a 2056 6563 3c5f  mut order: Vec<_
-00003150: 3e20 3d20 6465 6772 6565 730a 2020 2020  > = degrees.    
-00003160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003170: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
-00003180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003190: 2020 2020 2e65 6e75 6d65 7261 7465 2829      .enumerate()
-000031a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000031b0: 2020 2020 2020 2020 202e 6669 6c74 6572           .filter
-000031c0: 287c 285f 2c20 6429 7c20 2a2a 6420 3e20  (|(_, d)| **d > 
-000031d0: 3029 0a20 2020 2020 2020 2020 2020 2020  0).             
-000031e0: 2020 2020 2020 2020 2020 202e 636f 6c6c             .coll
-000031f0: 6563 7428 293b 0a20 2020 2020 2020 2020  ect();.         
-00003200: 2020 2020 2020 2020 2020 206f 7264 6572             order
-00003210: 2e73 6f72 745f 6279 5f6b 6579 287c 6f7c  .sort_by_key(|o|
-00003220: 2052 6576 6572 7365 286f 2e31 2929 3b0a   Reverse(o.1));.
-00003230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003240: 2020 2020 206c 6574 206d 7574 206f 7264       let mut ord
-00003250: 6572 3a20 5665 633c 5f3e 203d 206f 7264  er: Vec<_> = ord
-00003260: 6572 2e69 6e74 6f5f 6974 6572 2829 2e6d  er.into_iter().m
-00003270: 6170 287c 2876 2c20 5f29 7c20 7629 2e63  ap(|(v, _)| v).c
-00003280: 6f6c 6c65 6374 2829 3b0a 0a20 2020 2020  ollect();..     
-00003290: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000032a0: 6163 746f 7273 2e65 7874 656e 6428 0a20  actors.extend(. 
-000032b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000032c0: 2020 2020 2020 2066 2e6d 756c 7469 7661         f.multiva
-000032d0: 7269 6174 655f 6661 6374 6f72 697a 6174  riate_factorizat
-000032e0: 696f 6e28 266d 7574 206f 7264 6572 2c20  ion(&mut order, 
-000032f0: 302c 204e 6f6e 6529 0a20 2020 2020 2020  0, None).       
-00003300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003310: 2020 2020 202e 696e 746f 5f69 7465 7228       .into_iter(
-00003320: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00003330: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
-00003340: 6170 287c 6666 7c20 2866 662c 2070 2929  ap(|ff| (ff, p))
-00003350: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00003360: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00003370: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00003380: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-00003390: 7d0a 0a20 2020 2020 2020 2066 6163 746f  }..        facto
-000033a0: 7273 0a20 2020 207d 0a7d 0a0a 696d 706c  rs.    }.}..impl
-000033b0: 3c55 4669 656c 643a 2046 696e 6974 6546  <UField: FiniteF
-000033c0: 6965 6c64 576f 726b 7370 6163 652c 2045  ieldWorkspace, E
-000033d0: 3a20 4578 706f 6e65 6e74 3e0a 2020 2020  : Exponent>.    
-000033e0: 4d75 6c74 6976 6172 6961 7465 506f 6c79  MultivariatePoly
-000033f0: 6e6f 6d69 616c 3c46 696e 6974 6546 6965  nomial<FiniteFie
-00003400: 6c64 3c55 4669 656c 643e 2c20 452c 204c  ld<UField>, E, L
-00003410: 6578 4f72 6465 723e 0a77 6865 7265 0a20  exOrder>.where. 
-00003420: 2020 2046 696e 6974 6546 6965 6c64 3c55     FiniteField<U
-00003430: 4669 656c 643e 3a20 4669 656c 6420 2b20  Field>: Field + 
-00003440: 506f 6c79 6e6f 6d69 616c 4743 443c 453e  PolynomialGCD<E>
-00003450: 202b 2046 696e 6974 6546 6965 6c64 436f   + FiniteFieldCo
-00003460: 7265 3c55 4669 656c 643e 2c0a 7b0a 2020  re<UField>,.{.  
-00003470: 2020 2f2f 2f20 4265 726e 6172 6469 6e27    /// Bernardin'
-00003480: 7320 616c 676f 7269 7468 6d20 666f 7220  s algorithm for 
-00003490: 7371 7561 7265 2066 7265 6520 6661 6374  square free fact
-000034a0: 6f72 697a 6174 696f 6e2e 0a20 2020 2066  orization..    f
-000034b0: 6e20 7371 7561 7265 5f66 7265 655f 6661  n square_free_fa
-000034c0: 6374 6f72 697a 6174 696f 6e5f 6265 726e  ctorization_bern
-000034d0: 6172 6469 6e28 2673 656c 6629 202d 3e20  ardin(&self) -> 
-000034e0: 5665 633c 2853 656c 662c 2075 7369 7a65  Vec<(Self, usize
-000034f0: 293e 207b 0a20 2020 2020 2020 2069 6620  )> {.        if 
-00003500: 7365 6c66 2e69 735f 636f 6e73 7461 6e74  self.is_constant
-00003510: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00003520: 2069 6620 7365 6c66 2e69 735f 6f6e 6528   if self.is_one(
-00003530: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00003540: 2020 2020 7265 7475 726e 2076 6563 215b      return vec![
-00003550: 5d3b 0a20 2020 2020 2020 2020 2020 207d  ];.            }
-00003560: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
-00003570: 2020 2020 2020 2020 7265 7475 726e 2076          return v
-00003580: 6563 215b 2873 656c 662e 636c 6f6e 6528  ec![(self.clone(
-00003590: 292c 2031 295d 3b0a 2020 2020 2020 2020  ), 1)];.        
-000035a0: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
-000035b0: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-000035c0: 2066 203d 2073 656c 662e 636c 6f6e 6528   f = self.clone(
-000035d0: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
-000035e0: 6d75 7420 6820 3d20 4861 7368 4d61 703a  mut h = HashMap:
-000035f0: 3a64 6566 6175 6c74 2829 3b0a 2020 2020  :default();.    
-00003600: 2020 2020 6c65 7420 6d75 7420 6872 3b0a      let mut hr;.
-00003610: 2020 2020 2020 2020 666f 7220 7661 7220          for var 
-00003620: 696e 2030 2e2e 7365 6c66 2e6e 7661 7273  in 0..self.nvars
-00003630: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
-00003640: 6620 662e 6465 6772 6565 2876 6172 2920  f f.degree(var) 
-00003650: 3e20 453a 3a7a 6572 6f28 2920 7b0a 2020  > E::zero() {.  
-00003660: 2020 2020 2020 2020 2020 2020 2020 2866                (f
-00003670: 2c20 6872 2920 3d20 662e 7371 7561 7265  , hr) = f.square
-00003680: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
-00003690: 696f 6e5f 6666 5f79 756e 2876 6172 293b  ion_ff_yun(var);
-000036a0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000036b0: 2020 666f 7220 2870 6172 742c 2070 6f77    for (part, pow
-000036c0: 2920 696e 2068 7220 7b0a 2020 2020 2020  ) in hr {.      
-000036d0: 2020 2020 2020 2020 2020 2020 2020 682e                h.
-000036e0: 656e 7472 7928 706f 7729 0a20 2020 2020  entry(pow).     
-000036f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003700: 2020 202e 616e 645f 6d6f 6469 6679 287c     .and_modify(|
-00003710: 667c 207b 0a20 2020 2020 2020 2020 2020  f| {.           
+00002e50: 2020 2020 2020 2020 2020 6661 6374 6f72            factor
+00002e60: 732e 7075 7368 2828 6633 2c20 7029 293b  s.push((f3, p));
+00002e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002e80: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00002e90: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00002ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002eb0: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00002ec0: 2020 2032 203d 3e20 7b0a 2020 2020 2020     2 => {.      
+00002ed0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+00002ee0: 7420 6d75 7420 6f72 6465 723a 2056 6563  t mut order: Vec
+00002ef0: 3c5f 3e20 3d20 6465 6772 6565 730a 2020  <_> = degrees.  
+00002f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f10: 2020 2020 2020 2e69 7465 7228 290a 2020        .iter().  
+00002f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f30: 2020 2020 2020 2e65 6e75 6d65 7261 7465        .enumerate
+00002f40: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00002f50: 2020 2020 2020 2020 2020 202e 6669 6c74             .filt
+00002f60: 6572 287c 285f 2c20 6429 7c20 2a2a 6420  er(|(_, d)| **d 
+00002f70: 3e20 3029 0a20 2020 2020 2020 2020 2020  > 0).           
+00002f80: 2020 2020 2020 2020 2020 2020 202e 636f               .co
+00002f90: 6c6c 6563 7428 293b 0a20 2020 2020 2020  llect();.       
+00002fa0: 2020 2020 2020 2020 2020 2020 206f 7264               ord
+00002fb0: 6572 2e73 6f72 745f 6279 5f6b 6579 287c  er.sort_by_key(|
+00002fc0: 6f7c 2052 6576 6572 7365 286f 2e31 2929  o| Reverse(o.1))
+00002fd0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00002fe0: 2020 2020 2020 6c65 7420 6f72 6465 723a        let order:
+00002ff0: 2056 6563 3c5f 3e20 3d20 6f72 6465 722e   Vec<_> = order.
+00003000: 696e 746f 5f69 7465 7228 292e 6d61 7028  into_iter().map(
+00003010: 7c28 762c 205f 297c 2076 292e 636f 6c6c  |(v, _)| v).coll
+00003020: 6563 7428 293b 0a0a 2020 2020 2020 2020  ect();..        
+00003030: 2020 2020 2020 2020 2020 2020 6661 6374              fact
+00003040: 6f72 732e 6578 7465 6e64 280a 2020 2020  ors.extend(.    
+00003050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003060: 2020 2020 662e 6269 7661 7269 6174 655f      f.bivariate_
+00003070: 6661 6374 6f72 697a 6174 696f 6e28 6f72  factorization(or
+00003080: 6465 725b 305d 2c20 6f72 6465 725b 315d  der[0], order[1]
+00003090: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000030a0: 2020 2020 2020 2020 2020 2020 2020 2e69                .i
+000030b0: 6e74 6f5f 6974 6572 2829 0a20 2020 2020  nto_iter().     
+000030c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030d0: 2020 2020 2020 202e 6d61 7028 7c66 667c         .map(|ff|
+000030e0: 2028 6666 2c20 7029 292c 0a20 2020 2020   (ff, p)),.     
+000030f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00003100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003110: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00003120: 2020 205f 203d 3e20 7b0a 2020 2020 2020     _ => {.      
+00003130: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
+00003140: 2054 4f44 4f3a 2066 696e 6420 6265 7474   TODO: find bett
+00003150: 6572 206f 7264 6572 0a20 2020 2020 2020  er order.       
+00003160: 2020 2020 2020 2020 2020 2020 206c 6574               let
+00003170: 206d 7574 206f 7264 6572 3a20 5665 633c   mut order: Vec<
+00003180: 5f3e 203d 2064 6567 7265 6573 0a20 2020  _> = degrees.   
+00003190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000031a0: 2020 2020 202e 6974 6572 2829 0a20 2020       .iter().   
+000031b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000031c0: 2020 2020 202e 656e 756d 6572 6174 6528       .enumerate(
+000031d0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000031e0: 2020 2020 2020 2020 2020 2e66 696c 7465            .filte
+000031f0: 7228 7c28 5f2c 2064 297c 202a 2a64 203e  r(|(_, d)| **d >
+00003200: 2030 290a 2020 2020 2020 2020 2020 2020   0).            
+00003210: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
+00003220: 6c65 6374 2829 3b0a 2020 2020 2020 2020  lect();.        
+00003230: 2020 2020 2020 2020 2020 2020 6f72 6465              orde
+00003240: 722e 736f 7274 5f62 795f 6b65 7928 7c6f  r.sort_by_key(|o
+00003250: 7c20 5265 7665 7273 6528 6f2e 3129 293b  | Reverse(o.1));
+00003260: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00003270: 2020 2020 2020 6c65 7420 6d75 7420 6f72        let mut or
+00003280: 6465 723a 2056 6563 3c5f 3e20 3d20 6f72  der: Vec<_> = or
+00003290: 6465 722e 696e 746f 5f69 7465 7228 292e  der.into_iter().
+000032a0: 6d61 7028 7c28 762c 205f 297c 2076 292e  map(|(v, _)| v).
+000032b0: 636f 6c6c 6563 7428 293b 0a0a 2020 2020  collect();..    
+000032c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000032d0: 6661 6374 6f72 732e 6578 7465 6e64 280a  factors.extend(.
+000032e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000032f0: 2020 2020 2020 2020 662e 6d75 6c74 6976          f.multiv
+00003300: 6172 6961 7465 5f66 6163 746f 7269 7a61  ariate_factoriza
+00003310: 7469 6f6e 2826 6d75 7420 6f72 6465 722c  tion(&mut order,
+00003320: 2030 2c20 4e6f 6e65 290a 2020 2020 2020   0, None).      
+00003330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003340: 2020 2020 2020 2e69 6e74 6f5f 6974 6572        .into_iter
+00003350: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00003360: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00003370: 6d61 7028 7c66 667c 2028 6666 2c20 7029  map(|ff| (ff, p)
+00003380: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00003390: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000033a0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+000033b0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000033c0: 207d 0a0a 2020 2020 2020 2020 6661 6374   }..        fact
+000033d0: 6f72 730a 2020 2020 7d0a 7d0a 0a69 6d70  ors.    }.}..imp
+000033e0: 6c3c 5546 6965 6c64 3a20 4669 6e69 7465  l<UField: Finite
+000033f0: 4669 656c 6457 6f72 6b73 7061 6365 2c20  FieldWorkspace, 
+00003400: 453a 2045 7870 6f6e 656e 743e 0a20 2020  E: Exponent>.   
+00003410: 204d 756c 7469 7661 7269 6174 6550 6f6c   MultivariatePol
+00003420: 796e 6f6d 6961 6c3c 4669 6e69 7465 4669  ynomial<FiniteFi
+00003430: 656c 643c 5546 6965 6c64 3e2c 2045 2c20  eld<UField>, E, 
+00003440: 4c65 784f 7264 6572 3e0a 7768 6572 650a  LexOrder>.where.
+00003450: 2020 2020 4669 6e69 7465 4669 656c 643c      FiniteField<
+00003460: 5546 6965 6c64 3e3a 2046 6965 6c64 202b  UField>: Field +
+00003470: 2050 6f6c 796e 6f6d 6961 6c47 4344 3c45   PolynomialGCD<E
+00003480: 3e20 2b20 4669 6e69 7465 4669 656c 6443  > + FiniteFieldC
+00003490: 6f72 653c 5546 6965 6c64 3e2c 0a7b 0a20  ore<UField>,.{. 
+000034a0: 2020 202f 2f2f 2042 6572 6e61 7264 696e     /// Bernardin
+000034b0: 2773 2061 6c67 6f72 6974 686d 2066 6f72  's algorithm for
+000034c0: 2073 7175 6172 6520 6672 6565 2066 6163   square free fac
+000034d0: 746f 7269 7a61 7469 6f6e 2e0a 2020 2020  torization..    
+000034e0: 666e 2073 7175 6172 655f 6672 6565 5f66  fn square_free_f
+000034f0: 6163 746f 7269 7a61 7469 6f6e 5f62 6572  actorization_ber
+00003500: 6e61 7264 696e 2826 7365 6c66 2920 2d3e  nardin(&self) ->
+00003510: 2056 6563 3c28 5365 6c66 2c20 7573 697a   Vec<(Self, usiz
+00003520: 6529 3e20 7b0a 2020 2020 2020 2020 6966  e)> {.        if
+00003530: 2073 656c 662e 6973 5f63 6f6e 7374 616e   self.is_constan
+00003540: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
+00003550: 2020 6966 2073 656c 662e 6973 5f6f 6e65    if self.is_one
+00003560: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+00003570: 2020 2020 2072 6574 7572 6e20 7665 6321       return vec!
+00003580: 5b5d 3b0a 2020 2020 2020 2020 2020 2020  [];.            
+00003590: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+000035a0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000035b0: 7665 6321 5b28 7365 6c66 2e63 6c6f 6e65  vec![(self.clone
+000035c0: 2829 2c20 3129 5d3b 0a20 2020 2020 2020  (), 1)];.       
+000035d0: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
+000035e0: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
+000035f0: 7420 6620 3d20 7365 6c66 2e63 6c6f 6e65  t f = self.clone
+00003600: 2829 3b0a 0a20 2020 2020 2020 206c 6574  ();..        let
+00003610: 206d 7574 2068 203d 2048 6173 684d 6170   mut h = HashMap
+00003620: 3a3a 6465 6661 756c 7428 293b 0a20 2020  ::default();.   
+00003630: 2020 2020 206c 6574 206d 7574 2068 723b       let mut hr;
+00003640: 0a20 2020 2020 2020 2066 6f72 2076 6172  .        for var
+00003650: 2069 6e20 302e 2e73 656c 662e 6e76 6172   in 0..self.nvar
+00003660: 7328 2920 7b0a 2020 2020 2020 2020 2020  s() {.          
+00003670: 2020 6966 2066 2e64 6567 7265 6528 7661    if f.degree(va
+00003680: 7229 203e 2045 3a3a 7a65 726f 2829 207b  r) > E::zero() {
+00003690: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000036a0: 2028 662c 2068 7229 203d 2066 2e73 7175   (f, hr) = f.squ
+000036b0: 6172 655f 6672 6565 5f66 6163 746f 7269  are_free_factori
+000036c0: 7a61 7469 6f6e 5f66 665f 7975 6e28 7661  zation_ff_yun(va
+000036d0: 7229 3b0a 0a20 2020 2020 2020 2020 2020  r);..           
+000036e0: 2020 2020 2066 6f72 2028 7061 7274 2c20       for (part, 
+000036f0: 706f 7729 2069 6e20 6872 207b 0a20 2020  pow) in hr {.   
+00003700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003710: 2068 2e65 6e74 7279 2870 6f77 290a 2020   h.entry(pow).  
 00003720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003730: 202a 6620 3d20 262a 6620 2a20 2670 6172   *f = &*f * &par
-00003740: 743b 0a20 2020 2020 2020 2020 2020 2020  t;.             
-00003750: 2020 2020 2020 2020 2020 207d 290a 2020             }).  
-00003760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003770: 2020 2020 2020 2e6f 725f 696e 7365 7274        .or_insert
-00003780: 2870 6172 7429 3b0a 2020 2020 2020 2020  (part);.        
-00003790: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-000037a0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-000037b0: 7d0a 0a20 2020 2020 2020 202f 2f20 7461  }..        // ta
-000037c0: 6b65 2074 6865 2070 7468 2072 6f6f 740a  ke the pth root.
-000037d0: 2020 2020 2020 2020 2f2f 2074 6865 2063          // the c
-000037e0: 6f65 6666 6963 6965 6e74 7320 7265 6d61  oefficients rema
-000037f0: 696e 2075 6e63 6861 6e67 6564 2c20 7369  in unchanged, si
-00003800: 6e63 6520 785e 312f 7020 3d20 780a 2020  nce x^1/p = x.  
-00003810: 2020 2020 2020 2f2f 2073 696e 6365 2074        // since t
-00003820: 6865 2064 6572 6976 6174 6976 6520 696e  he derivative in
-00003830: 2065 7665 7279 2076 6172 2069 7320 302c   every var is 0,
-00003840: 2061 6c6c 2070 6f77 6572 7320 6172 6520   all powers are 
-00003850: 6469 7669 7369 626c 6520 6279 2070 0a20  divisible by p. 
-00003860: 2020 2020 2020 206c 6574 2070 203d 2073         let p = s
-00003870: 656c 662e 6669 656c 642e 6765 745f 7072  elf.field.get_pr
-00003880: 696d 6528 292e 746f 5f75 3634 2829 2061  ime().to_u64() a
-00003890: 7320 7573 697a 653b 0a20 2020 2020 2020  s usize;.       
-000038a0: 206c 6574 206d 7574 2062 203d 2066 2e63   let mut b = f.c
-000038b0: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
-000038c0: 666f 7220 6573 2069 6e20 622e 6578 706f  for es in b.expo
-000038d0: 6e65 6e74 732e 6368 756e 6b73 5f6d 7574  nents.chunks_mut
-000038e0: 2873 656c 662e 6e76 6172 7329 207b 0a20  (self.nvars) {. 
-000038f0: 2020 2020 2020 2020 2020 2066 6f72 2065             for e
-00003900: 2069 6e20 6573 207b 0a20 2020 2020 2020   in es {.       
-00003910: 2020 2020 2020 2020 2069 6620 652e 6973           if e.is
-00003920: 5f7a 6572 6f28 2920 7b0a 2020 2020 2020  _zero() {.      
-00003930: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00003940: 6e74 696e 7565 3b0a 2020 2020 2020 2020  ntinue;.        
-00003950: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00003960: 2020 2020 2020 2020 2020 2069 6620 7020             if p 
-00003970: 3c20 7533 323a 3a4d 4158 2061 7320 7573  < u32::MAX as us
-00003980: 697a 6520 7b0a 2020 2020 2020 2020 2020  ize {.          
-00003990: 2020 2020 2020 2020 2020 6465 6275 675f            debug_
-000039a0: 6173 7365 7274 5f65 7121 2865 2e74 6f5f  assert_eq!(e.to_
-000039b0: 7533 3228 2920 6173 2075 7369 7a65 2025  u32() as usize %
-000039c0: 2070 2c20 3029 3b0a 2020 2020 2020 2020   p, 0);.        
-000039d0: 2020 2020 2020 2020 2020 2020 2a65 203d              *e =
-000039e0: 202a 6520 2f20 453a 3a66 726f 6d5f 7533   *e / E::from_u3
-000039f0: 3228 7020 6173 2075 3332 293b 0a20 2020  2(p as u32);.   
-00003a00: 2020 2020 2020 2020 2020 2020 207d 2065               } e
-00003a10: 6c73 6520 7b0a 2020 2020 2020 2020 2020  lse {.          
-00003a20: 2020 2020 2020 2020 2020 2f2f 2061 7420            // at 
-00003a30: 7468 6520 6d6f 6d65 6e74 2065 7870 6f6e  the moment expon
-00003a40: 656e 7473 2061 7265 206c 696d 6974 6564  ents are limited
-00003a50: 2074 6f20 3332 2d62 6974 730a 2020 2020   to 32-bits.    
-00003a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003a70: 2f2f 2073 6f20 6f6e 6c79 2074 6865 2063  // so only the c
-00003a80: 6173 6520 7768 6572 6520 6520 3d20 3020  ase where e = 0 
-00003a90: 6973 2073 7570 706f 7274 6564 0a20 2020  is supported.   
-00003aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003ab0: 2061 7373 6572 7421 282a 6520 3d3d 2045   assert!(*e == E
-00003ac0: 3a3a 7a65 726f 2829 293b 0a20 2020 2020  ::zero());.     
-00003ad0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-00003ae0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00003af0: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
-00003b00: 7420 6d75 7420 6661 6374 6f72 7320 3d20  t mut factors = 
-00003b10: 7665 6321 5b5d 3b0a 2020 2020 2020 2020  vec![];.        
-00003b20: 6c65 7420 7375 625f 6661 6374 6f72 7320  let sub_factors 
-00003b30: 3d20 622e 7371 7561 7265 5f66 7265 655f  = b.square_free_
-00003b40: 6661 6374 6f72 697a 6174 696f 6e5f 6265  factorization_be
-00003b50: 726e 6172 6469 6e28 293b 0a0a 2020 2020  rnardin();..    
-00003b60: 2020 2020 666f 7220 286d 7574 206b 2c20      for (mut k, 
-00003b70: 6e29 2069 6e20 7375 625f 6661 6374 6f72  n) in sub_factor
-00003b80: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
-00003b90: 666f 7220 2870 6f77 682c 2068 6929 2069  for (powh, hi) i
-00003ba0: 6e20 266d 7574 2068 207b 0a20 2020 2020  n &mut h {.     
-00003bb0: 2020 2020 2020 2020 2020 2069 6620 2a70             if *p
-00003bc0: 6f77 6820 3c20 7020 7b0a 2020 2020 2020  owh < p {.      
-00003bd0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00003be0: 7420 6720 3d20 6b2e 6763 6428 6869 293b  t g = k.gcd(hi);
+00003730: 2020 2020 2020 2e61 6e64 5f6d 6f64 6966        .and_modif
+00003740: 7928 7c66 7c20 7b0a 2020 2020 2020 2020  y(|f| {.        
+00003750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003760: 2020 2020 2a66 203d 2026 2a66 202a 2026      *f = &*f * &
+00003770: 7061 7274 3b0a 2020 2020 2020 2020 2020  part;.          
+00003780: 2020 2020 2020 2020 2020 2020 2020 7d29                })
+00003790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000037a0: 2020 2020 2020 2020 202e 6f72 5f69 6e73           .or_ins
+000037b0: 6572 7428 7061 7274 293b 0a20 2020 2020  ert(part);.     
+000037c0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+000037d0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+000037e0: 2020 207d 0a0a 2020 2020 2020 2020 2f2f     }..        //
+000037f0: 2074 616b 6520 7468 6520 7074 6820 726f   take the pth ro
+00003800: 6f74 0a20 2020 2020 2020 202f 2f20 7468  ot.        // th
+00003810: 6520 636f 6566 6669 6369 656e 7473 2072  e coefficients r
+00003820: 656d 6169 6e20 756e 6368 616e 6765 642c  emain unchanged,
+00003830: 2073 696e 6365 2078 5e31 2f70 203d 2078   since x^1/p = x
+00003840: 0a20 2020 2020 2020 202f 2f20 7369 6e63  .        // sinc
+00003850: 6520 7468 6520 6465 7269 7661 7469 7665  e the derivative
+00003860: 2069 6e20 6576 6572 7920 7661 7220 6973   in every var is
+00003870: 2030 2c20 616c 6c20 706f 7765 7273 2061   0, all powers a
+00003880: 7265 2064 6976 6973 6962 6c65 2062 7920  re divisible by 
+00003890: 700a 2020 2020 2020 2020 6c65 7420 7020  p.        let p 
+000038a0: 3d20 7365 6c66 2e66 6965 6c64 2e67 6574  = self.field.get
+000038b0: 5f70 7269 6d65 2829 2e74 6f5f 7536 3428  _prime().to_u64(
+000038c0: 2920 6173 2075 7369 7a65 3b0a 2020 2020  ) as usize;.    
+000038d0: 2020 2020 6c65 7420 6d75 7420 6220 3d20      let mut b = 
+000038e0: 662e 636c 6f6e 6528 293b 0a20 2020 2020  f.clone();.     
+000038f0: 2020 2066 6f72 2065 7320 696e 2062 2e65     for es in b.e
+00003900: 7870 6f6e 656e 7473 5f69 7465 725f 6d75  xponents_iter_mu
+00003910: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
+00003920: 2020 666f 7220 6520 696e 2065 7320 7b0a    for e in es {.
+00003930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003940: 6966 2065 2e69 735f 7a65 726f 2829 207b  if e.is_zero() {
+00003950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003960: 2020 2020 2063 6f6e 7469 6e75 653b 0a20       continue;. 
+00003970: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00003980: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00003990: 2020 6966 2070 203c 2075 3332 3a3a 4d41    if p < u32::MA
+000039a0: 5820 6173 2075 7369 7a65 207b 0a20 2020  X as usize {.   
+000039b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000039c0: 2064 6562 7567 5f61 7373 6572 745f 6571   debug_assert_eq
+000039d0: 2128 652e 746f 5f75 3332 2829 2061 7320  !(e.to_u32() as 
+000039e0: 7573 697a 6520 2520 702c 2030 293b 0a20  usize % p, 0);. 
+000039f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003a00: 2020 202a 6520 3d20 2a65 202f 2045 3a3a     *e = *e / E::
+00003a10: 6672 6f6d 5f75 3332 2870 2061 7320 7533  from_u32(p as u3
+00003a20: 3229 3b0a 2020 2020 2020 2020 2020 2020  2);.            
+00003a30: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
+00003a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003a50: 202f 2f20 6174 2074 6865 206d 6f6d 656e   // at the momen
+00003a60: 7420 6578 706f 6e65 6e74 7320 6172 6520  t exponents are 
+00003a70: 6c69 6d69 7465 6420 746f 2033 322d 6269  limited to 32-bi
+00003a80: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+00003a90: 2020 2020 2020 202f 2f20 736f 206f 6e6c         // so onl
+00003aa0: 7920 7468 6520 6361 7365 2077 6865 7265  y the case where
+00003ab0: 2065 203d 2030 2069 7320 7375 7070 6f72   e = 0 is suppor
+00003ac0: 7465 640a 2020 2020 2020 2020 2020 2020  ted.            
+00003ad0: 2020 2020 2020 2020 6173 7365 7274 2128          assert!(
+00003ae0: 2a65 203d 3d20 453a 3a7a 6572 6f28 2929  *e == E::zero())
+00003af0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00003b00: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
+00003b10: 7d0a 2020 2020 2020 2020 7d0a 0a20 2020  }.        }..   
+00003b20: 2020 2020 206c 6574 206d 7574 2066 6163       let mut fac
+00003b30: 746f 7273 203d 2076 6563 215b 5d3b 0a20  tors = vec![];. 
+00003b40: 2020 2020 2020 206c 6574 2073 7562 5f66         let sub_f
+00003b50: 6163 746f 7273 203d 2062 2e73 7175 6172  actors = b.squar
+00003b60: 655f 6672 6565 5f66 6163 746f 7269 7a61  e_free_factoriza
+00003b70: 7469 6f6e 5f62 6572 6e61 7264 696e 2829  tion_bernardin()
+00003b80: 3b0a 0a20 2020 2020 2020 2066 6f72 2028  ;..        for (
+00003b90: 6d75 7420 6b2c 206e 2920 696e 2073 7562  mut k, n) in sub
+00003ba0: 5f66 6163 746f 7273 207b 0a20 2020 2020  _factors {.     
+00003bb0: 2020 2020 2020 2066 6f72 2028 706f 7768         for (powh
+00003bc0: 2c20 6869 2920 696e 2026 6d75 7420 6820  , hi) in &mut h 
+00003bd0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00003be0: 2020 6966 202a 706f 7768 203c 2070 207b    if *powh < p {
 00003bf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003c00: 2020 2020 2069 6620 2167 2e69 735f 636f       if !g.is_co
-00003c10: 6e73 7461 6e74 2829 207b 0a20 2020 2020  nstant() {.     
-00003c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c30: 2020 206b 203d 206b 202f 2026 673b 0a20     k = k / &g;. 
-00003c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c50: 2020 2020 2020 202a 6869 203d 2026 2a68         *hi = &*h
-00003c60: 6920 2f20 2667 3b0a 2020 2020 2020 2020  i / &g;.        
-00003c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c80: 6661 6374 6f72 732e 7075 7368 2828 672c  factors.push((g,
-00003c90: 206e 202a 2070 202b 202a 706f 7768 2929   n * p + *powh))
-00003ca0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00003cb0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-00003cc0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00003cd0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00003ce0: 2020 2020 2069 6620 216b 2e69 735f 636f       if !k.is_co
-00003cf0: 6e73 7461 6e74 2829 207b 0a20 2020 2020  nstant() {.     
-00003d00: 2020 2020 2020 2020 2020 2066 6163 746f             facto
-00003d10: 7273 2e70 7573 6828 286b 2c20 6e20 2a20  rs.push((k, n * 
-00003d20: 7029 293b 0a20 2020 2020 2020 2020 2020  p));.           
-00003d30: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
-00003d40: 2020 2020 2020 666f 7220 2870 6f77 682c        for (powh,
-00003d50: 2068 6929 2069 6e20 6820 7b0a 2020 2020   hi) in h {.    
-00003d60: 2020 2020 2020 2020 6966 2021 6869 2e69          if !hi.i
-00003d70: 735f 636f 6e73 7461 6e74 2829 207b 0a20  s_constant() {. 
-00003d80: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00003d90: 6163 746f 7273 2e70 7573 6828 2868 692c  actors.push((hi,
-00003da0: 2070 6f77 6829 293b 0a20 2020 2020 2020   powh));.       
-00003db0: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
-00003dc0: 0a0a 2020 2020 2020 2020 6661 6374 6f72  ..        factor
-00003dd0: 730a 2020 2020 7d0a 0a20 2020 202f 2f2f  s.    }..    ///
-00003de0: 2041 206d 6f64 6966 6965 6420 7665 7273   A modified vers
-00003df0: 696f 6e20 6f66 2059 756e 2773 2073 7175  ion of Yun's squ
-00003e00: 6172 6520 6672 6565 2066 6163 746f 7269  are free factori
-00003e10: 7a61 7469 6f6e 2061 6c67 6f72 6974 686d  zation algorithm
-00003e20: 2e0a 2020 2020 666e 2073 7175 6172 655f  ..    fn square_
-00003e30: 6672 6565 5f66 6163 746f 7269 7a61 7469  free_factorizati
-00003e40: 6f6e 5f66 665f 7975 6e28 2673 656c 662c  on_ff_yun(&self,
-00003e50: 2076 6172 3a20 7573 697a 6529 202d 3e20   var: usize) -> 
-00003e60: 2853 656c 662c 2056 6563 3c28 5365 6c66  (Self, Vec<(Self
-00003e70: 2c20 7573 697a 6529 3e29 207b 0a20 2020  , usize)>) {.   
-00003e80: 2020 2020 206c 6574 2062 203d 2073 656c       let b = sel
-00003e90: 662e 6465 7269 7661 7469 7665 2876 6172  f.derivative(var
-00003ea0: 293b 0a20 2020 2020 2020 206c 6574 206d  );.        let m
-00003eb0: 7574 2063 203d 2073 656c 662e 6763 6428  ut c = self.gcd(
-00003ec0: 2662 293b 0a20 2020 2020 2020 206c 6574  &b);.        let
-00003ed0: 206d 7574 2077 203d 2073 656c 6620 2f20   mut w = self / 
-00003ee0: 2663 3b0a 2020 2020 2020 2020 6c65 7420  &c;.        let 
-00003ef0: 6d75 7420 7620 3d20 2662 202f 2026 633b  mut v = &b / &c;
-00003f00: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
-00003f10: 7420 6661 6374 6f72 7320 3d20 7665 6321  t factors = vec!
-00003f20: 5b5d 3b0a 0a20 2020 2020 2020 206c 6574  [];..        let
-00003f30: 206d 7574 2069 203d 2031 3b0a 2020 2020   mut i = 1;.    
-00003f40: 2020 2020 7768 696c 6520 2177 2e69 735f      while !w.is_
-00003f50: 636f 6e73 7461 6e74 2829 2026 2620 6920  constant() && i 
-00003f60: 3c20 7365 6c66 2e66 6965 6c64 2e67 6574  < self.field.get
-00003f70: 5f70 7269 6d65 2829 2e74 6f5f 7536 3428  _prime().to_u64(
-00003f80: 2920 6173 2075 7369 7a65 207b 0a20 2020  ) as usize {.   
-00003f90: 2020 2020 2020 2020 206c 6574 207a 203d           let z =
-00003fa0: 2076 202d 2077 2e64 6572 6976 6174 6976   v - w.derivativ
-00003fb0: 6528 7661 7229 3b0a 2020 2020 2020 2020  e(var);.        
-00003fc0: 2020 2020 6c65 7420 6720 3d20 772e 6763      let g = w.gc
-00003fd0: 6428 267a 293b 0a20 2020 2020 2020 2020  d(&z);.         
-00003fe0: 2020 2077 203d 2077 202f 2026 673b 0a20     w = w / &g;. 
-00003ff0: 2020 2020 2020 2020 2020 2076 203d 207a             v = z
-00004000: 202f 2026 673b 0a20 2020 2020 2020 2020   / &g;.         
-00004010: 2020 2063 203d 2063 202f 2026 773b 0a0a     c = c / &w;..
-00004020: 2020 2020 2020 2020 2020 2020 6966 2021              if !
-00004030: 672e 6973 5f6f 6e65 2829 207b 0a20 2020  g.is_one() {.   
-00004040: 2020 2020 2020 2020 2020 2020 2066 6163               fac
-00004050: 746f 7273 2e70 7573 6828 2867 2c20 6929  tors.push((g, i)
-00004060: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
-00004070: 0a20 2020 2020 2020 2020 2020 2069 202b  .            i +
-00004080: 3d20 310a 2020 2020 2020 2020 7d0a 0a20  = 1.        }.. 
-00004090: 2020 2020 2020 2028 632c 2066 6163 746f         (c, facto
-000040a0: 7273 290a 2020 2020 7d0a 0a20 2020 202f  rs).    }..    /
-000040b0: 2f2f 2050 6572 666f 726d 2064 6973 7469  // Perform disti
-000040c0: 6e63 7420 6465 6772 6565 2066 6163 746f  nct degree facto
-000040d0: 7269 7a61 7469 6f6e 206f 6e20 6120 6d6f  rization on a mo
-000040e0: 6e69 632c 2075 6e69 7661 7269 6174 6520  nic, univariate 
-000040f0: 616e 6420 7371 7561 7265 2d66 7265 6520  and square-free 
-00004100: 706f 6c79 6e6f 6d69 616c 2e0a 2020 2020  polynomial..    
-00004110: 7075 6220 666e 2064 6973 7469 6e63 745f  pub fn distinct_
-00004120: 6465 6772 6565 5f66 6163 746f 7269 7a61  degree_factoriza
-00004130: 7469 6f6e 2826 7365 6c66 2920 2d3e 2056  tion(&self) -> V
-00004140: 6563 3c28 7573 697a 652c 2053 656c 6629  ec<(usize, Self)
-00004150: 3e20 7b0a 2020 2020 2020 2020 6173 7365  > {.        asse
-00004160: 7274 2128 7365 6c66 2e66 6965 6c64 2e67  rt!(self.field.g
-00004170: 6574 5f70 7269 6d65 2829 2e74 6f5f 7536  et_prime().to_u6
-00004180: 3428 2920 213d 2032 293b 0a20 2020 2020  4() != 2);.     
-00004190: 2020 206c 6574 2053 6f6d 6528 7661 7229     let Some(var)
-000041a0: 203d 2073 656c 662e 6c61 7374 5f65 7870   = self.last_exp
-000041b0: 6f6e 656e 7473 2829 2e69 7465 7228 292e  onents().iter().
-000041c0: 706f 7369 7469 6f6e 287c 787c 202a 7820  position(|x| *x 
-000041d0: 3e20 453a 3a7a 6572 6f28 2929 2065 6c73  > E::zero()) els
-000041e0: 6520 7b0a 2020 2020 2020 2020 2020 2020  e {.            
-000041f0: 7265 7475 726e 2076 6563 215b 2830 2c20  return vec![(0, 
-00004200: 7365 6c66 2e63 6c6f 6e65 2829 295d 3b20  self.clone())]; 
-00004210: 2f2f 2063 6f6e 7374 616e 7420 706f 6c79  // constant poly
-00004220: 6e6f 6d69 616c 0a20 2020 2020 2020 207d  nomial.        }
-00004230: 3b0a 0a20 2020 2020 2020 206c 6574 206d  ;..        let m
-00004240: 7574 2065 203d 2073 656c 662e 6c61 7374  ut e = self.last
-00004250: 5f65 7870 6f6e 656e 7473 2829 2e74 6f5f  _exponents().to_
-00004260: 7665 6328 293b 0a20 2020 2020 2020 2065  vec();.        e
-00004270: 5b76 6172 5d20 3d20 453a 3a6f 6e65 2829  [var] = E::one()
-00004280: 3b0a 2020 2020 2020 2020 6c65 7420 7820  ;.        let x 
-00004290: 3d20 7365 6c66 2e6d 6f6e 6f6d 6961 6c28  = self.monomial(
-000042a0: 7365 6c66 2e66 6965 6c64 2e6f 6e65 2829  self.field.one()
-000042b0: 2c20 6529 3b0a 0a20 2020 2020 2020 206c  , e);..        l
-000042c0: 6574 206d 7574 2066 6163 746f 7273 203d  et mut factors =
-000042d0: 2076 6563 215b 5d3b 0a20 2020 2020 2020   vec![];.       
-000042e0: 206c 6574 206d 7574 2068 203d 2078 2e63   let mut h = x.c
-000042f0: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
-00004300: 6c65 7420 6d75 7420 6620 3d20 7365 6c66  let mut f = self
-00004310: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
-00004320: 2020 6c65 7420 6d75 7420 693a 2075 7369    let mut i: usi
-00004330: 7a65 203d 2030 3b0a 2020 2020 2020 2020  ze = 0;.        
-00004340: 7768 696c 6520 2166 2e69 735f 6f6e 6528  while !f.is_one(
-00004350: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00004360: 6920 2b3d 2031 3b0a 0a20 2020 2020 2020  i += 1;..       
-00004370: 2020 2020 2068 203d 2068 2e65 7870 5f6d       h = h.exp_m
-00004380: 6f64 5f75 6e69 7661 7269 6174 6528 7365  od_univariate(se
-00004390: 6c66 2e66 6965 6c64 2e67 6574 5f70 7269  lf.field.get_pri
-000043a0: 6d65 2829 2e74 6f5f 7536 3428 292e 696e  me().to_u64().in
-000043b0: 746f 2829 2c20 266d 7574 2066 293b 0a0a  to(), &mut f);..
-000043c0: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-000043d0: 6d75 7420 6720 3d20 662e 6763 6428 2628  mut g = f.gcd(&(
-000043e0: 2668 202d 2026 7829 293b 0a0a 2020 2020  &h - &x));..    
-000043f0: 2020 2020 2020 2020 6966 2021 672e 6973          if !g.is
-00004400: 5f6f 6e65 2829 207b 0a20 2020 2020 2020  _one() {.       
-00004410: 2020 2020 2020 2020 2066 203d 2066 2e71           f = f.q
-00004420: 756f 745f 7265 6d5f 756e 6976 6172 6961  uot_rem_univaria
-00004430: 7465 2826 6d75 7420 6729 2e30 3b0a 2020  te(&mut g).0;.  
-00004440: 2020 2020 2020 2020 2020 2020 2020 6661                fa
-00004450: 6374 6f72 732e 7075 7368 2828 692c 2067  ctors.push((i, g
-00004460: 2929 3b0a 2020 2020 2020 2020 2020 2020  ));.            
-00004470: 7d0a 0a20 2020 2020 2020 2020 2020 2069  }..            i
-00004480: 6620 662e 6c61 7374 5f65 7870 6f6e 656e  f f.last_exponen
-00004490: 7473 2829 5b76 6172 5d20 3c20 453a 3a66  ts()[var] < E::f
-000044a0: 726f 6d5f 7533 3228 3220 2a20 2869 2061  rom_u32(2 * (i a
-000044b0: 7320 7533 3220 2b20 3129 2920 7b0a 2020  s u32 + 1)) {.  
-000044c0: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
-000044d0: 2066 2063 616e 6e6f 7420 6265 2073 706c   f cannot be spl
-000044e0: 6974 206d 6f72 650a 2020 2020 2020 2020  it more.        
-000044f0: 2020 2020 2020 2020 6966 2021 662e 6973          if !f.is
-00004500: 5f63 6f6e 7374 616e 7428 2920 7b0a 2020  _constant() {.  
-00004510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004520: 2020 6661 6374 6f72 732e 7075 7368 2828    factors.push((
-00004530: 662e 6c61 7374 5f65 7870 6f6e 656e 7473  f.last_exponents
-00004540: 2829 5b76 6172 5d2e 746f 5f75 3332 2829  ()[var].to_u32()
-00004550: 2061 7320 7573 697a 652c 2066 2929 3b0a   as usize, f));.
-00004560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004570: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-00004580: 2020 6272 6561 6b3b 0a20 2020 2020 2020    break;.       
-00004590: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
-000045a0: 0a0a 2020 2020 2020 2020 6661 6374 6f72  ..        factor
-000045b0: 730a 2020 2020 7d0a 0a20 2020 202f 2f2f  s.    }..    ///
-000045c0: 2050 6572 666f 726d 2043 616e 746f 722d   Perform Cantor-
-000045d0: 5a61 7373 656e 6861 7573 2773 2070 726f  Zassenhaus's pro
-000045e0: 6261 6269 6c69 7374 6963 2061 6c67 6f72  babilistic algor
-000045f0: 6974 686d 2066 6f72 0a20 2020 202f 2f2f  ithm for.    ///
-00004600: 2066 696e 6469 6e67 2069 7272 6564 7563   finding irreduc
-00004610: 6962 6c65 2066 6163 746f 7273 206f 6620  ible factors of 
-00004620: 6465 6772 6565 2060 6460 2e0a 2020 2020  degree `d`..    
-00004630: 7075 6220 666e 2065 7175 616c 5f64 6567  pub fn equal_deg
-00004640: 7265 655f 6661 6374 6f72 697a 6174 696f  ree_factorizatio
-00004650: 6e28 2673 656c 662c 2064 3a20 7573 697a  n(&self, d: usiz
-00004660: 6529 202d 3e20 5665 633c 5365 6c66 3e20  e) -> Vec<Self> 
-00004670: 7b0a 2020 2020 2020 2020 6173 7365 7274  {.        assert
-00004680: 2128 7365 6c66 2e66 6965 6c64 2e67 6574  !(self.field.get
-00004690: 5f70 7269 6d65 2829 2e74 6f5f 7536 3428  _prime().to_u64(
-000046a0: 2920 213d 2032 293b 0a20 2020 2020 2020  ) != 2);.       
-000046b0: 206c 6574 206d 7574 2073 203d 2073 656c   let mut s = sel
-000046c0: 662e 636c 6f6e 6528 292e 6d61 6b65 5f6d  f.clone().make_m
-000046d0: 6f6e 6963 2829 3b0a 0a20 2020 2020 2020  onic();..       
-000046e0: 206c 6574 2053 6f6d 6528 7661 7229 203d   let Some(var) =
-000046f0: 2073 656c 662e 6c61 7374 5f65 7870 6f6e   self.last_expon
-00004700: 656e 7473 2829 2e69 7465 7228 292e 706f  ents().iter().po
-00004710: 7369 7469 6f6e 287c 787c 202a 7820 3e20  sition(|x| *x > 
-00004720: 453a 3a7a 6572 6f28 2929 2065 6c73 6520  E::zero()) else 
-00004730: 7b0a 2020 2020 2020 2020 2020 2020 6966  {.            if
-00004740: 2064 203d 3d20 3120 7b0a 2020 2020 2020   d == 1 {.      
-00004750: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00004760: 2076 6563 215b 735d 3b0a 2020 2020 2020   vec![s];.      
-00004770: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
-00004780: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00004790: 616e 6963 2128 2244 6567 7265 6520 6d69  anic!("Degree mi
-000047a0: 736d 6174 6368 2066 6f72 207b 7d3a 207b  smatch for {}: {
-000047b0: 7d22 2c20 7365 6c66 2c20 6429 3b0a 2020  }", self, d);.  
-000047c0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-000047d0: 2020 2020 7d3b 0a0a 2020 2020 2020 2020      };..        
-000047e0: 6c65 7420 6e20 3d20 7365 6c66 2e64 6567  let n = self.deg
-000047f0: 7265 6528 7661 7229 2e74 6f5f 7533 3228  ree(var).to_u32(
-00004800: 2920 6173 2075 7369 7a65 3b0a 0a20 2020  ) as usize;..   
-00004810: 2020 2020 2069 6620 6e20 3d3d 2064 207b       if n == d {
-00004820: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00004830: 7572 6e20 7665 6321 5b73 5d3b 0a20 2020  urn vec![s];.   
-00004840: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-00004850: 6c65 7420 6d75 7420 726e 6720 3d20 7468  let mut rng = th
-00004860: 7265 6164 5f72 6e67 2829 3b0a 2020 2020  read_rng();.    
-00004870: 2020 2020 6c65 7420 6d75 7420 7261 6e64      let mut rand
-00004880: 6f6d 5f70 6f6c 7920 3d20 7365 6c66 2e7a  om_poly = self.z
-00004890: 6572 6f5f 7769 7468 5f63 6170 6163 6974  ero_with_capacit
-000048a0: 7928 6429 3b0a 2020 2020 2020 2020 6c65  y(d);.        le
-000048b0: 7420 6d75 7420 6578 7020 3d20 7665 6321  t mut exp = vec!
-000048c0: 5b45 3a3a 7a65 726f 2829 3b20 7365 6c66  [E::zero(); self
-000048d0: 2e6e 7661 7273 5d3b 0a0a 2020 2020 2020  .nvars];..      
-000048e0: 2020 6c65 7420 6d75 7420 7472 795f 636f    let mut try_co
-000048f0: 756e 7465 7220 3d20 303b 0a0a 2020 2020  unter = 0;..    
-00004900: 2020 2020 6c65 7420 6661 6374 6f72 203d      let factor =
-00004910: 206c 6f6f 7020 7b0a 2020 2020 2020 2020   loop {.        
-00004920: 2020 2020 2f2f 2067 656e 6572 6174 6520      // generate 
-00004930: 6120 7261 6e64 6f6d 206e 6f6e 2d63 6f6e  a random non-con
-00004940: 7374 616e 7420 706f 6c79 6e6f 6d69 616c  stant polynomial
-00004950: 0a20 2020 2020 2020 2020 2020 2072 616e  .            ran
-00004960: 646f 6d5f 706f 6c79 2e63 6c65 6172 2829  dom_poly.clear()
-00004970: 3b0a 0a20 2020 2020 2020 2020 2020 2069  ;..            i
-00004980: 6620 6420 3d3d 2031 207b 0a20 2020 2020  f d == 1 {.     
-00004990: 2020 2020 2020 2020 2020 2065 7870 5b76             exp[v
-000049a0: 6172 5d20 3d20 453a 3a7a 6572 6f28 293b  ar] = E::zero();
-000049b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000049c0: 2072 616e 646f 6d5f 706f 6c79 2e61 7070   random_poly.app
-000049d0: 656e 645f 6d6f 6e6f 6d69 616c 2873 656c  end_monomial(sel
-000049e0: 662e 6669 656c 642e 6e74 6828 7472 795f  f.field.nth(try_
-000049f0: 636f 756e 7465 7229 2c20 2665 7870 293b  counter), &exp);
-00004a00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004a10: 2065 7870 5b76 6172 5d20 3d20 453a 3a6f   exp[var] = E::o
-00004a20: 6e65 2829 3b0a 2020 2020 2020 2020 2020  ne();.          
-00004a30: 2020 2020 2020 7261 6e64 6f6d 5f70 6f6c        random_pol
-00004a40: 792e 6170 7065 6e64 5f6d 6f6e 6f6d 6961  y.append_monomia
-00004a50: 6c28 7365 6c66 2e66 6965 6c64 2e6f 6e65  l(self.field.one
-00004a60: 2829 2c20 2665 7870 293b 0a20 2020 2020  (), &exp);.     
-00004a70: 2020 2020 2020 2020 2020 2074 7279 5f63             try_c
-00004a80: 6f75 6e74 6572 202b 3d20 313b 0a20 2020  ounter += 1;.   
-00004a90: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
-00004aa0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00004ab0: 2020 666f 7220 6920 696e 2030 2e2e 3220    for i in 0..2 
-00004ac0: 2a20 6420 7b0a 2020 2020 2020 2020 2020  * d {.          
-00004ad0: 2020 2020 2020 2020 2020 6c65 7420 7220            let r 
-00004ae0: 3d20 7365 6c66 0a20 2020 2020 2020 2020  = self.         
-00004af0: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00004b00: 6669 656c 640a 2020 2020 2020 2020 2020  field.          
-00004b10: 2020 2020 2020 2020 2020 2020 2020 2e6e                .n
-00004b20: 7468 2872 6e67 2e67 656e 5f72 616e 6765  th(rng.gen_range
-00004b30: 2830 2e2e 7365 6c66 2e66 6965 6c64 2e67  (0..self.field.g
-00004b40: 6574 5f70 7269 6d65 2829 2e74 6f5f 7536  et_prime().to_u6
-00004b50: 3428 2929 293b 0a20 2020 2020 2020 2020  4()));.         
-00004b60: 2020 2020 2020 2020 2020 2069 6620 2146             if !F
-00004b70: 696e 6974 6546 6965 6c64 3a3a 3c55 4669  initeField::<UFi
-00004b80: 656c 643e 3a3a 6973 5f7a 6572 6f28 2672  eld>::is_zero(&r
-00004b90: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00004ba0: 2020 2020 2020 2020 2020 2020 6578 705b              exp[
-00004bb0: 7661 725d 203d 2045 3a3a 6672 6f6d 5f75  var] = E::from_u
-00004bc0: 3332 2869 2061 7320 7533 3229 3b0a 2020  32(i as u32);.  
-00004bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004be0: 2020 2020 2020 7261 6e64 6f6d 5f70 6f6c        random_pol
-00004bf0: 792e 6170 7065 6e64 5f6d 6f6e 6f6d 6961  y.append_monomia
-00004c00: 6c28 722c 2026 6578 7029 3b0a 2020 2020  l(r, &exp);.    
-00004c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c20: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-00004c30: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00004c40: 2020 2020 2069 6620 7261 6e64 6f6d 5f70       if random_p
-00004c50: 6f6c 792e 6465 6772 6565 2876 6172 2920  oly.degree(var) 
-00004c60: 3d3d 2045 3a3a 7a65 726f 2829 207b 0a20  == E::zero() {. 
-00004c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c80: 2020 2063 6f6e 7469 6e75 653b 0a20 2020     continue;.   
-00004c90: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
-00004ca0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-00004cb0: 2020 2020 2020 2020 2020 6c65 7420 6720            let g 
-00004cc0: 3d20 7261 6e64 6f6d 5f70 6f6c 792e 6763  = random_poly.gc
-00004cd0: 6428 2673 293b 0a0a 2020 2020 2020 2020  d(&s);..        
-00004ce0: 2020 2020 6966 2021 672e 6973 5f6f 6e65      if !g.is_one
-00004cf0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00004d00: 2020 2020 2062 7265 616b 2067 3b0a 2020       break g;.  
-00004d10: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
-00004d20: 2020 2020 2020 2020 202f 2f20 544f 444f           // TODO
-00004d30: 3a20 7573 6520 4672 6f62 656e 6975 7320  : use Frobenius 
-00004d40: 6d61 7020 616e 6420 6d6f 6475 6c61 7220  map and modular 
-00004d50: 636f 6d70 6f73 6974 696f 6e20 746f 2070  composition to p
-00004d60: 7265 7665 6e74 2063 6f6d 7075 7469 6e67  revent computing
-00004d70: 206c 6172 6765 2065 7870 6f6e 656e 7420   large exponent 
-00004d80: 706f 6c79 5e28 705e 6429 0a20 2020 2020  poly^(p^d).     
-00004d90: 2020 2020 2020 206c 6574 2070 3a20 496e         let p: In
-00004da0: 7465 6765 7220 3d20 7365 6c66 2e66 6965  teger = self.fie
-00004db0: 6c64 2e67 6574 5f70 7269 6d65 2829 2e74  ld.get_prime().t
-00004dc0: 6f5f 7536 3428 292e 696e 746f 2829 3b0a  o_u64().into();.
-00004dd0: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00004de0: 6220 3d20 7261 6e64 6f6d 5f70 6f6c 790a  b = random_poly.
-00004df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e00: 2e65 7870 5f6d 6f64 5f75 6e69 7661 7269  .exp_mod_univari
-00004e10: 6174 6528 2628 2670 2e70 6f77 2864 2061  ate(&(&p.pow(d a
-00004e20: 7320 7536 3429 202d 2026 3169 3634 2e69  s u64) - &1i64.i
-00004e30: 6e74 6f28 2929 202f 2026 3269 3634 2e69  nto()) / &2i64.i
-00004e40: 6e74 6f28 292c 2026 6d75 7420 7329 0a20  nto(), &mut s). 
-00004e50: 2020 2020 2020 2020 2020 2020 2020 202d                 -
-00004e60: 2073 656c 662e 6f6e 6528 293b 0a0a 2020   self.one();..  
-00004e70: 2020 2020 2020 2020 2020 6c65 7420 6720            let g 
-00004e80: 3d20 622e 6763 6428 2673 293b 0a0a 2020  = b.gcd(&s);..  
-00004e90: 2020 2020 2020 2020 2020 6966 2021 672e            if !g.
-00004ea0: 6973 5f6f 6e65 2829 2026 2620 6720 213d  is_one() && g !=
-00004eb0: 2073 207b 0a20 2020 2020 2020 2020 2020   s {.           
-00004ec0: 2020 2020 2062 7265 616b 2067 3b0a 2020       break g;.  
-00004ed0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00004ee0: 2020 2020 7d3b 0a0a 2020 2020 2020 2020      };..        
-00004ef0: 6c65 7420 6d75 7420 6661 6374 6f72 7320  let mut factors 
-00004f00: 3d20 6661 6374 6f72 2e65 7175 616c 5f64  = factor.equal_d
-00004f10: 6567 7265 655f 6661 6374 6f72 697a 6174  egree_factorizat
-00004f20: 696f 6e28 6429 3b0a 2020 2020 2020 2020  ion(d);.        
-00004f30: 6661 6374 6f72 732e 6578 7465 6e64 2828  factors.extend((
-00004f40: 7365 6c66 202f 2026 6661 6374 6f72 292e  self / &factor).
-00004f50: 6571 7561 6c5f 6465 6772 6565 5f66 6163  equal_degree_fac
-00004f60: 746f 7269 7a61 7469 6f6e 2864 2929 3b0a  torization(d));.
-00004f70: 2020 2020 2020 2020 6661 6374 6f72 730a          factors.
-00004f80: 2020 2020 7d0a 0a20 2020 202f 2f2f 2050      }..    /// P
-00004f90: 6572 666f 726d 2064 6973 7469 6e63 7420  erform distinct 
-00004fa0: 616e 6420 6571 7561 6c20 6465 6772 6565  and equal degree
-00004fb0: 2066 6163 746f 7269 7a61 7469 6f6e 206f   factorization o
-00004fc0: 6e20 6120 7371 7561 7265 2d66 7265 6520  n a square-free 
-00004fd0: 756e 6976 6172 6961 7465 2070 6f6c 796e  univariate polyn
-00004fe0: 6f6d 6961 6c2e 0a20 2020 2066 6e20 6661  omial..    fn fa
-00004ff0: 6374 6f72 5f64 6973 7469 6e63 745f 6571  ctor_distinct_eq
-00005000: 7561 6c5f 6465 6772 6565 2826 7365 6c66  ual_degree(&self
-00005010: 2920 2d3e 2056 6563 3c53 656c 663e 207b  ) -> Vec<Self> {
-00005020: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-00005030: 2066 6163 746f 7273 203d 2076 6563 215b   factors = vec![
-00005040: 5d3b 0a20 2020 2020 2020 2066 6f72 2028  ];.        for (
-00005050: 6432 2c20 6632 2920 696e 2073 656c 662e  d2, f2) in self.
-00005060: 6469 7374 696e 6374 5f64 6567 7265 655f  distinct_degree_
-00005070: 6661 6374 6f72 697a 6174 696f 6e28 2920  factorization() 
-00005080: 7b0a 2020 2020 2020 2020 2020 2020 6465  {.            de
-00005090: 6275 6721 2822 4444 4620 7b7d 207b 7d22  bug!("DDF {} {}"
-000050a0: 2c20 6632 2c20 6432 293b 0a20 2020 2020  , f2, d2);.     
-000050b0: 2020 2020 2020 2066 6f72 2066 3320 696e         for f3 in
-000050c0: 2066 322e 6571 7561 6c5f 6465 6772 6565   f2.equal_degree
-000050d0: 5f66 6163 746f 7269 7a61 7469 6f6e 2864  _factorization(d
-000050e0: 3229 207b 0a20 2020 2020 2020 2020 2020  2) {.           
-000050f0: 2020 2020 2064 6562 7567 2128 2245 4446       debug!("EDF
-00005100: 207b 7d22 2c20 6633 293b 0a20 2020 2020   {}", f3);.     
-00005110: 2020 2020 2020 2020 2020 2066 6163 746f             facto
-00005120: 7273 2e70 7573 6828 6633 293b 0a20 2020  rs.push(f3);.   
-00005130: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00005140: 2020 207d 0a20 2020 2020 2020 2066 6163     }.        fac
-00005150: 746f 7273 0a20 2020 207d 0a0a 2020 2020  tors.    }..    
-00005160: 2f2f 2f20 4265 726e 6172 6469 6e27 7320  /// Bernardin's 
-00005170: 616c 676f 7269 7468 6d20 6261 7365 6420  algorithm based 
-00005180: 6f6e 0a20 2020 202f 2f2f 2022 4120 6e65  on.    /// "A ne
-00005190: 7720 6269 7661 7269 6174 6520 4865 6e73  w bivariate Hens
-000051a0: 656c 206c 6966 7469 6e67 2061 6c67 6f72  el lifting algor
-000051b0: 6974 686d 2066 6f72 206e 2066 6163 746f  ithm for n facto
-000051c0: 7273 220a 2020 2020 2f2f 2f20 6279 2047  rs".    /// by G
-000051d0: 6172 7265 7474 2050 616c 7563 6b2e 2054  arrett Paluck. T
-000051e0: 6865 2066 6f72 6d75 6c61 7469 6f6e 206f  he formulation o
-000051f0: 6620 7468 6520 616c 676f 7269 7468 6d20  f the algorithm 
-00005200: 696e 206f 7468 6572 2073 6f75 7263 6573  in other sources
-00005210: 2063 6f6e 7461 696e 2073 6572 696f 7573   contain serious
-00005220: 2065 7272 6f72 732e 0a20 2020 202f 2f20   errors..    // 
-00005230: 544f 444f 3a20 6d65 7267 6520 7769 7468  TODO: merge with
-00005240: 2061 6e20 616c 6d6f 7374 2073 696d 696c   an almost simil
-00005250: 6172 206d 6574 686f 6420 666f 7220 7468  ar method for th
-00005260: 6520 696e 7465 6765 7220 6361 7365 2e20  e integer case. 
-00005270: 4120 6d6f 6469 6669 6361 7469 6f6e 2074  A modification t
-00005280: 6861 7420 6e65 6564 730a 2020 2020 2f2f  hat needs.    //
-00005290: 2074 6f20 6265 206d 6164 6520 6865 7265   to be made here
-000052a0: 2069 7320 746f 206d 616b 6520 7468 6520   is to make the 
-000052b0: 6c63 6f65 6666 5f79 3d30 206d 6f6e 6963  lcoeff_y=0 monic
-000052c0: 0a20 2020 2066 6e20 6269 7661 7269 6174  .    fn bivariat
-000052d0: 655f 6865 6e73 656c 5f6c 6966 745f 6265  e_hensel_lift_be
-000052e0: 726e 6172 6469 6e28 0a20 2020 2020 2020  rnardin(.       
-000052f0: 2026 7365 6c66 2c0a 2020 2020 2020 2020   &self,.        
-00005300: 696e 7465 7270 6f6c 6174 696f 6e5f 7661  interpolation_va
-00005310: 723a 2075 7369 7a65 2c0a 2020 2020 2020  r: usize,.      
-00005320: 2020 6c63 6f65 6666 3a20 2653 656c 662c    lcoeff: &Self,
-00005330: 0a20 2020 2020 2020 2075 6e69 7661 7269  .        univari
-00005340: 6174 655f 6661 6374 6f72 733a 2026 5b53  ate_factors: &[S
-00005350: 656c 665d 2c0a 2020 2020 2020 2020 6974  elf],.        it
-00005360: 6572 6174 696f 6e73 3a20 7573 697a 652c  erations: usize,
-00005370: 0a20 2020 2029 202d 3e20 5665 633c 5365  .    ) -> Vec<Se
-00005380: 6c66 3e20 7b0a 2020 2020 2020 2020 6c65  lf> {.        le
-00005390: 7420 795f 706f 6c79 203d 2073 656c 662e  t y_poly = self.
-000053a0: 746f 5f75 6e69 7661 7269 6174 655f 706f  to_univariate_po
-000053b0: 6c79 6e6f 6d69 616c 5f6c 6973 7428 696e  lynomial_list(in
-000053c0: 7465 7270 6f6c 6174 696f 6e5f 7661 7229  terpolation_var)
-000053d0: 3b0a 0a20 2020 2020 2020 202f 2f20 6164  ;..        // ad
-000053e0: 6420 7468 6520 6c65 6164 696e 6720 636f  d the leading co
-000053f0: 6566 6669 6369 656e 7420 6173 2061 2066  efficient as a f
-00005400: 6972 7374 2066 6163 746f 720a 2020 2020  irst factor.    
-00005410: 2020 2020 6c65 7420 6d75 7420 6661 6374      let mut fact
-00005420: 6f72 7320 3d20 7665 6321 5b6c 636f 6566  ors = vec![lcoef
-00005430: 662e 7265 706c 6163 6528 696e 7465 7270  f.replace(interp
-00005440: 6f6c 6174 696f 6e5f 7661 722c 2026 7365  olation_var, &se
-00005450: 6c66 2e66 6965 6c64 2e7a 6572 6f28 2929  lf.field.zero())
-00005460: 5d3b 0a20 2020 2020 2020 2066 6163 746f  ];.        facto
-00005470: 7273 2e65 7874 656e 645f 6672 6f6d 5f73  rs.extend_from_s
-00005480: 6c69 6365 2875 6e69 7661 7269 6174 655f  lice(univariate_
-00005490: 6661 6374 6f72 7329 3b0a 0a20 2020 2020  factors);..     
-000054a0: 2020 202f 2f20 6578 7472 6163 7420 636f     // extract co
-000054b0: 6566 6669 6369 656e 7473 2069 6e20 790a  efficients in y.
-000054c0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-000054d0: 753a 2056 6563 3c5f 3e20 3d20 6661 6374  u: Vec<_> = fact
-000054e0: 6f72 730a 2020 2020 2020 2020 2020 2020  ors.            
-000054f0: 2e69 7465 7228 290a 2020 2020 2020 2020  .iter().        
-00005500: 2020 2020 2e6d 6170 287c 667c 207b 0a20      .map(|f| {. 
-00005510: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00005520: 6574 206d 7574 2064 656e 7365 203d 2076  et mut dense = v
-00005530: 6563 215b 7365 6c66 2e7a 6572 6f28 293b  ec![self.zero();
-00005540: 2069 7465 7261 7469 6f6e 7320 2b20 315d   iterations + 1]
-00005550: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00005560: 2020 6465 6e73 655b 305d 203d 2066 2e63    dense[0] = f.c
-00005570: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
-00005580: 2020 2020 2020 2020 6465 6e73 650a 2020          dense.  
-00005590: 2020 2020 2020 2020 2020 7d29 0a20 2020            }).   
-000055a0: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-000055b0: 7428 293b 0a0a 2020 2020 2020 2020 2f2f  t();..        //
-000055c0: 2075 7064 6174 6520 7468 6520 6669 7273   update the firs
-000055d0: 7420 706f 6c79 6e6f 6d69 616c 2061 7320  t polynomial as 
-000055e0: 6974 206d 6179 2063 6f6e 7461 696e 2079  it may contain y
-000055f0: 2c20 7369 6e63 6520 6974 2773 206c 636f  , since it's lco
-00005600: 6566 660a 2020 2020 2020 2020 6c65 7420  eff.        let 
-00005610: 795f 6c63 6f65 6666 203d 206c 636f 6566  y_lcoeff = lcoef
-00005620: 662e 746f 5f75 6e69 7661 7269 6174 655f  f.to_univariate_
-00005630: 706f 6c79 6e6f 6d69 616c 5f6c 6973 7428  polynomial_list(
-00005640: 696e 7465 7270 6f6c 6174 696f 6e5f 7661  interpolation_va
-00005650: 7229 3b0a 2020 2020 2020 2020 666f 7220  r);.        for 
-00005660: 2870 2c20 6529 2069 6e20 795f 6c63 6f65  (p, e) in y_lcoe
-00005670: 6666 207b 0a20 2020 2020 2020 2020 2020  ff {.           
-00005680: 2075 5b30 5d5b 652e 746f 5f75 3332 2829   u[0][e.to_u32()
-00005690: 2061 7320 7573 697a 655d 203d 2070 3b0a   as usize] = p;.
-000056a0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-000056b0: 2020 206c 6574 206d 7574 2070 203d 2075     let mut p = u
-000056c0: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
-000056d0: 2020 6c65 7420 6d75 7420 6375 725f 7020    let mut cur_p 
-000056e0: 3d20 705b 305d 5b30 5d2e 636c 6f6e 6528  = p[0][0].clone(
-000056f0: 293b 0a20 2020 2020 2020 2066 6f72 2078  );.        for x
-00005700: 2069 6e20 266d 7574 2070 2e69 7465 725f   in &mut p.iter_
-00005710: 6d75 7428 292e 736b 6970 2831 2920 7b0a  mut().skip(1) {.
-00005720: 2020 2020 2020 2020 2020 2020 6375 725f              cur_
-00005730: 7020 3d20 6375 725f 7020 2a20 2678 5b30  p = cur_p * &x[0
-00005740: 5d3b 0a20 2020 2020 2020 2020 2020 2078  ];.            x
-00005750: 5b30 5d20 3d20 6375 725f 702e 636c 6f6e  [0] = cur_p.clon
-00005760: 6528 293b 0a20 2020 2020 2020 207d 0a0a  e();.        }..
-00005770: 2020 2020 2020 2020 6c65 7420 6465 6c74          let delt
-00005780: 6120 3d20 5365 6c66 3a3a 6469 6f70 6861  a = Self::diopha
-00005790: 6e74 696e 655f 756e 6976 6172 6961 7465  ntine_univariate
-000057a0: 2826 6d75 7420 6661 6374 6f72 732c 2026  (&mut factors, &
-000057b0: 7365 6c66 2e6f 6e65 2829 293b 0a0a 2020  self.one());..  
-000057c0: 2020 2020 2020 666f 7220 6b20 696e 2031        for k in 1
-000057d0: 2e2e 6974 6572 6174 696f 6e73 207b 0a20  ..iterations {. 
-000057e0: 2020 2020 2020 2020 2020 202f 2f20 6578             // ex
-000057f0: 7472 6163 7420 7468 6520 636f 6566 6669  tract the coeffi
-00005800: 6369 656e 7420 7265 7175 6972 6564 2074  cient required t
-00005810: 6f20 636f 6d70 7574 6520 7468 6520 6572  o compute the er
-00005820: 726f 7220 696e 2079 5e6b 0a20 2020 2020  ror in y^k.     
-00005830: 2020 2020 2020 202f 2f20 636f 6d70 7574         // comput
-00005840: 6564 2075 7369 6e67 2061 2063 6f6e 766f  ed using a convo
-00005850: 6c75 7469 6f6e 0a20 2020 2020 2020 2020  lution.         
-00005860: 2020 2070 5b30 5d5b 6b5d 203d 2075 5b30     p[0][k] = u[0
-00005870: 5d5b 6b5d 2e63 6c6f 6e65 2829 3b0a 2020  ][k].clone();.  
-00005880: 2020 2020 2020 2020 2020 666f 7220 6920            for i 
-00005890: 696e 2031 2e2e 6661 6374 6f72 732e 6c65  in 1..factors.le
-000058a0: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
-000058b0: 2020 2020 2020 666f 7220 6a20 696e 2030        for j in 0
-000058c0: 2e2e 6b20 7b0a 2020 2020 2020 2020 2020  ..k {.          
-000058d0: 2020 2020 2020 2020 2020 705b 695d 5b6b            p[i][k
-000058e0: 5d20 3d20 2670 5b69 5d5b 6b5d 202b 2026  ] = &p[i][k] + &
-000058f0: 2826 705b 6920 2d20 315d 5b6b 202d 206a  (&p[i - 1][k - j
-00005900: 5d20 2a20 2675 5b69 5d5b 6a5d 293b 0a20  ] * &u[i][j]);. 
-00005910: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00005920: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
-00005930: 2020 2020 2020 2020 2020 2020 2f2f 2066              // f
-00005940: 696e 6420 7468 6520 6b74 6820 706f 7765  ind the kth powe
-00005950: 7220 6f66 2079 2069 6e20 660a 2020 2020  r of y in f.    
-00005960: 2020 2020 2020 2020 2f2f 2073 696e 6365          // since
-00005970: 2077 6520 636f 6d70 7574 6520 7468 6520   we compute the 
-00005980: 6572 726f 7220 7065 7220 706f 7765 7220  error per power 
-00005990: 6f66 2079 2c20 7765 2063 616e 6e6f 7420  of y, we cannot 
-000059a0: 7374 6f70 206f 6e20 6120 3020 6572 726f  stop on a 0 erro
-000059b0: 720a 2020 2020 2020 2020 2020 2020 6c65  r.            le
-000059c0: 7420 6520 3d20 6966 206c 6574 2053 6f6d  t e = if let Som
-000059d0: 6528 2876 2c20 5f29 2920 3d20 795f 706f  e((v, _)) = y_po
-000059e0: 6c79 2e69 7465 7228 292e 6669 6e64 287c  ly.iter().find(|
-000059f0: 657c 2065 2e31 2e74 6f5f 7533 3228 2920  e| e.1.to_u32() 
-00005a00: 6173 2075 7369 7a65 203d 3d20 6b29 207b  as usize == k) {
-00005a10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005a20: 2076 202d 2026 702e 6c61 7374 2829 2e75   v - &p.last().u
-00005a30: 6e77 7261 7028 295b 6b5d 0a20 2020 2020  nwrap()[k].     
-00005a40: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
-00005a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005a60: 2d70 2e6c 6173 7428 292e 756e 7772 6170  -p.last().unwrap
-00005a70: 2829 5b6b 5d2e 636c 6f6e 6528 290a 2020  ()[k].clone().  
-00005a80: 2020 2020 2020 2020 2020 7d3b 0a0a 2020            };..  
-00005a90: 2020 2020 2020 2020 2020 6966 2065 2e69            if e.i
-00005aa0: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
-00005ab0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00005ac0: 6e75 653b 0a20 2020 2020 2020 2020 2020  nue;.           
-00005ad0: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
-00005ae0: 666f 7220 2828 6470 2c20 6629 2c20 6429  for ((dp, f), d)
-00005af0: 2069 6e20 752e 6974 6572 5f6d 7574 2829   in u.iter_mut()
-00005b00: 2e7a 6970 2866 6163 746f 7273 2e69 7465  .zip(factors.ite
-00005b10: 725f 6d75 7428 2929 2e7a 6970 2826 6465  r_mut()).zip(&de
-00005b20: 6c74 6129 207b 0a20 2020 2020 2020 2020  lta) {.         
-00005b30: 2020 2020 2020 2064 705b 6b5d 203d 2026         dp[k] = &
-00005b40: 6470 5b6b 5d20 2b20 2628 6420 2a20 2665  dp[k] + &(d * &e
-00005b50: 292e 7175 6f74 5f72 656d 5f75 6e69 7661  ).quot_rem_univa
-00005b60: 7269 6174 6528 6629 2e31 3b0a 2020 2020  riate(f).1;.    
-00005b70: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00005b80: 2020 2020 2020 202f 2f20 7570 6461 7465         // update
-00005b90: 2074 6865 2063 6f65 6666 6963 6965 6e74   the coefficient
-00005ba0: 7320 7769 7468 2074 6865 206e 6577 2079  s with the new y
-00005bb0: 5e6b 2063 6f6e 7472 6962 7574 696f 6e73  ^k contributions
-00005bc0: 0a20 2020 2020 2020 2020 2020 202f 2f20  .            // 
-00005bd0: 6e6f 7465 2074 6861 7420 7468 6520 6c63  note that the lc
-00005be0: 6f65 6666 5b6b 5d20 636f 6e74 7269 6275  oeff[k] contribu
-00005bf0: 7469 6f6e 2069 7320 6e6f 7420 6e65 770a  tion is not new.
-00005c00: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00005c10: 6d75 7420 7420 3d20 7365 6c66 2e7a 6572  mut t = self.zer
-00005c20: 6f28 293b 0a20 2020 2020 2020 2020 2020  o();.           
-00005c30: 2066 6f72 2069 2069 6e20 312e 2e66 6163   for i in 1..fac
-00005c40: 746f 7273 2e6c 656e 2829 207b 0a20 2020  tors.len() {.   
-00005c50: 2020 2020 2020 2020 2020 2020 2074 203d               t =
-00005c60: 2026 755b 695d 5b30 5d20 2a20 2674 202b   &u[i][0] * &t +
-00005c70: 2026 755b 695d 5b6b 5d20 2a20 2670 5b69   &u[i][k] * &p[i
-00005c80: 202d 2031 5d5b 305d 3b0a 2020 2020 2020   - 1][0];.      
-00005c90: 2020 2020 2020 2020 2020 705b 695d 5b6b            p[i][k
-00005ca0: 5d20 3d20 2670 5b69 5d5b 6b5d 202b 2026  ] = &p[i][k] + &
-00005cb0: 743b 0a20 2020 2020 2020 2020 2020 207d  t;.            }
-00005cc0: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-00005cd0: 2020 2020 2f2f 2063 6f6e 7665 7274 2064      // convert d
-00005ce0: 656e 7365 2070 6f6c 796e 6f6d 6961 6c73  ense polynomials
-00005cf0: 2074 6f20 6d75 6c74 6976 6172 6961 7465   to multivariate
-00005d00: 2070 6f6c 796e 6f6d 6961 6c73 0a20 2020   polynomials.   
-00005d10: 2020 2020 2075 2e69 6e74 6f5f 6974 6572       u.into_iter
-00005d20: 2829 0a20 2020 2020 2020 2020 2020 202e  ().            .
-00005d30: 6d61 7028 7c74 737c 207b 0a20 2020 2020  map(|ts| {.     
-00005d40: 2020 2020 2020 2020 2020 206c 6574 206d             let m
-00005d50: 7574 206e 6577 5f70 6f6c 7920 3d20 7365  ut new_poly = se
-00005d60: 6c66 2e7a 6572 6f5f 7769 7468 5f63 6170  lf.zero_with_cap
-00005d70: 6163 6974 7928 7473 2e6c 656e 2829 293b  acity(ts.len());
-00005d80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005d90: 2066 6f72 2028 692c 206d 7574 2066 2920   for (i, mut f) 
-00005da0: 696e 2074 732e 696e 746f 5f69 7465 7228  in ts.into_iter(
-00005db0: 292e 656e 756d 6572 6174 6528 2920 7b0a  ).enumerate() {.
-00005dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005dd0: 2020 2020 666f 7220 7820 696e 2066 2e65      for x in f.e
-00005de0: 7870 6f6e 656e 7473 2e63 6875 6e6b 735f  xponents.chunks_
-00005df0: 6d75 7428 662e 6e76 6172 7329 207b 0a20  mut(f.nvars) {. 
-00005e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005e10: 2020 2020 2020 2078 5b69 6e74 6572 706f         x[interpo
-00005e20: 6c61 7469 6f6e 5f76 6172 5d20 3d20 453a  lation_var] = E:
-00005e30: 3a66 726f 6d5f 7533 3228 6920 6173 2075  :from_u32(i as u
-00005e40: 3332 293b 0a20 2020 2020 2020 2020 2020  32);.           
-00005e50: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00005e60: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00005e70: 6577 5f70 6f6c 7920 3d20 6e65 775f 706f  ew_poly = new_po
-00005e80: 6c79 202b 2066 3b0a 2020 2020 2020 2020  ly + f;.        
-00005e90: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00005ea0: 2020 2020 2020 2020 2020 6e65 775f 706f            new_po
-00005eb0: 6c79 0a20 2020 2020 2020 2020 2020 207d  ly.            }
-00005ec0: 290a 2020 2020 2020 2020 2020 2020 2e63  ).            .c
-00005ed0: 6f6c 6c65 6374 2829 0a20 2020 207d 0a0a  ollect().    }..
-00005ee0: 2020 2020 2f2f 2f20 436f 6d70 7574 6520      /// Compute 
-00005ef0: 7468 6520 6269 7661 7269 6174 6520 6661  the bivariate fa
-00005f00: 6374 6f72 697a 6174 696f 6e20 6f66 2061  ctorization of a
-00005f10: 2073 7175 6172 652d 6672 6565 2070 6f6c   square-free pol
-00005f20: 796e 6f6d 6961 6c2e 0a20 2020 2066 6e20  ynomial..    fn 
-00005f30: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00005f40: 697a 6174 696f 6e28 2673 656c 662c 206d  ization(&self, m
-00005f50: 6169 6e5f 7661 723a 2075 7369 7a65 2c20  ain_var: usize, 
-00005f60: 696e 7465 7270 6f6c 6174 696f 6e5f 7661  interpolation_va
-00005f70: 723a 2075 7369 7a65 2920 2d3e 2056 6563  r: usize) -> Vec
-00005f80: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
-00005f90: 2061 7373 6572 7421 286d 6169 6e5f 7661   assert!(main_va
-00005fa0: 7220 213d 2069 6e74 6572 706f 6c61 7469  r != interpolati
-00005fb0: 6f6e 5f76 6172 293b 0a0a 2020 2020 2020  on_var);..      
-00005fc0: 2020 6966 2073 656c 662e 6269 7661 7269    if self.bivari
-00005fd0: 6174 655f 6972 7265 6475 6369 6269 6c69  ate_irreducibili
-00005fe0: 7479 5f74 6573 7428 2920 7b0a 2020 2020  ty_test() {.    
-00005ff0: 2020 2020 2020 2020 7265 7475 726e 2076          return v
-00006000: 6563 215b 7365 6c66 2e63 6c6f 6e65 2829  ec![self.clone()
-00006010: 5d3b 0a20 2020 2020 2020 207d 0a0a 2020  ];.        }..  
-00006020: 2020 2020 2020 2f2f 2063 6865 636b 2066        // check f
-00006030: 6f72 2070 726f 626c 656d 7320 6172 6973  or problems aris
-00006040: 696e 6720 6672 6f6d 2063 616e 6365 6c69  ing from canceli
-00006050: 6e67 2074 6572 6d73 2069 6e20 7468 6520  ng terms in the 
-00006060: 6465 7269 7661 7469 7665 0a20 2020 2020  derivative.     
-00006070: 2020 206c 6574 2064 6572 203d 2073 656c     let der = sel
-00006080: 662e 6465 7269 7661 7469 7665 286d 6169  f.derivative(mai
-00006090: 6e5f 7661 7229 3b0a 2020 2020 2020 2020  n_var);.        
-000060a0: 6966 2064 6572 2e69 735f 7a65 726f 2829  if der.is_zero()
-000060b0: 207b 0a20 2020 2020 2020 2020 2020 2072   {.            r
-000060c0: 6574 7572 6e20 7365 6c66 2e62 6976 6172  eturn self.bivar
-000060d0: 6961 7465 5f66 6163 746f 7269 7a61 7469  iate_factorizati
-000060e0: 6f6e 2869 6e74 6572 706f 6c61 7469 6f6e  on(interpolation
-000060f0: 5f76 6172 2c20 6d61 696e 5f76 6172 293b  _var, main_var);
-00006100: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-00006110: 2020 2020 6c65 7420 6720 3d20 7365 6c66      let g = self
-00006120: 2e67 6364 2826 6465 7229 3b0a 2020 2020  .gcd(&der);.    
-00006130: 2020 2020 6966 2021 672e 6973 5f63 6f6e      if !g.is_con
-00006140: 7374 616e 7428 2920 7b0a 2020 2020 2020  stant() {.      
-00006150: 2020 2020 2020 6c65 7420 6d75 7420 6661        let mut fa
-00006160: 6374 6f72 7320 3d20 672e 6269 7661 7269  ctors = g.bivari
-00006170: 6174 655f 6661 6374 6f72 697a 6174 696f  ate_factorizatio
-00006180: 6e28 6d61 696e 5f76 6172 2c20 696e 7465  n(main_var, inte
-00006190: 7270 6f6c 6174 696f 6e5f 7661 7229 3b0a  rpolation_var);.
-000061a0: 2020 2020 2020 2020 2020 2020 6661 6374              fact
-000061b0: 6f72 732e 6578 7465 6e64 2828 7365 6c66  ors.extend((self
-000061c0: 202f 2026 6729 2e62 6976 6172 6961 7465   / &g).bivariate
-000061d0: 5f66 6163 746f 7269 7a61 7469 6f6e 286d  _factorization(m
-000061e0: 6169 6e5f 7661 722c 2069 6e74 6572 706f  ain_var, interpo
-000061f0: 6c61 7469 6f6e 5f76 6172 2929 3b0a 2020  lation_var));.  
-00006200: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00006210: 2066 6163 746f 7273 3b0a 2020 2020 2020   factors;.      
-00006220: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
-00006230: 206d 7574 2073 616d 706c 655f 706f 696e   mut sample_poin
-00006240: 7420 3d20 7365 6c66 2e66 6965 6c64 2e7a  t = self.field.z
-00006250: 6572 6f28 293b 0a20 2020 2020 2020 206c  ero();.        l
-00006260: 6574 206d 7574 2075 6e69 5f66 203d 2073  et mut uni_f = s
-00006270: 656c 662e 7265 706c 6163 6528 696e 7465  elf.replace(inte
-00006280: 7270 6f6c 6174 696f 6e5f 7661 722c 2026  rpolation_var, &
-00006290: 7361 6d70 6c65 5f70 6f69 6e74 293b 0a0a  sample_point);..
-000062a0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-000062b0: 6920 3d20 303b 0a20 2020 2020 2020 206c  i = 0;.        l
-000062c0: 6f6f 7020 7b0a 2020 2020 2020 2020 2020  oop {.          
-000062d0: 2020 6966 2073 656c 662e 6465 6772 6565    if self.degree
-000062e0: 286d 6169 6e5f 7661 7229 203d 3d20 756e  (main_var) == un
-000062f0: 695f 662e 6465 6772 6565 286d 6169 6e5f  i_f.degree(main_
-00006300: 7661 7229 0a20 2020 2020 2020 2020 2020  var).           
-00006310: 2020 2020 2026 2620 756e 695f 662e 6763       && uni_f.gc
-00006320: 6428 2675 6e69 5f66 2e64 6572 6976 6174  d(&uni_f.derivat
-00006330: 6976 6528 6d61 696e 5f76 6172 2929 2e69  ive(main_var)).i
-00006340: 735f 636f 6e73 7461 6e74 2829 0a20 2020  s_constant().   
-00006350: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
-00006360: 2020 2020 2020 2020 2020 2062 7265 616b             break
-00006370: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
-00006380: 0a20 2020 2020 2020 2020 2020 2073 616d  .            sam
-00006390: 706c 655f 706f 696e 7420 3d20 7365 6c66  ple_point = self
-000063a0: 2e66 6965 6c64 2e6e 7468 2869 293b 0a20  .field.nth(i);. 
-000063b0: 2020 2020 2020 2020 2020 2075 6e69 5f66             uni_f
-000063c0: 203d 2073 656c 662e 7265 706c 6163 6528   = self.replace(
-000063d0: 696e 7465 7270 6f6c 6174 696f 6e5f 7661  interpolation_va
-000063e0: 722c 2026 7361 6d70 6c65 5f70 6f69 6e74  r, &sample_point
-000063f0: 293b 0a20 2020 2020 2020 2020 2020 2069  );.            i
-00006400: 202b 3d20 313b 0a20 2020 2020 2020 207d   += 1;.        }
-00006410: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
-00006420: 7420 6420 3d20 7365 6c66 2e64 6567 7265  t d = self.degre
-00006430: 6528 696e 7465 7270 6f6c 6174 696f 6e5f  e(interpolation_
-00006440: 7661 7229 2e74 6f5f 7533 3228 293b 0a0a  var).to_u32();..
-00006450: 2020 2020 2020 2020 6c65 7420 7368 6966          let shif
-00006460: 7465 645f 706f 6c79 203d 2069 6620 2146  ted_poly = if !F
-00006470: 696e 6974 6546 6965 6c64 3a3a 3c55 4669  initeField::<UFi
-00006480: 656c 643e 3a3a 6973 5f7a 6572 6f28 2673  eld>::is_zero(&s
-00006490: 616d 706c 655f 706f 696e 7429 207b 0a20  ample_point) {. 
-000064a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000064b0: 7368 6966 745f 7661 725f 6361 6368 6564  shift_var_cached
-000064c0: 2869 6e74 6572 706f 6c61 7469 6f6e 5f76  (interpolation_v
-000064d0: 6172 2c20 2673 616d 706c 655f 706f 696e  ar, &sample_poin
-000064e0: 7429 0a20 2020 2020 2020 207d 2065 6c73  t).        } els
-000064f0: 6520 7b0a 2020 2020 2020 2020 2020 2020  e {.            
-00006500: 7365 6c66 2e63 6c6f 6e65 2829 0a20 2020  self.clone().   
-00006510: 2020 2020 207d 3b0a 0a20 2020 2020 2020       };..       
-00006520: 206c 6574 2066 7320 3d20 756e 695f 662e   let fs = uni_f.
-00006530: 6661 6374 6f72 5f64 6973 7469 6e63 745f  factor_distinct_
-00006540: 6571 7561 6c5f 6465 6772 6565 2829 3b0a  equal_degree();.
-00006550: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-00006560: 206c 636f 6566 6620 3d20 7368 6966 7465   lcoeff = shifte
-00006570: 645f 706f 6c79 2e6c 636f 6566 665f 6c61  d_poly.lcoeff_la
-00006580: 7374 5f76 6172 6f72 6465 7228 265b 6d61  st_varorder(&[ma
-00006590: 696e 5f76 6172 2c20 696e 7465 7270 6f6c  in_var, interpol
-000065a0: 6174 696f 6e5f 7661 725d 293b 0a20 2020  ation_var]);.   
-000065b0: 2020 2020 206c 6574 206d 7574 206c 635f       let mut lc_
-000065c0: 6420 3d20 6c63 6f65 6666 2e64 6567 7265  d = lcoeff.degre
-000065d0: 6528 696e 7465 7270 6f6c 6174 696f 6e5f  e(interpolation_
-000065e0: 7661 7229 2e74 6f5f 7533 3228 293b 0a0a  var).to_u32();..
-000065f0: 2020 2020 2020 2020 6c65 7420 6974 6572          let iter
-00006600: 203d 2028 6420 2b20 6c63 5f64 202b 2031   = (d + lc_d + 1
-00006610: 2920 6173 2075 7369 7a65 3b0a 2020 2020  ) as usize;.    
-00006620: 2020 2020 6c65 7420 6d75 7420 6661 6374      let mut fact
-00006630: 6f72 7320 3d0a 2020 2020 2020 2020 2020  ors =.          
-00006640: 2020 7368 6966 7465 645f 706f 6c79 2e62    shifted_poly.b
-00006650: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
-00006660: 6c69 6674 5f62 6572 6e61 7264 696e 2869  lift_bernardin(i
-00006670: 6e74 6572 706f 6c61 7469 6f6e 5f76 6172  nterpolation_var
-00006680: 2c20 266c 636f 6566 662c 2026 6673 2c20  , &lcoeff, &fs, 
-00006690: 6974 6572 293b 0a0a 2020 2020 2020 2020  iter);..        
-000066a0: 6661 6374 6f72 732e 7377 6170 5f72 656d  factors.swap_rem
-000066b0: 6f76 6528 3029 3b20 2f2f 2072 656d 6f76  ove(0); // remov
-000066c0: 6520 7468 6520 6c63 6f65 6666 0a0a 2020  e the lcoeff..  
-000066d0: 2020 2020 2020 6c65 7420 6d75 7420 7265        let mut re
-000066e0: 635f 6661 6374 6f72 7320 3d20 7665 6321  c_factors = vec!
-000066f0: 5b5d 3b0a 2020 2020 2020 2020 2f2f 2066  [];.        // f
-00006700: 6163 746f 7220 7265 636f 6d62 696e 6174  actor recombinat
-00006710: 696f 6e0a 2020 2020 2020 2020 6c65 7420  ion.        let 
-00006720: 6d75 7420 7320 3d20 313b 0a0a 2020 2020  mut s = 1;..    
-00006730: 2020 2020 6c65 7420 6d75 7420 7265 7374      let mut rest
-00006740: 203d 2073 6869 6674 6564 5f70 6f6c 793b   = shifted_poly;
-00006750: 0a20 2020 2020 2020 2027 6c65 6e3a 2077  .        'len: w
-00006760: 6869 6c65 2032 202a 2073 203c 3d20 6661  hile 2 * s <= fa
-00006770: 6374 6f72 732e 6c65 6e28 2920 7b0a 2020  ctors.len() {.  
-00006780: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
-00006790: 7420 6673 203d 2043 6f6d 6269 6e61 7469  t fs = Combinati
-000067a0: 6f6e 4974 6572 6174 6f72 3a3a 6e65 7728  onIterator::new(
-000067b0: 6661 6374 6f72 732e 6c65 6e28 292c 2073  factors.len(), s
-000067c0: 293b 0a20 2020 2020 2020 2020 2020 2077  );.            w
-000067d0: 6869 6c65 206c 6574 2053 6f6d 6528 6373  hile let Some(cs
-000067e0: 2920 3d20 6673 2e6e 6578 7428 2920 7b0a  ) = fs.next() {.
-000067f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006800: 2f2f 2054 4f44 4f3a 206d 756c 7469 706c  // TODO: multipl
-00006810: 7920 696e 2074 6865 206c 6561 6469 6e67  y in the leading
-00006820: 2063 6f65 6666 6963 6965 6e74 2068 6572   coefficient her
-00006830: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00006840: 2020 202f 2f20 7468 656e 2077 6520 6361     // then we ca
-00006850: 6e20 736b 6970 2074 6865 2050 6164 6520  n skip the Pade 
-00006860: 6170 7072 6f78 696d 6174 696f 6e20 616e  approximation an
-00006870: 6420 7265 6475 6365 2074 6865 0a20 2020  d reduce the.   
-00006880: 2020 2020 2020 2020 2020 2020 202f 2f20               // 
-00006890: 6e75 6d62 6572 206f 6620 6974 6572 6174  number of iterat
-000068a0: 696f 6e73 2069 6e20 7468 6520 4865 6e73  ions in the Hens
-000068b0: 656c 206c 6966 7469 6e67 2074 6f20 6420  el lifting to d 
-000068c0: 2b20 312c 206c 696b 6520 696e 2074 6865  + 1, like in the
-000068d0: 2069 6e74 6567 6572 2063 6173 653f 0a20   integer case?. 
-000068e0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000068f0: 6574 206d 7574 2067 203d 2072 6573 742e  et mut g = rest.
-00006900: 636f 6e73 7461 6e74 2872 6573 742e 6c63  constant(rest.lc
-00006910: 6f65 6666 2829 293b 0a20 2020 2020 2020  oeff());.       
-00006920: 2020 2020 2020 2020 2066 6f72 2028 692c           for (i,
-00006930: 2066 2920 696e 2066 6163 746f 7273 2e69   f) in factors.i
-00006940: 7465 7228 292e 656e 756d 6572 6174 6528  ter().enumerate(
-00006950: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00006960: 2020 2020 2020 2020 6966 2063 732e 636f          if cs.co
-00006970: 6e74 6169 6e73 2826 6929 207b 0a20 2020  ntains(&i) {.   
-00006980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006990: 2020 2020 2067 203d 2028 2667 202a 2066       g = (&g * f
-000069a0: 292e 6d6f 645f 7661 7228 696e 7465 7270  ).mod_var(interp
-000069b0: 6f6c 6174 696f 6e5f 7661 722c 2045 3a3a  olation_var, E::
-000069c0: 6672 6f6d 5f75 3332 2869 7465 7220 6173  from_u32(iter as
-000069d0: 2075 3332 202b 2031 2929 3b0a 2020 2020   u32 + 1));.    
-000069e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000069f0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-00006a00: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00006a10: 2020 2020 206c 6574 2079 5f70 6f6c 7973       let y_polys
-00006a20: 3a20 5665 633c 5f3e 203d 2067 0a20 2020  : Vec<_> = g.   
-00006a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006a40: 202e 746f 5f75 6e69 7661 7269 6174 655f   .to_univariate_
-00006a50: 706f 6c79 6e6f 6d69 616c 5f6c 6973 7428  polynomial_list(
-00006a60: 6d61 696e 5f76 6172 290a 2020 2020 2020  main_var).      
-00006a70: 2020 2020 2020 2020 2020 2020 2020 2e69                .i
-00006a80: 6e74 6f5f 6974 6572 2829 0a20 2020 2020  nto_iter().     
-00006a90: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00006aa0: 6d61 7028 7c28 782c 205f 297c 2078 290a  map(|(x, _)| x).
-00006ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ac0: 2020 2020 2e63 6f6c 6c65 6374 2829 3b0a      .collect();.
-00006ad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006ae0: 206c 6574 206d 7574 2067 5f6c 636f 6566   let mut g_lcoef
-00006af0: 6620 3d20 5365 6c66 3a3a 6c63 6f65 6666  f = Self::lcoeff
-00006b00: 5f72 6563 6f6e 7374 7275 6374 2826 795f  _reconstruct(&y_
-00006b10: 706f 6c79 732c 2064 2c20 6c63 5f64 293b  polys, d, lc_d);
-00006b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006b30: 2067 203d 2028 2667 202a 2026 675f 6c63   g = (&g * &g_lc
-00006b40: 6f65 6666 290a 2020 2020 2020 2020 2020  oeff).          
-00006b50: 2020 2020 2020 2020 2020 2e6d 6f64 5f76            .mod_v
-00006b60: 6172 2869 6e74 6572 706f 6c61 7469 6f6e  ar(interpolation
-00006b70: 5f76 6172 2c20 453a 3a66 726f 6d5f 7533  _var, E::from_u3
-00006b80: 3228 6420 2b20 3129 290a 2020 2020 2020  2(d + 1)).      
-00006b90: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
-00006ba0: 616b 655f 6d6f 6e69 6328 293b 0a0a 2020  ake_monic();..  
-00006bb0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00006bc0: 7420 2868 2c20 7229 203d 2072 6573 742e  t (h, r) = rest.
-00006bd0: 7175 6f74 5f72 656d 2826 672c 2074 7275  quot_rem(&g, tru
-00006be0: 6529 3b0a 0a20 2020 2020 2020 2020 2020  e);..           
-00006bf0: 2020 2020 2069 6620 722e 6973 5f7a 6572       if r.is_zer
-00006c00: 6f28 2920 7b0a 2020 2020 2020 2020 2020  o() {.          
-00006c10: 2020 2020 2020 2020 2020 7265 635f 6661            rec_fa
-00006c20: 6374 6f72 732e 7075 7368 2867 293b 0a0a  ctors.push(g);..
-00006c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c40: 2020 2020 666f 7220 6920 696e 2063 732e      for i in cs.
-00006c50: 6974 6572 2829 2e72 6576 2829 207b 0a20  iter().rev() {. 
-00006c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c70: 2020 2020 2020 2066 6163 746f 7273 2e72         factors.r
-00006c80: 656d 6f76 6528 2a69 293b 0a20 2020 2020  emove(*i);.     
-00006c90: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00006ca0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006cb0: 2020 2020 2020 7265 7374 203d 2068 3b0a        rest = h;.
-00006cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006cd0: 2020 2020 6c63 6f65 6666 203d 206c 636f      lcoeff = lco
-00006ce0: 6566 662e 7175 6f74 5f72 656d 5f75 6e69  eff.quot_rem_uni
-00006cf0: 7661 7269 6174 6528 266d 7574 2067 5f6c  variate(&mut g_l
-00006d00: 636f 6566 6629 2e30 3b0a 2020 2020 2020  coeff).0;.      
-00006d10: 2020 2020 2020 2020 2020 2020 2020 6c63                lc
-00006d20: 5f64 203d 206c 636f 6566 662e 6465 6772  _d = lcoeff.degr
-00006d30: 6565 2869 6e74 6572 706f 6c61 7469 6f6e  ee(interpolation
-00006d40: 5f76 6172 292e 746f 5f75 3332 2829 3b0a  _var).to_u32();.
-00006d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006d60: 2020 2020 6420 3d20 7265 7374 2e64 6567      d = rest.deg
-00006d70: 7265 6528 696e 7465 7270 6f6c 6174 696f  ree(interpolatio
-00006d80: 6e5f 7661 7229 2e74 6f5f 7533 3228 293b  n_var).to_u32();
-00006d90: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006da0: 2020 2020 2020 636f 6e74 696e 7565 2027        continue '
-00006db0: 6c65 6e3b 0a20 2020 2020 2020 2020 2020  len;.           
-00006dc0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-00006dd0: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00006de0: 2020 7320 2b3d 2031 3b0a 2020 2020 2020    s += 1;.      
-00006df0: 2020 7d0a 0a20 2020 2020 2020 2072 6563    }..        rec
-00006e00: 5f66 6163 746f 7273 2e70 7573 6828 7265  _factors.push(re
-00006e10: 7374 293b 0a0a 2020 2020 2020 2020 6966  st);..        if
-00006e20: 2021 4669 6e69 7465 4669 656c 643a 3a3c   !FiniteField::<
-00006e30: 5546 6965 6c64 3e3a 3a69 735f 7a65 726f  UField>::is_zero
-00006e40: 2826 7361 6d70 6c65 5f70 6f69 6e74 2920  (&sample_point) 
-00006e50: 7b0a 2020 2020 2020 2020 2020 2020 666f  {.            fo
-00006e60: 7220 7820 696e 2026 6d75 7420 7265 635f  r x in &mut rec_
-00006e70: 6661 6374 6f72 7320 7b0a 2020 2020 2020  factors {.      
-00006e80: 2020 2020 2020 2020 2020 2f2f 2073 6869            // shi
-00006e90: 6674 2074 6865 2070 6f6c 796e 6f6d 6961  ft the polynomia
-00006ea0: 6c20 746f 2079 202d 2073 616d 706c 650a  l to y - sample.
-00006eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ec0: 2a78 203d 2078 2e73 6869 6674 5f76 6172  *x = x.shift_var
-00006ed0: 5f63 6163 6865 6428 696e 7465 7270 6f6c  _cached(interpol
-00006ee0: 6174 696f 6e5f 7661 722c 2026 7365 6c66  ation_var, &self
-00006ef0: 2e66 6965 6c64 2e6e 6567 2826 7361 6d70  .field.neg(&samp
-00006f00: 6c65 5f70 6f69 6e74 2929 3b0a 2020 2020  le_point));.    
-00006f10: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00006f20: 2020 7d0a 0a20 2020 2020 2020 2072 6563    }..        rec
-00006f30: 5f66 6163 746f 7273 0a20 2020 207d 0a0a  _factors.    }..
-00006f40: 2020 2020 2f2f 2f20 5265 636f 6e73 7472      /// Reconstr
-00006f50: 7563 7420 7468 6520 6c65 6164 696e 6720  uct the leading 
-00006f60: 636f 6566 6669 6369 656e 7420 7573 696e  coefficient usin
-00006f70: 6720 6120 5061 6465 2061 7070 726f 7869  g a Pade approxi
-00006f80: 6d61 7469 6f6e 2077 6974 6820 6e75 6d65  mation with nume
-00006f90: 7261 746f 7220 6465 6772 6565 2060 6465  rator degree `de
-00006fa0: 675f 6e60 2061 6e64 0a20 2020 202f 2f2f  g_n` and.    ///
-00006fb0: 2064 656e 6f6d 696e 6174 6f72 2064 6567   denominator deg
-00006fc0: 7265 6520 6064 6567 5f64 602e 2054 6865  ree `deg_d`. The
-00006fd0: 2072 6573 756c 7469 6e67 2064 656e 6f6d   resulting denom
-00006fe0: 696e 6174 6f72 2073 686f 756c 6420 6265  inator should be
-00006ff0: 2061 2066 6163 746f 7220 6f66 2074 6865   a factor of the
-00007000: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
-00007010: 6965 6e74 2e0a 2020 2020 666e 206c 636f  ient..    fn lco
-00007020: 6566 665f 7265 636f 6e73 7472 7563 7428  eff_reconstruct(
-00007030: 636f 6566 6673 3a20 265b 5365 6c66 5d2c  coeffs: &[Self],
-00007040: 2064 6567 5f6e 3a20 7533 322c 2064 6567   deg_n: u32, deg
-00007050: 5f64 3a20 7533 3229 202d 3e20 5365 6c66  _d: u32) -> Self
-00007060: 207b 0a20 2020 2020 2020 206c 6574 206d   {.        let m
-00007070: 7574 206c 636f 6566 6620 3d20 636f 6566  ut lcoeff = coef
-00007080: 6673 5b30 5d2e 636f 6e73 7461 6e74 2863  fs[0].constant(c
-00007090: 6f65 6666 735b 305d 2e66 6965 6c64 2e6f  oeffs[0].field.o
-000070a0: 6e65 2829 293b 0a20 2020 2020 2020 2066  ne());.        f
-000070b0: 6f72 2078 2069 6e20 636f 6566 6673 207b  or x in coeffs {
-000070c0: 0a20 2020 2020 2020 2020 2020 206c 6574  .            let
-000070d0: 2064 203d 2078 2e72 6174 696f 6e61 6c5f   d = x.rational_
-000070e0: 6170 7072 6f78 696d 616e 745f 756e 6976  approximant_univ
-000070f0: 6172 6961 7465 2864 6567 5f6e 2c20 6465  ariate(deg_n, de
-00007100: 675f 6429 2e75 6e77 7261 7028 292e 313b  g_d).unwrap().1;
-00007110: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00007120: 2164 2e69 735f 6f6e 6528 2920 7b0a 2020  !d.is_one() {.  
-00007130: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00007140: 7420 6720 3d20 642e 6763 6428 266c 636f  t g = d.gcd(&lco
-00007150: 6566 6629 3b0a 2020 2020 2020 2020 2020  eff);.          
-00007160: 2020 2020 2020 6c63 6f65 6666 203d 206c        lcoeff = l
-00007170: 636f 6566 6620 2a20 2628 6420 2f20 2667  coeff * &(d / &g
-00007180: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
-00007190: 0a20 2020 2020 2020 207d 0a20 2020 2020  .        }.     
-000071a0: 2020 206c 636f 6566 660a 2020 2020 7d0a     lcoeff.    }.
-000071b0: 0a20 2020 202f 2f2f 2053 6f72 7420 7468  .    /// Sort th
-000071c0: 6520 6269 7661 7269 6174 6520 6661 6374  e bivariate fact
-000071d0: 6f72 7320 6261 7365 6420 6f6e 2074 6865  ors based on the
-000071e0: 6972 2075 6e69 7661 7269 6174 6520 696d  ir univariate im
-000071f0: 6167 6520 736f 2074 6861 7420 7468 6579  age so that they
-00007200: 2061 7265 0a20 2020 202f 2f2f 2061 6c69   are.    /// ali
-00007210: 676e 6564 2062 6574 7765 656e 2074 6865  gned between the
-00007220: 2064 6966 6665 7265 6e74 2076 6172 732e   different vars.
-00007230: 0a20 2020 2066 6e20 6361 6e6f 6e69 6361  .    fn canonica
-00007240: 6c5f 736f 7274 280a 2020 2020 2020 2020  l_sort(.        
-00007250: 6269 765f 706f 6c79 733a 2026 5b53 656c  biv_polys: &[Sel
-00007260: 665d 2c0a 2020 2020 2020 2020 7265 706c  f],.        repl
-00007270: 6163 655f 7661 723a 2075 7369 7a65 2c0a  ace_var: usize,.
-00007280: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
-00007290: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
-000072a0: 203c 4669 6e69 7465 4669 656c 643c 5546   <FiniteField<UF
-000072b0: 6965 6c64 3e20 6173 2052 696e 673e 3a3a  ield> as Ring>::
-000072c0: 456c 656d 656e 7429 5d2c 0a20 2020 2029  Element)],.    )
-000072d0: 202d 3e20 5665 633c 2853 656c 662c 203c   -> Vec<(Self, <
-000072e0: 4669 6e69 7465 4669 656c 643c 5546 6965  FiniteField<UFie
-000072f0: 6c64 3e20 6173 2052 696e 673e 3a3a 456c  ld> as Ring>::El
-00007300: 656d 656e 742c 2053 656c 6629 3e20 7b0a  ement, Self)> {.
-00007310: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-00007320: 756e 6976 6172 6961 7465 5f66 6163 746f  univariate_facto
-00007330: 7273 203d 2062 6976 5f70 6f6c 7973 0a20  rs = biv_polys. 
-00007340: 2020 2020 2020 2020 2020 202e 6974 6572             .iter
-00007350: 2829 0a20 2020 2020 2020 2020 2020 202e  ().            .
-00007360: 6d61 7028 7c66 7c20 7b0a 2020 2020 2020  map(|f| {.      
-00007370: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
-00007380: 7420 7520 3d20 662e 636c 6f6e 6528 293b  t u = f.clone();
-00007390: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000073a0: 2066 6f72 2028 762c 2070 2920 696e 2073   for (v, p) in s
-000073b0: 616d 706c 655f 706f 696e 7473 207b 0a20  ample_points {. 
-000073c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000073d0: 2020 2069 6620 2a76 203d 3d20 7265 706c     if *v == repl
-000073e0: 6163 655f 7661 7220 7b0a 2020 2020 2020  ace_var {.      
-000073f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007400: 2020 7520 3d20 752e 7265 706c 6163 6528    u = u.replace(
-00007410: 2a76 2c20 7029 3b0a 2020 2020 2020 2020  *v, p);.        
-00007420: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00007430: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-00007440: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007450: 2028 662e 636c 6f6e 6528 292c 2075 2e6c   (f.clone(), u.l
-00007460: 636f 6566 6628 292c 2075 2e6d 616b 655f  coeff(), u.make_
-00007470: 6d6f 6e69 6328 2929 0a20 2020 2020 2020  monic()).       
-00007480: 2020 2020 207d 290a 2020 2020 2020 2020       }).        
-00007490: 2020 2020 2e63 6f6c 6c65 6374 3a3a 3c56      .collect::<V
-000074a0: 6563 3c5f 3e3e 2829 3b0a 2020 2020 2020  ec<_>>();.      
-000074b0: 2020 756e 6976 6172 6961 7465 5f66 6163    univariate_fac
-000074c0: 746f 7273 2e73 6f72 745f 6279 287c 285f  tors.sort_by(|(_
-000074d0: 2c20 5f2c 2061 292c 2028 5f2c 205f 2c20  , _, a), (_, _, 
-000074e0: 6229 7c20 7b0a 2020 2020 2020 2020 2020  b)| {.          
-000074f0: 2020 612e 6578 706f 6e65 6e74 730a 2020    a.exponents.  
-00007500: 2020 2020 2020 2020 2020 2020 2020 2e63                .c
-00007510: 6d70 2826 622e 6578 706f 6e65 6e74 7329  mp(&b.exponents)
-00007520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007530: 202e 7468 656e 2861 2e63 6f65 6666 6963   .then(a.coeffic
-00007540: 6965 6e74 732e 7061 7274 6961 6c5f 636d  ients.partial_cm
-00007550: 7028 2662 2e63 6f65 6666 6963 6965 6e74  p(&b.coefficient
-00007560: 7329 2e75 6e77 7261 7028 2929 0a20 2020  s).unwrap()).   
-00007570: 2020 2020 207d 293b 0a0a 2020 2020 2020       });..      
-00007580: 2020 756e 6976 6172 6961 7465 5f66 6163    univariate_fac
-00007590: 746f 7273 0a20 2020 207d 0a0a 2020 2020  tors.    }..    
-000075a0: 2f2f 2f20 5072 6563 6f6d 7075 7465 2074  /// Precompute t
-000075b0: 6865 206c 6561 6469 6e67 2063 6f65 6666  he leading coeff
-000075c0: 6963 6965 6e74 7320 6f66 2074 6865 2070  icients of the p
-000075d0: 6f6c 796e 6f6d 6961 6c20 6661 6374 6f72  olynomial factor
-000075e0: 732c 2075 7369 6e67 2061 6e0a 2020 2020  s, using an.    
-000075f0: 2f2f 2f20 6164 6170 7465 6420 7665 7273  /// adapted vers
-00007600: 696f 6e20 6f66 204b 616c 746f 6665 6e27  ion of Kaltofen'
-00007610: 7320 616c 676f 7269 7468 6d20 7468 6174  s algorithm that
-00007620: 2068 6173 206d 6f64 6966 6963 6174 696f   has modificatio
-00007630: 6e73 206f 6620 4d61 7274 696e 204c 6565  ns of Martin Lee
-00007640: 2061 6e64 2053 7461 6e69 736c 6176 2050   and Stanislav P
-00007650: 6f73 6c61 7673 6b79 2e0a 2020 2020 666e  oslavsky..    fn
-00007660: 206c 636f 6566 665f 7072 6563 6f6d 7075   lcoeff_precompu
-00007670: 7461 7469 6f6e 280a 2020 2020 2020 2020  tation(.        
-00007680: 2673 656c 662c 0a20 2020 2020 2020 2062  &self,.        b
-00007690: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-000076a0: 3a20 265b 5365 6c66 5d2c 0a20 2020 2020  : &[Self],.     
-000076b0: 2020 2073 616d 706c 655f 706f 696e 7473     sample_points
-000076c0: 3a20 265b 2875 7369 7a65 2c20 3c46 696e  : &[(usize, <Fin
-000076d0: 6974 6546 6965 6c64 3c55 4669 656c 643e  iteField<UField>
-000076e0: 2061 7320 5269 6e67 3e3a 3a45 6c65 6d65   as Ring>::Eleme
-000076f0: 6e74 295d 2c0a 2020 2020 2020 2020 6f72  nt)],.        or
-00007700: 6465 723a 2026 5b75 7369 7a65 5d2c 0a20  der: &[usize],. 
-00007710: 2020 2029 202d 3e20 5265 7375 6c74 3c28     ) -> Result<(
-00007720: 5665 633c 5365 6c66 3e2c 2056 6563 3c53  Vec<Self>, Vec<S
-00007730: 656c 663e 292c 2075 7369 7a65 3e20 7b0a  elf>), usize> {.
-00007740: 2020 2020 2020 2020 6c65 7420 6c63 6f65          let lcoe
-00007750: 6666 203d 2073 656c 662e 756e 6976 6172  ff = self.univar
-00007760: 6961 7465 5f6c 636f 6566 6628 6f72 6465  iate_lcoeff(orde
-00007770: 725b 305d 293b 0a20 2020 2020 2020 206c  r[0]);.        l
-00007780: 6574 2073 7166 203d 206c 636f 6566 662e  et sqf = lcoeff.
-00007790: 7371 7561 7265 5f66 7265 655f 6661 6374  square_free_fact
-000077a0: 6f72 697a 6174 696f 6e28 293b 0a0a 2020  orization();..  
-000077b0: 2020 2020 2020 6c65 7420 6d75 7420 6c63        let mut lc
-000077c0: 6f65 6666 5f73 7175 6172 655f 6672 6565  oeff_square_free
-000077d0: 203d 2073 656c 662e 6f6e 6528 293b 0a20   = self.one();. 
-000077e0: 2020 2020 2020 2066 6f72 2028 662c 205f         for (f, _
-000077f0: 2920 696e 2026 7371 6620 7b0a 2020 2020  ) in &sqf {.    
-00007800: 2020 2020 2020 2020 6c63 6f65 6666 5f73          lcoeff_s
-00007810: 7175 6172 655f 6672 6565 203d 206c 636f  quare_free = lco
-00007820: 6566 665f 7371 7561 7265 5f66 7265 6520  eff_square_free 
-00007830: 2a20 663b 0a20 2020 2020 2020 207d 0a0a  * f;.        }..
-00007840: 2020 2020 2020 2020 6c65 7420 736f 7274          let sort
-00007850: 6564 5f6d 6169 6e5f 6661 6374 6f72 7320  ed_main_factors 
-00007860: 3d20 5365 6c66 3a3a 6361 6e6f 6e69 6361  = Self::canonica
-00007870: 6c5f 736f 7274 2862 6976 6172 6961 7465  l_sort(bivariate
-00007880: 5f66 6163 746f 7273 2c20 6f72 6465 725b  _factors, order[
-00007890: 315d 2c20 7361 6d70 6c65 5f70 6f69 6e74  1], sample_point
-000078a0: 7329 3b0a 0a20 2020 2020 2020 206c 6574  s);..        let
-000078b0: 206d 7574 2074 7275 655f 6c63 6f65 6666   mut true_lcoeff
-000078c0: 733a 2056 6563 3c5f 3e20 3d20 736f 7274  s: Vec<_> = sort
-000078d0: 6564 5f6d 6169 6e5f 6661 6374 6f72 730a  ed_main_factors.
-000078e0: 2020 2020 2020 2020 2020 2020 2e69 7465              .ite
-000078f0: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-00007900: 2e6d 6170 287c 285f 2c20 752c 205f 297c  .map(|(_, u, _)|
-00007910: 2073 656c 662e 636f 6e73 7461 6e74 2875   self.constant(u
-00007920: 2e63 6c6f 6e65 2829 2929 0a20 2020 2020  .clone())).     
-00007930: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
-00007940: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
-00007950: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
-00007960: 6163 746f 7273 3a20 5665 633c 5f3e 203d  actors: Vec<_> =
-00007970: 0a20 2020 2020 2020 2020 2020 2073 6f72  .            sor
-00007980: 7465 645f 6d61 696e 5f66 6163 746f 7273  ted_main_factors
-00007990: 2e69 6e74 6f5f 6974 6572 2829 2e6d 6170  .into_iter().map
-000079a0: 287c 2866 2c20 5f2c 205f 297c 2066 292e  (|(f, _, _)| f).
-000079b0: 636f 6c6c 6563 7428 293b 0a0a 2020 2020  collect();..    
-000079c0: 2020 2020 6c65 7420 6d75 7420 6c63 6f65      let mut lcoe
-000079d0: 6666 5f6c 6566 7420 3d20 6c63 6f65 6666  ff_left = lcoeff
-000079e0: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
-000079f0: 2020 666f 7220 6620 696e 2026 7472 7565    for f in &true
-00007a00: 5f6c 636f 6566 6673 207b 0a20 2020 2020  _lcoeffs {.     
-00007a10: 2020 2020 2020 206c 636f 6566 665f 6c65         lcoeff_le
-00007a20: 6674 203d 206c 636f 6566 665f 6c65 6674  ft = lcoeff_left
-00007a30: 202f 2066 3b0a 2020 2020 2020 2020 7d0a   / f;.        }.
-00007a40: 0a20 2020 2020 2020 202f 2f20 544f 444f  .        // TODO
-00007a50: 3a20 736d 6172 7465 7220 6f72 6465 7269  : smarter orderi
-00007a60: 6e67 0a20 2020 2020 2020 2066 6f72 2028  ng.        for (
-00007a70: 692c 2026 7661 7229 2069 6e20 6f72 6465  i, &var) in orde
-00007a80: 725b 312e 2e5d 2e69 7465 7228 292e 656e  r[1..].iter().en
-00007a90: 756d 6572 6174 6528 2920 7b0a 2020 2020  umerate() {.    
-00007aa0: 2020 2020 2020 2020 6966 206c 636f 6566          if lcoef
-00007ab0: 665f 6c65 6674 2e69 735f 6f6e 6528 2920  f_left.is_one() 
-00007ac0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00007ad0: 2020 6272 6561 6b3b 0a20 2020 2020 2020    break;.       
-00007ae0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-00007af0: 2020 2020 6966 206c 636f 6566 665f 6c65      if lcoeff_le
-00007b00: 6674 2e64 6567 7265 6528 7661 7229 2e69  ft.degree(var).i
-00007b10: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
-00007b20: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00007b30: 6e75 653b 0a20 2020 2020 2020 2020 2020  nue;.           
-00007b40: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
-00007b50: 2f2f 206f 6e6c 7920 636f 6e73 7472 7563  // only construc
-00007b60: 7420 6661 6374 6f72 7320 7468 6174 2064  t factors that d
-00007b70: 6570 656e 6420 6f6e 2076 6172 0a20 2020  epend on var.   
-00007b80: 2020 2020 2020 2020 206c 6574 2063 203d           let c =
-00007b90: 206c 636f 6566 665f 7371 7561 7265 5f66   lcoeff_square_f
-00007ba0: 7265 652e 756e 6976 6172 6961 7465 5f63  ree.univariate_c
-00007bb0: 6f6e 7465 6e74 2876 6172 293b 0a20 2020  ontent(var);.   
-00007bc0: 2020 2020 2020 2020 202f 2f20 6d61 6b65           // make
-00007bd0: 2073 7572 6520 7468 6174 2074 6865 2063   sure that the c
-00007be0: 6f6e 7465 6e74 2072 656d 6f76 616c 2064  ontent removal d
-00007bf0: 6f65 7320 6e6f 7420 6368 616e 6765 2074  oes not change t
-00007c00: 6865 2075 6e69 740a 2020 2020 2020 2020  he unit.        
-00007c10: 2020 2020 6c65 7420 6d75 7420 635f 6576      let mut c_ev
-00007c20: 616c 203d 2063 2e63 6c6f 6e65 2829 3b0a  al = c.clone();.
-00007c30: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00007c40: 2876 2c20 7029 2069 6e20 7361 6d70 6c65  (v, p) in sample
-00007c50: 5f70 6f69 6e74 7320 7b0a 2020 2020 2020  _points {.      
-00007c60: 2020 2020 2020 2020 2020 635f 6576 616c            c_eval
-00007c70: 203d 2063 5f65 7661 6c2e 7265 706c 6163   = c_eval.replac
-00007c80: 6528 2a76 2c20 7029 3b0a 2020 2020 2020  e(*v, p);.      
-00007c90: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00007ca0: 2020 2020 206c 6574 206c 636f 6566 665f       let lcoeff_
-00007cb0: 7371 7561 7265 5f66 7265 655f 7070 203d  square_free_pp =
-00007cc0: 2026 6c63 6f65 6666 5f73 7175 6172 655f   &lcoeff_square_
-00007cd0: 6672 6565 202f 2026 6320 2a20 2663 5f65  free / &c * &c_e
-00007ce0: 7661 6c3b 0a20 2020 2020 2020 2020 2020  val;.           
-00007cf0: 2064 6562 7567 2128 2243 6f6e 7465 6e74   debug!("Content
-00007d00: 2d66 7265 6520 6c63 7371 6620 7b7d 222c  -free lcsqf {}",
-00007d10: 206c 636f 6566 665f 7371 7561 7265 5f66   lcoeff_square_f
-00007d20: 7265 655f 7070 293b 0a0a 2020 2020 2020  ree_pp);..      
-00007d30: 2020 2020 2020 2f2f 2063 6865 636b 2069        // check i
-00007d40: 6620 7468 6520 6576 616c 7561 7465 6420  f the evaluated 
-00007d50: 6c65 6164 696e 6720 636f 6566 6669 6369  leading coeffici
-00007d60: 656e 7420 7265 6d61 696e 7320 7371 7561  ent remains squa
-00007d70: 7265 2066 7265 650a 2020 2020 2020 2020  re free.        
-00007d80: 2020 2020 6c65 7420 6d75 7420 706f 6c79      let mut poly
-00007d90: 5f65 7661 6c20 3d20 6c63 6f65 6666 5f73  _eval = lcoeff_s
-00007da0: 7175 6172 655f 6672 6565 5f70 702e 636c  quare_free_pp.cl
-00007db0: 6f6e 6528 293b 0a20 2020 2020 2020 2020  one();.         
-00007dc0: 2020 2066 6f72 2028 762c 2070 2920 696e     for (v, p) in
-00007dd0: 2073 616d 706c 655f 706f 696e 7473 207b   sample_points {
-00007de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007df0: 2069 6620 2a76 2021 3d20 7661 7220 7b0a   if *v != var {.
-00007e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007e10: 2020 2020 706f 6c79 5f65 7661 6c20 3d20      poly_eval = 
-00007e20: 706f 6c79 5f65 7661 6c2e 7265 706c 6163  poly_eval.replac
-00007e30: 6528 2a76 2c20 7029 3b0a 2020 2020 2020  e(*v, p);.      
-00007e40: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00007e50: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00007e60: 2020 2020 2020 6c65 7420 7371 6620 3d20        let sqf = 
-00007e70: 706f 6c79 5f65 7661 6c2e 7371 7561 7265  poly_eval.square
-00007e80: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
-00007e90: 696f 6e28 293b 0a20 2020 2020 2020 2020  ion();.         
-00007ea0: 2020 2069 6620 7371 662e 6c65 6e28 2920     if sqf.len() 
-00007eb0: 213d 2031 207c 7c20 7371 665b 305d 2e31  != 1 || sqf[0].1
-00007ec0: 2021 3d20 3120 7b0a 2020 2020 2020 2020   != 1 {.        
-00007ed0: 2020 2020 2020 2020 6465 6275 6721 2822          debug!("
-00007ee0: 506f 6c79 6e6f 6d69 616c 2069 7320 6e6f  Polynomial is no
-00007ef0: 7420 7371 7561 7265 2066 7265 653a 207b  t square free: {
-00007f00: 7d22 2c20 706f 6c79 5f65 7661 6c29 3b0a  }", poly_eval);.
-00007f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f20: 7265 7475 726e 2045 7272 286d 6169 6e5f  return Err(main_
-00007f30: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00007f40: 732e 6c65 6e28 2929 3b0a 2020 2020 2020  s.len());.      
-00007f50: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00007f60: 2020 2020 206c 6574 2062 6976 6172 6961       let bivaria
-00007f70: 7465 5f66 6163 746f 7273 203d 2069 6620  te_factors = if 
-00007f80: 7661 7220 3d3d 206f 7264 6572 5b31 5d20  var == order[1] 
-00007f90: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00007fa0: 2020 6d61 696e 5f62 6976 6172 6961 7465    main_bivariate
-00007fb0: 5f66 6163 746f 7273 2e74 6f5f 7665 6328  _factors.to_vec(
-00007fc0: 290a 2020 2020 2020 2020 2020 2020 7d20  ).            } 
-00007fd0: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
-00007fe0: 2020 2020 2020 206c 6574 206d 7574 2070         let mut p
-00007ff0: 6f6c 795f 6576 616c 203d 2073 656c 662e  oly_eval = self.
-00008000: 636c 6f6e 6528 293b 0a20 2020 2020 2020  clone();.       
-00008010: 2020 2020 2020 2020 2066 6f72 2028 762c           for (v,
-00008020: 2070 2920 696e 2073 616d 706c 655f 706f   p) in sample_po
-00008030: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
-00008040: 2020 2020 2020 2020 2020 2069 6620 2a76             if *v
-00008050: 2021 3d20 7661 7220 7b0a 2020 2020 2020   != var {.      
-00008060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008070: 2020 706f 6c79 5f65 7661 6c20 3d20 706f    poly_eval = po
-00008080: 6c79 5f65 7661 6c2e 7265 706c 6163 6528  ly_eval.replace(
-00008090: 2a76 2c20 7029 3b0a 2020 2020 2020 2020  *v, p);.        
-000080a0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-000080b0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-000080c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000080d0: 2069 6620 706f 6c79 5f65 7661 6c2e 6465   if poly_eval.de
-000080e0: 6772 6565 286f 7264 6572 5b30 5d29 2021  gree(order[0]) !
-000080f0: 3d20 7365 6c66 2e64 6567 7265 6528 6f72  = self.degree(or
-00008100: 6465 725b 305d 290a 2020 2020 2020 2020  der[0]).        
-00008110: 2020 2020 2020 2020 2020 2020 7c7c 2070              || p
-00008120: 6f6c 795f 6576 616c 2e64 6567 7265 6528  oly_eval.degree(
-00008130: 7661 7229 2021 3d20 7365 6c66 2e64 6567  var) != self.deg
-00008140: 7265 6528 7661 7229 0a20 2020 2020 2020  ree(var).       
-00008150: 2020 2020 2020 2020 2020 2020 207c 7c20               || 
-00008160: 706f 6c79 5f65 7661 6c2e 756e 6976 6172  poly_eval.univar
-00008170: 6961 7465 5f6c 636f 6566 6628 6f72 6465  iate_lcoeff(orde
-00008180: 725b 305d 292e 6465 6772 6565 2876 6172  r[0]).degree(var
-00008190: 2920 213d 206c 636f 6566 662e 6465 6772  ) != lcoeff.degr
-000081a0: 6565 2876 6172 290a 2020 2020 2020 2020  ee(var).        
-000081b0: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
-000081c0: 2020 2020 2020 2020 2020 2020 2020 6465                de
-000081d0: 6275 6721 2822 4261 6420 7361 6d70 6c65  bug!("Bad sample
-000081e0: 2066 6f72 2072 6563 6f6e 7374 7275 6374   for reconstruct
-000081f0: 696e 6720 6c63 6f65 6666 3a20 6465 6772  ing lcoeff: degr
-00008200: 6565 7320 646f 206e 6f74 206d 6174 6368  ees do not match
-00008210: 2229 3b0a 2020 2020 2020 2020 2020 2020  ");.            
-00008220: 2020 2020 2020 2020 7265 7475 726e 2045          return E
-00008230: 7272 286d 6169 6e5f 6269 7661 7269 6174  rr(main_bivariat
-00008240: 655f 6661 6374 6f72 732e 6c65 6e28 2929  e_factors.len())
-00008250: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00008260: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00008270: 2020 2020 206c 6574 2062 6976 6172 6961       let bivaria
-00008280: 7465 5f66 6163 746f 7273 3a20 5665 633c  te_factors: Vec<
-00008290: 5f3e 203d 0a20 2020 2020 2020 2020 2020  _> =.           
-000082a0: 2020 2020 2020 2020 2070 6f6c 795f 6576           poly_ev
-000082b0: 616c 2e66 6163 746f 7228 292e 696e 746f  al.factor().into
-000082c0: 5f69 7465 7228 292e 6d61 7028 7c28 662c  _iter().map(|(f,
-000082d0: 205f 297c 2066 292e 636f 6c6c 6563 7428   _)| f).collect(
-000082e0: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-000082f0: 2020 2020 6966 2062 6976 6172 6961 7465      if bivariate
-00008300: 5f66 6163 746f 7273 2e6c 656e 2829 2021  _factors.len() !
-00008310: 3d20 6d61 696e 5f62 6976 6172 6961 7465  = main_bivariate
-00008320: 5f66 6163 746f 7273 2e6c 656e 2829 207b  _factors.len() {
-00008330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008340: 2020 2020 2072 6574 7572 6e20 4572 7228       return Err(
-00008350: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00008360: 732e 6c65 6e28 292e 6d69 6e28 6d61 696e  s.len().min(main
-00008370: 5f62 6976 6172 6961 7465 5f66 6163 746f  _bivariate_facto
-00008380: 7273 2e6c 656e 2829 2929 3b0a 2020 2020  rs.len()));.    
-00008390: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
-000083a0: 2020 2020 2020 2020 2020 2020 2020 2053                 S
-000083b0: 656c 663a 3a63 616e 6f6e 6963 616c 5f73  elf::canonical_s
-000083c0: 6f72 7428 2662 6976 6172 6961 7465 5f66  ort(&bivariate_f
-000083d0: 6163 746f 7273 2c20 7661 722c 2073 616d  actors, var, sam
-000083e0: 706c 655f 706f 696e 7473 290a 2020 2020  ple_points).    
-000083f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008400: 2e69 6e74 6f5f 6974 6572 2829 0a20 2020  .into_iter().   
+00003c00: 2020 2020 206c 6574 2067 203d 206b 2e67       let g = k.g
+00003c10: 6364 2868 6929 3b0a 2020 2020 2020 2020  cd(hi);.        
+00003c20: 2020 2020 2020 2020 2020 2020 6966 2021              if !
+00003c30: 672e 6973 5f63 6f6e 7374 616e 7428 2920  g.is_constant() 
+00003c40: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00003c50: 2020 2020 2020 2020 2020 6b20 3d20 6b20            k = k 
+00003c60: 2f20 2667 3b0a 2020 2020 2020 2020 2020  / &g;.          
+00003c70: 2020 2020 2020 2020 2020 2020 2020 2a68                *h
+00003c80: 6920 3d20 262a 6869 202f 2026 673b 0a20  i = &*hi / &g;. 
+00003c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003ca0: 2020 2020 2020 2066 6163 746f 7273 2e70         factors.p
+00003cb0: 7573 6828 2867 2c20 6e20 2a20 7020 2b20  ush((g, n * p + 
+00003cc0: 2a70 6f77 6829 293b 0a20 2020 2020 2020  *powh));.       
+00003cd0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00003ce0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00003cf0: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+00003d00: 2020 2020 2020 2020 2020 2020 6966 2021              if !
+00003d10: 6b2e 6973 5f63 6f6e 7374 616e 7428 2920  k.is_constant() 
+00003d20: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00003d30: 2020 6661 6374 6f72 732e 7075 7368 2828    factors.push((
+00003d40: 6b2c 206e 202a 2070 2929 3b0a 2020 2020  k, n * p));.    
+00003d50: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00003d60: 2020 7d0a 0a20 2020 2020 2020 2066 6f72    }..        for
+00003d70: 2028 706f 7768 2c20 6869 2920 696e 2068   (powh, hi) in h
+00003d80: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
+00003d90: 6620 2168 692e 6973 5f63 6f6e 7374 616e  f !hi.is_constan
+00003da0: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
+00003db0: 2020 2020 2020 6661 6374 6f72 732e 7075        factors.pu
+00003dc0: 7368 2828 6869 2c20 706f 7768 2929 3b0a  sh((hi, powh));.
+00003dd0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00003de0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00003df0: 2066 6163 746f 7273 0a20 2020 207d 0a0a   factors.    }..
+00003e00: 2020 2020 2f2f 2f20 4120 6d6f 6469 6669      /// A modifi
+00003e10: 6564 2076 6572 7369 6f6e 206f 6620 5975  ed version of Yu
+00003e20: 6e27 7320 7371 7561 7265 2066 7265 6520  n's square free 
+00003e30: 6661 6374 6f72 697a 6174 696f 6e20 616c  factorization al
+00003e40: 676f 7269 7468 6d2e 0a20 2020 2066 6e20  gorithm..    fn 
+00003e50: 7371 7561 7265 5f66 7265 655f 6661 6374  square_free_fact
+00003e60: 6f72 697a 6174 696f 6e5f 6666 5f79 756e  orization_ff_yun
+00003e70: 2826 7365 6c66 2c20 7661 723a 2075 7369  (&self, var: usi
+00003e80: 7a65 2920 2d3e 2028 5365 6c66 2c20 5665  ze) -> (Self, Ve
+00003e90: 633c 2853 656c 662c 2075 7369 7a65 293e  c<(Self, usize)>
+00003ea0: 2920 7b0a 2020 2020 2020 2020 6c65 7420  ) {.        let 
+00003eb0: 6220 3d20 7365 6c66 2e64 6572 6976 6174  b = self.derivat
+00003ec0: 6976 6528 7661 7229 3b0a 2020 2020 2020  ive(var);.      
+00003ed0: 2020 6c65 7420 6d75 7420 6320 3d20 7365    let mut c = se
+00003ee0: 6c66 2e67 6364 2826 6229 3b0a 2020 2020  lf.gcd(&b);.    
+00003ef0: 2020 2020 6c65 7420 6d75 7420 7720 3d20      let mut w = 
+00003f00: 7365 6c66 202f 2026 633b 0a20 2020 2020  self / &c;.     
+00003f10: 2020 206c 6574 206d 7574 2076 203d 2026     let mut v = &
+00003f20: 6220 2f20 2663 3b0a 0a20 2020 2020 2020  b / &c;..       
+00003f30: 206c 6574 206d 7574 2066 6163 746f 7273   let mut factors
+00003f40: 203d 2076 6563 215b 5d3b 0a0a 2020 2020   = vec![];..    
+00003f50: 2020 2020 6c65 7420 6d75 7420 6920 3d20      let mut i = 
+00003f60: 313b 0a20 2020 2020 2020 2077 6869 6c65  1;.        while
+00003f70: 2021 772e 6973 5f63 6f6e 7374 616e 7428   !w.is_constant(
+00003f80: 2920 2626 2069 203c 2073 656c 662e 6669  ) && i < self.fi
+00003f90: 656c 642e 6765 745f 7072 696d 6528 292e  eld.get_prime().
+00003fa0: 746f 5f75 3634 2829 2061 7320 7573 697a  to_u64() as usiz
+00003fb0: 6520 7b0a 2020 2020 2020 2020 2020 2020  e {.            
+00003fc0: 6c65 7420 7a20 3d20 7620 2d20 772e 6465  let z = v - w.de
+00003fd0: 7269 7661 7469 7665 2876 6172 293b 0a20  rivative(var);. 
+00003fe0: 2020 2020 2020 2020 2020 206c 6574 2067             let g
+00003ff0: 203d 2077 2e67 6364 2826 7a29 3b0a 2020   = w.gcd(&z);.  
+00004000: 2020 2020 2020 2020 2020 7720 3d20 7720            w = w 
+00004010: 2f20 2667 3b0a 2020 2020 2020 2020 2020  / &g;.          
+00004020: 2020 7620 3d20 7a20 2f20 2667 3b0a 2020    v = z / &g;.  
+00004030: 2020 2020 2020 2020 2020 6320 3d20 6320            c = c 
+00004040: 2f20 2677 3b0a 0a20 2020 2020 2020 2020  / &w;..         
+00004050: 2020 2069 6620 2167 2e69 735f 6f6e 6528     if !g.is_one(
+00004060: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00004070: 2020 2020 6661 6374 6f72 732e 7075 7368      factors.push
+00004080: 2828 672c 2069 2929 3b0a 2020 2020 2020  ((g, i));.      
+00004090: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+000040a0: 2020 2020 6920 2b3d 2031 0a20 2020 2020      i += 1.     
+000040b0: 2020 207d 0a0a 2020 2020 2020 2020 2863     }..        (c
+000040c0: 2c20 6661 6374 6f72 7329 0a20 2020 207d  , factors).    }
+000040d0: 0a0a 2020 2020 2f2f 2f20 5065 7266 6f72  ..    /// Perfor
+000040e0: 6d20 6469 7374 696e 6374 2064 6567 7265  m distinct degre
+000040f0: 6520 6661 6374 6f72 697a 6174 696f 6e20  e factorization 
+00004100: 6f6e 2061 206d 6f6e 6963 2c20 756e 6976  on a monic, univ
+00004110: 6172 6961 7465 2061 6e64 2073 7175 6172  ariate and squar
+00004120: 652d 6672 6565 2070 6f6c 796e 6f6d 6961  e-free polynomia
+00004130: 6c2e 0a20 2020 2070 7562 2066 6e20 6469  l..    pub fn di
+00004140: 7374 696e 6374 5f64 6567 7265 655f 6661  stinct_degree_fa
+00004150: 6374 6f72 697a 6174 696f 6e28 2673 656c  ctorization(&sel
+00004160: 6629 202d 3e20 5665 633c 2875 7369 7a65  f) -> Vec<(usize
+00004170: 2c20 5365 6c66 293e 207b 0a20 2020 2020  , Self)> {.     
+00004180: 2020 2061 7373 6572 7421 2873 656c 662e     assert!(self.
+00004190: 6669 656c 642e 6765 745f 7072 696d 6528  field.get_prime(
+000041a0: 292e 746f 5f75 3634 2829 2021 3d20 3229  ).to_u64() != 2)
+000041b0: 3b0a 2020 2020 2020 2020 6c65 7420 536f  ;.        let So
+000041c0: 6d65 2876 6172 2920 3d20 7365 6c66 2e6c  me(var) = self.l
+000041d0: 6173 745f 6578 706f 6e65 6e74 7328 292e  ast_exponents().
+000041e0: 6974 6572 2829 2e70 6f73 6974 696f 6e28  iter().position(
+000041f0: 7c78 7c20 2a78 203e 2045 3a3a 7a65 726f  |x| *x > E::zero
+00004200: 2829 2920 656c 7365 207b 0a20 2020 2020  ()) else {.     
+00004210: 2020 2020 2020 2072 6574 7572 6e20 7665         return ve
+00004220: 6321 5b28 302c 2073 656c 662e 636c 6f6e  c![(0, self.clon
+00004230: 6528 2929 5d3b 202f 2f20 636f 6e73 7461  e())]; // consta
+00004240: 6e74 2070 6f6c 796e 6f6d 6961 6c0a 2020  nt polynomial.  
+00004250: 2020 2020 2020 7d3b 0a0a 2020 2020 2020        };..      
+00004260: 2020 6c65 7420 6d75 7420 6520 3d20 7365    let mut e = se
+00004270: 6c66 2e6c 6173 745f 6578 706f 6e65 6e74  lf.last_exponent
+00004280: 7328 292e 746f 5f76 6563 2829 3b0a 2020  s().to_vec();.  
+00004290: 2020 2020 2020 655b 7661 725d 203d 2045        e[var] = E
+000042a0: 3a3a 6f6e 6528 293b 0a20 2020 2020 2020  ::one();.       
+000042b0: 206c 6574 2078 203d 2073 656c 662e 6d6f   let x = self.mo
+000042c0: 6e6f 6d69 616c 2873 656c 662e 6669 656c  nomial(self.fiel
+000042d0: 642e 6f6e 6528 292c 2065 293b 0a0a 2020  d.one(), e);..  
+000042e0: 2020 2020 2020 6c65 7420 6d75 7420 6661        let mut fa
+000042f0: 6374 6f72 7320 3d20 7665 6321 5b5d 3b0a  ctors = vec![];.
+00004300: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00004310: 6820 3d20 782e 636c 6f6e 6528 293b 0a20  h = x.clone();. 
+00004320: 2020 2020 2020 206c 6574 206d 7574 2066         let mut f
+00004330: 203d 2073 656c 662e 636c 6f6e 6528 293b   = self.clone();
+00004340: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00004350: 2069 3a20 7573 697a 6520 3d20 303b 0a20   i: usize = 0;. 
+00004360: 2020 2020 2020 2077 6869 6c65 2021 662e         while !f.
+00004370: 6973 5f6f 6e65 2829 207b 0a20 2020 2020  is_one() {.     
+00004380: 2020 2020 2020 2069 202b 3d20 313b 0a0a         i += 1;..
+00004390: 2020 2020 2020 2020 2020 2020 6820 3d20              h = 
+000043a0: 682e 6578 705f 6d6f 645f 756e 6976 6172  h.exp_mod_univar
+000043b0: 6961 7465 2873 656c 662e 6669 656c 642e  iate(self.field.
+000043c0: 6765 745f 7072 696d 6528 292e 746f 5f75  get_prime().to_u
+000043d0: 3634 2829 2e69 6e74 6f28 292c 2026 6d75  64().into(), &mu
+000043e0: 7420 6629 3b0a 0a20 2020 2020 2020 2020  t f);..         
+000043f0: 2020 206c 6574 206d 7574 2067 203d 2066     let mut g = f
+00004400: 2e67 6364 2826 2826 6820 2d20 2678 2929  .gcd(&(&h - &x))
+00004410: 3b0a 0a20 2020 2020 2020 2020 2020 2069  ;..            i
+00004420: 6620 2167 2e69 735f 6f6e 6528 2920 7b0a  f !g.is_one() {.
+00004430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004440: 6620 3d20 662e 7175 6f74 5f72 656d 5f75  f = f.quot_rem_u
+00004450: 6e69 7661 7269 6174 6528 266d 7574 2067  nivariate(&mut g
+00004460: 292e 303b 0a20 2020 2020 2020 2020 2020  ).0;.           
+00004470: 2020 2020 2066 6163 746f 7273 2e70 7573       factors.pus
+00004480: 6828 2869 2c20 6729 293b 0a20 2020 2020  h((i, g));.     
+00004490: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+000044a0: 2020 2020 2020 6966 2066 2e6c 6173 745f        if f.last_
+000044b0: 6578 706f 6e65 6e74 7328 295b 7661 725d  exponents()[var]
+000044c0: 203c 2045 3a3a 6672 6f6d 5f75 3332 2832   < E::from_u32(2
+000044d0: 202a 2028 6920 6173 2075 3332 202b 2031   * (i as u32 + 1
+000044e0: 2929 207b 0a20 2020 2020 2020 2020 2020  )) {.           
+000044f0: 2020 2020 202f 2f20 6620 6361 6e6e 6f74       // f cannot
+00004500: 2062 6520 7370 6c69 7420 6d6f 7265 0a20   be split more. 
+00004510: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00004520: 6620 2166 2e69 735f 636f 6e73 7461 6e74  f !f.is_constant
+00004530: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+00004540: 2020 2020 2020 2020 2066 6163 746f 7273           factors
+00004550: 2e70 7573 6828 2866 2e6c 6173 745f 6578  .push((f.last_ex
+00004560: 706f 6e65 6e74 7328 295b 7661 725d 2e74  ponents()[var].t
+00004570: 6f5f 7533 3228 2920 6173 2075 7369 7a65  o_u32() as usize
+00004580: 2c20 6629 293b 0a20 2020 2020 2020 2020  , f));.         
+00004590: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000045a0: 2020 2020 2020 2020 2062 7265 616b 3b0a           break;.
+000045b0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+000045c0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+000045d0: 2066 6163 746f 7273 0a20 2020 207d 0a0a   factors.    }..
+000045e0: 2020 2020 2f2f 2f20 5065 7266 6f72 6d20      /// Perform 
+000045f0: 4361 6e74 6f72 2d5a 6173 7365 6e68 6175  Cantor-Zassenhau
+00004600: 7327 7320 7072 6f62 6162 696c 6973 7469  s's probabilisti
+00004610: 6320 616c 676f 7269 7468 6d20 666f 720a  c algorithm for.
+00004620: 2020 2020 2f2f 2f20 6669 6e64 696e 6720      /// finding 
+00004630: 6972 7265 6475 6369 626c 6520 6661 6374  irreducible fact
+00004640: 6f72 7320 6f66 2064 6567 7265 6520 6064  ors of degree `d
+00004650: 602e 0a20 2020 2070 7562 2066 6e20 6571  `..    pub fn eq
+00004660: 7561 6c5f 6465 6772 6565 5f66 6163 746f  ual_degree_facto
+00004670: 7269 7a61 7469 6f6e 2826 7365 6c66 2c20  rization(&self, 
+00004680: 643a 2075 7369 7a65 2920 2d3e 2056 6563  d: usize) -> Vec
+00004690: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
+000046a0: 2061 7373 6572 7421 2873 656c 662e 6669   assert!(self.fi
+000046b0: 656c 642e 6765 745f 7072 696d 6528 292e  eld.get_prime().
+000046c0: 746f 5f75 3634 2829 2021 3d20 3229 3b0a  to_u64() != 2);.
+000046d0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+000046e0: 7320 3d20 7365 6c66 2e63 6c6f 6e65 2829  s = self.clone()
+000046f0: 2e6d 616b 655f 6d6f 6e69 6328 293b 0a0a  .make_monic();..
+00004700: 2020 2020 2020 2020 6c65 7420 536f 6d65          let Some
+00004710: 2876 6172 2920 3d20 7365 6c66 2e6c 6173  (var) = self.las
+00004720: 745f 6578 706f 6e65 6e74 7328 292e 6974  t_exponents().it
+00004730: 6572 2829 2e70 6f73 6974 696f 6e28 7c78  er().position(|x
+00004740: 7c20 2a78 203e 2045 3a3a 7a65 726f 2829  | *x > E::zero()
+00004750: 2920 656c 7365 207b 0a20 2020 2020 2020  ) else {.       
+00004760: 2020 2020 2069 6620 6420 3d3d 2031 207b       if d == 1 {
+00004770: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004780: 2072 6574 7572 6e20 7665 6321 5b73 5d3b   return vec![s];
+00004790: 0a20 2020 2020 2020 2020 2020 207d 2065  .            } e
+000047a0: 6c73 6520 7b0a 2020 2020 2020 2020 2020  lse {.          
+000047b0: 2020 2020 2020 7061 6e69 6321 2822 4465        panic!("De
+000047c0: 6772 6565 206d 6973 6d61 7463 6820 666f  gree mismatch fo
+000047d0: 7220 7b7d 3a20 7b7d 222c 2073 656c 662c  r {}: {}", self,
+000047e0: 2064 293b 0a20 2020 2020 2020 2020 2020   d);.           
+000047f0: 207d 0a20 2020 2020 2020 207d 3b0a 0a20   }.        };.. 
+00004800: 2020 2020 2020 206c 6574 206e 203d 2073         let n = s
+00004810: 656c 662e 6465 6772 6565 2876 6172 292e  elf.degree(var).
+00004820: 746f 5f75 3332 2829 2061 7320 7573 697a  to_u32() as usiz
+00004830: 653b 0a0a 2020 2020 2020 2020 6966 206e  e;..        if n
+00004840: 203d 3d20 6420 7b0a 2020 2020 2020 2020   == d {.        
+00004850: 2020 2020 7265 7475 726e 2076 6563 215b      return vec![
+00004860: 735d 3b0a 2020 2020 2020 2020 7d0a 0a20  s];.        }.. 
+00004870: 2020 2020 2020 206c 6574 206d 7574 2072         let mut r
+00004880: 6e67 203d 2074 6872 6561 645f 726e 6728  ng = thread_rng(
+00004890: 293b 0a20 2020 2020 2020 206c 6574 206d  );.        let m
+000048a0: 7574 2072 616e 646f 6d5f 706f 6c79 203d  ut random_poly =
+000048b0: 2073 656c 662e 7a65 726f 5f77 6974 685f   self.zero_with_
+000048c0: 6361 7061 6369 7479 2864 293b 0a20 2020  capacity(d);.   
+000048d0: 2020 2020 206c 6574 206d 7574 2065 7870       let mut exp
+000048e0: 203d 2076 6563 215b 453a 3a7a 6572 6f28   = vec![E::zero(
+000048f0: 293b 2073 656c 662e 6e76 6172 7328 295d  ); self.nvars()]
+00004900: 3b0a 0a20 2020 2020 2020 206c 6574 206d  ;..        let m
+00004910: 7574 2074 7279 5f63 6f75 6e74 6572 203d  ut try_counter =
+00004920: 2030 3b0a 0a20 2020 2020 2020 206c 6574   0;..        let
+00004930: 2066 6163 746f 7220 3d20 6c6f 6f70 207b   factor = loop {
+00004940: 0a20 2020 2020 2020 2020 2020 202f 2f20  .            // 
+00004950: 6765 6e65 7261 7465 2061 2072 616e 646f  generate a rando
+00004960: 6d20 6e6f 6e2d 636f 6e73 7461 6e74 2070  m non-constant p
+00004970: 6f6c 796e 6f6d 6961 6c0a 2020 2020 2020  olynomial.      
+00004980: 2020 2020 2020 7261 6e64 6f6d 5f70 6f6c        random_pol
+00004990: 792e 636c 6561 7228 293b 0a0a 2020 2020  y.clear();..    
+000049a0: 2020 2020 2020 2020 6966 2064 203d 3d20          if d == 
+000049b0: 3120 7b0a 2020 2020 2020 2020 2020 2020  1 {.            
+000049c0: 2020 2020 6578 705b 7661 725d 203d 2045      exp[var] = E
+000049d0: 3a3a 7a65 726f 2829 3b0a 2020 2020 2020  ::zero();.      
+000049e0: 2020 2020 2020 2020 2020 7261 6e64 6f6d            random
+000049f0: 5f70 6f6c 792e 6170 7065 6e64 5f6d 6f6e  _poly.append_mon
+00004a00: 6f6d 6961 6c28 7365 6c66 2e66 6965 6c64  omial(self.field
+00004a10: 2e6e 7468 2874 7279 5f63 6f75 6e74 6572  .nth(try_counter
+00004a20: 292c 2026 6578 7029 3b0a 2020 2020 2020  ), &exp);.      
+00004a30: 2020 2020 2020 2020 2020 6578 705b 7661            exp[va
+00004a40: 725d 203d 2045 3a3a 6f6e 6528 293b 0a20  r] = E::one();. 
+00004a50: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004a60: 616e 646f 6d5f 706f 6c79 2e61 7070 656e  andom_poly.appen
+00004a70: 645f 6d6f 6e6f 6d69 616c 2873 656c 662e  d_monomial(self.
+00004a80: 6669 656c 642e 6f6e 6528 292c 2026 6578  field.one(), &ex
+00004a90: 7029 3b0a 2020 2020 2020 2020 2020 2020  p);.            
+00004aa0: 2020 2020 7472 795f 636f 756e 7465 7220      try_counter 
+00004ab0: 2b3d 2031 3b0a 2020 2020 2020 2020 2020  += 1;.          
+00004ac0: 2020 7d20 656c 7365 207b 0a20 2020 2020    } else {.     
+00004ad0: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00004ae0: 2069 6e20 302e 2e32 202a 2064 207b 0a20   in 0..2 * d {. 
+00004af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b00: 2020 206c 6574 2072 203d 2073 656c 660a     let r = self.
+00004b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b20: 2020 2020 2020 2020 2e66 6965 6c64 0a20          .field. 
+00004b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b40: 2020 2020 2020 202e 6e74 6828 726e 672e         .nth(rng.
+00004b50: 6765 6e5f 7261 6e67 6528 302e 2e73 656c  gen_range(0..sel
+00004b60: 662e 6669 656c 642e 6765 745f 7072 696d  f.field.get_prim
+00004b70: 6528 292e 746f 5f75 3634 2829 2929 3b0a  e().to_u64()));.
+00004b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b90: 2020 2020 6966 2021 4669 6e69 7465 4669      if !FiniteFi
+00004ba0: 656c 643a 3a3c 5546 6965 6c64 3e3a 3a69  eld::<UField>::i
+00004bb0: 735f 7a65 726f 2826 7229 207b 0a20 2020  s_zero(&r) {.   
+00004bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004bd0: 2020 2020 2065 7870 5b76 6172 5d20 3d20       exp[var] = 
+00004be0: 453a 3a66 726f 6d5f 7533 3228 6920 6173  E::from_u32(i as
+00004bf0: 2075 3332 293b 0a20 2020 2020 2020 2020   u32);.         
+00004c00: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004c10: 616e 646f 6d5f 706f 6c79 2e61 7070 656e  andom_poly.appen
+00004c20: 645f 6d6f 6e6f 6d69 616c 2872 2c20 2665  d_monomial(r, &e
+00004c30: 7870 293b 0a20 2020 2020 2020 2020 2020  xp);.           
+00004c40: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00004c50: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+00004c60: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00004c70: 2072 616e 646f 6d5f 706f 6c79 2e64 6567   random_poly.deg
+00004c80: 7265 6528 7661 7229 203d 3d20 453a 3a7a  ree(var) == E::z
+00004c90: 6572 6f28 2920 7b0a 2020 2020 2020 2020  ero() {.        
+00004ca0: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+00004cb0: 696e 7565 3b0a 2020 2020 2020 2020 2020  inue;.          
+00004cc0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+00004cd0: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
+00004ce0: 2020 206c 6574 2067 203d 2072 616e 646f     let g = rando
+00004cf0: 6d5f 706f 6c79 2e67 6364 2826 7329 3b0a  m_poly.gcd(&s);.
+00004d00: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00004d10: 2167 2e69 735f 6f6e 6528 2920 7b0a 2020  !g.is_one() {.  
+00004d20: 2020 2020 2020 2020 2020 2020 2020 6272                br
+00004d30: 6561 6b20 673b 0a20 2020 2020 2020 2020  eak g;.         
+00004d40: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+00004d50: 2020 2f2f 2054 4f44 4f3a 2075 7365 2046    // TODO: use F
+00004d60: 726f 6265 6e69 7573 206d 6170 2061 6e64  robenius map and
+00004d70: 206d 6f64 756c 6172 2063 6f6d 706f 7369   modular composi
+00004d80: 7469 6f6e 2074 6f20 7072 6576 656e 7420  tion to prevent 
+00004d90: 636f 6d70 7574 696e 6720 6c61 7267 6520  computing large 
+00004da0: 6578 706f 6e65 6e74 2070 6f6c 795e 2870  exponent poly^(p
+00004db0: 5e64 290a 2020 2020 2020 2020 2020 2020  ^d).            
+00004dc0: 6c65 7420 703a 2049 6e74 6567 6572 203d  let p: Integer =
+00004dd0: 2073 656c 662e 6669 656c 642e 6765 745f   self.field.get_
+00004de0: 7072 696d 6528 292e 746f 5f75 3634 2829  prime().to_u64()
+00004df0: 2e69 6e74 6f28 293b 0a20 2020 2020 2020  .into();.       
+00004e00: 2020 2020 206c 6574 2062 203d 2072 616e       let b = ran
+00004e10: 646f 6d5f 706f 6c79 0a20 2020 2020 2020  dom_poly.       
+00004e20: 2020 2020 2020 2020 202e 6578 705f 6d6f           .exp_mo
+00004e30: 645f 756e 6976 6172 6961 7465 2826 2826  d_univariate(&(&
+00004e40: 702e 706f 7728 6420 6173 2075 3634 2920  p.pow(d as u64) 
+00004e50: 2d20 2631 6936 342e 696e 746f 2829 2920  - &1i64.into()) 
+00004e60: 2f20 2632 6936 342e 696e 746f 2829 2c20  / &2i64.into(), 
+00004e70: 266d 7574 2073 290a 2020 2020 2020 2020  &mut s).        
+00004e80: 2020 2020 2020 2020 2d20 7365 6c66 2e6f          - self.o
+00004e90: 6e65 2829 3b0a 0a20 2020 2020 2020 2020  ne();..         
+00004ea0: 2020 206c 6574 2067 203d 2062 2e67 6364     let g = b.gcd
+00004eb0: 2826 7329 3b0a 0a20 2020 2020 2020 2020  (&s);..         
+00004ec0: 2020 2069 6620 2167 2e69 735f 6f6e 6528     if !g.is_one(
+00004ed0: 2920 2626 2067 2021 3d20 7320 7b0a 2020  ) && g != s {.  
+00004ee0: 2020 2020 2020 2020 2020 2020 2020 6272                br
+00004ef0: 6561 6b20 673b 0a20 2020 2020 2020 2020  eak g;.         
+00004f00: 2020 207d 0a20 2020 2020 2020 207d 3b0a     }.        };.
+00004f10: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00004f20: 2066 6163 746f 7273 203d 2066 6163 746f   factors = facto
+00004f30: 722e 6571 7561 6c5f 6465 6772 6565 5f66  r.equal_degree_f
+00004f40: 6163 746f 7269 7a61 7469 6f6e 2864 293b  actorization(d);
+00004f50: 0a20 2020 2020 2020 2066 6163 746f 7273  .        factors
+00004f60: 2e65 7874 656e 6428 2873 656c 6620 2f20  .extend((self / 
+00004f70: 2666 6163 746f 7229 2e65 7175 616c 5f64  &factor).equal_d
+00004f80: 6567 7265 655f 6661 6374 6f72 697a 6174  egree_factorizat
+00004f90: 696f 6e28 6429 293b 0a20 2020 2020 2020  ion(d));.       
+00004fa0: 2066 6163 746f 7273 0a20 2020 207d 0a0a   factors.    }..
+00004fb0: 2020 2020 2f2f 2f20 5065 7266 6f72 6d20      /// Perform 
+00004fc0: 6469 7374 696e 6374 2061 6e64 2065 7175  distinct and equ
+00004fd0: 616c 2064 6567 7265 6520 6661 6374 6f72  al degree factor
+00004fe0: 697a 6174 696f 6e20 6f6e 2061 2073 7175  ization on a squ
+00004ff0: 6172 652d 6672 6565 2075 6e69 7661 7269  are-free univari
+00005000: 6174 6520 706f 6c79 6e6f 6d69 616c 2e0a  ate polynomial..
+00005010: 2020 2020 666e 2066 6163 746f 725f 6469      fn factor_di
+00005020: 7374 696e 6374 5f65 7175 616c 5f64 6567  stinct_equal_deg
+00005030: 7265 6528 2673 656c 6629 202d 3e20 5665  ree(&self) -> Ve
+00005040: 633c 5365 6c66 3e20 7b0a 2020 2020 2020  c<Self> {.      
+00005050: 2020 6c65 7420 6d75 7420 6661 6374 6f72    let mut factor
+00005060: 7320 3d20 7665 6321 5b5d 3b0a 2020 2020  s = vec![];.    
+00005070: 2020 2020 666f 7220 2864 322c 2066 3229      for (d2, f2)
+00005080: 2069 6e20 7365 6c66 2e64 6973 7469 6e63   in self.distinc
+00005090: 745f 6465 6772 6565 5f66 6163 746f 7269  t_degree_factori
+000050a0: 7a61 7469 6f6e 2829 207b 0a20 2020 2020  zation() {.     
+000050b0: 2020 2020 2020 2064 6562 7567 2128 2244         debug!("D
+000050c0: 4446 207b 7d20 7b7d 222c 2066 322c 2064  DF {} {}", f2, d
+000050d0: 3229 3b0a 2020 2020 2020 2020 2020 2020  2);.            
+000050e0: 666f 7220 6633 2069 6e20 6632 2e65 7175  for f3 in f2.equ
+000050f0: 616c 5f64 6567 7265 655f 6661 6374 6f72  al_degree_factor
+00005100: 697a 6174 696f 6e28 6432 2920 7b0a 2020  ization(d2) {.  
+00005110: 2020 2020 2020 2020 2020 2020 2020 6465                de
+00005120: 6275 6721 2822 4544 4620 7b7d 222c 2066  bug!("EDF {}", f
+00005130: 3329 3b0a 2020 2020 2020 2020 2020 2020  3);.            
+00005140: 2020 2020 6661 6374 6f72 732e 7075 7368      factors.push
+00005150: 2866 3329 3b0a 2020 2020 2020 2020 2020  (f3);.          
+00005160: 2020 7d0a 2020 2020 2020 2020 7d0a 2020    }.        }.  
+00005170: 2020 2020 2020 6661 6374 6f72 730a 2020        factors.  
+00005180: 2020 7d0a 0a20 2020 202f 2f2f 2042 6572    }..    /// Ber
+00005190: 6e61 7264 696e 2773 2061 6c67 6f72 6974  nardin's algorit
+000051a0: 686d 2062 6173 6564 206f 6e0a 2020 2020  hm based on.    
+000051b0: 2f2f 2f20 2241 206e 6577 2062 6976 6172  /// "A new bivar
+000051c0: 6961 7465 2048 656e 7365 6c20 6c69 6674  iate Hensel lift
+000051d0: 696e 6720 616c 676f 7269 7468 6d20 666f  ing algorithm fo
+000051e0: 7220 6e20 6661 6374 6f72 7322 0a20 2020  r n factors".   
+000051f0: 202f 2f2f 2062 7920 4761 7272 6574 7420   /// by Garrett 
+00005200: 5061 6c75 636b 2e20 5468 6520 666f 726d  Paluck. The form
+00005210: 756c 6174 696f 6e20 6f66 2074 6865 2061  ulation of the a
+00005220: 6c67 6f72 6974 686d 2069 6e20 6f74 6865  lgorithm in othe
+00005230: 7220 736f 7572 6365 7320 636f 6e74 6169  r sources contai
+00005240: 6e20 7365 7269 6f75 7320 6572 726f 7273  n serious errors
+00005250: 2e0a 2020 2020 2f2f 2054 4f44 4f3a 206d  ..    // TODO: m
+00005260: 6572 6765 2077 6974 6820 616e 2061 6c6d  erge with an alm
+00005270: 6f73 7420 7369 6d69 6c61 7220 6d65 7468  ost similar meth
+00005280: 6f64 2066 6f72 2074 6865 2069 6e74 6567  od for the integ
+00005290: 6572 2063 6173 652e 2041 206d 6f64 6966  er case. A modif
+000052a0: 6963 6174 696f 6e20 7468 6174 206e 6565  ication that nee
+000052b0: 6473 0a20 2020 202f 2f20 746f 2062 6520  ds.    // to be 
+000052c0: 6d61 6465 2068 6572 6520 6973 2074 6f20  made here is to 
+000052d0: 6d61 6b65 2074 6865 206c 636f 6566 665f  make the lcoeff_
+000052e0: 793d 3020 6d6f 6e69 630a 2020 2020 666e  y=0 monic.    fn
+000052f0: 2062 6976 6172 6961 7465 5f68 656e 7365   bivariate_hense
+00005300: 6c5f 6c69 6674 5f62 6572 6e61 7264 696e  l_lift_bernardin
+00005310: 280a 2020 2020 2020 2020 2673 656c 662c  (.        &self,
+00005320: 0a20 2020 2020 2020 2069 6e74 6572 706f  .        interpo
+00005330: 6c61 7469 6f6e 5f76 6172 3a20 7573 697a  lation_var: usiz
+00005340: 652c 0a20 2020 2020 2020 206c 636f 6566  e,.        lcoef
+00005350: 663a 2026 5365 6c66 2c0a 2020 2020 2020  f: &Self,.      
+00005360: 2020 756e 6976 6172 6961 7465 5f66 6163    univariate_fac
+00005370: 746f 7273 3a20 265b 5365 6c66 5d2c 0a20  tors: &[Self],. 
+00005380: 2020 2020 2020 2069 7465 7261 7469 6f6e         iteration
+00005390: 733a 2075 7369 7a65 2c0a 2020 2020 2920  s: usize,.    ) 
+000053a0: 2d3e 2056 6563 3c53 656c 663e 207b 0a20  -> Vec<Self> {. 
+000053b0: 2020 2020 2020 206c 6574 2079 5f70 6f6c         let y_pol
+000053c0: 7920 3d20 7365 6c66 2e74 6f5f 756e 6976  y = self.to_univ
+000053d0: 6172 6961 7465 5f70 6f6c 796e 6f6d 6961  ariate_polynomia
+000053e0: 6c5f 6c69 7374 2869 6e74 6572 706f 6c61  l_list(interpola
+000053f0: 7469 6f6e 5f76 6172 293b 0a0a 2020 2020  tion_var);..    
+00005400: 2020 2020 2f2f 2061 6464 2074 6865 206c      // add the l
+00005410: 6561 6469 6e67 2063 6f65 6666 6963 6965  eading coefficie
+00005420: 6e74 2061 7320 6120 6669 7273 7420 6661  nt as a first fa
+00005430: 6374 6f72 0a20 2020 2020 2020 206c 6574  ctor.        let
+00005440: 206d 7574 2066 6163 746f 7273 203d 2076   mut factors = v
+00005450: 6563 215b 6c63 6f65 6666 2e72 6570 6c61  ec![lcoeff.repla
+00005460: 6365 2869 6e74 6572 706f 6c61 7469 6f6e  ce(interpolation
+00005470: 5f76 6172 2c20 2673 656c 662e 6669 656c  _var, &self.fiel
+00005480: 642e 7a65 726f 2829 295d 3b0a 2020 2020  d.zero())];.    
+00005490: 2020 2020 6661 6374 6f72 732e 6578 7465      factors.exte
+000054a0: 6e64 5f66 726f 6d5f 736c 6963 6528 756e  nd_from_slice(un
+000054b0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+000054c0: 293b 0a0a 2020 2020 2020 2020 2f2f 2065  );..        // e
+000054d0: 7874 7261 6374 2063 6f65 6666 6963 6965  xtract coefficie
+000054e0: 6e74 7320 696e 2079 0a20 2020 2020 2020  nts in y.       
+000054f0: 206c 6574 206d 7574 2075 3a20 5665 633c   let mut u: Vec<
+00005500: 5f3e 203d 2066 6163 746f 7273 0a20 2020  _> = factors.   
+00005510: 2020 2020 2020 2020 202e 6974 6572 2829           .iter()
+00005520: 0a20 2020 2020 2020 2020 2020 202e 6d61  .            .ma
+00005530: 7028 7c66 7c20 7b0a 2020 2020 2020 2020  p(|f| {.        
+00005540: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00005550: 6465 6e73 6520 3d20 7665 6321 5b73 656c  dense = vec![sel
+00005560: 662e 7a65 726f 2829 3b20 6974 6572 6174  f.zero(); iterat
+00005570: 696f 6e73 202b 2031 5d3b 0a20 2020 2020  ions + 1];.     
+00005580: 2020 2020 2020 2020 2020 2064 656e 7365             dense
+00005590: 5b30 5d20 3d20 662e 636c 6f6e 6528 293b  [0] = f.clone();
+000055a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000055b0: 2064 656e 7365 0a20 2020 2020 2020 2020   dense.         
+000055c0: 2020 207d 290a 2020 2020 2020 2020 2020     }).          
+000055d0: 2020 2e63 6f6c 6c65 6374 2829 3b0a 0a20    .collect();.. 
+000055e0: 2020 2020 2020 202f 2f20 7570 6461 7465         // update
+000055f0: 2074 6865 2066 6972 7374 2070 6f6c 796e   the first polyn
+00005600: 6f6d 6961 6c20 6173 2069 7420 6d61 7920  omial as it may 
+00005610: 636f 6e74 6169 6e20 792c 2073 696e 6365  contain y, since
+00005620: 2069 7427 7320 6c63 6f65 6666 0a20 2020   it's lcoeff.   
+00005630: 2020 2020 206c 6574 2079 5f6c 636f 6566       let y_lcoef
+00005640: 6620 3d20 6c63 6f65 6666 2e74 6f5f 756e  f = lcoeff.to_un
+00005650: 6976 6172 6961 7465 5f70 6f6c 796e 6f6d  ivariate_polynom
+00005660: 6961 6c5f 6c69 7374 2869 6e74 6572 706f  ial_list(interpo
+00005670: 6c61 7469 6f6e 5f76 6172 293b 0a20 2020  lation_var);.   
+00005680: 2020 2020 2066 6f72 2028 702c 2065 2920       for (p, e) 
+00005690: 696e 2079 5f6c 636f 6566 6620 7b0a 2020  in y_lcoeff {.  
+000056a0: 2020 2020 2020 2020 2020 755b 305d 5b65            u[0][e
+000056b0: 2e74 6f5f 7533 3228 2920 6173 2075 7369  .to_u32() as usi
+000056c0: 7a65 5d20 3d20 703b 0a20 2020 2020 2020  ze] = p;.       
+000056d0: 207d 0a0a 2020 2020 2020 2020 6c65 7420   }..        let 
+000056e0: 6d75 7420 7020 3d20 752e 636c 6f6e 6528  mut p = u.clone(
+000056f0: 293b 0a20 2020 2020 2020 206c 6574 206d  );.        let m
+00005700: 7574 2063 7572 5f70 203d 2070 5b30 5d5b  ut cur_p = p[0][
+00005710: 305d 2e63 6c6f 6e65 2829 3b0a 2020 2020  0].clone();.    
+00005720: 2020 2020 666f 7220 7820 696e 2026 6d75      for x in &mu
+00005730: 7420 702e 6974 6572 5f6d 7574 2829 2e73  t p.iter_mut().s
+00005740: 6b69 7028 3129 207b 0a20 2020 2020 2020  kip(1) {.       
+00005750: 2020 2020 2063 7572 5f70 203d 2063 7572       cur_p = cur
+00005760: 5f70 202a 2026 785b 305d 3b0a 2020 2020  _p * &x[0];.    
+00005770: 2020 2020 2020 2020 785b 305d 203d 2063          x[0] = c
+00005780: 7572 5f70 2e63 6c6f 6e65 2829 3b0a 2020  ur_p.clone();.  
+00005790: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+000057a0: 206c 6574 2064 656c 7461 203d 2053 656c   let delta = Sel
+000057b0: 663a 3a64 696f 7068 616e 7469 6e65 5f75  f::diophantine_u
+000057c0: 6e69 7661 7269 6174 6528 266d 7574 2066  nivariate(&mut f
+000057d0: 6163 746f 7273 2c20 2673 656c 662e 6f6e  actors, &self.on
+000057e0: 6528 2929 3b0a 0a20 2020 2020 2020 2066  e());..        f
+000057f0: 6f72 206b 2069 6e20 312e 2e69 7465 7261  or k in 1..itera
+00005800: 7469 6f6e 7320 7b0a 2020 2020 2020 2020  tions {.        
+00005810: 2020 2020 2f2f 2065 7874 7261 6374 2074      // extract t
+00005820: 6865 2063 6f65 6666 6963 6965 6e74 2072  he coefficient r
+00005830: 6571 7569 7265 6420 746f 2063 6f6d 7075  equired to compu
+00005840: 7465 2074 6865 2065 7272 6f72 2069 6e20  te the error in 
+00005850: 795e 6b0a 2020 2020 2020 2020 2020 2020  y^k.            
+00005860: 2f2f 2063 6f6d 7075 7465 6420 7573 696e  // computed usin
+00005870: 6720 6120 636f 6e76 6f6c 7574 696f 6e0a  g a convolution.
+00005880: 2020 2020 2020 2020 2020 2020 705b 305d              p[0]
+00005890: 5b6b 5d20 3d20 755b 305d 5b6b 5d2e 636c  [k] = u[0][k].cl
+000058a0: 6f6e 6528 293b 0a20 2020 2020 2020 2020  one();.         
+000058b0: 2020 2066 6f72 2069 2069 6e20 312e 2e66     for i in 1..f
+000058c0: 6163 746f 7273 2e6c 656e 2829 207b 0a20  actors.len() {. 
+000058d0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000058e0: 6f72 206a 2069 6e20 302e 2e6b 207b 0a20  or j in 0..k {. 
+000058f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005900: 2020 2070 5b69 5d5b 6b5d 203d 2026 705b     p[i][k] = &p[
+00005910: 695d 5b6b 5d20 2b20 2628 2670 5b69 202d  i][k] + &(&p[i -
+00005920: 2031 5d5b 6b20 2d20 6a5d 202a 2026 755b   1][k - j] * &u[
+00005930: 695d 5b6a 5d29 3b0a 2020 2020 2020 2020  i][j]);.        
+00005940: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00005950: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00005960: 2020 2020 202f 2f20 6669 6e64 2074 6865       // find the
+00005970: 206b 7468 2070 6f77 6572 206f 6620 7920   kth power of y 
+00005980: 696e 2066 0a20 2020 2020 2020 2020 2020  in f.           
+00005990: 202f 2f20 7369 6e63 6520 7765 2063 6f6d   // since we com
+000059a0: 7075 7465 2074 6865 2065 7272 6f72 2070  pute the error p
+000059b0: 6572 2070 6f77 6572 206f 6620 792c 2077  er power of y, w
+000059c0: 6520 6361 6e6e 6f74 2073 746f 7020 6f6e  e cannot stop on
+000059d0: 2061 2030 2065 7272 6f72 0a20 2020 2020   a 0 error.     
+000059e0: 2020 2020 2020 206c 6574 2065 203d 2069         let e = i
+000059f0: 6620 6c65 7420 536f 6d65 2828 762c 205f  f let Some((v, _
+00005a00: 2929 203d 2079 5f70 6f6c 792e 6974 6572  )) = y_poly.iter
+00005a10: 2829 2e66 696e 6428 7c65 7c20 652e 312e  ().find(|e| e.1.
+00005a20: 746f 5f75 3332 2829 2061 7320 7573 697a  to_u32() as usiz
+00005a30: 6520 3d3d 206b 2920 7b0a 2020 2020 2020  e == k) {.      
+00005a40: 2020 2020 2020 2020 2020 7620 2d20 2670            v - &p
+00005a50: 2e6c 6173 7428 292e 756e 7772 6170 2829  .last().unwrap()
+00005a60: 5b6b 5d0a 2020 2020 2020 2020 2020 2020  [k].            
+00005a70: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+00005a80: 2020 2020 2020 2020 202d 702e 6c61 7374           -p.last
+00005a90: 2829 2e75 6e77 7261 7028 295b 6b5d 2e63  ().unwrap()[k].c
+00005aa0: 6c6f 6e65 2829 0a20 2020 2020 2020 2020  lone().         
+00005ab0: 2020 207d 3b0a 0a20 2020 2020 2020 2020     };..         
+00005ac0: 2020 2069 6620 652e 6973 5f7a 6572 6f28     if e.is_zero(
+00005ad0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00005ae0: 2020 2020 636f 6e74 696e 7565 3b0a 2020      continue;.  
+00005af0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+00005b00: 2020 2020 2020 2020 2066 6f72 2028 2864           for ((d
+00005b10: 702c 2066 292c 2064 2920 696e 2075 2e69  p, f), d) in u.i
+00005b20: 7465 725f 6d75 7428 292e 7a69 7028 6661  ter_mut().zip(fa
+00005b30: 6374 6f72 732e 6974 6572 5f6d 7574 2829  ctors.iter_mut()
+00005b40: 292e 7a69 7028 2664 656c 7461 2920 7b0a  ).zip(&delta) {.
+00005b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b60: 6470 5b6b 5d20 3d20 2664 705b 6b5d 202b  dp[k] = &dp[k] +
+00005b70: 2026 2864 202a 2026 6529 2e71 756f 745f   &(d * &e).quot_
+00005b80: 7265 6d5f 756e 6976 6172 6961 7465 2866  rem_univariate(f
+00005b90: 292e 313b 0a20 2020 2020 2020 2020 2020  ).1;.           
+00005ba0: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
+00005bb0: 2f2f 2075 7064 6174 6520 7468 6520 636f  // update the co
+00005bc0: 6566 6669 6369 656e 7473 2077 6974 6820  efficients with 
+00005bd0: 7468 6520 6e65 7720 795e 6b20 636f 6e74  the new y^k cont
+00005be0: 7269 6275 7469 6f6e 730a 2020 2020 2020  ributions.      
+00005bf0: 2020 2020 2020 2f2f 206e 6f74 6520 7468        // note th
+00005c00: 6174 2074 6865 206c 636f 6566 665b 6b5d  at the lcoeff[k]
+00005c10: 2063 6f6e 7472 6962 7574 696f 6e20 6973   contribution is
+00005c20: 206e 6f74 206e 6577 0a20 2020 2020 2020   not new.       
+00005c30: 2020 2020 206c 6574 206d 7574 2074 203d       let mut t =
+00005c40: 2073 656c 662e 7a65 726f 2829 3b0a 2020   self.zero();.  
+00005c50: 2020 2020 2020 2020 2020 666f 7220 6920            for i 
+00005c60: 696e 2031 2e2e 6661 6374 6f72 732e 6c65  in 1..factors.le
+00005c70: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
+00005c80: 2020 2020 2020 7420 3d20 2675 5b69 5d5b        t = &u[i][
+00005c90: 305d 202a 2026 7420 2b20 2675 5b69 5d5b  0] * &t + &u[i][
+00005ca0: 6b5d 202a 2026 705b 6920 2d20 315d 5b30  k] * &p[i - 1][0
+00005cb0: 5d3b 0a20 2020 2020 2020 2020 2020 2020  ];.             
+00005cc0: 2020 2070 5b69 5d5b 6b5d 203d 2026 705b     p[i][k] = &p[
+00005cd0: 695d 5b6b 5d20 2b20 2674 3b0a 2020 2020  i][k] + &t;.    
+00005ce0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00005cf0: 2020 7d0a 0a20 2020 2020 2020 202f 2f20    }..        // 
+00005d00: 636f 6e76 6572 7420 6465 6e73 6520 706f  convert dense po
+00005d10: 6c79 6e6f 6d69 616c 7320 746f 206d 756c  lynomials to mul
+00005d20: 7469 7661 7269 6174 6520 706f 6c79 6e6f  tivariate polyno
+00005d30: 6d69 616c 730a 2020 2020 2020 2020 752e  mials.        u.
+00005d40: 696e 746f 5f69 7465 7228 290a 2020 2020  into_iter().    
+00005d50: 2020 2020 2020 2020 2e6d 6170 287c 7473          .map(|ts
+00005d60: 7c20 7b0a 2020 2020 2020 2020 2020 2020  | {.            
+00005d70: 2020 2020 6c65 7420 6d75 7420 6e65 775f      let mut new_
+00005d80: 706f 6c79 203d 2073 656c 662e 7a65 726f  poly = self.zero
+00005d90: 5f77 6974 685f 6361 7061 6369 7479 2874  _with_capacity(t
+00005da0: 732e 6c65 6e28 2929 3b0a 2020 2020 2020  s.len());.      
+00005db0: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
+00005dc0: 2c20 6d75 7420 6629 2069 6e20 7473 2e69  , mut f) in ts.i
+00005dd0: 6e74 6f5f 6974 6572 2829 2e65 6e75 6d65  nto_iter().enume
+00005de0: 7261 7465 2829 207b 0a20 2020 2020 2020  rate() {.       
+00005df0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00005e00: 2078 2069 6e20 662e 6578 706f 6e65 6e74   x in f.exponent
+00005e10: 735f 6974 6572 5f6d 7574 2829 207b 0a20  s_iter_mut() {. 
+00005e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005e30: 2020 2020 2020 2078 5b69 6e74 6572 706f         x[interpo
+00005e40: 6c61 7469 6f6e 5f76 6172 5d20 3d20 453a  lation_var] = E:
+00005e50: 3a66 726f 6d5f 7533 3228 6920 6173 2075  :from_u32(i as u
+00005e60: 3332 293b 0a20 2020 2020 2020 2020 2020  32);.           
+00005e70: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00005e80: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00005e90: 6577 5f70 6f6c 7920 3d20 6e65 775f 706f  ew_poly = new_po
+00005ea0: 6c79 202b 2066 3b0a 2020 2020 2020 2020  ly + f;.        
+00005eb0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00005ec0: 2020 2020 2020 2020 2020 6e65 775f 706f            new_po
+00005ed0: 6c79 0a20 2020 2020 2020 2020 2020 207d  ly.            }
+00005ee0: 290a 2020 2020 2020 2020 2020 2020 2e63  ).            .c
+00005ef0: 6f6c 6c65 6374 2829 0a20 2020 207d 0a0a  ollect().    }..
+00005f00: 2020 2020 2f2f 2f20 436f 6d70 7574 6520      /// Compute 
+00005f10: 7468 6520 6269 7661 7269 6174 6520 6661  the bivariate fa
+00005f20: 6374 6f72 697a 6174 696f 6e20 6f66 2061  ctorization of a
+00005f30: 2073 7175 6172 652d 6672 6565 2070 6f6c   square-free pol
+00005f40: 796e 6f6d 6961 6c2e 0a20 2020 2066 6e20  ynomial..    fn 
+00005f50: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+00005f60: 697a 6174 696f 6e28 2673 656c 662c 206d  ization(&self, m
+00005f70: 6169 6e5f 7661 723a 2075 7369 7a65 2c20  ain_var: usize, 
+00005f80: 696e 7465 7270 6f6c 6174 696f 6e5f 7661  interpolation_va
+00005f90: 723a 2075 7369 7a65 2920 2d3e 2056 6563  r: usize) -> Vec
+00005fa0: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
+00005fb0: 2061 7373 6572 7421 286d 6169 6e5f 7661   assert!(main_va
+00005fc0: 7220 213d 2069 6e74 6572 706f 6c61 7469  r != interpolati
+00005fd0: 6f6e 5f76 6172 293b 0a0a 2020 2020 2020  on_var);..      
+00005fe0: 2020 6966 2073 656c 662e 6269 7661 7269    if self.bivari
+00005ff0: 6174 655f 6972 7265 6475 6369 6269 6c69  ate_irreducibili
+00006000: 7479 5f74 6573 7428 2920 7b0a 2020 2020  ty_test() {.    
+00006010: 2020 2020 2020 2020 7265 7475 726e 2076          return v
+00006020: 6563 215b 7365 6c66 2e63 6c6f 6e65 2829  ec![self.clone()
+00006030: 5d3b 0a20 2020 2020 2020 207d 0a0a 2020  ];.        }..  
+00006040: 2020 2020 2020 2f2f 2063 6865 636b 2066        // check f
+00006050: 6f72 2070 726f 626c 656d 7320 6172 6973  or problems aris
+00006060: 696e 6720 6672 6f6d 2063 616e 6365 6c69  ing from canceli
+00006070: 6e67 2074 6572 6d73 2069 6e20 7468 6520  ng terms in the 
+00006080: 6465 7269 7661 7469 7665 0a20 2020 2020  derivative.     
+00006090: 2020 206c 6574 2064 6572 203d 2073 656c     let der = sel
+000060a0: 662e 6465 7269 7661 7469 7665 286d 6169  f.derivative(mai
+000060b0: 6e5f 7661 7229 3b0a 2020 2020 2020 2020  n_var);.        
+000060c0: 6966 2064 6572 2e69 735f 7a65 726f 2829  if der.is_zero()
+000060d0: 207b 0a20 2020 2020 2020 2020 2020 2072   {.            r
+000060e0: 6574 7572 6e20 7365 6c66 2e62 6976 6172  eturn self.bivar
+000060f0: 6961 7465 5f66 6163 746f 7269 7a61 7469  iate_factorizati
+00006100: 6f6e 2869 6e74 6572 706f 6c61 7469 6f6e  on(interpolation
+00006110: 5f76 6172 2c20 6d61 696e 5f76 6172 293b  _var, main_var);
+00006120: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
+00006130: 2020 2020 6c65 7420 6720 3d20 7365 6c66      let g = self
+00006140: 2e67 6364 2826 6465 7229 3b0a 2020 2020  .gcd(&der);.    
+00006150: 2020 2020 6966 2021 672e 6973 5f63 6f6e      if !g.is_con
+00006160: 7374 616e 7428 2920 7b0a 2020 2020 2020  stant() {.      
+00006170: 2020 2020 2020 6c65 7420 6d75 7420 6661        let mut fa
+00006180: 6374 6f72 7320 3d20 672e 6269 7661 7269  ctors = g.bivari
+00006190: 6174 655f 6661 6374 6f72 697a 6174 696f  ate_factorizatio
+000061a0: 6e28 6d61 696e 5f76 6172 2c20 696e 7465  n(main_var, inte
+000061b0: 7270 6f6c 6174 696f 6e5f 7661 7229 3b0a  rpolation_var);.
+000061c0: 2020 2020 2020 2020 2020 2020 6661 6374              fact
+000061d0: 6f72 732e 6578 7465 6e64 2828 7365 6c66  ors.extend((self
+000061e0: 202f 2026 6729 2e62 6976 6172 6961 7465   / &g).bivariate
+000061f0: 5f66 6163 746f 7269 7a61 7469 6f6e 286d  _factorization(m
+00006200: 6169 6e5f 7661 722c 2069 6e74 6572 706f  ain_var, interpo
+00006210: 6c61 7469 6f6e 5f76 6172 2929 3b0a 2020  lation_var));.  
+00006220: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00006230: 2066 6163 746f 7273 3b0a 2020 2020 2020   factors;.      
+00006240: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
+00006250: 206d 7574 2073 616d 706c 655f 706f 696e   mut sample_poin
+00006260: 7420 3d20 7365 6c66 2e66 6965 6c64 2e7a  t = self.field.z
+00006270: 6572 6f28 293b 0a20 2020 2020 2020 206c  ero();.        l
+00006280: 6574 206d 7574 2075 6e69 5f66 203d 2073  et mut uni_f = s
+00006290: 656c 662e 7265 706c 6163 6528 696e 7465  elf.replace(inte
+000062a0: 7270 6f6c 6174 696f 6e5f 7661 722c 2026  rpolation_var, &
+000062b0: 7361 6d70 6c65 5f70 6f69 6e74 293b 0a0a  sample_point);..
+000062c0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+000062d0: 6920 3d20 303b 0a20 2020 2020 2020 206c  i = 0;.        l
+000062e0: 6f6f 7020 7b0a 2020 2020 2020 2020 2020  oop {.          
+000062f0: 2020 6966 2073 656c 662e 6465 6772 6565    if self.degree
+00006300: 286d 6169 6e5f 7661 7229 203d 3d20 756e  (main_var) == un
+00006310: 695f 662e 6465 6772 6565 286d 6169 6e5f  i_f.degree(main_
+00006320: 7661 7229 0a20 2020 2020 2020 2020 2020  var).           
+00006330: 2020 2020 2026 2620 756e 695f 662e 6763       && uni_f.gc
+00006340: 6428 2675 6e69 5f66 2e64 6572 6976 6174  d(&uni_f.derivat
+00006350: 6976 6528 6d61 696e 5f76 6172 2929 2e69  ive(main_var)).i
+00006360: 735f 636f 6e73 7461 6e74 2829 0a20 2020  s_constant().   
+00006370: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
+00006380: 2020 2020 2020 2020 2020 2062 7265 616b             break
+00006390: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
+000063a0: 0a20 2020 2020 2020 2020 2020 2073 616d  .            sam
+000063b0: 706c 655f 706f 696e 7420 3d20 7365 6c66  ple_point = self
+000063c0: 2e66 6965 6c64 2e6e 7468 2869 293b 0a20  .field.nth(i);. 
+000063d0: 2020 2020 2020 2020 2020 2075 6e69 5f66             uni_f
+000063e0: 203d 2073 656c 662e 7265 706c 6163 6528   = self.replace(
+000063f0: 696e 7465 7270 6f6c 6174 696f 6e5f 7661  interpolation_va
+00006400: 722c 2026 7361 6d70 6c65 5f70 6f69 6e74  r, &sample_point
+00006410: 293b 0a20 2020 2020 2020 2020 2020 2069  );.            i
+00006420: 202b 3d20 313b 0a20 2020 2020 2020 207d   += 1;.        }
+00006430: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
+00006440: 7420 6420 3d20 7365 6c66 2e64 6567 7265  t d = self.degre
+00006450: 6528 696e 7465 7270 6f6c 6174 696f 6e5f  e(interpolation_
+00006460: 7661 7229 2e74 6f5f 7533 3228 293b 0a0a  var).to_u32();..
+00006470: 2020 2020 2020 2020 6c65 7420 7368 6966          let shif
+00006480: 7465 645f 706f 6c79 203d 2069 6620 2146  ted_poly = if !F
+00006490: 696e 6974 6546 6965 6c64 3a3a 3c55 4669  initeField::<UFi
+000064a0: 656c 643e 3a3a 6973 5f7a 6572 6f28 2673  eld>::is_zero(&s
+000064b0: 616d 706c 655f 706f 696e 7429 207b 0a20  ample_point) {. 
+000064c0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000064d0: 7368 6966 745f 7661 725f 6361 6368 6564  shift_var_cached
+000064e0: 2869 6e74 6572 706f 6c61 7469 6f6e 5f76  (interpolation_v
+000064f0: 6172 2c20 2673 616d 706c 655f 706f 696e  ar, &sample_poin
+00006500: 7429 0a20 2020 2020 2020 207d 2065 6c73  t).        } els
+00006510: 6520 7b0a 2020 2020 2020 2020 2020 2020  e {.            
+00006520: 7365 6c66 2e63 6c6f 6e65 2829 0a20 2020  self.clone().   
+00006530: 2020 2020 207d 3b0a 0a20 2020 2020 2020       };..       
+00006540: 206c 6574 2066 7320 3d20 756e 695f 662e   let fs = uni_f.
+00006550: 6661 6374 6f72 5f64 6973 7469 6e63 745f  factor_distinct_
+00006560: 6571 7561 6c5f 6465 6772 6565 2829 3b0a  equal_degree();.
+00006570: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00006580: 206c 636f 6566 6620 3d20 7368 6966 7465   lcoeff = shifte
+00006590: 645f 706f 6c79 2e6c 636f 6566 665f 6c61  d_poly.lcoeff_la
+000065a0: 7374 5f76 6172 6f72 6465 7228 265b 6d61  st_varorder(&[ma
+000065b0: 696e 5f76 6172 2c20 696e 7465 7270 6f6c  in_var, interpol
+000065c0: 6174 696f 6e5f 7661 725d 293b 0a20 2020  ation_var]);.   
+000065d0: 2020 2020 206c 6574 206d 7574 206c 635f       let mut lc_
+000065e0: 6420 3d20 6c63 6f65 6666 2e64 6567 7265  d = lcoeff.degre
+000065f0: 6528 696e 7465 7270 6f6c 6174 696f 6e5f  e(interpolation_
+00006600: 7661 7229 2e74 6f5f 7533 3228 293b 0a0a  var).to_u32();..
+00006610: 2020 2020 2020 2020 6c65 7420 6974 6572          let iter
+00006620: 203d 2028 6420 2b20 6c63 5f64 202b 2031   = (d + lc_d + 1
+00006630: 2920 6173 2075 7369 7a65 3b0a 2020 2020  ) as usize;.    
+00006640: 2020 2020 6c65 7420 6d75 7420 6661 6374      let mut fact
+00006650: 6f72 7320 3d0a 2020 2020 2020 2020 2020  ors =.          
+00006660: 2020 7368 6966 7465 645f 706f 6c79 2e62    shifted_poly.b
+00006670: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
+00006680: 6c69 6674 5f62 6572 6e61 7264 696e 2869  lift_bernardin(i
+00006690: 6e74 6572 706f 6c61 7469 6f6e 5f76 6172  nterpolation_var
+000066a0: 2c20 266c 636f 6566 662c 2026 6673 2c20  , &lcoeff, &fs, 
+000066b0: 6974 6572 293b 0a0a 2020 2020 2020 2020  iter);..        
+000066c0: 6661 6374 6f72 732e 7377 6170 5f72 656d  factors.swap_rem
+000066d0: 6f76 6528 3029 3b20 2f2f 2072 656d 6f76  ove(0); // remov
+000066e0: 6520 7468 6520 6c63 6f65 6666 0a0a 2020  e the lcoeff..  
+000066f0: 2020 2020 2020 6c65 7420 6d75 7420 7265        let mut re
+00006700: 635f 6661 6374 6f72 7320 3d20 7665 6321  c_factors = vec!
+00006710: 5b5d 3b0a 2020 2020 2020 2020 2f2f 2066  [];.        // f
+00006720: 6163 746f 7220 7265 636f 6d62 696e 6174  actor recombinat
+00006730: 696f 6e0a 2020 2020 2020 2020 6c65 7420  ion.        let 
+00006740: 6d75 7420 7320 3d20 313b 0a0a 2020 2020  mut s = 1;..    
+00006750: 2020 2020 6c65 7420 6d75 7420 7265 7374      let mut rest
+00006760: 203d 2073 6869 6674 6564 5f70 6f6c 793b   = shifted_poly;
+00006770: 0a20 2020 2020 2020 2027 6c65 6e3a 2077  .        'len: w
+00006780: 6869 6c65 2032 202a 2073 203c 3d20 6661  hile 2 * s <= fa
+00006790: 6374 6f72 732e 6c65 6e28 2920 7b0a 2020  ctors.len() {.  
+000067a0: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
+000067b0: 7420 6673 203d 2043 6f6d 6269 6e61 7469  t fs = Combinati
+000067c0: 6f6e 4974 6572 6174 6f72 3a3a 6e65 7728  onIterator::new(
+000067d0: 6661 6374 6f72 732e 6c65 6e28 292c 2073  factors.len(), s
+000067e0: 293b 0a20 2020 2020 2020 2020 2020 2077  );.            w
+000067f0: 6869 6c65 206c 6574 2053 6f6d 6528 6373  hile let Some(cs
+00006800: 2920 3d20 6673 2e6e 6578 7428 2920 7b0a  ) = fs.next() {.
+00006810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006820: 2f2f 2054 4f44 4f3a 206d 756c 7469 706c  // TODO: multipl
+00006830: 7920 696e 2074 6865 206c 6561 6469 6e67  y in the leading
+00006840: 2063 6f65 6666 6963 6965 6e74 2068 6572   coefficient her
+00006850: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00006860: 2020 202f 2f20 7468 656e 2077 6520 6361     // then we ca
+00006870: 6e20 736b 6970 2074 6865 2050 6164 6520  n skip the Pade 
+00006880: 6170 7072 6f78 696d 6174 696f 6e20 616e  approximation an
+00006890: 6420 7265 6475 6365 2074 6865 0a20 2020  d reduce the.   
+000068a0: 2020 2020 2020 2020 2020 2020 202f 2f20               // 
+000068b0: 6e75 6d62 6572 206f 6620 6974 6572 6174  number of iterat
+000068c0: 696f 6e73 2069 6e20 7468 6520 4865 6e73  ions in the Hens
+000068d0: 656c 206c 6966 7469 6e67 2074 6f20 6420  el lifting to d 
+000068e0: 2b20 312c 206c 696b 6520 696e 2074 6865  + 1, like in the
+000068f0: 2069 6e74 6567 6572 2063 6173 653f 0a20   integer case?. 
+00006900: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00006910: 6574 206d 7574 2067 203d 2072 6573 742e  et mut g = rest.
+00006920: 636f 6e73 7461 6e74 2872 6573 742e 6c63  constant(rest.lc
+00006930: 6f65 6666 2829 293b 0a20 2020 2020 2020  oeff());.       
+00006940: 2020 2020 2020 2020 2066 6f72 2028 692c           for (i,
+00006950: 2066 2920 696e 2066 6163 746f 7273 2e69   f) in factors.i
+00006960: 7465 7228 292e 656e 756d 6572 6174 6528  ter().enumerate(
+00006970: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00006980: 2020 2020 2020 2020 6966 2063 732e 636f          if cs.co
+00006990: 6e74 6169 6e73 2826 6929 207b 0a20 2020  ntains(&i) {.   
+000069a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000069b0: 2020 2020 2067 203d 2028 2667 202a 2066       g = (&g * f
+000069c0: 292e 6d6f 645f 7661 7228 696e 7465 7270  ).mod_var(interp
+000069d0: 6f6c 6174 696f 6e5f 7661 722c 2045 3a3a  olation_var, E::
+000069e0: 6672 6f6d 5f75 3332 2869 7465 7220 6173  from_u32(iter as
+000069f0: 2075 3332 202b 2031 2929 3b0a 2020 2020   u32 + 1));.    
+00006a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006a10: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+00006a20: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
+00006a30: 2020 2020 206c 6574 2079 5f70 6f6c 7973       let y_polys
+00006a40: 3a20 5665 633c 5f3e 203d 2067 0a20 2020  : Vec<_> = g.   
+00006a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006a60: 202e 746f 5f75 6e69 7661 7269 6174 655f   .to_univariate_
+00006a70: 706f 6c79 6e6f 6d69 616c 5f6c 6973 7428  polynomial_list(
+00006a80: 6d61 696e 5f76 6172 290a 2020 2020 2020  main_var).      
+00006a90: 2020 2020 2020 2020 2020 2020 2020 2e69                .i
+00006aa0: 6e74 6f5f 6974 6572 2829 0a20 2020 2020  nto_iter().     
+00006ab0: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00006ac0: 6d61 7028 7c28 782c 205f 297c 2078 290a  map(|(x, _)| x).
+00006ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006ae0: 2020 2020 2e63 6f6c 6c65 6374 2829 3b0a      .collect();.
+00006af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006b00: 206c 6574 206d 7574 2067 5f6c 636f 6566   let mut g_lcoef
+00006b10: 6620 3d20 5365 6c66 3a3a 6c63 6f65 6666  f = Self::lcoeff
+00006b20: 5f72 6563 6f6e 7374 7275 6374 2826 795f  _reconstruct(&y_
+00006b30: 706f 6c79 732c 2064 2c20 6c63 5f64 293b  polys, d, lc_d);
+00006b40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006b50: 2067 203d 2028 2667 202a 2026 675f 6c63   g = (&g * &g_lc
+00006b60: 6f65 6666 290a 2020 2020 2020 2020 2020  oeff).          
+00006b70: 2020 2020 2020 2020 2020 2e6d 6f64 5f76            .mod_v
+00006b80: 6172 2869 6e74 6572 706f 6c61 7469 6f6e  ar(interpolation
+00006b90: 5f76 6172 2c20 453a 3a66 726f 6d5f 7533  _var, E::from_u3
+00006ba0: 3228 6420 2b20 3129 290a 2020 2020 2020  2(d + 1)).      
+00006bb0: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
+00006bc0: 616b 655f 6d6f 6e69 6328 293b 0a0a 2020  ake_monic();..  
+00006bd0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+00006be0: 7420 2868 2c20 7229 203d 2072 6573 742e  t (h, r) = rest.
+00006bf0: 7175 6f74 5f72 656d 2826 672c 2074 7275  quot_rem(&g, tru
+00006c00: 6529 3b0a 0a20 2020 2020 2020 2020 2020  e);..           
+00006c10: 2020 2020 2069 6620 722e 6973 5f7a 6572       if r.is_zer
+00006c20: 6f28 2920 7b0a 2020 2020 2020 2020 2020  o() {.          
+00006c30: 2020 2020 2020 2020 2020 7265 635f 6661            rec_fa
+00006c40: 6374 6f72 732e 7075 7368 2867 293b 0a0a  ctors.push(g);..
+00006c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006c60: 2020 2020 666f 7220 6920 696e 2063 732e      for i in cs.
+00006c70: 6974 6572 2829 2e72 6576 2829 207b 0a20  iter().rev() {. 
+00006c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006c90: 2020 2020 2020 2066 6163 746f 7273 2e72         factors.r
+00006ca0: 656d 6f76 6528 2a69 293b 0a20 2020 2020  emove(*i);.     
+00006cb0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00006cc0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00006cd0: 2020 2020 2020 7265 7374 203d 2068 3b0a        rest = h;.
+00006ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006cf0: 2020 2020 6c63 6f65 6666 203d 206c 636f      lcoeff = lco
+00006d00: 6566 662e 7175 6f74 5f72 656d 5f75 6e69  eff.quot_rem_uni
+00006d10: 7661 7269 6174 6528 266d 7574 2067 5f6c  variate(&mut g_l
+00006d20: 636f 6566 6629 2e30 3b0a 2020 2020 2020  coeff).0;.      
+00006d30: 2020 2020 2020 2020 2020 2020 2020 6c63                lc
+00006d40: 5f64 203d 206c 636f 6566 662e 6465 6772  _d = lcoeff.degr
+00006d50: 6565 2869 6e74 6572 706f 6c61 7469 6f6e  ee(interpolation
+00006d60: 5f76 6172 292e 746f 5f75 3332 2829 3b0a  _var).to_u32();.
+00006d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d80: 2020 2020 6420 3d20 7265 7374 2e64 6567      d = rest.deg
+00006d90: 7265 6528 696e 7465 7270 6f6c 6174 696f  ree(interpolatio
+00006da0: 6e5f 7661 7229 2e74 6f5f 7533 3228 293b  n_var).to_u32();
+00006db0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00006dc0: 2020 2020 2020 636f 6e74 696e 7565 2027        continue '
+00006dd0: 6c65 6e3b 0a20 2020 2020 2020 2020 2020  len;.           
+00006de0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00006df0: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+00006e00: 2020 7320 2b3d 2031 3b0a 2020 2020 2020    s += 1;.      
+00006e10: 2020 7d0a 0a20 2020 2020 2020 2072 6563    }..        rec
+00006e20: 5f66 6163 746f 7273 2e70 7573 6828 7265  _factors.push(re
+00006e30: 7374 293b 0a0a 2020 2020 2020 2020 6966  st);..        if
+00006e40: 2021 4669 6e69 7465 4669 656c 643a 3a3c   !FiniteField::<
+00006e50: 5546 6965 6c64 3e3a 3a69 735f 7a65 726f  UField>::is_zero
+00006e60: 2826 7361 6d70 6c65 5f70 6f69 6e74 2920  (&sample_point) 
+00006e70: 7b0a 2020 2020 2020 2020 2020 2020 666f  {.            fo
+00006e80: 7220 7820 696e 2026 6d75 7420 7265 635f  r x in &mut rec_
+00006e90: 6661 6374 6f72 7320 7b0a 2020 2020 2020  factors {.      
+00006ea0: 2020 2020 2020 2020 2020 2f2f 2073 6869            // shi
+00006eb0: 6674 2074 6865 2070 6f6c 796e 6f6d 6961  ft the polynomia
+00006ec0: 6c20 746f 2079 202d 2073 616d 706c 650a  l to y - sample.
+00006ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006ee0: 2a78 203d 2078 2e73 6869 6674 5f76 6172  *x = x.shift_var
+00006ef0: 5f63 6163 6865 6428 696e 7465 7270 6f6c  _cached(interpol
+00006f00: 6174 696f 6e5f 7661 722c 2026 7365 6c66  ation_var, &self
+00006f10: 2e66 6965 6c64 2e6e 6567 2826 7361 6d70  .field.neg(&samp
+00006f20: 6c65 5f70 6f69 6e74 2929 3b0a 2020 2020  le_point));.    
+00006f30: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00006f40: 2020 7d0a 0a20 2020 2020 2020 2072 6563    }..        rec
+00006f50: 5f66 6163 746f 7273 0a20 2020 207d 0a0a  _factors.    }..
+00006f60: 2020 2020 2f2f 2f20 5265 636f 6e73 7472      /// Reconstr
+00006f70: 7563 7420 7468 6520 6c65 6164 696e 6720  uct the leading 
+00006f80: 636f 6566 6669 6369 656e 7420 7573 696e  coefficient usin
+00006f90: 6720 6120 5061 6465 2061 7070 726f 7869  g a Pade approxi
+00006fa0: 6d61 7469 6f6e 2077 6974 6820 6e75 6d65  mation with nume
+00006fb0: 7261 746f 7220 6465 6772 6565 2060 6465  rator degree `de
+00006fc0: 675f 6e60 2061 6e64 0a20 2020 202f 2f2f  g_n` and.    ///
+00006fd0: 2064 656e 6f6d 696e 6174 6f72 2064 6567   denominator deg
+00006fe0: 7265 6520 6064 6567 5f64 602e 2054 6865  ree `deg_d`. The
+00006ff0: 2072 6573 756c 7469 6e67 2064 656e 6f6d   resulting denom
+00007000: 696e 6174 6f72 2073 686f 756c 6420 6265  inator should be
+00007010: 2061 2066 6163 746f 7220 6f66 2074 6865   a factor of the
+00007020: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
+00007030: 6965 6e74 2e0a 2020 2020 666e 206c 636f  ient..    fn lco
+00007040: 6566 665f 7265 636f 6e73 7472 7563 7428  eff_reconstruct(
+00007050: 636f 6566 6673 3a20 265b 5365 6c66 5d2c  coeffs: &[Self],
+00007060: 2064 6567 5f6e 3a20 7533 322c 2064 6567   deg_n: u32, deg
+00007070: 5f64 3a20 7533 3229 202d 3e20 5365 6c66  _d: u32) -> Self
+00007080: 207b 0a20 2020 2020 2020 206c 6574 206d   {.        let m
+00007090: 7574 206c 636f 6566 6620 3d20 636f 6566  ut lcoeff = coef
+000070a0: 6673 5b30 5d2e 636f 6e73 7461 6e74 2863  fs[0].constant(c
+000070b0: 6f65 6666 735b 305d 2e66 6965 6c64 2e6f  oeffs[0].field.o
+000070c0: 6e65 2829 293b 0a20 2020 2020 2020 2066  ne());.        f
+000070d0: 6f72 2078 2069 6e20 636f 6566 6673 207b  or x in coeffs {
+000070e0: 0a20 2020 2020 2020 2020 2020 206c 6574  .            let
+000070f0: 2064 203d 2078 2e72 6174 696f 6e61 6c5f   d = x.rational_
+00007100: 6170 7072 6f78 696d 616e 745f 756e 6976  approximant_univ
+00007110: 6172 6961 7465 2864 6567 5f6e 2c20 6465  ariate(deg_n, de
+00007120: 675f 6429 2e75 6e77 7261 7028 292e 313b  g_d).unwrap().1;
+00007130: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00007140: 2164 2e69 735f 6f6e 6528 2920 7b0a 2020  !d.is_one() {.  
+00007150: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+00007160: 7420 6720 3d20 642e 6763 6428 266c 636f  t g = d.gcd(&lco
+00007170: 6566 6629 3b0a 2020 2020 2020 2020 2020  eff);.          
+00007180: 2020 2020 2020 6c63 6f65 6666 203d 206c        lcoeff = l
+00007190: 636f 6566 6620 2a20 2628 6420 2f20 2667  coeff * &(d / &g
+000071a0: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
+000071b0: 0a20 2020 2020 2020 207d 0a20 2020 2020  .        }.     
+000071c0: 2020 206c 636f 6566 660a 2020 2020 7d0a     lcoeff.    }.
+000071d0: 0a20 2020 202f 2f2f 2053 6f72 7420 7468  .    /// Sort th
+000071e0: 6520 6269 7661 7269 6174 6520 6661 6374  e bivariate fact
+000071f0: 6f72 7320 6261 7365 6420 6f6e 2074 6865  ors based on the
+00007200: 6972 2075 6e69 7661 7269 6174 6520 696d  ir univariate im
+00007210: 6167 6520 736f 2074 6861 7420 7468 6579  age so that they
+00007220: 2061 7265 0a20 2020 202f 2f2f 2061 6c69   are.    /// ali
+00007230: 676e 6564 2062 6574 7765 656e 2074 6865  gned between the
+00007240: 2064 6966 6665 7265 6e74 2076 6172 732e   different vars.
+00007250: 0a20 2020 2066 6e20 6361 6e6f 6e69 6361  .    fn canonica
+00007260: 6c5f 736f 7274 280a 2020 2020 2020 2020  l_sort(.        
+00007270: 6269 765f 706f 6c79 733a 2026 5b53 656c  biv_polys: &[Sel
+00007280: 665d 2c0a 2020 2020 2020 2020 7265 706c  f],.        repl
+00007290: 6163 655f 7661 723a 2075 7369 7a65 2c0a  ace_var: usize,.
+000072a0: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
+000072b0: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
+000072c0: 203c 4669 6e69 7465 4669 656c 643c 5546   <FiniteField<UF
+000072d0: 6965 6c64 3e20 6173 2052 696e 673e 3a3a  ield> as Ring>::
+000072e0: 456c 656d 656e 7429 5d2c 0a20 2020 2029  Element)],.    )
+000072f0: 202d 3e20 5665 633c 2853 656c 662c 203c   -> Vec<(Self, <
+00007300: 4669 6e69 7465 4669 656c 643c 5546 6965  FiniteField<UFie
+00007310: 6c64 3e20 6173 2052 696e 673e 3a3a 456c  ld> as Ring>::El
+00007320: 656d 656e 742c 2053 656c 6629 3e20 7b0a  ement, Self)> {.
+00007330: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00007340: 756e 6976 6172 6961 7465 5f66 6163 746f  univariate_facto
+00007350: 7273 203d 2062 6976 5f70 6f6c 7973 0a20  rs = biv_polys. 
+00007360: 2020 2020 2020 2020 2020 202e 6974 6572             .iter
+00007370: 2829 0a20 2020 2020 2020 2020 2020 202e  ().            .
+00007380: 6d61 7028 7c66 7c20 7b0a 2020 2020 2020  map(|f| {.      
+00007390: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
+000073a0: 7420 7520 3d20 662e 636c 6f6e 6528 293b  t u = f.clone();
+000073b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000073c0: 2066 6f72 2028 762c 2070 2920 696e 2073   for (v, p) in s
+000073d0: 616d 706c 655f 706f 696e 7473 207b 0a20  ample_points {. 
+000073e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000073f0: 2020 2069 6620 2a76 203d 3d20 7265 706c     if *v == repl
+00007400: 6163 655f 7661 7220 7b0a 2020 2020 2020  ace_var {.      
+00007410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007420: 2020 7520 3d20 752e 7265 706c 6163 6528    u = u.replace(
+00007430: 2a76 2c20 7029 3b0a 2020 2020 2020 2020  *v, p);.        
+00007440: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00007450: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+00007460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007470: 2028 662e 636c 6f6e 6528 292c 2075 2e6c   (f.clone(), u.l
+00007480: 636f 6566 6628 292c 2075 2e6d 616b 655f  coeff(), u.make_
+00007490: 6d6f 6e69 6328 2929 0a20 2020 2020 2020  monic()).       
+000074a0: 2020 2020 207d 290a 2020 2020 2020 2020       }).        
+000074b0: 2020 2020 2e63 6f6c 6c65 6374 3a3a 3c56      .collect::<V
+000074c0: 6563 3c5f 3e3e 2829 3b0a 2020 2020 2020  ec<_>>();.      
+000074d0: 2020 756e 6976 6172 6961 7465 5f66 6163    univariate_fac
+000074e0: 746f 7273 2e73 6f72 745f 6279 287c 285f  tors.sort_by(|(_
+000074f0: 2c20 5f2c 2061 292c 2028 5f2c 205f 2c20  , _, a), (_, _, 
+00007500: 6229 7c20 7b0a 2020 2020 2020 2020 2020  b)| {.          
+00007510: 2020 612e 6578 706f 6e65 6e74 730a 2020    a.exponents.  
+00007520: 2020 2020 2020 2020 2020 2020 2020 2e63                .c
+00007530: 6d70 2826 622e 6578 706f 6e65 6e74 7329  mp(&b.exponents)
+00007540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007550: 202e 7468 656e 2861 2e63 6f65 6666 6963   .then(a.coeffic
+00007560: 6965 6e74 732e 7061 7274 6961 6c5f 636d  ients.partial_cm
+00007570: 7028 2662 2e63 6f65 6666 6963 6965 6e74  p(&b.coefficient
+00007580: 7329 2e75 6e77 7261 7028 2929 0a20 2020  s).unwrap()).   
+00007590: 2020 2020 207d 293b 0a0a 2020 2020 2020       });..      
+000075a0: 2020 756e 6976 6172 6961 7465 5f66 6163    univariate_fac
+000075b0: 746f 7273 0a20 2020 207d 0a0a 2020 2020  tors.    }..    
+000075c0: 2f2f 2f20 5072 6563 6f6d 7075 7465 2074  /// Precompute t
+000075d0: 6865 206c 6561 6469 6e67 2063 6f65 6666  he leading coeff
+000075e0: 6963 6965 6e74 7320 6f66 2074 6865 2070  icients of the p
+000075f0: 6f6c 796e 6f6d 6961 6c20 6661 6374 6f72  olynomial factor
+00007600: 732c 2075 7369 6e67 2061 6e0a 2020 2020  s, using an.    
+00007610: 2f2f 2f20 6164 6170 7465 6420 7665 7273  /// adapted vers
+00007620: 696f 6e20 6f66 204b 616c 746f 6665 6e27  ion of Kaltofen'
+00007630: 7320 616c 676f 7269 7468 6d20 7468 6174  s algorithm that
+00007640: 2068 6173 206d 6f64 6966 6963 6174 696f   has modificatio
+00007650: 6e73 206f 6620 4d61 7274 696e 204c 6565  ns of Martin Lee
+00007660: 2061 6e64 2053 7461 6e69 736c 6176 2050   and Stanislav P
+00007670: 6f73 6c61 7673 6b79 2e0a 2020 2020 666e  oslavsky..    fn
+00007680: 206c 636f 6566 665f 7072 6563 6f6d 7075   lcoeff_precompu
+00007690: 7461 7469 6f6e 280a 2020 2020 2020 2020  tation(.        
+000076a0: 2673 656c 662c 0a20 2020 2020 2020 2062  &self,.        b
+000076b0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+000076c0: 3a20 265b 5365 6c66 5d2c 0a20 2020 2020  : &[Self],.     
+000076d0: 2020 2073 616d 706c 655f 706f 696e 7473     sample_points
+000076e0: 3a20 265b 2875 7369 7a65 2c20 3c46 696e  : &[(usize, <Fin
+000076f0: 6974 6546 6965 6c64 3c55 4669 656c 643e  iteField<UField>
+00007700: 2061 7320 5269 6e67 3e3a 3a45 6c65 6d65   as Ring>::Eleme
+00007710: 6e74 295d 2c0a 2020 2020 2020 2020 6f72  nt)],.        or
+00007720: 6465 723a 2026 5b75 7369 7a65 5d2c 0a20  der: &[usize],. 
+00007730: 2020 2029 202d 3e20 5265 7375 6c74 3c28     ) -> Result<(
+00007740: 5665 633c 5365 6c66 3e2c 2056 6563 3c53  Vec<Self>, Vec<S
+00007750: 656c 663e 292c 2075 7369 7a65 3e20 7b0a  elf>), usize> {.
+00007760: 2020 2020 2020 2020 6c65 7420 6c63 6f65          let lcoe
+00007770: 6666 203d 2073 656c 662e 756e 6976 6172  ff = self.univar
+00007780: 6961 7465 5f6c 636f 6566 6628 6f72 6465  iate_lcoeff(orde
+00007790: 725b 305d 293b 0a20 2020 2020 2020 206c  r[0]);.        l
+000077a0: 6574 2073 7166 203d 206c 636f 6566 662e  et sqf = lcoeff.
+000077b0: 7371 7561 7265 5f66 7265 655f 6661 6374  square_free_fact
+000077c0: 6f72 697a 6174 696f 6e28 293b 0a0a 2020  orization();..  
+000077d0: 2020 2020 2020 6c65 7420 6d75 7420 6c63        let mut lc
+000077e0: 6f65 6666 5f73 7175 6172 655f 6672 6565  oeff_square_free
+000077f0: 203d 2073 656c 662e 6f6e 6528 293b 0a20   = self.one();. 
+00007800: 2020 2020 2020 2066 6f72 2028 662c 205f         for (f, _
+00007810: 2920 696e 2026 7371 6620 7b0a 2020 2020  ) in &sqf {.    
+00007820: 2020 2020 2020 2020 6c63 6f65 6666 5f73          lcoeff_s
+00007830: 7175 6172 655f 6672 6565 203d 206c 636f  quare_free = lco
+00007840: 6566 665f 7371 7561 7265 5f66 7265 6520  eff_square_free 
+00007850: 2a20 663b 0a20 2020 2020 2020 207d 0a0a  * f;.        }..
+00007860: 2020 2020 2020 2020 6c65 7420 736f 7274          let sort
+00007870: 6564 5f6d 6169 6e5f 6661 6374 6f72 7320  ed_main_factors 
+00007880: 3d20 5365 6c66 3a3a 6361 6e6f 6e69 6361  = Self::canonica
+00007890: 6c5f 736f 7274 2862 6976 6172 6961 7465  l_sort(bivariate
+000078a0: 5f66 6163 746f 7273 2c20 6f72 6465 725b  _factors, order[
+000078b0: 315d 2c20 7361 6d70 6c65 5f70 6f69 6e74  1], sample_point
+000078c0: 7329 3b0a 0a20 2020 2020 2020 206c 6574  s);..        let
+000078d0: 206d 7574 2074 7275 655f 6c63 6f65 6666   mut true_lcoeff
+000078e0: 733a 2056 6563 3c5f 3e20 3d20 736f 7274  s: Vec<_> = sort
+000078f0: 6564 5f6d 6169 6e5f 6661 6374 6f72 730a  ed_main_factors.
+00007900: 2020 2020 2020 2020 2020 2020 2e69 7465              .ite
+00007910: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
+00007920: 2e6d 6170 287c 285f 2c20 752c 205f 297c  .map(|(_, u, _)|
+00007930: 2073 656c 662e 636f 6e73 7461 6e74 2875   self.constant(u
+00007940: 2e63 6c6f 6e65 2829 2929 0a20 2020 2020  .clone())).     
+00007950: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+00007960: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
+00007970: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
+00007980: 6163 746f 7273 3a20 5665 633c 5f3e 203d  actors: Vec<_> =
+00007990: 0a20 2020 2020 2020 2020 2020 2073 6f72  .            sor
+000079a0: 7465 645f 6d61 696e 5f66 6163 746f 7273  ted_main_factors
+000079b0: 2e69 6e74 6f5f 6974 6572 2829 2e6d 6170  .into_iter().map
+000079c0: 287c 2866 2c20 5f2c 205f 297c 2066 292e  (|(f, _, _)| f).
+000079d0: 636f 6c6c 6563 7428 293b 0a0a 2020 2020  collect();..    
+000079e0: 2020 2020 6c65 7420 6d75 7420 6c63 6f65      let mut lcoe
+000079f0: 6666 5f6c 6566 7420 3d20 6c63 6f65 6666  ff_left = lcoeff
+00007a00: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
+00007a10: 2020 666f 7220 6620 696e 2026 7472 7565    for f in &true
+00007a20: 5f6c 636f 6566 6673 207b 0a20 2020 2020  _lcoeffs {.     
+00007a30: 2020 2020 2020 206c 636f 6566 665f 6c65         lcoeff_le
+00007a40: 6674 203d 206c 636f 6566 665f 6c65 6674  ft = lcoeff_left
+00007a50: 202f 2066 3b0a 2020 2020 2020 2020 7d0a   / f;.        }.
+00007a60: 0a20 2020 2020 2020 202f 2f20 544f 444f  .        // TODO
+00007a70: 3a20 736d 6172 7465 7220 6f72 6465 7269  : smarter orderi
+00007a80: 6e67 0a20 2020 2020 2020 2066 6f72 2028  ng.        for (
+00007a90: 692c 2026 7661 7229 2069 6e20 6f72 6465  i, &var) in orde
+00007aa0: 725b 312e 2e5d 2e69 7465 7228 292e 656e  r[1..].iter().en
+00007ab0: 756d 6572 6174 6528 2920 7b0a 2020 2020  umerate() {.    
+00007ac0: 2020 2020 2020 2020 6966 206c 636f 6566          if lcoef
+00007ad0: 665f 6c65 6674 2e69 735f 6f6e 6528 2920  f_left.is_one() 
+00007ae0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00007af0: 2020 6272 6561 6b3b 0a20 2020 2020 2020    break;.       
+00007b00: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00007b10: 2020 2020 6966 206c 636f 6566 665f 6c65      if lcoeff_le
+00007b20: 6674 2e64 6567 7265 6528 7661 7229 2e69  ft.degree(var).i
+00007b30: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
+00007b40: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+00007b50: 6e75 653b 0a20 2020 2020 2020 2020 2020  nue;.           
+00007b60: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
+00007b70: 2f2f 206f 6e6c 7920 636f 6e73 7472 7563  // only construc
+00007b80: 7420 6661 6374 6f72 7320 7468 6174 2064  t factors that d
+00007b90: 6570 656e 6420 6f6e 2076 6172 0a20 2020  epend on var.   
+00007ba0: 2020 2020 2020 2020 206c 6574 2063 203d           let c =
+00007bb0: 206c 636f 6566 665f 7371 7561 7265 5f66   lcoeff_square_f
+00007bc0: 7265 652e 756e 6976 6172 6961 7465 5f63  ree.univariate_c
+00007bd0: 6f6e 7465 6e74 2876 6172 293b 0a20 2020  ontent(var);.   
+00007be0: 2020 2020 2020 2020 202f 2f20 6d61 6b65           // make
+00007bf0: 2073 7572 6520 7468 6174 2074 6865 2063   sure that the c
+00007c00: 6f6e 7465 6e74 2072 656d 6f76 616c 2064  ontent removal d
+00007c10: 6f65 7320 6e6f 7420 6368 616e 6765 2074  oes not change t
+00007c20: 6865 2075 6e69 740a 2020 2020 2020 2020  he unit.        
+00007c30: 2020 2020 6c65 7420 6d75 7420 635f 6576      let mut c_ev
+00007c40: 616c 203d 2063 2e63 6c6f 6e65 2829 3b0a  al = c.clone();.
+00007c50: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00007c60: 2876 2c20 7029 2069 6e20 7361 6d70 6c65  (v, p) in sample
+00007c70: 5f70 6f69 6e74 7320 7b0a 2020 2020 2020  _points {.      
+00007c80: 2020 2020 2020 2020 2020 635f 6576 616c            c_eval
+00007c90: 203d 2063 5f65 7661 6c2e 7265 706c 6163   = c_eval.replac
+00007ca0: 6528 2a76 2c20 7029 3b0a 2020 2020 2020  e(*v, p);.      
+00007cb0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00007cc0: 2020 2020 206c 6574 206c 636f 6566 665f       let lcoeff_
+00007cd0: 7371 7561 7265 5f66 7265 655f 7070 203d  square_free_pp =
+00007ce0: 2026 6c63 6f65 6666 5f73 7175 6172 655f   &lcoeff_square_
+00007cf0: 6672 6565 202f 2026 6320 2a20 2663 5f65  free / &c * &c_e
+00007d00: 7661 6c3b 0a20 2020 2020 2020 2020 2020  val;.           
+00007d10: 2064 6562 7567 2128 2243 6f6e 7465 6e74   debug!("Content
+00007d20: 2d66 7265 6520 6c63 7371 6620 7b7d 222c  -free lcsqf {}",
+00007d30: 206c 636f 6566 665f 7371 7561 7265 5f66   lcoeff_square_f
+00007d40: 7265 655f 7070 293b 0a0a 2020 2020 2020  ree_pp);..      
+00007d50: 2020 2020 2020 2f2f 2063 6865 636b 2069        // check i
+00007d60: 6620 7468 6520 6576 616c 7561 7465 6420  f the evaluated 
+00007d70: 6c65 6164 696e 6720 636f 6566 6669 6369  leading coeffici
+00007d80: 656e 7420 7265 6d61 696e 7320 7371 7561  ent remains squa
+00007d90: 7265 2066 7265 650a 2020 2020 2020 2020  re free.        
+00007da0: 2020 2020 6c65 7420 6d75 7420 706f 6c79      let mut poly
+00007db0: 5f65 7661 6c20 3d20 6c63 6f65 6666 5f73  _eval = lcoeff_s
+00007dc0: 7175 6172 655f 6672 6565 5f70 702e 636c  quare_free_pp.cl
+00007dd0: 6f6e 6528 293b 0a20 2020 2020 2020 2020  one();.         
+00007de0: 2020 2066 6f72 2028 762c 2070 2920 696e     for (v, p) in
+00007df0: 2073 616d 706c 655f 706f 696e 7473 207b   sample_points {
+00007e00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007e10: 2069 6620 2a76 2021 3d20 7661 7220 7b0a   if *v != var {.
+00007e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e30: 2020 2020 706f 6c79 5f65 7661 6c20 3d20      poly_eval = 
+00007e40: 706f 6c79 5f65 7661 6c2e 7265 706c 6163  poly_eval.replac
+00007e50: 6528 2a76 2c20 7029 3b0a 2020 2020 2020  e(*v, p);.      
+00007e60: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00007e70: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00007e80: 2020 2020 2020 6c65 7420 7371 6620 3d20        let sqf = 
+00007e90: 706f 6c79 5f65 7661 6c2e 7371 7561 7265  poly_eval.square
+00007ea0: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
+00007eb0: 696f 6e28 293b 0a20 2020 2020 2020 2020  ion();.         
+00007ec0: 2020 2069 6620 7371 662e 6c65 6e28 2920     if sqf.len() 
+00007ed0: 213d 2031 207c 7c20 7371 665b 305d 2e31  != 1 || sqf[0].1
+00007ee0: 2021 3d20 3120 7b0a 2020 2020 2020 2020   != 1 {.        
+00007ef0: 2020 2020 2020 2020 6465 6275 6721 2822          debug!("
+00007f00: 506f 6c79 6e6f 6d69 616c 2069 7320 6e6f  Polynomial is no
+00007f10: 7420 7371 7561 7265 2066 7265 653a 207b  t square free: {
+00007f20: 7d22 2c20 706f 6c79 5f65 7661 6c29 3b0a  }", poly_eval);.
+00007f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f40: 7265 7475 726e 2045 7272 286d 6169 6e5f  return Err(main_
+00007f50: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+00007f60: 732e 6c65 6e28 2929 3b0a 2020 2020 2020  s.len());.      
+00007f70: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00007f80: 2020 2020 206c 6574 2062 6976 6172 6961       let bivaria
+00007f90: 7465 5f66 6163 746f 7273 203d 2069 6620  te_factors = if 
+00007fa0: 7661 7220 3d3d 206f 7264 6572 5b31 5d20  var == order[1] 
+00007fb0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00007fc0: 2020 6d61 696e 5f62 6976 6172 6961 7465    main_bivariate
+00007fd0: 5f66 6163 746f 7273 2e74 6f5f 7665 6328  _factors.to_vec(
+00007fe0: 290a 2020 2020 2020 2020 2020 2020 7d20  ).            } 
+00007ff0: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
+00008000: 2020 2020 2020 206c 6574 206d 7574 2070         let mut p
+00008010: 6f6c 795f 6576 616c 203d 2073 656c 662e  oly_eval = self.
+00008020: 636c 6f6e 6528 293b 0a20 2020 2020 2020  clone();.       
+00008030: 2020 2020 2020 2020 2066 6f72 2028 762c           for (v,
+00008040: 2070 2920 696e 2073 616d 706c 655f 706f   p) in sample_po
+00008050: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
+00008060: 2020 2020 2020 2020 2020 2069 6620 2a76             if *v
+00008070: 2021 3d20 7661 7220 7b0a 2020 2020 2020   != var {.      
+00008080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008090: 2020 706f 6c79 5f65 7661 6c20 3d20 706f    poly_eval = po
+000080a0: 6c79 5f65 7661 6c2e 7265 706c 6163 6528  ly_eval.replace(
+000080b0: 2a76 2c20 7029 3b0a 2020 2020 2020 2020  *v, p);.        
+000080c0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+000080d0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+000080e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000080f0: 2069 6620 706f 6c79 5f65 7661 6c2e 6465   if poly_eval.de
+00008100: 6772 6565 286f 7264 6572 5b30 5d29 2021  gree(order[0]) !
+00008110: 3d20 7365 6c66 2e64 6567 7265 6528 6f72  = self.degree(or
+00008120: 6465 725b 305d 290a 2020 2020 2020 2020  der[0]).        
+00008130: 2020 2020 2020 2020 2020 2020 7c7c 2070              || p
+00008140: 6f6c 795f 6576 616c 2e64 6567 7265 6528  oly_eval.degree(
+00008150: 7661 7229 2021 3d20 7365 6c66 2e64 6567  var) != self.deg
+00008160: 7265 6528 7661 7229 0a20 2020 2020 2020  ree(var).       
+00008170: 2020 2020 2020 2020 2020 2020 207c 7c20               || 
+00008180: 706f 6c79 5f65 7661 6c2e 756e 6976 6172  poly_eval.univar
+00008190: 6961 7465 5f6c 636f 6566 6628 6f72 6465  iate_lcoeff(orde
+000081a0: 725b 305d 292e 6465 6772 6565 2876 6172  r[0]).degree(var
+000081b0: 2920 213d 206c 636f 6566 662e 6465 6772  ) != lcoeff.degr
+000081c0: 6565 2876 6172 290a 2020 2020 2020 2020  ee(var).        
+000081d0: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
+000081e0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+000081f0: 6275 6721 2822 4261 6420 7361 6d70 6c65  bug!("Bad sample
+00008200: 2066 6f72 2072 6563 6f6e 7374 7275 6374   for reconstruct
+00008210: 696e 6720 6c63 6f65 6666 3a20 6465 6772  ing lcoeff: degr
+00008220: 6565 7320 646f 206e 6f74 206d 6174 6368  ees do not match
+00008230: 2229 3b0a 2020 2020 2020 2020 2020 2020  ");.            
+00008240: 2020 2020 2020 2020 7265 7475 726e 2045          return E
+00008250: 7272 286d 6169 6e5f 6269 7661 7269 6174  rr(main_bivariat
+00008260: 655f 6661 6374 6f72 732e 6c65 6e28 2929  e_factors.len())
+00008270: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00008280: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
+00008290: 2020 2020 206c 6574 2062 6976 6172 6961       let bivaria
+000082a0: 7465 5f66 6163 746f 7273 3a20 5665 633c  te_factors: Vec<
+000082b0: 5f3e 203d 0a20 2020 2020 2020 2020 2020  _> =.           
+000082c0: 2020 2020 2020 2020 2070 6f6c 795f 6576           poly_ev
+000082d0: 616c 2e66 6163 746f 7228 292e 696e 746f  al.factor().into
+000082e0: 5f69 7465 7228 292e 6d61 7028 7c28 662c  _iter().map(|(f,
+000082f0: 205f 297c 2066 292e 636f 6c6c 6563 7428   _)| f).collect(
+00008300: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
+00008310: 2020 2020 6966 2062 6976 6172 6961 7465      if bivariate
+00008320: 5f66 6163 746f 7273 2e6c 656e 2829 2021  _factors.len() !
+00008330: 3d20 6d61 696e 5f62 6976 6172 6961 7465  = main_bivariate
+00008340: 5f66 6163 746f 7273 2e6c 656e 2829 207b  _factors.len() {
+00008350: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008360: 2020 2020 2072 6574 7572 6e20 4572 7228       return Err(
+00008370: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+00008380: 732e 6c65 6e28 292e 6d69 6e28 6d61 696e  s.len().min(main
+00008390: 5f62 6976 6172 6961 7465 5f66 6163 746f  _bivariate_facto
+000083a0: 7273 2e6c 656e 2829 2929 3b0a 2020 2020  rs.len()));.    
+000083b0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+000083c0: 2020 2020 2020 2020 2020 2020 2020 2053                 S
+000083d0: 656c 663a 3a63 616e 6f6e 6963 616c 5f73  elf::canonical_s
+000083e0: 6f72 7428 2662 6976 6172 6961 7465 5f66  ort(&bivariate_f
+000083f0: 6163 746f 7273 2c20 7661 722c 2073 616d  actors, var, sam
+00008400: 706c 655f 706f 696e 7473 290a 2020 2020  ple_points).    
 00008410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008420: 202e 6d61 7028 7c28 662c 205f 2c20 5f29   .map(|(f, _, _)
-00008430: 7c20 6629 0a20 2020 2020 2020 2020 2020  | f).           
-00008440: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-00008450: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
-00008460: 7d3b 0a0a 2020 2020 2020 2020 2020 2020  };..            
-00008470: 6c65 7420 7371 7561 7265 5f66 7265 655f  let square_free_
-00008480: 6c63 5f62 6976 5f66 6163 746f 7273 3a20  lc_biv_factors: 
-00008490: 5665 633c 5f3e 203d 2062 6976 6172 6961  Vec<_> = bivaria
-000084a0: 7465 5f66 6163 746f 7273 0a20 2020 2020  te_factors.     
-000084b0: 2020 2020 2020 2020 2020 202e 6974 6572             .iter
-000084c0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
-000084d0: 2020 202e 6d61 7028 7c66 7c20 662e 756e     .map(|f| f.un
-000084e0: 6976 6172 6961 7465 5f6c 636f 6566 6628  ivariate_lcoeff(
-000084f0: 6f72 6465 725b 305d 292e 7371 7561 7265  order[0]).square
-00008500: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
-00008510: 696f 6e28 2929 0a20 2020 2020 2020 2020  ion()).         
-00008520: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
-00008530: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-00008540: 6c65 7420 6261 7369 7320 3d20 5365 6c66  let basis = Self
-00008550: 3a3a 6763 645f 6672 6565 5f62 6173 6973  ::gcd_free_basis
-00008560: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00008570: 2020 7371 7561 7265 5f66 7265 655f 6c63    square_free_lc
-00008580: 5f62 6976 5f66 6163 746f 7273 0a20 2020  _biv_factors.   
-00008590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085a0: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
-000085b0: 2020 2020 2020 2020 2020 2020 202e 666c               .fl
-000085c0: 6174 7465 6e28 290a 2020 2020 2020 2020  atten().        
-000085d0: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
-000085e0: 287c 787c 2078 2e30 2e63 6c6f 6e65 2829  (|x| x.0.clone()
-000085f0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00008600: 2020 2020 2020 2e66 696c 7465 7228 7c78        .filter(|x
-00008610: 7c20 2178 2e69 735f 636f 6e73 7461 6e74  | !x.is_constant
-00008620: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
-00008630: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
-00008640: 2829 2c0a 2020 2020 2020 2020 2020 2020  (),.            
-00008650: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-00008660: 6966 2062 6173 6973 2e69 735f 656d 7074  if basis.is_empt
-00008670: 7928 2920 7b0a 2020 2020 2020 2020 2020  y() {.          
-00008680: 2020 2020 2020 636f 6e74 696e 7565 3b0a        continue;.
-00008690: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
-000086a0: 2020 2020 2020 2020 2020 206c 6574 206c             let l
-000086b0: 6966 7465 6420 3d20 6966 2062 6173 6973  ifted = if basis
-000086c0: 2e6c 656e 2829 203d 3d20 3120 7b0a 2020  .len() == 1 {.  
-000086d0: 2020 2020 2020 2020 2020 2020 2020 7665                ve
-000086e0: 6321 5b6c 636f 6566 665f 7371 7561 7265  c![lcoeff_square
-000086f0: 5f66 7265 655f 7070 2e63 6c6f 6e65 2829  _free_pp.clone()
-00008700: 5d0a 2020 2020 2020 2020 2020 2020 7d20  ].            } 
-00008710: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
-00008720: 2020 2020 2020 206c 6574 206d 7574 206e         let mut n
-00008730: 6577 5f6f 7264 6572 203d 206f 7264 6572  ew_order = order
-00008740: 2e74 6f5f 7665 6328 293b 0a20 2020 2020  .to_vec();.     
-00008750: 2020 2020 2020 2020 2020 206e 6577 5f6f             new_o
-00008760: 7264 6572 2e73 7761 7028 312c 2069 202b  rder.swap(1, i +
-00008770: 2031 293b 0a20 2020 2020 2020 2020 2020   1);.           
-00008780: 2020 2020 206e 6577 5f6f 7264 6572 2e72       new_order.r
-00008790: 656d 6f76 6528 3029 3b0a 0a20 2020 2020  emove(0);..     
-000087a0: 2020 2020 2020 2020 2020 206c 636f 6566             lcoef
-000087b0: 665f 7371 7561 7265 5f66 7265 655f 7070  f_square_free_pp
-000087c0: 2e6d 756c 7469 7661 7269 6174 655f 6865  .multivariate_he
-000087d0: 6e73 656c 5f6c 6966 745f 7769 7468 5f61  nsel_lift_with_a
-000087e0: 7574 6f5f 6c63 6f65 6666 5f66 6978 696e  uto_lcoeff_fixin
-000087f0: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
-00008800: 2020 2020 2020 2026 6261 7369 732c 0a20         &basis,. 
-00008810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008820: 2020 2073 616d 706c 655f 706f 696e 7473     sample_points
-00008830: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008840: 2020 2020 2020 266e 6577 5f6f 7264 6572        &new_order
+00008420: 2e69 6e74 6f5f 6974 6572 2829 0a20 2020  .into_iter().   
+00008430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008440: 202e 6d61 7028 7c28 662c 205f 2c20 5f29   .map(|(f, _, _)
+00008450: 7c20 6629 0a20 2020 2020 2020 2020 2020  | f).           
+00008460: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
+00008470: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
+00008480: 7d3b 0a0a 2020 2020 2020 2020 2020 2020  };..            
+00008490: 6c65 7420 7371 7561 7265 5f66 7265 655f  let square_free_
+000084a0: 6c63 5f62 6976 5f66 6163 746f 7273 3a20  lc_biv_factors: 
+000084b0: 5665 633c 5f3e 203d 2062 6976 6172 6961  Vec<_> = bivaria
+000084c0: 7465 5f66 6163 746f 7273 0a20 2020 2020  te_factors.     
+000084d0: 2020 2020 2020 2020 2020 202e 6974 6572             .iter
+000084e0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+000084f0: 2020 202e 6d61 7028 7c66 7c20 662e 756e     .map(|f| f.un
+00008500: 6976 6172 6961 7465 5f6c 636f 6566 6628  ivariate_lcoeff(
+00008510: 6f72 6465 725b 305d 292e 7371 7561 7265  order[0]).square
+00008520: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
+00008530: 696f 6e28 2929 0a20 2020 2020 2020 2020  ion()).         
+00008540: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+00008550: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
+00008560: 6c65 7420 6261 7369 7320 3d20 5365 6c66  let basis = Self
+00008570: 3a3a 6763 645f 6672 6565 5f62 6173 6973  ::gcd_free_basis
+00008580: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00008590: 2020 7371 7561 7265 5f66 7265 655f 6c63    square_free_lc
+000085a0: 5f62 6976 5f66 6163 746f 7273 0a20 2020  _biv_factors.   
+000085b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000085c0: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
+000085d0: 2020 2020 2020 2020 2020 2020 202e 666c               .fl
+000085e0: 6174 7465 6e28 290a 2020 2020 2020 2020  atten().        
+000085f0: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
+00008600: 287c 787c 2078 2e30 2e63 6c6f 6e65 2829  (|x| x.0.clone()
+00008610: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00008620: 2020 2020 2020 2e66 696c 7465 7228 7c78        .filter(|x
+00008630: 7c20 2178 2e69 735f 636f 6e73 7461 6e74  | !x.is_constant
+00008640: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
+00008650: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
+00008660: 2829 2c0a 2020 2020 2020 2020 2020 2020  (),.            
+00008670: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
+00008680: 6966 2062 6173 6973 2e69 735f 656d 7074  if basis.is_empt
+00008690: 7928 2920 7b0a 2020 2020 2020 2020 2020  y() {.          
+000086a0: 2020 2020 2020 636f 6e74 696e 7565 3b0a        continue;.
+000086b0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+000086c0: 2020 2020 2020 2020 2020 206c 6574 206c             let l
+000086d0: 6966 7465 6420 3d20 6966 2062 6173 6973  ifted = if basis
+000086e0: 2e6c 656e 2829 203d 3d20 3120 7b0a 2020  .len() == 1 {.  
+000086f0: 2020 2020 2020 2020 2020 2020 2020 7665                ve
+00008700: 6321 5b6c 636f 6566 665f 7371 7561 7265  c![lcoeff_square
+00008710: 5f66 7265 655f 7070 2e63 6c6f 6e65 2829  _free_pp.clone()
+00008720: 5d0a 2020 2020 2020 2020 2020 2020 7d20  ].            } 
+00008730: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
+00008740: 2020 2020 2020 206c 6574 206d 7574 206e         let mut n
+00008750: 6577 5f6f 7264 6572 203d 206f 7264 6572  ew_order = order
+00008760: 2e74 6f5f 7665 6328 293b 0a20 2020 2020  .to_vec();.     
+00008770: 2020 2020 2020 2020 2020 206e 6577 5f6f             new_o
+00008780: 7264 6572 2e73 7761 7028 312c 2069 202b  rder.swap(1, i +
+00008790: 2031 293b 0a20 2020 2020 2020 2020 2020   1);.           
+000087a0: 2020 2020 206e 6577 5f6f 7264 6572 2e72       new_order.r
+000087b0: 656d 6f76 6528 3029 3b0a 0a20 2020 2020  emove(0);..     
+000087c0: 2020 2020 2020 2020 2020 206c 636f 6566             lcoef
+000087d0: 665f 7371 7561 7265 5f66 7265 655f 7070  f_square_free_pp
+000087e0: 2e6d 756c 7469 7661 7269 6174 655f 6865  .multivariate_he
+000087f0: 6e73 656c 5f6c 6966 745f 7769 7468 5f61  nsel_lift_with_a
+00008800: 7574 6f5f 6c63 6f65 6666 5f66 6978 696e  uto_lcoeff_fixin
+00008810: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
+00008820: 2020 2020 2020 2026 6261 7369 732c 0a20         &basis,. 
+00008830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008840: 2020 2073 616d 706c 655f 706f 696e 7473     sample_points
 00008850: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008860: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00008870: 7d3b 0a0a 2020 2020 2020 2020 2020 2020  };..            
-00008880: 666f 7220 286c 2c20 6661 6329 2069 6e20  for (l, fac) in 
-00008890: 7472 7565 5f6c 636f 6566 6673 2e69 7465  true_lcoeffs.ite
-000088a0: 725f 6d75 7428 292e 7a69 7028 2673 7175  r_mut().zip(&squ
-000088b0: 6172 655f 6672 6565 5f6c 635f 6269 765f  are_free_lc_biv_
-000088c0: 6661 6374 6f72 7329 207b 0a20 2020 2020  factors) {.     
-000088d0: 2020 2020 2020 2020 2020 206c 6574 206d             let m
-000088e0: 7574 2063 6f6e 7472 6962 203d 2073 656c  ut contrib = sel
-000088f0: 662e 6f6e 6528 293b 0a20 2020 2020 2020  f.one();.       
-00008900: 2020 2020 2020 2020 2066 6f72 2028 6675           for (fu
-00008910: 6c6c 2c20 6229 2069 6e20 6c69 6674 6564  ll, b) in lifted
-00008920: 2e69 7465 7228 292e 7a69 7028 2662 6173  .iter().zip(&bas
-00008930: 6973 2920 7b0a 2020 2020 2020 2020 2020  is) {.          
-00008940: 2020 2020 2020 2020 2020 2f2f 2063 6865            // che
-00008950: 636b 2069 6620 6120 4743 442d 6672 6565  ck if a GCD-free
-00008960: 2062 6173 6973 2065 6c65 6d65 6e74 2069   basis element i
-00008970: 7320 6120 6661 6374 6f72 206f 6620 7468  s a factor of th
-00008980: 6520 6c65 6164 696e 6720 636f 6566 6669  e leading coeffi
-00008990: 6369 656e 7420 6f66 2074 6869 7320 6269  cient of this bi
-000089a0: 7661 7269 6174 6520 6661 6374 6f72 0a20  variate factor. 
-000089b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089c0: 2020 2069 6620 6c65 7420 536f 6d65 2828     if let Some((
-000089d0: 5f2c 206d 2929 203d 2066 6163 2e69 7465  _, m)) = fac.ite
-000089e0: 7228 292e 6669 6e64 287c 2866 2c20 5f29  r().find(|(f, _)
-000089f0: 7c20 6620 3d3d 2062 207c 7c20 662e 6469  | f == b || f.di
-00008a00: 7669 6465 7328 6229 2e69 735f 736f 6d65  vides(b).is_some
-00008a10: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
-00008a20: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
-00008a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008a40: 2020 666f 7220 5f20 696e 2030 2e2e 2a6d    for _ in 0..*m
-00008a50: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00008a60: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00008a70: 6f6e 7472 6962 203d 2026 636f 6e74 7269  ontrib = &contri
-00008a80: 6220 2a20 2666 756c 6c3b 0a20 2020 2020  b * &full;.     
-00008a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008aa0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00008ab0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00008ac0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-00008ad0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00008ae0: 7420 6720 3d20 636f 6e74 7269 622e 6763  t g = contrib.gc
-00008af0: 6428 6c29 3b0a 2020 2020 2020 2020 2020  d(l);.          
-00008b00: 2020 2020 2020 6c65 7420 6d75 7420 6e65        let mut ne
-00008b10: 7720 3d20 636f 6e74 7269 6220 2f20 2667  w = contrib / &g
-00008b20: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
-00008b30: 2020 202f 2f20 6d61 6b65 2073 7572 6520     // make sure 
-00008b40: 7468 6520 6e65 7720 7061 7274 206b 6565  the new part kee
-00008b50: 7073 2074 6865 2064 6573 6972 6564 2069  ps the desired i
-00008b60: 6d61 6765 2063 6f65 6666 2069 6e74 6163  mage coeff intac
-00008b70: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00008b80: 2020 6c65 7420 6d75 7420 625f 6c63 5f65    let mut b_lc_e
-00008b90: 7661 6c20 3d20 6e65 772e 636c 6f6e 6528  val = new.clone(
-00008ba0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00008bb0: 2020 2066 6f72 2028 762c 2070 2920 696e     for (v, p) in
-00008bc0: 2073 616d 706c 655f 706f 696e 7473 207b   sample_points {
-00008bd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008be0: 2020 2020 2062 5f6c 635f 6576 616c 203d       b_lc_eval =
-00008bf0: 2062 5f6c 635f 6576 616c 2e72 6570 6c61   b_lc_eval.repla
-00008c00: 6365 282a 762c 2070 293b 0a20 2020 2020  ce(*v, p);.     
-00008c10: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-00008c20: 2020 2020 2020 2020 2020 2020 2020 6e65                ne
-00008c30: 7720 3d20 6e65 7720 2f20 2662 5f6c 635f  w = new / &b_lc_
-00008c40: 6576 616c 3b0a 0a20 2020 2020 2020 2020  eval;..         
-00008c50: 2020 2020 2020 202a 6c20 3d20 262a 6c20         *l = &*l 
-00008c60: 2a20 266e 6577 3b0a 2020 2020 2020 2020  * &new;.        
-00008c70: 2020 2020 2020 2020 6c63 6f65 6666 5f6c          lcoeff_l
-00008c80: 6566 7420 3d20 266c 636f 6566 665f 6c65  eft = &lcoeff_le
-00008c90: 6674 202f 2026 6e65 773b 0a20 2020 2020  ft / &new;.     
-00008ca0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-00008cb0: 207d 0a0a 2020 2020 2020 2020 6966 2021   }..        if !
-00008cc0: 6c63 6f65 6666 5f6c 6566 742e 6973 5f6f  lcoeff_left.is_o
-00008cd0: 6e65 2829 207b 0a20 2020 2020 2020 2020  ne() {.         
-00008ce0: 2020 2070 616e 6963 2128 0a20 2020 2020     panic!(.     
-00008cf0: 2020 2020 2020 2020 2020 2022 436f 756c             "Coul
-00008d00: 6420 6e6f 7420 7265 636f 6e73 7472 7563  d not reconstruc
-00008d10: 7420 6c65 6164 696e 6720 636f 6566 6669  t leading coeffi
-00008d20: 6369 656e 7420 6f66 207b 7d3a 206f 7264  cient of {}: ord
-00008d30: 6572 3d7b 3a3f 7d2c 2073 616d 706c 6573  er={:?}, samples
-00008d40: 3d7b 3a3f 7d20 5265 7374 203d 207b 7d22  ={:?} Rest = {}"
-00008d50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008d60: 2020 7365 6c66 2c0a 2020 2020 2020 2020    self,.        
-00008d70: 2020 2020 2020 2020 6f72 6465 722c 0a20          order,. 
-00008d80: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00008d90: 616d 706c 655f 706f 696e 7473 2c0a 2020  ample_points,.  
-00008da0: 2020 2020 2020 2020 2020 2020 2020 6c63                lc
-00008db0: 6f65 6666 5f6c 6566 740a 2020 2020 2020  oeff_left.      
-00008dc0: 2020 2020 2020 293b 0a20 2020 2020 2020        );.       
-00008dd0: 207d 0a0a 2020 2020 2020 2020 4f6b 2828   }..        Ok((
-00008de0: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
-00008df0: 6163 746f 7273 2c20 7472 7565 5f6c 636f  actors, true_lco
-00008e00: 6566 6673 2929 0a20 2020 207d 0a0a 2020  effs)).    }..  
-00008e10: 2020 666e 206d 756c 7469 7661 7269 6174    fn multivariat
-00008e20: 655f 6865 6e73 656c 5f6c 6966 745f 7769  e_hensel_lift_wi
-00008e30: 7468 5f61 7574 6f5f 6c63 6f65 6666 5f66  th_auto_lcoeff_f
-00008e40: 6978 696e 6728 0a20 2020 2020 2020 2026  ixing(.        &
-00008e50: 7365 6c66 2c0a 2020 2020 2020 2020 6661  self,.        fa
-00008e60: 6374 6f72 733a 2026 5b53 656c 665d 2c0a  ctors: &[Self],.
-00008e70: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
-00008e80: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
-00008e90: 203c 4669 6e69 7465 4669 656c 643c 5546   <FiniteField<UF
-00008ea0: 6965 6c64 3e20 6173 2052 696e 673e 3a3a  ield> as Ring>::
-00008eb0: 456c 656d 656e 7429 5d2c 0a20 2020 2020  Element)],.     
-00008ec0: 2020 206f 7264 6572 3a20 265b 7573 697a     order: &[usiz
-00008ed0: 655d 2c0a 2020 2020 2920 2d3e 2056 6563  e],.    ) -> Vec
-00008ee0: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
-00008ef0: 206c 6574 206c 636f 6566 6620 3d20 7365   let lcoeff = se
-00008f00: 6c66 2e75 6e69 7661 7269 6174 655f 6c63  lf.univariate_lc
-00008f10: 6f65 6666 286f 7264 6572 5b30 5d29 3b0a  oeff(order[0]);.
-00008f20: 0a20 2020 2020 2020 2069 6620 6c63 6f65  .        if lcoe
-00008f30: 6666 2e69 735f 636f 6e73 7461 6e74 2829  ff.is_constant()
-00008f40: 207b 0a20 2020 2020 2020 2020 2020 202f   {.            /
-00008f50: 2f20 7468 6520 6661 6374 6f72 7320 7368  / the factors sh
-00008f60: 6f75 6c64 2062 6520 7072 6f70 6572 6c79  ould be properly
-00008f70: 206e 6f72 6d61 6c69 7a65 640a 2020 2020   normalized.    
-00008f80: 2020 2020 2020 2020 6c65 7420 286d 7574          let (mut
-00008f90: 2075 6e69 2c20 6465 6c74 6129 203d 0a20   uni, delta) =. 
-00008fa0: 2020 2020 2020 2020 2020 2020 2020 2053                 S
-00008fb0: 656c 663a 3a75 6e69 7661 7269 6174 655f  elf::univariate_
-00008fc0: 6469 6f70 6861 6e74 696e 655f 6669 656c  diophantine_fiel
-00008fd0: 6428 6661 6374 6f72 732c 206f 7264 6572  d(factors, order
-00008fe0: 2c20 7361 6d70 6c65 5f70 6f69 6e74 7329  , sample_points)
-00008ff0: 3b0a 2020 2020 2020 2020 2020 2020 7265  ;.            re
-00009000: 7475 726e 2073 656c 662e 6d75 6c74 6976  turn self.multiv
-00009010: 6172 6961 7465 5f68 656e 7365 6c5f 6c69  ariate_hensel_li
-00009020: 6674 696e 6728 0a20 2020 2020 2020 2020  fting(.         
-00009030: 2020 2020 2020 2066 6163 746f 7273 2c0a         factors,.
-00009040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009050: 266d 7574 2075 6e69 2c0a 2020 2020 2020  &mut uni,.      
-00009060: 2020 2020 2020 2020 2020 2664 656c 7461            &delta
-00009070: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009080: 2020 7361 6d70 6c65 5f70 6f69 6e74 732c    sample_points,
-00009090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000090a0: 204e 6f6e 652c 0a20 2020 2020 2020 2020   None,.         
-000090b0: 2020 2020 2020 206f 7264 6572 2c0a 2020         order,.  
-000090c0: 2020 2020 2020 2020 2020 2020 2020 312c                1,
-000090d0: 0a20 2020 2020 2020 2020 2020 2029 3b0a  .            );.
-000090e0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-000090f0: 2020 202f 2f20 7265 7065 6174 2074 6865     // repeat the
-00009100: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
-00009110: 6965 6e74 2066 6f72 2065 7665 7279 2066  ient for every f
-00009120: 6163 746f 7220 736f 2074 6861 7420 7468  actor so that th
-00009130: 6520 6c65 6164 696e 6720 636f 6566 6669  e leading coeffi
-00009140: 6369 656e 7420 6973 206b 6e6f 776e 0a20  cient is known. 
-00009150: 2020 2020 2020 206c 6574 2070 6164 6465         let padde
-00009160: 645f 6c63 6f65 6666 7320 3d20 7665 6321  d_lcoeffs = vec!
-00009170: 5b6c 636f 6566 662e 636c 6f6e 6528 293b  [lcoeff.clone();
-00009180: 2066 6163 746f 7273 2e6c 656e 2829 5d3b   factors.len()];
-00009190: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
-000091a0: 7420 7365 6c66 5f61 646a 7573 7465 6420  t self_adjusted 
-000091b0: 3d20 7365 6c66 2e63 6c6f 6e65 2829 3b0a  = self.clone();.
-000091c0: 2020 2020 2020 2020 666f 7220 5f20 696e          for _ in
-000091d0: 2031 2e2e 6661 6374 6f72 732e 6c65 6e28   1..factors.len(
-000091e0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-000091f0: 7365 6c66 5f61 646a 7573 7465 6420 3d20  self_adjusted = 
-00009200: 2673 656c 665f 6164 6a75 7374 6564 202a  &self_adjusted *
-00009210: 2026 6c63 6f65 6666 3b0a 2020 2020 2020   &lcoeff;.      
-00009220: 2020 7d0a 0a20 2020 2020 2020 202f 2f20    }..        // 
-00009230: 7365 7420 7468 6520 7072 6f70 6572 206c  set the proper l
-00009240: 630a 2020 2020 2020 2020 6c65 7420 6d75  c.        let mu
-00009250: 7420 6c63 5f76 6172 5f65 7661 6c20 3d20  t lc_var_eval = 
-00009260: 6c63 6f65 6666 2e63 6c6f 6e65 2829 3b0a  lcoeff.clone();.
-00009270: 2020 2020 2020 2020 666f 7220 2876 2c20          for (v, 
-00009280: 7029 2069 6e20 7361 6d70 6c65 5f70 6f69  p) in sample_poi
-00009290: 6e74 7320 7b0a 2020 2020 2020 2020 2020  nts {.          
-000092a0: 2020 6966 202a 7620 213d 206f 7264 6572    if *v != order
-000092b0: 5b30 5d20 7b0a 2020 2020 2020 2020 2020  [0] {.          
-000092c0: 2020 2020 2020 6c63 5f76 6172 5f65 7661        lc_var_eva
-000092d0: 6c20 3d20 6c63 5f76 6172 5f65 7661 6c2e  l = lc_var_eval.
-000092e0: 7265 706c 6163 6528 2a76 2c20 7029 3b0a  replace(*v, p);.
-000092f0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00009300: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00009310: 206c 6574 2061 646a 7573 7465 645f 6661   let adjusted_fa
-00009320: 6374 6f72 733a 2056 6563 3c5f 3e20 3d20  ctors: Vec<_> = 
-00009330: 6661 6374 6f72 730a 2020 2020 2020 2020  factors.        
-00009340: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
-00009350: 2020 2020 2020 2020 2e6d 6170 287c 667c          .map(|f|
-00009360: 2066 2e63 6c6f 6e65 2829 2e6d 616b 655f   f.clone().make_
-00009370: 6d6f 6e69 6328 2920 2a20 266c 635f 7661  monic() * &lc_va
-00009380: 725f 6576 616c 290a 2020 2020 2020 2020  r_eval).        
-00009390: 2020 2020 2e63 6f6c 6c65 6374 2829 3b0a      .collect();.
-000093a0: 0a20 2020 2020 2020 206c 6574 2028 6d75  .        let (mu
-000093b0: 7420 756e 692c 2064 656c 7461 2920 3d0a  t uni, delta) =.
-000093c0: 2020 2020 2020 2020 2020 2020 5365 6c66              Self
-000093d0: 3a3a 756e 6976 6172 6961 7465 5f64 696f  ::univariate_dio
-000093e0: 7068 616e 7469 6e65 5f66 6965 6c64 2826  phantine_field(&
-000093f0: 6164 6a75 7374 6564 5f66 6163 746f 7273  adjusted_factors
-00009400: 2c20 6f72 6465 722c 2073 616d 706c 655f  , order, sample_
-00009410: 706f 696e 7473 293b 0a20 2020 2020 2020  points);.       
-00009420: 2073 656c 665f 6164 6a75 7374 6564 0a20   self_adjusted. 
-00009430: 2020 2020 2020 2020 2020 202e 6d75 6c74             .mult
-00009440: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
-00009450: 6c69 6674 696e 6728 0a20 2020 2020 2020  lifting(.       
-00009460: 2020 2020 2020 2020 2026 6164 6a75 7374           &adjust
-00009470: 6564 5f66 6163 746f 7273 2c0a 2020 2020  ed_factors,.    
-00009480: 2020 2020 2020 2020 2020 2020 266d 7574              &mut
-00009490: 2075 6e69 2c0a 2020 2020 2020 2020 2020   uni,.          
-000094a0: 2020 2020 2020 2664 656c 7461 2c0a 2020        &delta,.  
-000094b0: 2020 2020 2020 2020 2020 2020 2020 7361                sa
-000094c0: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
-000094d0: 2020 2020 2020 2020 2020 2020 2053 6f6d               Som
-000094e0: 6528 2670 6164 6465 645f 6c63 6f65 6666  e(&padded_lcoeff
-000094f0: 7329 2c0a 2020 2020 2020 2020 2020 2020  s),.            
-00009500: 2020 2020 6f72 6465 722c 0a20 2020 2020      order,.     
-00009510: 2020 2020 2020 2020 2020 2031 2c0a 2020             1,.  
-00009520: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00009530: 2020 2020 2020 2020 2e69 6e74 6f5f 6974          .into_it
-00009540: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
-00009550: 202e 6d61 7028 7c66 7c20 7b0a 2020 2020   .map(|f| {.    
-00009560: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00009570: 6320 3d20 662e 756e 6976 6172 6961 7465  c = f.univariate
-00009580: 5f63 6f6e 7465 6e74 286f 7264 6572 5b30  _content(order[0
-00009590: 5d29 3b0a 2020 2020 2020 2020 2020 2020  ]);.            
-000095a0: 2020 2020 6620 2f20 2663 0a20 2020 2020      f / &c.     
-000095b0: 2020 2020 2020 207d 290a 2020 2020 2020         }).      
-000095c0: 2020 2020 2020 2e63 6f6c 6c65 6374 2829        .collect()
-000095d0: 0a20 2020 207d 0a0a 2020 2020 666e 2075  .    }..    fn u
-000095e0: 6e69 7661 7269 6174 655f 6469 6f70 6861  nivariate_diopha
-000095f0: 6e74 696e 655f 6669 656c 6428 0a20 2020  ntine_field(.   
-00009600: 2020 2020 2066 6163 746f 7273 3a20 265b       factors: &[
-00009610: 5365 6c66 5d2c 0a20 2020 2020 2020 206f  Self],.        o
-00009620: 7264 6572 3a20 265b 7573 697a 655d 2c0a  rder: &[usize],.
-00009630: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
-00009640: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
-00009650: 203c 4669 6e69 7465 4669 656c 643c 5546   <FiniteField<UF
-00009660: 6965 6c64 3e20 6173 2052 696e 673e 3a3a  ield> as Ring>::
-00009670: 456c 656d 656e 7429 5d2c 0a20 2020 2029  Element)],.    )
-00009680: 202d 3e20 2856 6563 3c53 656c 663e 2c20   -> (Vec<Self>, 
-00009690: 5665 633c 5365 6c66 3e29 207b 0a20 2020  Vec<Self>) {.   
-000096a0: 2020 2020 202f 2f20 7072 6f64 7563 6520       // produce 
-000096b0: 756e 6976 6172 6961 7465 2066 6163 746f  univariate facto
-000096c0: 7273 2061 6e64 2075 6e69 7661 7269 6174  rs and univariat
-000096d0: 6520 6465 6c74 610a 2020 2020 2020 2020  e delta.        
-000096e0: 6c65 7420 6d75 7420 756e 6976 6172 6961  let mut univaria
-000096f0: 7465 5f66 6163 746f 7273 203d 2066 6163  te_factors = fac
-00009700: 746f 7273 2e74 6f5f 7665 6328 293b 0a20  tors.to_vec();. 
-00009710: 2020 2020 2020 2066 6f72 2066 2069 6e20         for f in 
-00009720: 266d 7574 2075 6e69 7661 7269 6174 655f  &mut univariate_
-00009730: 6661 6374 6f72 7320 7b0a 2020 2020 2020  factors {.      
-00009740: 2020 2020 2020 666f 7220 2876 2c20 7329        for (v, s)
-00009750: 2069 6e20 7361 6d70 6c65 5f70 6f69 6e74   in sample_point
-00009760: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
-00009770: 2020 2020 6966 206f 7264 6572 5b30 5d20      if order[0] 
-00009780: 213d 202a 7620 7b0a 2020 2020 2020 2020  != *v {.        
-00009790: 2020 2020 2020 2020 2020 2020 2a66 203d              *f =
-000097a0: 2066 2e72 6570 6c61 6365 282a 762c 2073   f.replace(*v, s
-000097b0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-000097c0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-000097d0: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
-000097e0: 2020 2020 2020 6c65 7420 756e 6976 6172        let univar
-000097f0: 6961 7465 5f64 656c 7461 7320 3d20 5365  iate_deltas = Se
-00009800: 6c66 3a3a 6469 6f70 6861 6e74 696e 655f  lf::diophantine_
-00009810: 756e 6976 6172 6961 7465 280a 2020 2020  univariate(.    
-00009820: 2020 2020 2020 2020 266d 7574 2075 6e69          &mut uni
-00009830: 7661 7269 6174 655f 6661 6374 6f72 732c  variate_factors,
-00009840: 0a20 2020 2020 2020 2020 2020 2026 6661  .            &fa
-00009850: 6374 6f72 735b 305d 2e63 6f6e 7374 616e  ctors[0].constan
-00009860: 7428 6661 6374 6f72 735b 305d 2e66 6965  t(factors[0].fie
-00009870: 6c64 2e6f 6e65 2829 292c 0a20 2020 2020  ld.one()),.     
-00009880: 2020 2029 3b0a 0a20 2020 2020 2020 2028     );..        (
-00009890: 756e 6976 6172 6961 7465 5f66 6163 746f  univariate_facto
-000098a0: 7273 2c20 756e 6976 6172 6961 7465 5f64  rs, univariate_d
-000098b0: 656c 7461 7329 0a20 2020 207d 0a0a 2020  eltas).    }..  
-000098c0: 2020 2f2f 2f20 5065 7266 6f72 6d20 6d75    /// Perform mu
-000098d0: 6c74 6976 6172 6961 7465 2066 6163 746f  ltivariate facto
-000098e0: 7269 7a61 7469 6f6e 206f 6e20 6120 7371  rization on a sq
-000098f0: 7561 7265 2d66 7265 6520 706f 6c79 6e6f  uare-free polyno
-00009900: 6d69 616c 2e0a 2020 2020 666e 206d 756c  mial..    fn mul
-00009910: 7469 7661 7269 6174 655f 6661 6374 6f72  tivariate_factor
-00009920: 697a 6174 696f 6e28 0a20 2020 2020 2020  ization(.       
-00009930: 2026 7365 6c66 2c0a 2020 2020 2020 2020   &self,.        
-00009940: 6f72 6465 723a 2026 6d75 7420 5b75 7369  order: &mut [usi
-00009950: 7a65 5d2c 0a20 2020 2020 2020 206d 7574  ze],.        mut
-00009960: 2063 6f65 6666 6963 6965 6e74 5f75 7070   coefficient_upp
-00009970: 6572 5f62 6f75 6e64 3a20 7536 342c 0a20  er_bound: u64,. 
-00009980: 2020 2020 2020 206d 6178 5f62 6976 6172         max_bivar
-00009990: 6961 7465 5f66 6163 746f 7273 3a20 4f70  iate_factors: Op
-000099a0: 7469 6f6e 3c75 7369 7a65 3e2c 0a20 2020  tion<usize>,.   
-000099b0: 2029 202d 3e20 5665 633c 5365 6c66 3e20   ) -> Vec<Self> 
-000099c0: 7b0a 2020 2020 2020 2020 6966 206c 6574  {.        if let
-000099d0: 2053 6f6d 6528 6d29 203d 206d 6178 5f62   Some(m) = max_b
-000099e0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-000099f0: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
-00009a00: 6620 6d20 3d3d 2031 207b 0a20 2020 2020  f m == 1 {.     
-00009a10: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00009a20: 6e20 7665 6321 5b73 656c 662e 636c 6f6e  n vec![self.clon
-00009a30: 6528 295d 3b0a 2020 2020 2020 2020 2020  e()];.          
-00009a40: 2020 7d0a 2020 2020 2020 2020 7d0a 0a20    }.        }.. 
-00009a50: 2020 2020 2020 202f 2f20 6368 6563 6b20         // check 
-00009a60: 666f 7220 7072 6f62 6c65 6d73 2061 7269  for problems ari
-00009a70: 7369 6e67 2066 726f 6d20 6361 6e63 656c  sing from cancel
-00009a80: 696e 6720 7465 726d 7320 696e 2074 6865  ing terms in the
-00009a90: 2064 6572 6976 6174 6976 650a 2020 2020   derivative.    
-00009aa0: 2020 2020 6c65 7420 6465 7220 3d20 7365      let der = se
-00009ab0: 6c66 2e64 6572 6976 6174 6976 6528 6f72  lf.derivative(or
-00009ac0: 6465 725b 305d 293b 0a20 2020 2020 2020  der[0]);.       
-00009ad0: 2069 6620 6465 722e 6973 5f7a 6572 6f28   if der.is_zero(
-00009ae0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00009af0: 6c65 7420 6d75 7420 6e65 775f 6f72 6465  let mut new_orde
-00009b00: 7220 3d20 6f72 6465 722e 746f 5f76 6563  r = order.to_vec
-00009b10: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-00009b20: 6c65 7420 7620 3d20 6e65 775f 6f72 6465  let v = new_orde
-00009b30: 722e 7265 6d6f 7665 2830 293b 0a20 2020  r.remove(0);.   
-00009b40: 2020 2020 2020 2020 206e 6577 5f6f 7264           new_ord
-00009b50: 6572 2e70 7573 6828 7629 3b0a 2020 2020  er.push(v);.    
-00009b60: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00009b70: 656c 662e 6d75 6c74 6976 6172 6961 7465  elf.multivariate
-00009b80: 5f66 6163 746f 7269 7a61 7469 6f6e 280a  _factorization(.
-00009b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ba0: 266d 7574 206e 6577 5f6f 7264 6572 2c0a  &mut new_order,.
+00008860: 2020 2020 2020 266e 6577 5f6f 7264 6572        &new_order
+00008870: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00008880: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00008890: 7d3b 0a0a 2020 2020 2020 2020 2020 2020  };..            
+000088a0: 666f 7220 286c 2c20 6661 6329 2069 6e20  for (l, fac) in 
+000088b0: 7472 7565 5f6c 636f 6566 6673 2e69 7465  true_lcoeffs.ite
+000088c0: 725f 6d75 7428 292e 7a69 7028 2673 7175  r_mut().zip(&squ
+000088d0: 6172 655f 6672 6565 5f6c 635f 6269 765f  are_free_lc_biv_
+000088e0: 6661 6374 6f72 7329 207b 0a20 2020 2020  factors) {.     
+000088f0: 2020 2020 2020 2020 2020 206c 6574 206d             let m
+00008900: 7574 2063 6f6e 7472 6962 203d 2073 656c  ut contrib = sel
+00008910: 662e 6f6e 6528 293b 0a20 2020 2020 2020  f.one();.       
+00008920: 2020 2020 2020 2020 2066 6f72 2028 6675           for (fu
+00008930: 6c6c 2c20 6229 2069 6e20 6c69 6674 6564  ll, b) in lifted
+00008940: 2e69 7465 7228 292e 7a69 7028 2662 6173  .iter().zip(&bas
+00008950: 6973 2920 7b0a 2020 2020 2020 2020 2020  is) {.          
+00008960: 2020 2020 2020 2020 2020 2f2f 2063 6865            // che
+00008970: 636b 2069 6620 6120 4743 442d 6672 6565  ck if a GCD-free
+00008980: 2062 6173 6973 2065 6c65 6d65 6e74 2069   basis element i
+00008990: 7320 6120 6661 6374 6f72 206f 6620 7468  s a factor of th
+000089a0: 6520 6c65 6164 696e 6720 636f 6566 6669  e leading coeffi
+000089b0: 6369 656e 7420 6f66 2074 6869 7320 6269  cient of this bi
+000089c0: 7661 7269 6174 6520 6661 6374 6f72 0a20  variate factor. 
+000089d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000089e0: 2020 2069 6620 6c65 7420 536f 6d65 2828     if let Some((
+000089f0: 5f2c 206d 2929 203d 2066 6163 2e69 7465  _, m)) = fac.ite
+00008a00: 7228 292e 6669 6e64 287c 2866 2c20 5f29  r().find(|(f, _)
+00008a10: 7c20 6620 3d3d 2062 207c 7c20 662e 6469  | f == b || f.di
+00008a20: 7669 6465 7328 6229 2e69 735f 736f 6d65  vides(b).is_some
+00008a30: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
+00008a40: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
+00008a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008a60: 2020 666f 7220 5f20 696e 2030 2e2e 2a6d    for _ in 0..*m
+00008a70: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00008a80: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00008a90: 6f6e 7472 6962 203d 2026 636f 6e74 7269  ontrib = &contri
+00008aa0: 6220 2a20 2666 756c 6c3b 0a20 2020 2020  b * &full;.     
+00008ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008ac0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00008ad0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00008ae0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+00008af0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+00008b00: 7420 6720 3d20 636f 6e74 7269 622e 6763  t g = contrib.gc
+00008b10: 6428 6c29 3b0a 2020 2020 2020 2020 2020  d(l);.          
+00008b20: 2020 2020 2020 6c65 7420 6d75 7420 6e65        let mut ne
+00008b30: 7720 3d20 636f 6e74 7269 6220 2f20 2667  w = contrib / &g
+00008b40: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
+00008b50: 2020 202f 2f20 6d61 6b65 2073 7572 6520     // make sure 
+00008b60: 7468 6520 6e65 7720 7061 7274 206b 6565  the new part kee
+00008b70: 7073 2074 6865 2064 6573 6972 6564 2069  ps the desired i
+00008b80: 6d61 6765 2063 6f65 6666 2069 6e74 6163  mage coeff intac
+00008b90: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+00008ba0: 2020 6c65 7420 6d75 7420 625f 6c63 5f65    let mut b_lc_e
+00008bb0: 7661 6c20 3d20 6e65 772e 636c 6f6e 6528  val = new.clone(
+00008bc0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00008bd0: 2020 2066 6f72 2028 762c 2070 2920 696e     for (v, p) in
+00008be0: 2073 616d 706c 655f 706f 696e 7473 207b   sample_points {
+00008bf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008c00: 2020 2020 2062 5f6c 635f 6576 616c 203d       b_lc_eval =
+00008c10: 2062 5f6c 635f 6576 616c 2e72 6570 6c61   b_lc_eval.repla
+00008c20: 6365 282a 762c 2070 293b 0a20 2020 2020  ce(*v, p);.     
+00008c30: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+00008c40: 2020 2020 2020 2020 2020 2020 2020 6e65                ne
+00008c50: 7720 3d20 6e65 7720 2f20 2662 5f6c 635f  w = new / &b_lc_
+00008c60: 6576 616c 3b0a 0a20 2020 2020 2020 2020  eval;..         
+00008c70: 2020 2020 2020 202a 6c20 3d20 262a 6c20         *l = &*l 
+00008c80: 2a20 266e 6577 3b0a 2020 2020 2020 2020  * &new;.        
+00008c90: 2020 2020 2020 2020 6c63 6f65 6666 5f6c          lcoeff_l
+00008ca0: 6566 7420 3d20 266c 636f 6566 665f 6c65  eft = &lcoeff_le
+00008cb0: 6674 202f 2026 6e65 773b 0a20 2020 2020  ft / &new;.     
+00008cc0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00008cd0: 207d 0a0a 2020 2020 2020 2020 6966 2021   }..        if !
+00008ce0: 6c63 6f65 6666 5f6c 6566 742e 6973 5f6f  lcoeff_left.is_o
+00008cf0: 6e65 2829 207b 0a20 2020 2020 2020 2020  ne() {.         
+00008d00: 2020 2070 616e 6963 2128 0a20 2020 2020     panic!(.     
+00008d10: 2020 2020 2020 2020 2020 2022 436f 756c             "Coul
+00008d20: 6420 6e6f 7420 7265 636f 6e73 7472 7563  d not reconstruc
+00008d30: 7420 6c65 6164 696e 6720 636f 6566 6669  t leading coeffi
+00008d40: 6369 656e 7420 6f66 207b 7d3a 206f 7264  cient of {}: ord
+00008d50: 6572 3d7b 3a3f 7d2c 2073 616d 706c 6573  er={:?}, samples
+00008d60: 3d7b 3a3f 7d20 5265 7374 203d 207b 7d22  ={:?} Rest = {}"
+00008d70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00008d80: 2020 7365 6c66 2c0a 2020 2020 2020 2020    self,.        
+00008d90: 2020 2020 2020 2020 6f72 6465 722c 0a20          order,. 
+00008da0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00008db0: 616d 706c 655f 706f 696e 7473 2c0a 2020  ample_points,.  
+00008dc0: 2020 2020 2020 2020 2020 2020 2020 6c63                lc
+00008dd0: 6f65 6666 5f6c 6566 740a 2020 2020 2020  oeff_left.      
+00008de0: 2020 2020 2020 293b 0a20 2020 2020 2020        );.       
+00008df0: 207d 0a0a 2020 2020 2020 2020 4f6b 2828   }..        Ok((
+00008e00: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
+00008e10: 6163 746f 7273 2c20 7472 7565 5f6c 636f  actors, true_lco
+00008e20: 6566 6673 2929 0a20 2020 207d 0a0a 2020  effs)).    }..  
+00008e30: 2020 666e 206d 756c 7469 7661 7269 6174    fn multivariat
+00008e40: 655f 6865 6e73 656c 5f6c 6966 745f 7769  e_hensel_lift_wi
+00008e50: 7468 5f61 7574 6f5f 6c63 6f65 6666 5f66  th_auto_lcoeff_f
+00008e60: 6978 696e 6728 0a20 2020 2020 2020 2026  ixing(.        &
+00008e70: 7365 6c66 2c0a 2020 2020 2020 2020 6661  self,.        fa
+00008e80: 6374 6f72 733a 2026 5b53 656c 665d 2c0a  ctors: &[Self],.
+00008e90: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
+00008ea0: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
+00008eb0: 203c 4669 6e69 7465 4669 656c 643c 5546   <FiniteField<UF
+00008ec0: 6965 6c64 3e20 6173 2052 696e 673e 3a3a  ield> as Ring>::
+00008ed0: 456c 656d 656e 7429 5d2c 0a20 2020 2020  Element)],.     
+00008ee0: 2020 206f 7264 6572 3a20 265b 7573 697a     order: &[usiz
+00008ef0: 655d 2c0a 2020 2020 2920 2d3e 2056 6563  e],.    ) -> Vec
+00008f00: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
+00008f10: 206c 6574 206c 636f 6566 6620 3d20 7365   let lcoeff = se
+00008f20: 6c66 2e75 6e69 7661 7269 6174 655f 6c63  lf.univariate_lc
+00008f30: 6f65 6666 286f 7264 6572 5b30 5d29 3b0a  oeff(order[0]);.
+00008f40: 0a20 2020 2020 2020 2069 6620 6c63 6f65  .        if lcoe
+00008f50: 6666 2e69 735f 636f 6e73 7461 6e74 2829  ff.is_constant()
+00008f60: 207b 0a20 2020 2020 2020 2020 2020 202f   {.            /
+00008f70: 2f20 7468 6520 6661 6374 6f72 7320 7368  / the factors sh
+00008f80: 6f75 6c64 2062 6520 7072 6f70 6572 6c79  ould be properly
+00008f90: 206e 6f72 6d61 6c69 7a65 640a 2020 2020   normalized.    
+00008fa0: 2020 2020 2020 2020 6c65 7420 286d 7574          let (mut
+00008fb0: 2075 6e69 2c20 6465 6c74 6129 203d 0a20   uni, delta) =. 
+00008fc0: 2020 2020 2020 2020 2020 2020 2020 2053                 S
+00008fd0: 656c 663a 3a75 6e69 7661 7269 6174 655f  elf::univariate_
+00008fe0: 6469 6f70 6861 6e74 696e 655f 6669 656c  diophantine_fiel
+00008ff0: 6428 6661 6374 6f72 732c 206f 7264 6572  d(factors, order
+00009000: 2c20 7361 6d70 6c65 5f70 6f69 6e74 7329  , sample_points)
+00009010: 3b0a 2020 2020 2020 2020 2020 2020 7265  ;.            re
+00009020: 7475 726e 2073 656c 662e 6d75 6c74 6976  turn self.multiv
+00009030: 6172 6961 7465 5f68 656e 7365 6c5f 6c69  ariate_hensel_li
+00009040: 6674 696e 6728 0a20 2020 2020 2020 2020  fting(.         
+00009050: 2020 2020 2020 2066 6163 746f 7273 2c0a         factors,.
+00009060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009070: 266d 7574 2075 6e69 2c0a 2020 2020 2020  &mut uni,.      
+00009080: 2020 2020 2020 2020 2020 2664 656c 7461            &delta
+00009090: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000090a0: 2020 7361 6d70 6c65 5f70 6f69 6e74 732c    sample_points,
+000090b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000090c0: 204e 6f6e 652c 0a20 2020 2020 2020 2020   None,.         
+000090d0: 2020 2020 2020 206f 7264 6572 2c0a 2020         order,.  
+000090e0: 2020 2020 2020 2020 2020 2020 2020 312c                1,
+000090f0: 0a20 2020 2020 2020 2020 2020 2029 3b0a  .            );.
+00009100: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00009110: 2020 202f 2f20 7265 7065 6174 2074 6865     // repeat the
+00009120: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
+00009130: 6965 6e74 2066 6f72 2065 7665 7279 2066  ient for every f
+00009140: 6163 746f 7220 736f 2074 6861 7420 7468  actor so that th
+00009150: 6520 6c65 6164 696e 6720 636f 6566 6669  e leading coeffi
+00009160: 6369 656e 7420 6973 206b 6e6f 776e 0a20  cient is known. 
+00009170: 2020 2020 2020 206c 6574 2070 6164 6465         let padde
+00009180: 645f 6c63 6f65 6666 7320 3d20 7665 6321  d_lcoeffs = vec!
+00009190: 5b6c 636f 6566 662e 636c 6f6e 6528 293b  [lcoeff.clone();
+000091a0: 2066 6163 746f 7273 2e6c 656e 2829 5d3b   factors.len()];
+000091b0: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
+000091c0: 7420 7365 6c66 5f61 646a 7573 7465 6420  t self_adjusted 
+000091d0: 3d20 7365 6c66 2e63 6c6f 6e65 2829 3b0a  = self.clone();.
+000091e0: 2020 2020 2020 2020 666f 7220 5f20 696e          for _ in
+000091f0: 2031 2e2e 6661 6374 6f72 732e 6c65 6e28   1..factors.len(
+00009200: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00009210: 7365 6c66 5f61 646a 7573 7465 6420 3d20  self_adjusted = 
+00009220: 2673 656c 665f 6164 6a75 7374 6564 202a  &self_adjusted *
+00009230: 2026 6c63 6f65 6666 3b0a 2020 2020 2020   &lcoeff;.      
+00009240: 2020 7d0a 0a20 2020 2020 2020 202f 2f20    }..        // 
+00009250: 7365 7420 7468 6520 7072 6f70 6572 206c  set the proper l
+00009260: 630a 2020 2020 2020 2020 6c65 7420 6d75  c.        let mu
+00009270: 7420 6c63 5f76 6172 5f65 7661 6c20 3d20  t lc_var_eval = 
+00009280: 6c63 6f65 6666 2e63 6c6f 6e65 2829 3b0a  lcoeff.clone();.
+00009290: 2020 2020 2020 2020 666f 7220 2876 2c20          for (v, 
+000092a0: 7029 2069 6e20 7361 6d70 6c65 5f70 6f69  p) in sample_poi
+000092b0: 6e74 7320 7b0a 2020 2020 2020 2020 2020  nts {.          
+000092c0: 2020 6966 202a 7620 213d 206f 7264 6572    if *v != order
+000092d0: 5b30 5d20 7b0a 2020 2020 2020 2020 2020  [0] {.          
+000092e0: 2020 2020 2020 6c63 5f76 6172 5f65 7661        lc_var_eva
+000092f0: 6c20 3d20 6c63 5f76 6172 5f65 7661 6c2e  l = lc_var_eval.
+00009300: 7265 706c 6163 6528 2a76 2c20 7029 3b0a  replace(*v, p);.
+00009310: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00009320: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00009330: 206c 6574 2061 646a 7573 7465 645f 6661   let adjusted_fa
+00009340: 6374 6f72 733a 2056 6563 3c5f 3e20 3d20  ctors: Vec<_> = 
+00009350: 6661 6374 6f72 730a 2020 2020 2020 2020  factors.        
+00009360: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
+00009370: 2020 2020 2020 2020 2e6d 6170 287c 667c          .map(|f|
+00009380: 2066 2e63 6c6f 6e65 2829 2e6d 616b 655f   f.clone().make_
+00009390: 6d6f 6e69 6328 2920 2a20 266c 635f 7661  monic() * &lc_va
+000093a0: 725f 6576 616c 290a 2020 2020 2020 2020  r_eval).        
+000093b0: 2020 2020 2e63 6f6c 6c65 6374 2829 3b0a      .collect();.
+000093c0: 0a20 2020 2020 2020 206c 6574 2028 6d75  .        let (mu
+000093d0: 7420 756e 692c 2064 656c 7461 2920 3d0a  t uni, delta) =.
+000093e0: 2020 2020 2020 2020 2020 2020 5365 6c66              Self
+000093f0: 3a3a 756e 6976 6172 6961 7465 5f64 696f  ::univariate_dio
+00009400: 7068 616e 7469 6e65 5f66 6965 6c64 2826  phantine_field(&
+00009410: 6164 6a75 7374 6564 5f66 6163 746f 7273  adjusted_factors
+00009420: 2c20 6f72 6465 722c 2073 616d 706c 655f  , order, sample_
+00009430: 706f 696e 7473 293b 0a20 2020 2020 2020  points);.       
+00009440: 2073 656c 665f 6164 6a75 7374 6564 0a20   self_adjusted. 
+00009450: 2020 2020 2020 2020 2020 202e 6d75 6c74             .mult
+00009460: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
+00009470: 6c69 6674 696e 6728 0a20 2020 2020 2020  lifting(.       
+00009480: 2020 2020 2020 2020 2026 6164 6a75 7374           &adjust
+00009490: 6564 5f66 6163 746f 7273 2c0a 2020 2020  ed_factors,.    
+000094a0: 2020 2020 2020 2020 2020 2020 266d 7574              &mut
+000094b0: 2075 6e69 2c0a 2020 2020 2020 2020 2020   uni,.          
+000094c0: 2020 2020 2020 2664 656c 7461 2c0a 2020        &delta,.  
+000094d0: 2020 2020 2020 2020 2020 2020 2020 7361                sa
+000094e0: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
+000094f0: 2020 2020 2020 2020 2020 2020 2053 6f6d               Som
+00009500: 6528 2670 6164 6465 645f 6c63 6f65 6666  e(&padded_lcoeff
+00009510: 7329 2c0a 2020 2020 2020 2020 2020 2020  s),.            
+00009520: 2020 2020 6f72 6465 722c 0a20 2020 2020      order,.     
+00009530: 2020 2020 2020 2020 2020 2031 2c0a 2020             1,.  
+00009540: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00009550: 2020 2020 2020 2020 2e69 6e74 6f5f 6974          .into_it
+00009560: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
+00009570: 202e 6d61 7028 7c66 7c20 7b0a 2020 2020   .map(|f| {.    
+00009580: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+00009590: 6320 3d20 662e 756e 6976 6172 6961 7465  c = f.univariate
+000095a0: 5f63 6f6e 7465 6e74 286f 7264 6572 5b30  _content(order[0
+000095b0: 5d29 3b0a 2020 2020 2020 2020 2020 2020  ]);.            
+000095c0: 2020 2020 6620 2f20 2663 0a20 2020 2020      f / &c.     
+000095d0: 2020 2020 2020 207d 290a 2020 2020 2020         }).      
+000095e0: 2020 2020 2020 2e63 6f6c 6c65 6374 2829        .collect()
+000095f0: 0a20 2020 207d 0a0a 2020 2020 666e 2075  .    }..    fn u
+00009600: 6e69 7661 7269 6174 655f 6469 6f70 6861  nivariate_diopha
+00009610: 6e74 696e 655f 6669 656c 6428 0a20 2020  ntine_field(.   
+00009620: 2020 2020 2066 6163 746f 7273 3a20 265b       factors: &[
+00009630: 5365 6c66 5d2c 0a20 2020 2020 2020 206f  Self],.        o
+00009640: 7264 6572 3a20 265b 7573 697a 655d 2c0a  rder: &[usize],.
+00009650: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
+00009660: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
+00009670: 203c 4669 6e69 7465 4669 656c 643c 5546   <FiniteField<UF
+00009680: 6965 6c64 3e20 6173 2052 696e 673e 3a3a  ield> as Ring>::
+00009690: 456c 656d 656e 7429 5d2c 0a20 2020 2029  Element)],.    )
+000096a0: 202d 3e20 2856 6563 3c53 656c 663e 2c20   -> (Vec<Self>, 
+000096b0: 5665 633c 5365 6c66 3e29 207b 0a20 2020  Vec<Self>) {.   
+000096c0: 2020 2020 202f 2f20 7072 6f64 7563 6520       // produce 
+000096d0: 756e 6976 6172 6961 7465 2066 6163 746f  univariate facto
+000096e0: 7273 2061 6e64 2075 6e69 7661 7269 6174  rs and univariat
+000096f0: 6520 6465 6c74 610a 2020 2020 2020 2020  e delta.        
+00009700: 6c65 7420 6d75 7420 756e 6976 6172 6961  let mut univaria
+00009710: 7465 5f66 6163 746f 7273 203d 2066 6163  te_factors = fac
+00009720: 746f 7273 2e74 6f5f 7665 6328 293b 0a20  tors.to_vec();. 
+00009730: 2020 2020 2020 2066 6f72 2066 2069 6e20         for f in 
+00009740: 266d 7574 2075 6e69 7661 7269 6174 655f  &mut univariate_
+00009750: 6661 6374 6f72 7320 7b0a 2020 2020 2020  factors {.      
+00009760: 2020 2020 2020 666f 7220 2876 2c20 7329        for (v, s)
+00009770: 2069 6e20 7361 6d70 6c65 5f70 6f69 6e74   in sample_point
+00009780: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
+00009790: 2020 2020 6966 206f 7264 6572 5b30 5d20      if order[0] 
+000097a0: 213d 202a 7620 7b0a 2020 2020 2020 2020  != *v {.        
+000097b0: 2020 2020 2020 2020 2020 2020 2a66 203d              *f =
+000097c0: 2066 2e72 6570 6c61 6365 282a 762c 2073   f.replace(*v, s
+000097d0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+000097e0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+000097f0: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
+00009800: 2020 2020 2020 6c65 7420 756e 6976 6172        let univar
+00009810: 6961 7465 5f64 656c 7461 7320 3d20 5365  iate_deltas = Se
+00009820: 6c66 3a3a 6469 6f70 6861 6e74 696e 655f  lf::diophantine_
+00009830: 756e 6976 6172 6961 7465 280a 2020 2020  univariate(.    
+00009840: 2020 2020 2020 2020 266d 7574 2075 6e69          &mut uni
+00009850: 7661 7269 6174 655f 6661 6374 6f72 732c  variate_factors,
+00009860: 0a20 2020 2020 2020 2020 2020 2026 6661  .            &fa
+00009870: 6374 6f72 735b 305d 2e63 6f6e 7374 616e  ctors[0].constan
+00009880: 7428 6661 6374 6f72 735b 305d 2e66 6965  t(factors[0].fie
+00009890: 6c64 2e6f 6e65 2829 292c 0a20 2020 2020  ld.one()),.     
+000098a0: 2020 2029 3b0a 0a20 2020 2020 2020 2028     );..        (
+000098b0: 756e 6976 6172 6961 7465 5f66 6163 746f  univariate_facto
+000098c0: 7273 2c20 756e 6976 6172 6961 7465 5f64  rs, univariate_d
+000098d0: 656c 7461 7329 0a20 2020 207d 0a0a 2020  eltas).    }..  
+000098e0: 2020 2f2f 2f20 5065 7266 6f72 6d20 6d75    /// Perform mu
+000098f0: 6c74 6976 6172 6961 7465 2066 6163 746f  ltivariate facto
+00009900: 7269 7a61 7469 6f6e 206f 6e20 6120 7371  rization on a sq
+00009910: 7561 7265 2d66 7265 6520 706f 6c79 6e6f  uare-free polyno
+00009920: 6d69 616c 2e0a 2020 2020 666e 206d 756c  mial..    fn mul
+00009930: 7469 7661 7269 6174 655f 6661 6374 6f72  tivariate_factor
+00009940: 697a 6174 696f 6e28 0a20 2020 2020 2020  ization(.       
+00009950: 2026 7365 6c66 2c0a 2020 2020 2020 2020   &self,.        
+00009960: 6f72 6465 723a 2026 6d75 7420 5b75 7369  order: &mut [usi
+00009970: 7a65 5d2c 0a20 2020 2020 2020 206d 7574  ze],.        mut
+00009980: 2063 6f65 6666 6963 6965 6e74 5f75 7070   coefficient_upp
+00009990: 6572 5f62 6f75 6e64 3a20 7536 342c 0a20  er_bound: u64,. 
+000099a0: 2020 2020 2020 206d 6178 5f62 6976 6172         max_bivar
+000099b0: 6961 7465 5f66 6163 746f 7273 3a20 4f70  iate_factors: Op
+000099c0: 7469 6f6e 3c75 7369 7a65 3e2c 0a20 2020  tion<usize>,.   
+000099d0: 2029 202d 3e20 5665 633c 5365 6c66 3e20   ) -> Vec<Self> 
+000099e0: 7b0a 2020 2020 2020 2020 6966 206c 6574  {.        if let
+000099f0: 2053 6f6d 6528 6d29 203d 206d 6178 5f62   Some(m) = max_b
+00009a00: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+00009a10: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
+00009a20: 6620 6d20 3d3d 2031 207b 0a20 2020 2020  f m == 1 {.     
+00009a30: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00009a40: 6e20 7665 6321 5b73 656c 662e 636c 6f6e  n vec![self.clon
+00009a50: 6528 295d 3b0a 2020 2020 2020 2020 2020  e()];.          
+00009a60: 2020 7d0a 2020 2020 2020 2020 7d0a 0a20    }.        }.. 
+00009a70: 2020 2020 2020 202f 2f20 6368 6563 6b20         // check 
+00009a80: 666f 7220 7072 6f62 6c65 6d73 2061 7269  for problems ari
+00009a90: 7369 6e67 2066 726f 6d20 6361 6e63 656c  sing from cancel
+00009aa0: 696e 6720 7465 726d 7320 696e 2074 6865  ing terms in the
+00009ab0: 2064 6572 6976 6174 6976 650a 2020 2020   derivative.    
+00009ac0: 2020 2020 6c65 7420 6465 7220 3d20 7365      let der = se
+00009ad0: 6c66 2e64 6572 6976 6174 6976 6528 6f72  lf.derivative(or
+00009ae0: 6465 725b 305d 293b 0a20 2020 2020 2020  der[0]);.       
+00009af0: 2069 6620 6465 722e 6973 5f7a 6572 6f28   if der.is_zero(
+00009b00: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00009b10: 6c65 7420 6d75 7420 6e65 775f 6f72 6465  let mut new_orde
+00009b20: 7220 3d20 6f72 6465 722e 746f 5f76 6563  r = order.to_vec
+00009b30: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
+00009b40: 6c65 7420 7620 3d20 6e65 775f 6f72 6465  let v = new_orde
+00009b50: 722e 7265 6d6f 7665 2830 293b 0a20 2020  r.remove(0);.   
+00009b60: 2020 2020 2020 2020 206e 6577 5f6f 7264           new_ord
+00009b70: 6572 2e70 7573 6828 7629 3b0a 2020 2020  er.push(v);.    
+00009b80: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00009b90: 656c 662e 6d75 6c74 6976 6172 6961 7465  elf.multivariate
+00009ba0: 5f66 6163 746f 7269 7a61 7469 6f6e 280a  _factorization(.
 00009bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009bc0: 636f 6566 6669 6369 656e 745f 7570 7065  coefficient_uppe
-00009bd0: 725f 626f 756e 642c 0a20 2020 2020 2020  r_bound,.       
-00009be0: 2020 2020 2020 2020 206d 6178 5f62 6976           max_biv
-00009bf0: 6172 6961 7465 5f66 6163 746f 7273 2c0a  ariate_factors,.
-00009c00: 2020 2020 2020 2020 2020 2020 293b 0a20              );. 
-00009c10: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
-00009c20: 2020 6c65 7420 6720 3d20 7365 6c66 2e67    let g = self.g
-00009c30: 6364 2826 6465 7229 3b0a 2020 2020 2020  cd(&der);.      
-00009c40: 2020 6966 2021 672e 6973 5f63 6f6e 7374    if !g.is_const
-00009c50: 616e 7428 2920 7b0a 2020 2020 2020 2020  ant() {.        
-00009c60: 2020 2020 6c65 7420 6d75 7420 6661 6374      let mut fact
-00009c70: 6f72 7320 3d0a 2020 2020 2020 2020 2020  ors =.          
-00009c80: 2020 2020 2020 672e 6d75 6c74 6976 6172        g.multivar
-00009c90: 6961 7465 5f66 6163 746f 7269 7a61 7469  iate_factorizati
-00009ca0: 6f6e 286f 7264 6572 2c20 636f 6566 6669  on(order, coeffi
-00009cb0: 6369 656e 745f 7570 7065 725f 626f 756e  cient_upper_boun
-00009cc0: 642c 206d 6178 5f62 6976 6172 6961 7465  d, max_bivariate
-00009cd0: 5f66 6163 746f 7273 293b 0a20 2020 2020  _factors);.     
-00009ce0: 2020 2020 2020 2066 6163 746f 7273 2e65         factors.e
-00009cf0: 7874 656e 6428 2873 656c 6620 2f20 2667  xtend((self / &g
-00009d00: 292e 6d75 6c74 6976 6172 6961 7465 5f66  ).multivariate_f
-00009d10: 6163 746f 7269 7a61 7469 6f6e 280a 2020  actorization(.  
-00009d20: 2020 2020 2020 2020 2020 2020 2020 6f72                or
-00009d30: 6465 722c 0a20 2020 2020 2020 2020 2020  der,.           
-00009d40: 2020 2020 2063 6f65 6666 6963 6965 6e74       coefficient
-00009d50: 5f75 7070 6572 5f62 6f75 6e64 2c0a 2020  _upper_bound,.  
-00009d60: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
-00009d70: 785f 6269 7661 7269 6174 655f 6661 6374  x_bivariate_fact
-00009d80: 6f72 732c 0a20 2020 2020 2020 2020 2020  ors,.           
-00009d90: 2029 293b 0a20 2020 2020 2020 2020 2020   ));.           
-00009da0: 2072 6574 7572 6e20 6661 6374 6f72 733b   return factors;
-00009db0: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-00009dc0: 2020 2020 2f2f 2073 656c 6563 7420 6120      // select a 
-00009dd0: 7375 6974 6162 6c65 2065 7661 6c75 6174  suitable evaluat
-00009de0: 696f 6e20 706f 696e 740a 2020 2020 2020  ion point.      
-00009df0: 2020 6c65 7420 6d75 7420 7361 6d70 6c65    let mut sample
-00009e00: 5f70 6f69 6e74 733a 2056 6563 3c5f 3e20  _points: Vec<_> 
-00009e10: 3d0a 2020 2020 2020 2020 2020 2020 6f72  =.            or
-00009e20: 6465 725b 312e 2e5d 2e69 7465 7228 292e  der[1..].iter().
-00009e30: 6d61 7028 7c69 7c20 282a 692c 2073 656c  map(|i| (*i, sel
-00009e40: 662e 6669 656c 642e 7a65 726f 2829 2929  f.field.zero()))
-00009e50: 2e63 6f6c 6c65 6374 2829 3b0a 2020 2020  .collect();.    
-00009e60: 2020 2020 6c65 7420 6d75 7420 756e 695f      let mut uni_
-00009e70: 663b 0a20 2020 2020 2020 206c 6574 206d  f;.        let m
-00009e80: 7574 2062 6976 5f66 3b0a 2020 2020 2020  ut biv_f;.      
-00009e90: 2020 6c65 7420 6d75 7420 726e 6720 3d20    let mut rng = 
-00009ea0: 7468 7265 6164 5f72 6e67 2829 3b0a 2020  thread_rng();.  
-00009eb0: 2020 2020 2020 6c65 7420 6465 6772 6565        let degree
-00009ec0: 203d 2073 656c 662e 6465 6772 6565 286f   = self.degree(o
-00009ed0: 7264 6572 5b30 5d29 3b0a 0a20 2020 2020  rder[0]);..     
-00009ee0: 2020 206c 6574 2075 6e69 5f6c 636f 6566     let uni_lcoef
-00009ef0: 6620 3d20 7365 6c66 2e75 6e69 7661 7269  f = self.univari
-00009f00: 6174 655f 6c63 6f65 6666 286f 7264 6572  ate_lcoeff(order
-00009f10: 5b30 5d29 3b0a 0a20 2020 2020 2020 206c  [0]);..        l
-00009f20: 6574 206d 7574 2063 6f6e 7465 6e74 5f66  et mut content_f
-00009f30: 6169 6c5f 636f 756e 7420 3d20 303b 0a20  ail_count = 0;. 
-00009f40: 2020 2020 2020 2027 6e65 775f 7361 6d70         'new_samp
-00009f50: 6c65 3a20 6c6f 6f70 207b 0a20 2020 2020  le: loop {.     
-00009f60: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
-00009f70: 266d 7574 2073 616d 706c 655f 706f 696e  &mut sample_poin
-00009f80: 7473 207b 0a20 2020 2020 2020 2020 2020  ts {.           
-00009f90: 2020 2020 2073 2e31 203d 2073 656c 662e       s.1 = self.
-00009fa0: 6669 656c 642e 6e74 6828 726e 672e 6765  field.nth(rng.ge
-00009fb0: 6e5f 7261 6e67 6528 302e 2e3d 636f 6566  n_range(0..=coef
-00009fc0: 6669 6369 656e 745f 7570 7065 725f 626f  ficient_upper_bo
-00009fd0: 756e 6429 293b 0a20 2020 2020 2020 2020  und));.         
-00009fe0: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00009ff0: 2020 6269 765f 6620 3d20 7365 6c66 2e63    biv_f = self.c
-0000a000: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
-0000a010: 2020 2020 666f 7220 2828 762c 2073 292c      for ((v, s),
-0000a020: 2072 656d 5f76 6172 2920 696e 2073 616d   rem_var) in sam
-0000a030: 706c 655f 706f 696e 7473 5b31 2e2e 5d2e  ple_points[1..].
-0000a040: 6974 6572 2829 2e7a 6970 2826 6f72 6465  iter().zip(&orde
-0000a050: 725b 312e 2e5d 292e 7265 7628 2920 7b0a  r[1..]).rev() {.
-0000a060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a070: 6269 765f 6620 3d20 6269 765f 662e 7265  biv_f = biv_f.re
-0000a080: 706c 6163 6528 2a76 2c20 7329 3b0a 2020  place(*v, s);.  
-0000a090: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000a0a0: 2062 6976 5f66 2e64 6567 7265 6528 2a72   biv_f.degree(*r
-0000a0b0: 656d 5f76 6172 2920 213d 2073 656c 662e  em_var) != self.
-0000a0c0: 6465 6772 6565 282a 7265 6d5f 7661 7229  degree(*rem_var)
-0000a0d0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-0000a0e0: 2020 2020 2020 2063 6f65 6666 6963 6965         coefficie
-0000a0f0: 6e74 5f75 7070 6572 5f62 6f75 6e64 202b  nt_upper_bound +
-0000a100: 3d20 313b 0a20 2020 2020 2020 2020 2020  = 1;.           
-0000a110: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-0000a120: 6520 276e 6577 5f73 616d 706c 653b 0a20  e 'new_sample;. 
-0000a130: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-0000a140: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
-0000a150: 2020 2020 2020 2020 2020 2020 2f2f 2072              // r
-0000a160: 6571 7569 7265 6d65 6e74 2066 6f72 206c  equirement for l
-0000a170: 6561 6469 6e67 2063 6f65 6666 6963 6965  eading coefficie
-0000a180: 6e74 2070 7265 636f 6d70 7574 6174 696f  nt precomputatio
-0000a190: 6e0a 2020 2020 2020 2020 2020 2020 6966  n.            if
-0000a1a0: 2062 6976 5f66 2e75 6e69 7661 7269 6174   biv_f.univariat
-0000a1b0: 655f 6c63 6f65 6666 286f 7264 6572 5b30  e_lcoeff(order[0
-0000a1c0: 5d29 2e64 6567 7265 6528 6f72 6465 725b  ]).degree(order[
-0000a1d0: 315d 2920 213d 2075 6e69 5f6c 636f 6566  1]) != uni_lcoef
-0000a1e0: 662e 6465 6772 6565 286f 7264 6572 5b31  f.degree(order[1
-0000a1f0: 5d29 207b 0a20 2020 2020 2020 2020 2020  ]) {.           
-0000a200: 2020 2020 2064 6562 7567 2128 0a20 2020       debug!(.   
-0000a210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a220: 2022 4465 6772 6565 206f 6620 787b 7d20   "Degree of x{} 
-0000a230: 696e 206c 6561 6469 6e67 2063 6f65 6666  in leading coeff
-0000a240: 6963 6965 6e74 206f 6620 6269 7661 7269  icient of bivari
-0000a250: 6174 6520 696d 6167 6520 6973 2077 726f  ate image is wro
-0000a260: 6e67 222c 0a20 2020 2020 2020 2020 2020  ng",.           
-0000a270: 2020 2020 2020 2020 206f 7264 6572 5b31           order[1
-0000a280: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0000a290: 2020 293b 0a20 2020 2020 2020 2020 2020    );.           
-0000a2a0: 2020 2020 2063 6f65 6666 6963 6965 6e74       coefficient
-0000a2b0: 5f75 7070 6572 5f62 6f75 6e64 202b 3d20  _upper_bound += 
-0000a2c0: 313b 0a20 2020 2020 2020 2020 2020 2020  1;.             
-0000a2d0: 2020 2063 6f6e 7469 6e75 6520 276e 6577     continue 'new
-0000a2e0: 5f73 616d 706c 653b 0a20 2020 2020 2020  _sample;.       
-0000a2f0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-0000a300: 2020 2020 6c65 7420 6269 765f 6466 203d      let biv_df =
-0000a310: 2062 6976 5f66 2e64 6572 6976 6174 6976   biv_f.derivativ
-0000a320: 6528 6f72 6465 725b 305d 293b 0a0a 2020  e(order[0]);..  
-0000a330: 2020 2020 2020 2020 2020 756e 695f 6620            uni_f 
-0000a340: 3d20 6269 765f 662e 7265 706c 6163 6528  = biv_f.replace(
-0000a350: 7361 6d70 6c65 5f70 6f69 6e74 735b 305d  sample_points[0]
-0000a360: 2e30 2c20 2673 616d 706c 655f 706f 696e  .0, &sample_poin
-0000a370: 7473 5b30 5d2e 3129 3b0a 2020 2020 2020  ts[0].1);.      
-0000a380: 2020 2020 2020 6c65 7420 756e 695f 6466        let uni_df
-0000a390: 203d 2075 6e69 5f66 2e64 6572 6976 6174   = uni_f.derivat
-0000a3a0: 6976 6528 6f72 6465 725b 305d 293b 0a0a  ive(order[0]);..
-0000a3b0: 2020 2020 2020 2020 2020 2020 6966 2064              if d
-0000a3c0: 6567 7265 6520 3d3d 2062 6976 5f66 2e64  egree == biv_f.d
-0000a3d0: 6567 7265 6528 6f72 6465 725b 305d 290a  egree(order[0]).
-0000a3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3f0: 2626 2064 6567 7265 6520 3d3d 2075 6e69  && degree == uni
-0000a400: 5f66 2e64 6567 7265 6528 6f72 6465 725b  _f.degree(order[
-0000a410: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-0000a420: 2020 2020 2626 2062 6976 5f66 2e67 6364      && biv_f.gcd
-0000a430: 2826 6269 765f 6466 292e 6973 5f63 6f6e  (&biv_df).is_con
-0000a440: 7374 616e 7428 290a 2020 2020 2020 2020  stant().        
-0000a450: 2020 2020 2020 2020 2626 2075 6e69 5f66          && uni_f
-0000a460: 2e67 6364 2826 756e 695f 6466 292e 6973  .gcd(&uni_df).is
-0000a470: 5f63 6f6e 7374 616e 7428 290a 2020 2020  _constant().    
-0000a480: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
-0000a490: 2020 2020 2020 2020 2020 6966 2021 6269            if !bi
-0000a4a0: 765f 662e 756e 6976 6172 6961 7465 5f63  v_f.univariate_c
-0000a4b0: 6f6e 7465 6e74 286f 7264 6572 5b30 5d29  ontent(order[0])
-0000a4c0: 2e69 735f 6f6e 6528 2920 7b0a 2020 2020  .is_one() {.    
-0000a4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4e0: 636f 6e74 656e 745f 6661 696c 5f63 6f75  content_fail_cou
-0000a4f0: 6e74 202b 3d20 313b 0a0a 2020 2020 2020  nt += 1;..      
-0000a500: 2020 2020 2020 2020 2020 2020 2020 6465                de
-0000a510: 6275 6721 2822 556e 6976 6172 6961 7465  bug!("Univariate
-0000a520: 2063 6f6e 7465 6e74 2069 7320 6e6f 7420   content is not 
-0000a530: 6f6e 6522 293b 0a20 2020 2020 2020 2020  one");.         
-0000a540: 2020 2020 2020 2020 2020 2069 6620 636f             if co
-0000a550: 6e74 656e 745f 6661 696c 5f63 6f75 6e74  ntent_fail_count
-0000a560: 203d 3d20 3420 7b0a 2020 2020 2020 2020   == 4 {.        
-0000a570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a580: 2f2f 2069 7420 6973 206c 696b 656c 7920  // it is likely 
-0000a590: 7468 6174 2077 6520 7769 6c6c 2061 6c77  that we will alw
-0000a5a0: 6179 7320 6669 6e64 2063 6f6e 7465 6e74  ays find content
-0000a5b0: 2066 6f72 2074 6869 7320 7661 7269 6162   for this variab
-0000a5c0: 6c65 206f 7264 6572 696e 672c 2073 6f20  le ordering, so 
-0000a5d0: 6368 616e 6765 2074 6865 0a20 2020 2020  change the.     
-0000a5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5f0: 2020 202f 2f20 7365 636f 6e64 2076 6172     // second var
-0000a600: 6961 626c 650a 2020 2020 2020 2020 2020  iable.          
-0000a610: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
-0000a620: 2054 4f44 4f3a 2069 7320 7468 6973 2067   TODO: is this g
-0000a630: 7561 7261 6e74 6565 6420 746f 2077 6f72  uaranteed to wor
-0000a640: 6b20 6f72 2073 686f 756c 6420 7765 2061  k or should we a
-0000a650: 6c73 6f20 6368 616e 6765 2074 6865 2066  lso change the f
-0000a660: 6972 7374 2076 6172 6961 626c 653f 0a20  irst variable?. 
-0000a670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a680: 2020 2020 2020 206c 6574 2073 6563 5f76         let sec_v
-0000a690: 6172 203d 206f 7264 6572 5b31 5d3b 0a20  ar = order[1];. 
-0000a6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6b0: 2020 2020 2020 206f 7264 6572 2e63 6f70         order.cop
-0000a6c0: 795f 7769 7468 696e 2832 2e2e 6f72 6465  y_within(2..orde
-0000a6d0: 722e 6c65 6e28 292c 2031 293b 0a20 2020  r.len(), 1);.   
-0000a6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6f0: 2020 2020 206f 7264 6572 5b6f 7264 6572       order[order
-0000a700: 2e6c 656e 2829 202d 2031 5d20 3d20 7365  .len() - 1] = se
-0000a710: 635f 7661 723b 0a0a 2020 2020 2020 2020  c_var;..        
-0000a720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a730: 666f 7220 2828 7673 2c20 5f29 2c20 7629  for ((vs, _), v)
-0000a740: 2069 6e20 7361 6d70 6c65 5f70 6f69 6e74   in sample_point
-0000a750: 732e 6974 6572 5f6d 7574 2829 2e7a 6970  s.iter_mut().zip
-0000a760: 2826 6f72 6465 725b 312e 2e5d 2920 7b0a  (&order[1..]) {.
-0000a770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a780: 2020 2020 2020 2020 2020 2020 2a76 7320              *vs 
-0000a790: 3d20 2a76 3b0a 2020 2020 2020 2020 2020  = *v;.          
-0000a7a0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-0000a7b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a7c0: 2020 2020 2020 2020 2064 6562 7567 2128           debug!(
-0000a7d0: 2243 6861 6e67 6564 2074 6865 2073 6563  "Changed the sec
-0000a7e0: 6f6e 6420 7661 7269 6162 6c65 2074 6f20  ond variable to 
-0000a7f0: 7b7d 222c 206f 7264 6572 5b31 5d29 3b0a  {}", order[1]);.
-0000a800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a810: 2020 2020 2020 2020 636f 6e74 656e 745f          content_
-0000a820: 6661 696c 5f63 6f75 6e74 203d 2030 3b0a  fail_count = 0;.
-0000a830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a840: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-0000a850: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
-0000a860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a870: 2020 2062 7265 616b 3b0a 2020 2020 2020     break;.      
-0000a880: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-0000a890: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-0000a8a0: 2020 2020 2020 2063 6f65 6666 6963 6965         coefficie
-0000a8b0: 6e74 5f75 7070 6572 5f62 6f75 6e64 202b  nt_upper_bound +
-0000a8c0: 3d20 313b 0a20 2020 2020 2020 207d 0a0a  = 1;.        }..
-0000a8d0: 2020 2020 2020 2020 666f 7220 2876 2c20          for (v, 
-0000a8e0: 7329 2069 6e20 2673 616d 706c 655f 706f  s) in &sample_po
-0000a8f0: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
-0000a900: 2020 2064 6562 7567 2128 2253 616d 706c     debug!("Sampl
-0000a910: 6520 706f 696e 7420 7b7d 3d7b 7d22 2c20  e point {}={}", 
-0000a920: 762c 2073 656c 662e 6669 656c 642e 6672  v, self.field.fr
-0000a930: 6f6d 5f65 6c65 6d65 6e74 2873 2929 3b0a  om_element(s));.
-0000a940: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-0000a950: 2020 206c 6574 2062 6976 6172 6961 7465     let bivariate
-0000a960: 5f66 6163 746f 7273 203d 2062 6976 5f66  _factors = biv_f
-0000a970: 2e62 6976 6172 6961 7465 5f66 6163 746f  .bivariate_facto
-0000a980: 7269 7a61 7469 6f6e 286f 7264 6572 5b30  rization(order[0
-0000a990: 5d2c 206f 7264 6572 5b31 5d29 3b0a 0a20  ], order[1]);.. 
-0000a9a0: 2020 2020 2020 2069 6620 6269 7661 7269         if bivari
-0000a9b0: 6174 655f 6661 6374 6f72 732e 6c65 6e28  ate_factors.len(
-0000a9c0: 2920 3d3d 2031 207b 0a20 2020 2020 2020  ) == 1 {.       
-0000a9d0: 2020 2020 202f 2f20 7468 6520 706f 6c79       // the poly
-0000a9e0: 6e6f 6d69 616c 2069 7320 6972 7265 6475  nomial is irredu
-0000a9f0: 6369 626c 650a 2020 2020 2020 2020 2020  cible.          
-0000aa00: 2020 7265 7475 726e 2076 6563 215b 7365    return vec![se
-0000aa10: 6c66 2e63 6c6f 6e65 2829 5d3b 0a20 2020  lf.clone()];.   
-0000aa20: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-0000aa30: 6966 206c 6574 2053 6f6d 6528 6d61 7829  if let Some(max)
-0000aa40: 203d 206d 6178 5f62 6976 6172 6961 7465   = max_bivariate
-0000aa50: 5f66 6163 746f 7273 207b 0a20 2020 2020  _factors {.     
-0000aa60: 2020 2020 2020 2069 6620 6269 7661 7269         if bivari
-0000aa70: 6174 655f 6661 6374 6f72 732e 6c65 6e28  ate_factors.len(
-0000aa80: 2920 3e20 6d61 7820 7b0a 2020 2020 2020  ) > max {.      
-0000aa90: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000aaa0: 2073 656c 662e 6d75 6c74 6976 6172 6961   self.multivaria
-0000aab0: 7465 5f66 6163 746f 7269 7a61 7469 6f6e  te_factorization
-0000aac0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000aad0: 2020 2020 2020 6f72 6465 722c 0a20 2020        order,.   
-0000aae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aaf0: 2063 6f65 6666 6963 6965 6e74 5f75 7070   coefficient_upp
-0000ab00: 6572 5f62 6f75 6e64 2c0a 2020 2020 2020  er_bound,.      
-0000ab10: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
-0000ab20: 785f 6269 7661 7269 6174 655f 6661 6374  x_bivariate_fact
-0000ab30: 6f72 732c 0a20 2020 2020 2020 2020 2020  ors,.           
-0000ab40: 2020 2020 2029 3b0a 2020 2020 2020 2020       );.        
-0000ab50: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
-0000ab60: 0a20 2020 2020 2020 206c 6574 2028 736f  .        let (so
-0000ab70: 7274 6564 5f62 6976 5f66 6163 746f 7273  rted_biv_factors
-0000ab80: 2c20 7472 7565 5f6c 636f 6566 6673 2920  , true_lcoeffs) 
-0000ab90: 3d0a 2020 2020 2020 2020 2020 2020 6d61  =.            ma
-0000aba0: 7463 6820 7365 6c66 2e6c 636f 6566 665f  tch self.lcoeff_
-0000abb0: 7072 6563 6f6d 7075 7461 7469 6f6e 2826  precomputation(&
-0000abc0: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-0000abd0: 732c 2026 7361 6d70 6c65 5f70 6f69 6e74  s, &sample_point
-0000abe0: 732c 206f 7264 6572 2920 7b0a 2020 2020  s, order) {.    
-0000abf0: 2020 2020 2020 2020 2020 2020 4f6b 2828              Ok((
-0000ac00: 736f 7274 6564 5f62 6976 5f66 6163 746f  sorted_biv_facto
-0000ac10: 7273 2c20 7472 7565 5f6c 636f 6566 6673  rs, true_lcoeffs
-0000ac20: 2929 203d 3e20 2873 6f72 7465 645f 6269  )) => (sorted_bi
-0000ac30: 765f 6661 6374 6f72 732c 2074 7275 655f  v_factors, true_
-0000ac40: 6c63 6f65 6666 7329 2c0a 2020 2020 2020  lcoeffs),.      
-0000ac50: 2020 2020 2020 2020 2020 4572 7228 6d61            Err(ma
-0000ac60: 785f 6269 7629 203d 3e20 7b0a 2020 2020  x_biv) => {.    
-0000ac70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac80: 2f2f 2074 6865 206c 6561 6469 6e67 2063  // the leading c
-0000ac90: 6f65 6666 6963 6965 6e74 2063 6f6d 7075  oefficient compu
-0000aca0: 7461 7469 6f6e 2066 6169 6c65 6420 6265  tation failed be
-0000acb0: 6361 7573 6520 7468 6520 6269 7661 7261  cause the bivara
-0000acc0: 6974 6520 6661 6374 6f72 697a 6174 696f  ite factorizatio
-0000acd0: 6e20 7761 7320 7772 6f6e 670a 2020 2020  n was wrong.    
-0000ace0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000acf0: 2f2f 2074 7279 2061 6761 696e 2077 6974  // try again wit
-0000ad00: 6820 6f74 6865 7220 7361 6d70 6c65 2070  h other sample p
-0000ad10: 6f69 6e74 7320 616e 6420 6120 6265 7474  oints and a bett
-0000ad20: 6572 2062 6f75 6e64 0a20 2020 2020 2020  er bound.       
-0000ad30: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000ad40: 7572 6e20 7365 6c66 2e6d 756c 7469 7661  urn self.multiva
-0000ad50: 7269 6174 655f 6661 6374 6f72 697a 6174  riate_factorizat
-0000ad60: 696f 6e28 0a20 2020 2020 2020 2020 2020  ion(.           
-0000ad70: 2020 2020 2020 2020 2020 2020 206f 7264               ord
-0000ad80: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
-0000ad90: 2020 2020 2020 2020 2020 2020 636f 6566              coef
-0000ada0: 6669 6369 656e 745f 7570 7065 725f 626f  ficient_upper_bo
-0000adb0: 756e 6420 2b20 312c 0a20 2020 2020 2020  und + 1,.       
-0000adc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000add0: 2053 6f6d 6528 6d61 785f 6269 7629 2c0a   Some(max_biv),.
+00009bc0: 266d 7574 206e 6577 5f6f 7264 6572 2c0a  &mut new_order,.
+00009bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009be0: 636f 6566 6669 6369 656e 745f 7570 7065  coefficient_uppe
+00009bf0: 725f 626f 756e 642c 0a20 2020 2020 2020  r_bound,.       
+00009c00: 2020 2020 2020 2020 206d 6178 5f62 6976           max_biv
+00009c10: 6172 6961 7465 5f66 6163 746f 7273 2c0a  ariate_factors,.
+00009c20: 2020 2020 2020 2020 2020 2020 293b 0a20              );. 
+00009c30: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+00009c40: 2020 6c65 7420 6720 3d20 7365 6c66 2e67    let g = self.g
+00009c50: 6364 2826 6465 7229 3b0a 2020 2020 2020  cd(&der);.      
+00009c60: 2020 6966 2021 672e 6973 5f63 6f6e 7374    if !g.is_const
+00009c70: 616e 7428 2920 7b0a 2020 2020 2020 2020  ant() {.        
+00009c80: 2020 2020 6c65 7420 6d75 7420 6661 6374      let mut fact
+00009c90: 6f72 7320 3d0a 2020 2020 2020 2020 2020  ors =.          
+00009ca0: 2020 2020 2020 672e 6d75 6c74 6976 6172        g.multivar
+00009cb0: 6961 7465 5f66 6163 746f 7269 7a61 7469  iate_factorizati
+00009cc0: 6f6e 286f 7264 6572 2c20 636f 6566 6669  on(order, coeffi
+00009cd0: 6369 656e 745f 7570 7065 725f 626f 756e  cient_upper_boun
+00009ce0: 642c 206d 6178 5f62 6976 6172 6961 7465  d, max_bivariate
+00009cf0: 5f66 6163 746f 7273 293b 0a20 2020 2020  _factors);.     
+00009d00: 2020 2020 2020 2066 6163 746f 7273 2e65         factors.e
+00009d10: 7874 656e 6428 2873 656c 6620 2f20 2667  xtend((self / &g
+00009d20: 292e 6d75 6c74 6976 6172 6961 7465 5f66  ).multivariate_f
+00009d30: 6163 746f 7269 7a61 7469 6f6e 280a 2020  actorization(.  
+00009d40: 2020 2020 2020 2020 2020 2020 2020 6f72                or
+00009d50: 6465 722c 0a20 2020 2020 2020 2020 2020  der,.           
+00009d60: 2020 2020 2063 6f65 6666 6963 6965 6e74       coefficient
+00009d70: 5f75 7070 6572 5f62 6f75 6e64 2c0a 2020  _upper_bound,.  
+00009d80: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+00009d90: 785f 6269 7661 7269 6174 655f 6661 6374  x_bivariate_fact
+00009da0: 6f72 732c 0a20 2020 2020 2020 2020 2020  ors,.           
+00009db0: 2029 293b 0a20 2020 2020 2020 2020 2020   ));.           
+00009dc0: 2072 6574 7572 6e20 6661 6374 6f72 733b   return factors;
+00009dd0: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
+00009de0: 2020 2020 2f2f 2073 656c 6563 7420 6120      // select a 
+00009df0: 7375 6974 6162 6c65 2065 7661 6c75 6174  suitable evaluat
+00009e00: 696f 6e20 706f 696e 740a 2020 2020 2020  ion point.      
+00009e10: 2020 6c65 7420 6d75 7420 7361 6d70 6c65    let mut sample
+00009e20: 5f70 6f69 6e74 733a 2056 6563 3c5f 3e20  _points: Vec<_> 
+00009e30: 3d0a 2020 2020 2020 2020 2020 2020 6f72  =.            or
+00009e40: 6465 725b 312e 2e5d 2e69 7465 7228 292e  der[1..].iter().
+00009e50: 6d61 7028 7c69 7c20 282a 692c 2073 656c  map(|i| (*i, sel
+00009e60: 662e 6669 656c 642e 7a65 726f 2829 2929  f.field.zero()))
+00009e70: 2e63 6f6c 6c65 6374 2829 3b0a 2020 2020  .collect();.    
+00009e80: 2020 2020 6c65 7420 6d75 7420 756e 695f      let mut uni_
+00009e90: 663b 0a20 2020 2020 2020 206c 6574 206d  f;.        let m
+00009ea0: 7574 2062 6976 5f66 3b0a 2020 2020 2020  ut biv_f;.      
+00009eb0: 2020 6c65 7420 6d75 7420 726e 6720 3d20    let mut rng = 
+00009ec0: 7468 7265 6164 5f72 6e67 2829 3b0a 2020  thread_rng();.  
+00009ed0: 2020 2020 2020 6c65 7420 6465 6772 6565        let degree
+00009ee0: 203d 2073 656c 662e 6465 6772 6565 286f   = self.degree(o
+00009ef0: 7264 6572 5b30 5d29 3b0a 0a20 2020 2020  rder[0]);..     
+00009f00: 2020 206c 6574 2075 6e69 5f6c 636f 6566     let uni_lcoef
+00009f10: 6620 3d20 7365 6c66 2e75 6e69 7661 7269  f = self.univari
+00009f20: 6174 655f 6c63 6f65 6666 286f 7264 6572  ate_lcoeff(order
+00009f30: 5b30 5d29 3b0a 0a20 2020 2020 2020 206c  [0]);..        l
+00009f40: 6574 206d 7574 2063 6f6e 7465 6e74 5f66  et mut content_f
+00009f50: 6169 6c5f 636f 756e 7420 3d20 303b 0a20  ail_count = 0;. 
+00009f60: 2020 2020 2020 2027 6e65 775f 7361 6d70         'new_samp
+00009f70: 6c65 3a20 6c6f 6f70 207b 0a20 2020 2020  le: loop {.     
+00009f80: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
+00009f90: 266d 7574 2073 616d 706c 655f 706f 696e  &mut sample_poin
+00009fa0: 7473 207b 0a20 2020 2020 2020 2020 2020  ts {.           
+00009fb0: 2020 2020 2073 2e31 203d 2073 656c 662e       s.1 = self.
+00009fc0: 6669 656c 642e 6e74 6828 726e 672e 6765  field.nth(rng.ge
+00009fd0: 6e5f 7261 6e67 6528 302e 2e3d 636f 6566  n_range(0..=coef
+00009fe0: 6669 6369 656e 745f 7570 7065 725f 626f  ficient_upper_bo
+00009ff0: 756e 6429 293b 0a20 2020 2020 2020 2020  und));.         
+0000a000: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+0000a010: 2020 6269 765f 6620 3d20 7365 6c66 2e63    biv_f = self.c
+0000a020: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
+0000a030: 2020 2020 666f 7220 2828 762c 2073 292c      for ((v, s),
+0000a040: 2072 656d 5f76 6172 2920 696e 2073 616d   rem_var) in sam
+0000a050: 706c 655f 706f 696e 7473 5b31 2e2e 5d2e  ple_points[1..].
+0000a060: 6974 6572 2829 2e7a 6970 2826 6f72 6465  iter().zip(&orde
+0000a070: 725b 312e 2e5d 292e 7265 7628 2920 7b0a  r[1..]).rev() {.
+0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a090: 6269 765f 6620 3d20 6269 765f 662e 7265  biv_f = biv_f.re
+0000a0a0: 706c 6163 6528 2a76 2c20 7329 3b0a 2020  place(*v, s);.  
+0000a0b0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000a0c0: 2062 6976 5f66 2e64 6567 7265 6528 2a72   biv_f.degree(*r
+0000a0d0: 656d 5f76 6172 2920 213d 2073 656c 662e  em_var) != self.
+0000a0e0: 6465 6772 6565 282a 7265 6d5f 7661 7229  degree(*rem_var)
+0000a0f0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+0000a100: 2020 2020 2020 2063 6f65 6666 6963 6965         coefficie
+0000a110: 6e74 5f75 7070 6572 5f62 6f75 6e64 202b  nt_upper_bound +
+0000a120: 3d20 313b 0a20 2020 2020 2020 2020 2020  = 1;.           
+0000a130: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+0000a140: 6520 276e 6577 5f73 616d 706c 653b 0a20  e 'new_sample;. 
+0000a150: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+0000a160: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+0000a170: 2020 2020 2020 2020 2020 2020 2f2f 2072              // r
+0000a180: 6571 7569 7265 6d65 6e74 2066 6f72 206c  equirement for l
+0000a190: 6561 6469 6e67 2063 6f65 6666 6963 6965  eading coefficie
+0000a1a0: 6e74 2070 7265 636f 6d70 7574 6174 696f  nt precomputatio
+0000a1b0: 6e0a 2020 2020 2020 2020 2020 2020 6966  n.            if
+0000a1c0: 2062 6976 5f66 2e75 6e69 7661 7269 6174   biv_f.univariat
+0000a1d0: 655f 6c63 6f65 6666 286f 7264 6572 5b30  e_lcoeff(order[0
+0000a1e0: 5d29 2e64 6567 7265 6528 6f72 6465 725b  ]).degree(order[
+0000a1f0: 315d 2920 213d 2075 6e69 5f6c 636f 6566  1]) != uni_lcoef
+0000a200: 662e 6465 6772 6565 286f 7264 6572 5b31  f.degree(order[1
+0000a210: 5d29 207b 0a20 2020 2020 2020 2020 2020  ]) {.           
+0000a220: 2020 2020 2064 6562 7567 2128 0a20 2020       debug!(.   
+0000a230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a240: 2022 4465 6772 6565 206f 6620 787b 7d20   "Degree of x{} 
+0000a250: 696e 206c 6561 6469 6e67 2063 6f65 6666  in leading coeff
+0000a260: 6963 6965 6e74 206f 6620 6269 7661 7269  icient of bivari
+0000a270: 6174 6520 696d 6167 6520 6973 2077 726f  ate image is wro
+0000a280: 6e67 222c 0a20 2020 2020 2020 2020 2020  ng",.           
+0000a290: 2020 2020 2020 2020 206f 7264 6572 5b31           order[1
+0000a2a0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000a2b0: 2020 293b 0a20 2020 2020 2020 2020 2020    );.           
+0000a2c0: 2020 2020 2063 6f65 6666 6963 6965 6e74       coefficient
+0000a2d0: 5f75 7070 6572 5f62 6f75 6e64 202b 3d20  _upper_bound += 
+0000a2e0: 313b 0a20 2020 2020 2020 2020 2020 2020  1;.             
+0000a2f0: 2020 2063 6f6e 7469 6e75 6520 276e 6577     continue 'new
+0000a300: 5f73 616d 706c 653b 0a20 2020 2020 2020  _sample;.       
+0000a310: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+0000a320: 2020 2020 6c65 7420 6269 765f 6466 203d      let biv_df =
+0000a330: 2062 6976 5f66 2e64 6572 6976 6174 6976   biv_f.derivativ
+0000a340: 6528 6f72 6465 725b 305d 293b 0a0a 2020  e(order[0]);..  
+0000a350: 2020 2020 2020 2020 2020 756e 695f 6620            uni_f 
+0000a360: 3d20 6269 765f 662e 7265 706c 6163 6528  = biv_f.replace(
+0000a370: 7361 6d70 6c65 5f70 6f69 6e74 735b 305d  sample_points[0]
+0000a380: 2e30 2c20 2673 616d 706c 655f 706f 696e  .0, &sample_poin
+0000a390: 7473 5b30 5d2e 3129 3b0a 2020 2020 2020  ts[0].1);.      
+0000a3a0: 2020 2020 2020 6c65 7420 756e 695f 6466        let uni_df
+0000a3b0: 203d 2075 6e69 5f66 2e64 6572 6976 6174   = uni_f.derivat
+0000a3c0: 6976 6528 6f72 6465 725b 305d 293b 0a0a  ive(order[0]);..
+0000a3d0: 2020 2020 2020 2020 2020 2020 6966 2064              if d
+0000a3e0: 6567 7265 6520 3d3d 2062 6976 5f66 2e64  egree == biv_f.d
+0000a3f0: 6567 7265 6528 6f72 6465 725b 305d 290a  egree(order[0]).
+0000a400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a410: 2626 2064 6567 7265 6520 3d3d 2075 6e69  && degree == uni
+0000a420: 5f66 2e64 6567 7265 6528 6f72 6465 725b  _f.degree(order[
+0000a430: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
+0000a440: 2020 2020 2626 2062 6976 5f66 2e67 6364      && biv_f.gcd
+0000a450: 2826 6269 765f 6466 292e 6973 5f63 6f6e  (&biv_df).is_con
+0000a460: 7374 616e 7428 290a 2020 2020 2020 2020  stant().        
+0000a470: 2020 2020 2020 2020 2626 2075 6e69 5f66          && uni_f
+0000a480: 2e67 6364 2826 756e 695f 6466 292e 6973  .gcd(&uni_df).is
+0000a490: 5f63 6f6e 7374 616e 7428 290a 2020 2020  _constant().    
+0000a4a0: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
+0000a4b0: 2020 2020 2020 2020 2020 6966 2021 6269            if !bi
+0000a4c0: 765f 662e 756e 6976 6172 6961 7465 5f63  v_f.univariate_c
+0000a4d0: 6f6e 7465 6e74 286f 7264 6572 5b30 5d29  ontent(order[0])
+0000a4e0: 2e69 735f 6f6e 6528 2920 7b0a 2020 2020  .is_one() {.    
+0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a500: 636f 6e74 656e 745f 6661 696c 5f63 6f75  content_fail_cou
+0000a510: 6e74 202b 3d20 313b 0a0a 2020 2020 2020  nt += 1;..      
+0000a520: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0000a530: 6275 6721 2822 556e 6976 6172 6961 7465  bug!("Univariate
+0000a540: 2063 6f6e 7465 6e74 2069 7320 6e6f 7420   content is not 
+0000a550: 6f6e 6522 293b 0a20 2020 2020 2020 2020  one");.         
+0000a560: 2020 2020 2020 2020 2020 2069 6620 636f             if co
+0000a570: 6e74 656e 745f 6661 696c 5f63 6f75 6e74  ntent_fail_count
+0000a580: 203d 3d20 3420 7b0a 2020 2020 2020 2020   == 4 {.        
+0000a590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a5a0: 2f2f 2069 7420 6973 206c 696b 656c 7920  // it is likely 
+0000a5b0: 7468 6174 2077 6520 7769 6c6c 2061 6c77  that we will alw
+0000a5c0: 6179 7320 6669 6e64 2063 6f6e 7465 6e74  ays find content
+0000a5d0: 2066 6f72 2074 6869 7320 7661 7269 6162   for this variab
+0000a5e0: 6c65 206f 7264 6572 696e 672c 2073 6f20  le ordering, so 
+0000a5f0: 6368 616e 6765 2074 6865 0a20 2020 2020  change the.     
+0000a600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a610: 2020 202f 2f20 7365 636f 6e64 2076 6172     // second var
+0000a620: 6961 626c 650a 2020 2020 2020 2020 2020  iable.          
+0000a630: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
+0000a640: 2054 4f44 4f3a 2069 7320 7468 6973 2067   TODO: is this g
+0000a650: 7561 7261 6e74 6565 6420 746f 2077 6f72  uaranteed to wor
+0000a660: 6b20 6f72 2073 686f 756c 6420 7765 2061  k or should we a
+0000a670: 6c73 6f20 6368 616e 6765 2074 6865 2066  lso change the f
+0000a680: 6972 7374 2076 6172 6961 626c 653f 0a20  irst variable?. 
+0000a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6a0: 2020 2020 2020 206c 6574 2073 6563 5f76         let sec_v
+0000a6b0: 6172 203d 206f 7264 6572 5b31 5d3b 0a20  ar = order[1];. 
+0000a6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6d0: 2020 2020 2020 206f 7264 6572 2e63 6f70         order.cop
+0000a6e0: 795f 7769 7468 696e 2832 2e2e 6f72 6465  y_within(2..orde
+0000a6f0: 722e 6c65 6e28 292c 2031 293b 0a20 2020  r.len(), 1);.   
+0000a700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a710: 2020 2020 206f 7264 6572 5b6f 7264 6572       order[order
+0000a720: 2e6c 656e 2829 202d 2031 5d20 3d20 7365  .len() - 1] = se
+0000a730: 635f 7661 723b 0a0a 2020 2020 2020 2020  c_var;..        
+0000a740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a750: 666f 7220 2828 7673 2c20 5f29 2c20 7629  for ((vs, _), v)
+0000a760: 2069 6e20 7361 6d70 6c65 5f70 6f69 6e74   in sample_point
+0000a770: 732e 6974 6572 5f6d 7574 2829 2e7a 6970  s.iter_mut().zip
+0000a780: 2826 6f72 6465 725b 312e 2e5d 2920 7b0a  (&order[1..]) {.
+0000a790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7a0: 2020 2020 2020 2020 2020 2020 2a76 7320              *vs 
+0000a7b0: 3d20 2a76 3b0a 2020 2020 2020 2020 2020  = *v;.          
+0000a7c0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+0000a7d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a7e0: 2020 2020 2020 2020 2064 6562 7567 2128           debug!(
+0000a7f0: 2243 6861 6e67 6564 2074 6865 2073 6563  "Changed the sec
+0000a800: 6f6e 6420 7661 7269 6162 6c65 2074 6f20  ond variable to 
+0000a810: 7b7d 222c 206f 7264 6572 5b31 5d29 3b0a  {}", order[1]);.
+0000a820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a830: 2020 2020 2020 2020 636f 6e74 656e 745f          content_
+0000a840: 6661 696c 5f63 6f75 6e74 203d 2030 3b0a  fail_count = 0;.
+0000a850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a860: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+0000a870: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
+0000a880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a890: 2020 2062 7265 616b 3b0a 2020 2020 2020     break;.      
+0000a8a0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+0000a8b0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+0000a8c0: 2020 2020 2020 2063 6f65 6666 6963 6965         coefficie
+0000a8d0: 6e74 5f75 7070 6572 5f62 6f75 6e64 202b  nt_upper_bound +
+0000a8e0: 3d20 313b 0a20 2020 2020 2020 207d 0a0a  = 1;.        }..
+0000a8f0: 2020 2020 2020 2020 666f 7220 2876 2c20          for (v, 
+0000a900: 7329 2069 6e20 2673 616d 706c 655f 706f  s) in &sample_po
+0000a910: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
+0000a920: 2020 2064 6562 7567 2128 2253 616d 706c     debug!("Sampl
+0000a930: 6520 706f 696e 7420 7b7d 3d7b 7d22 2c20  e point {}={}", 
+0000a940: 762c 2073 656c 662e 6669 656c 642e 6672  v, self.field.fr
+0000a950: 6f6d 5f65 6c65 6d65 6e74 2873 2929 3b0a  om_element(s));.
+0000a960: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+0000a970: 2020 206c 6574 2062 6976 6172 6961 7465     let bivariate
+0000a980: 5f66 6163 746f 7273 203d 2062 6976 5f66  _factors = biv_f
+0000a990: 2e62 6976 6172 6961 7465 5f66 6163 746f  .bivariate_facto
+0000a9a0: 7269 7a61 7469 6f6e 286f 7264 6572 5b30  rization(order[0
+0000a9b0: 5d2c 206f 7264 6572 5b31 5d29 3b0a 0a20  ], order[1]);.. 
+0000a9c0: 2020 2020 2020 2069 6620 6269 7661 7269         if bivari
+0000a9d0: 6174 655f 6661 6374 6f72 732e 6c65 6e28  ate_factors.len(
+0000a9e0: 2920 3d3d 2031 207b 0a20 2020 2020 2020  ) == 1 {.       
+0000a9f0: 2020 2020 202f 2f20 7468 6520 706f 6c79       // the poly
+0000aa00: 6e6f 6d69 616c 2069 7320 6972 7265 6475  nomial is irredu
+0000aa10: 6369 626c 650a 2020 2020 2020 2020 2020  cible.          
+0000aa20: 2020 7265 7475 726e 2076 6563 215b 7365    return vec![se
+0000aa30: 6c66 2e63 6c6f 6e65 2829 5d3b 0a20 2020  lf.clone()];.   
+0000aa40: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+0000aa50: 6966 206c 6574 2053 6f6d 6528 6d61 7829  if let Some(max)
+0000aa60: 203d 206d 6178 5f62 6976 6172 6961 7465   = max_bivariate
+0000aa70: 5f66 6163 746f 7273 207b 0a20 2020 2020  _factors {.     
+0000aa80: 2020 2020 2020 2069 6620 6269 7661 7269         if bivari
+0000aa90: 6174 655f 6661 6374 6f72 732e 6c65 6e28  ate_factors.len(
+0000aaa0: 2920 3e20 6d61 7820 7b0a 2020 2020 2020  ) > max {.      
+0000aab0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000aac0: 2073 656c 662e 6d75 6c74 6976 6172 6961   self.multivaria
+0000aad0: 7465 5f66 6163 746f 7269 7a61 7469 6f6e  te_factorization
+0000aae0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000aaf0: 2020 2020 2020 6f72 6465 722c 0a20 2020        order,.   
+0000ab00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab10: 2063 6f65 6666 6963 6965 6e74 5f75 7070   coefficient_upp
+0000ab20: 6572 5f62 6f75 6e64 2c0a 2020 2020 2020  er_bound,.      
+0000ab30: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+0000ab40: 785f 6269 7661 7269 6174 655f 6661 6374  x_bivariate_fact
+0000ab50: 6f72 732c 0a20 2020 2020 2020 2020 2020  ors,.           
+0000ab60: 2020 2020 2029 3b0a 2020 2020 2020 2020       );.        
+0000ab70: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
+0000ab80: 0a20 2020 2020 2020 206c 6574 2028 736f  .        let (so
+0000ab90: 7274 6564 5f62 6976 5f66 6163 746f 7273  rted_biv_factors
+0000aba0: 2c20 7472 7565 5f6c 636f 6566 6673 2920  , true_lcoeffs) 
+0000abb0: 3d0a 2020 2020 2020 2020 2020 2020 6d61  =.            ma
+0000abc0: 7463 6820 7365 6c66 2e6c 636f 6566 665f  tch self.lcoeff_
+0000abd0: 7072 6563 6f6d 7075 7461 7469 6f6e 2826  precomputation(&
+0000abe0: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+0000abf0: 732c 2026 7361 6d70 6c65 5f70 6f69 6e74  s, &sample_point
+0000ac00: 732c 206f 7264 6572 2920 7b0a 2020 2020  s, order) {.    
+0000ac10: 2020 2020 2020 2020 2020 2020 4f6b 2828              Ok((
+0000ac20: 736f 7274 6564 5f62 6976 5f66 6163 746f  sorted_biv_facto
+0000ac30: 7273 2c20 7472 7565 5f6c 636f 6566 6673  rs, true_lcoeffs
+0000ac40: 2929 203d 3e20 2873 6f72 7465 645f 6269  )) => (sorted_bi
+0000ac50: 765f 6661 6374 6f72 732c 2074 7275 655f  v_factors, true_
+0000ac60: 6c63 6f65 6666 7329 2c0a 2020 2020 2020  lcoeffs),.      
+0000ac70: 2020 2020 2020 2020 2020 4572 7228 6d61            Err(ma
+0000ac80: 785f 6269 7629 203d 3e20 7b0a 2020 2020  x_biv) => {.    
+0000ac90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aca0: 2f2f 2074 6865 206c 6561 6469 6e67 2063  // the leading c
+0000acb0: 6f65 6666 6963 6965 6e74 2063 6f6d 7075  oefficient compu
+0000acc0: 7461 7469 6f6e 2066 6169 6c65 6420 6265  tation failed be
+0000acd0: 6361 7573 6520 7468 6520 6269 7661 7261  cause the bivara
+0000ace0: 6974 6520 6661 6374 6f72 697a 6174 696f  ite factorizatio
+0000acf0: 6e20 7761 7320 7772 6f6e 670a 2020 2020  n was wrong.    
+0000ad00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad10: 2f2f 2074 7279 2061 6761 696e 2077 6974  // try again wit
+0000ad20: 6820 6f74 6865 7220 7361 6d70 6c65 2070  h other sample p
+0000ad30: 6f69 6e74 7320 616e 6420 6120 6265 7474  oints and a bett
+0000ad40: 6572 2062 6f75 6e64 0a20 2020 2020 2020  er bound.       
+0000ad50: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+0000ad60: 7572 6e20 7365 6c66 2e6d 756c 7469 7661  urn self.multiva
+0000ad70: 7269 6174 655f 6661 6374 6f72 697a 6174  riate_factorizat
+0000ad80: 696f 6e28 0a20 2020 2020 2020 2020 2020  ion(.           
+0000ad90: 2020 2020 2020 2020 2020 2020 206f 7264               ord
+0000ada0: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
+0000adb0: 2020 2020 2020 2020 2020 2020 636f 6566              coef
+0000adc0: 6669 6369 656e 745f 7570 7065 725f 626f  ficient_upper_bo
+0000add0: 756e 6420 2b20 312c 0a20 2020 2020 2020  und + 1,.       
 0000ade0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000adf0: 2020 2020 293b 0a20 2020 2020 2020 2020      );.         
-0000ae00: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000ae10: 2020 2020 207d 3b0a 0a20 2020 2020 2020       };..       
-0000ae20: 2066 6f72 2028 622c 206c 2920 696e 2073   for (b, l) in s
-0000ae30: 6f72 7465 645f 6269 765f 6661 6374 6f72  orted_biv_factor
-0000ae40: 732e 6974 6572 2829 2e7a 6970 2826 7472  s.iter().zip(&tr
-0000ae50: 7565 5f6c 636f 6566 6673 2920 7b0a 2020  ue_lcoeffs) {.  
-0000ae60: 2020 2020 2020 2020 2020 6465 6275 6721            debug!
-0000ae70: 2822 4269 7661 7269 6174 6520 6661 6374  ("Bivariate fact
-0000ae80: 6f72 207b 7d20 7769 7468 2074 7275 6520  or {} with true 
-0000ae90: 6c63 6f65 6666 207b 7d22 2c20 622c 206c  lcoeff {}", b, l
-0000aea0: 293b 0a20 2020 2020 2020 207d 0a0a 2020  );.        }..  
-0000aeb0: 2020 2020 2020 6c65 7420 286d 7574 2075        let (mut u
-0000aec0: 6e69 2c20 6465 6c74 6129 203d 204d 756c  ni, delta) = Mul
-0000aed0: 7469 7661 7269 6174 6550 6f6c 796e 6f6d  tivariatePolynom
-0000aee0: 6961 6c3a 3a75 6e69 7661 7269 6174 655f  ial::univariate_
-0000aef0: 6469 6f70 6861 6e74 696e 655f 6669 656c  diophantine_fiel
-0000af00: 6428 0a20 2020 2020 2020 2020 2020 2026  d(.            &
-0000af10: 736f 7274 6564 5f62 6976 5f66 6163 746f  sorted_biv_facto
-0000af20: 7273 2c0a 2020 2020 2020 2020 2020 2020  rs,.            
-0000af30: 6f72 6465 722c 0a20 2020 2020 2020 2020  order,.         
-0000af40: 2020 2026 7361 6d70 6c65 5f70 6f69 6e74     &sample_point
-0000af50: 732c 0a20 2020 2020 2020 2029 3b0a 0a20  s,.        );.. 
-0000af60: 2020 2020 2020 206c 6574 2066 6163 746f         let facto
-0000af70: 7269 7a61 7469 6f6e 203d 2073 656c 662e  rization = self.
-0000af80: 6d75 6c74 6976 6172 6961 7465 5f68 656e  multivariate_hen
-0000af90: 7365 6c5f 6c69 6674 696e 6728 0a20 2020  sel_lifting(.   
-0000afa0: 2020 2020 2020 2020 2026 736f 7274 6564           &sorted
-0000afb0: 5f62 6976 5f66 6163 746f 7273 2c0a 2020  _biv_factors,.  
-0000afc0: 2020 2020 2020 2020 2020 266d 7574 2075            &mut u
-0000afd0: 6e69 2c0a 2020 2020 2020 2020 2020 2020  ni,.            
-0000afe0: 2664 656c 7461 2c0a 2020 2020 2020 2020  &delta,.        
-0000aff0: 2020 2020 2673 616d 706c 655f 706f 696e      &sample_poin
-0000b000: 7473 2c0a 2020 2020 2020 2020 2020 2020  ts,.            
-0000b010: 536f 6d65 2826 7472 7565 5f6c 636f 6566  Some(&true_lcoef
-0000b020: 6673 292c 0a20 2020 2020 2020 2020 2020  fs),.           
-0000b030: 206f 7264 6572 2c0a 2020 2020 2020 2020   order,.        
-0000b040: 2020 2020 322c 0a20 2020 2020 2020 2029      2,.        )
-0000b050: 3b0a 0a20 2020 2020 2020 202f 2f20 7465  ;..        // te
-0000b060: 7374 2074 6865 2066 6163 746f 7269 7a61  st the factoriza
-0000b070: 7469 6f6e 0a20 2020 2020 2020 206c 6574  tion.        let
-0000b080: 206d 7574 2074 6573 7420 3d20 7365 6c66   mut test = self
-0000b090: 2e6f 6e65 2829 3b0a 2020 2020 2020 2020  .one();.        
-0000b0a0: 666f 7220 6620 696e 2026 6661 6374 6f72  for f in &factor
-0000b0b0: 697a 6174 696f 6e20 7b0a 2020 2020 2020  ization {.      
-0000b0c0: 2020 2020 2020 6465 6275 6721 2822 4661        debug!("Fa
-0000b0d0: 6374 6f72 203d 207b 7d22 2c20 6629 3b0a  ctor = {}", f);.
-0000b0e0: 2020 2020 2020 2020 2020 2020 7465 7374              test
-0000b0f0: 203d 2026 7465 7374 202a 2066 3b0a 2020   = &test * f;.  
-0000b100: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-0000b110: 2069 6620 2674 6573 7420 3d3d 2073 656c   if &test == sel
-0000b120: 6620 7b0a 2020 2020 2020 2020 2020 2020  f {.            
-0000b130: 6661 6374 6f72 697a 6174 696f 6e0a 2020  factorization.  
-0000b140: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
-0000b150: 2020 2020 2020 2020 2020 2064 6562 7567             debug
-0000b160: 2128 0a20 2020 2020 2020 2020 2020 2020  !(.             
-0000b170: 2020 2022 4e6f 2069 6d6d 6564 6961 7465     "No immediate
-0000b180: 2066 6163 746f 7269 7a61 7469 6f6e 206f   factorization o
-0000b190: 6620 7b7d 2066 6f72 2073 616d 706c 6520  f {} for sample 
-0000b1a0: 706f 696e 7473 207b 3a3f 7d22 2c0a 2020  points {:?}",.  
-0000b1b0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000b1c0: 6c66 2c20 7361 6d70 6c65 5f70 6f69 6e74  lf, sample_point
-0000b1d0: 730a 2020 2020 2020 2020 2020 2020 293b  s.            );
-0000b1e0: 0a0a 2020 2020 2020 2020 2020 2020 2f2f  ..            //
-0000b1f0: 2074 6865 2062 6976 6172 6961 7465 2066   the bivariate f
-0000b200: 6163 746f 7269 7a61 7469 6f6e 2068 6173  actorization has
-0000b210: 2074 6f6f 206d 616e 7920 6661 6374 6f72   too many factor
-0000b220: 732c 2074 7279 2061 6761 696e 2077 6974  s, try again wit
-0000b230: 6820 6f74 6865 7220 7361 6d70 6c65 2070  h other sample p
-0000b240: 6f69 6e74 730a 2020 2020 2020 2020 2020  oints.          
-0000b250: 2020 7365 6c66 2e6d 756c 7469 7661 7269    self.multivari
-0000b260: 6174 655f 6661 6374 6f72 697a 6174 696f  ate_factorizatio
-0000b270: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
-0000b280: 2020 206f 7264 6572 2c0a 2020 2020 2020     order,.      
-0000b290: 2020 2020 2020 2020 2020 636f 6566 6669            coeffi
-0000b2a0: 6369 656e 745f 7570 7065 725f 626f 756e  cient_upper_boun
-0000b2b0: 6420 2b20 312c 0a20 2020 2020 2020 2020  d + 1,.         
-0000b2c0: 2020 2020 2020 2053 6f6d 6528 6d61 785f         Some(max_
-0000b2d0: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-0000b2e0: 732e 756e 7772 6170 5f6f 7228 6269 7661  s.unwrap_or(biva
-0000b2f0: 7269 6174 655f 6661 6374 6f72 732e 6c65  riate_factors.le
-0000b300: 6e28 2929 202d 2031 292c 0a20 2020 2020  n()) - 1),.     
-0000b310: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-0000b320: 207d 0a20 2020 207d 0a7d 0a0a 696d 706c   }.    }.}..impl
-0000b330: 3c46 3a20 4669 656c 642c 2045 3a20 4578  <F: Field, E: Ex
-0000b340: 706f 6e65 6e74 3e20 4d75 6c74 6976 6172  ponent> Multivar
-0000b350: 6961 7465 506f 6c79 6e6f 6d69 616c 3c46  iatePolynomial<F
-0000b360: 2c20 452c 204c 6578 4f72 6465 723e 207b  , E, LexOrder> {
-0000b370: 0a20 2020 2066 6e20 6d75 6c74 6976 6172  .    fn multivar
-0000b380: 6961 7465 5f64 696f 7068 616e 7469 6e65  iate_diophantine
-0000b390: 280a 2020 2020 2020 2020 756e 6976 6172  (.        univar
-0000b3a0: 6961 7465 5f64 656c 7461 733a 2026 5b53  iate_deltas: &[S
-0000b3b0: 656c 665d 2c0a 2020 2020 2020 2020 756e  elf],.        un
-0000b3c0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-0000b3d0: 3a20 266d 7574 205b 5365 6c66 5d2c 0a20  : &mut [Self],. 
-0000b3e0: 2020 2020 2020 2070 726f 6473 3a20 265b         prods: &[
-0000b3f0: 5365 6c66 5d2c 0a20 2020 2020 2020 2065  Self],.        e
-0000b400: 7272 6f72 3a20 2653 656c 662c 0a20 2020  rror: &Self,.   
-0000b410: 2020 2020 206f 7264 6572 3a20 265b 7573       order: &[us
-0000b420: 697a 655d 2c0a 2020 2020 2020 2020 7361  ize],.        sa
-0000b430: 6d70 6c65 5f70 6f69 6e74 733a 2026 5b28  mple_points: &[(
-0000b440: 7573 697a 652c 2046 3a3a 456c 656d 656e  usize, F::Elemen
-0000b450: 7429 5d2c 0a20 2020 2020 2020 2064 6567  t)],.        deg
-0000b460: 7265 6573 3a20 265b 7573 697a 655d 2c0a  rees: &[usize],.
-0000b470: 2020 2020 2920 2d3e 2056 6563 3c53 656c      ) -> Vec<Sel
-0000b480: 663e 207b 0a20 2020 2020 2020 2069 6620  f> {.        if 
-0000b490: 6f72 6465 722e 6c65 6e28 2920 3d3d 2031  order.len() == 1
-0000b4a0: 207b 0a20 2020 2020 2020 2020 2020 2072   {.            r
-0000b4b0: 6574 7572 6e20 756e 6976 6172 6961 7465  eturn univariate
-0000b4c0: 5f64 656c 7461 730a 2020 2020 2020 2020  _deltas.        
-0000b4d0: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
-0000b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4f0: 2e7a 6970 2875 6e69 7661 7269 6174 655f  .zip(univariate_
-0000b500: 6661 6374 6f72 7329 0a20 2020 2020 2020  factors).       
-0000b510: 2020 2020 2020 2020 202e 6d61 7028 7c28           .map(|(
-0000b520: 642c 2066 297c 2028 6420 2a20 6572 726f  d, f)| (d * erro
-0000b530: 7229 2e71 756f 745f 7265 6d5f 756e 6976  r).quot_rem_univ
-0000b540: 6172 6961 7465 2866 292e 3129 0a20 2020  ariate(f).1).   
-0000b550: 2020 2020 2020 2020 2020 2020 202e 636f               .co
-0000b560: 6c6c 6563 7428 293b 0a20 2020 2020 2020  llect();.       
-0000b570: 207d 0a0a 2020 2020 2020 2020 6c65 7420   }..        let 
-0000b580: 6c61 7374 5f76 6172 203d 202a 6f72 6465  last_var = *orde
-0000b590: 722e 6c61 7374 2829 2e75 6e77 7261 7028  r.last().unwrap(
-0000b5a0: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
-0000b5b0: 7368 6966 7420 3d20 2673 616d 706c 655f  shift = &sample_
-0000b5c0: 706f 696e 7473 2e69 7465 7228 292e 6669  points.iter().fi
-0000b5d0: 6e64 287c 737c 2073 2e30 203d 3d20 6c61  nd(|s| s.0 == la
-0000b5e0: 7374 5f76 6172 292e 756e 7772 6170 2829  st_var).unwrap()
-0000b5f0: 2e31 3b0a 0a20 2020 2020 2020 206c 6574  .1;..        let
-0000b600: 2070 726f 6473 5f6d 6f64 203d 2070 726f   prods_mod = pro
-0000b610: 6473 0a20 2020 2020 2020 2020 2020 202e  ds.            .
-0000b620: 6974 6572 2829 0a20 2020 2020 2020 2020  iter().         
-0000b630: 2020 202e 6d61 7028 7c66 7c20 662e 7265     .map(|f| f.re
-0000b640: 706c 6163 6528 6c61 7374 5f76 6172 2c20  place(last_var, 
-0000b650: 7368 6966 7429 290a 2020 2020 2020 2020  shift)).        
-0000b660: 2020 2020 2e63 6f6c 6c65 6374 3a3a 3c56      .collect::<V
-0000b670: 6563 3c5f 3e3e 2829 3b0a 2020 2020 2020  ec<_>>();.      
-0000b680: 2020 6c65 7420 6572 726f 725f 6d6f 6420    let error_mod 
-0000b690: 3d20 6572 726f 722e 7265 706c 6163 6528  = error.replace(
-0000b6a0: 6c61 7374 5f76 6172 2c20 7368 6966 7429  last_var, shift)
-0000b6b0: 3b0a 0a20 2020 2020 2020 2064 6562 7567  ;..        debug
-0000b6c0: 2128 2264 696f 7068 2065 5b78 7b7d 5e30  !("dioph e[x{}^0
-0000b6d0: 5d20 3d20 7b7d 222c 206c 6173 745f 7661  ] = {}", last_va
-0000b6e0: 722c 2065 7272 6f72 5f6d 6f64 293b 0a0a  r, error_mod);..
-0000b6f0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-0000b700: 6465 6c74 6173 203d 2053 656c 663a 3a6d  deltas = Self::m
-0000b710: 756c 7469 7661 7269 6174 655f 6469 6f70  ultivariate_diop
-0000b720: 6861 6e74 696e 6528 0a20 2020 2020 2020  hantine(.       
-0000b730: 2020 2020 2075 6e69 7661 7269 6174 655f       univariate_
-0000b740: 6465 6c74 6173 2c0a 2020 2020 2020 2020  deltas,.        
-0000b750: 2020 2020 756e 6976 6172 6961 7465 5f66      univariate_f
-0000b760: 6163 746f 7273 2c0a 2020 2020 2020 2020  actors,.        
-0000b770: 2020 2020 2670 726f 6473 5f6d 6f64 2c0a      &prods_mod,.
-0000b780: 2020 2020 2020 2020 2020 2020 2665 7272              &err
-0000b790: 6f72 5f6d 6f64 2c0a 2020 2020 2020 2020  or_mod,.        
-0000b7a0: 2020 2020 266f 7264 6572 5b2e 2e6f 7264      &order[..ord
-0000b7b0: 6572 2e6c 656e 2829 202d 2031 5d2c 0a20  er.len() - 1],. 
-0000b7c0: 2020 2020 2020 2020 2020 2073 616d 706c             sampl
-0000b7d0: 655f 706f 696e 7473 2c0a 2020 2020 2020  e_points,.      
-0000b7e0: 2020 2020 2020 2664 6567 7265 6573 5b2e        &degrees[.
-0000b7f0: 2e6f 7264 6572 2e6c 656e 2829 202d 2031  .order.len() - 1
-0000b800: 5d2c 0a20 2020 2020 2020 2029 3b0a 0a20  ],.        );.. 
-0000b810: 2020 2020 2020 202f 2f20 544f 444f 3a20         // TODO: 
-0000b820: 7072 6563 6f6d 7075 7465 0a20 2020 2020  precompute.     
-0000b830: 2020 206c 6574 206d 7574 206d 6f64 5f76     let mut mod_v
-0000b840: 6172 7320 3d20 5665 633a 3a77 6974 685f  ars = Vec::with_
-0000b850: 6361 7061 6369 7479 286f 7264 6572 2e6c  capacity(order.l
-0000b860: 656e 2829 202d 2032 293b 0a20 2020 2020  en() - 2);.     
-0000b870: 2020 206c 6574 206d 7574 2065 7870 203d     let mut exp =
-0000b880: 2076 6563 215b 453a 3a7a 6572 6f28 293b   vec![E::zero();
-0000b890: 2065 7272 6f72 2e6e 7661 7273 5d3b 0a20   error.nvars];. 
-0000b8a0: 2020 2020 2020 2066 6f72 2072 2069 6e20         for r in 
-0000b8b0: 6f72 6465 725b 312e 2e6f 7264 6572 2e6c  order[1..order.l
-0000b8c0: 656e 2829 202d 2031 5d2e 6974 6572 2829  en() - 1].iter()
-0000b8d0: 2e7a 6970 2826 6465 6772 6565 735b 312e  .zip(&degrees[1.
-0000b8e0: 2e5d 2920 7b0a 2020 2020 2020 2020 2020  .]) {.          
-0000b8f0: 2020 6c65 7420 7368 6966 7420 3d20 2673    let shift = &s
-0000b900: 616d 706c 655f 706f 696e 7473 2e69 7465  ample_points.ite
-0000b910: 7228 292e 6669 6e64 287c 737c 2073 2e30  r().find(|s| s.0
-0000b920: 203d 3d20 2a72 2e30 292e 756e 7772 6170   == *r.0).unwrap
-0000b930: 2829 2e31 3b0a 2020 2020 2020 2020 2020  ().1;.          
-0000b940: 2020 6578 705b 2a72 2e30 5d20 3d20 453a    exp[*r.0] = E:
-0000b950: 3a6f 6e65 2829 3b0a 2020 2020 2020 2020  :one();.        
-0000b960: 2020 2020 6c65 7420 7661 725f 706f 7720      let var_pow 
-0000b970: 3d20 6572 726f 720a 2020 2020 2020 2020  = error.        
-0000b980: 2020 2020 2020 2020 2e6d 6f6e 6f6d 6961          .monomia
-0000b990: 6c28 6572 726f 722e 6669 656c 642e 6f6e  l(error.field.on
-0000b9a0: 6528 292c 2065 7870 2e63 6c6f 6e65 2829  e(), exp.clone()
-0000b9b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000b9c0: 2020 2e73 6869 6674 5f76 6172 282a 722e    .shift_var(*r.
-0000b9d0: 302c 2026 6572 726f 722e 6669 656c 642e  0, &error.field.
-0000b9e0: 6e65 6728 7368 6966 7429 290a 2020 2020  neg(shift)).    
-0000b9f0: 2020 2020 2020 2020 2020 2020 2e70 6f77              .pow
-0000ba00: 2872 2e31 202b 2031 293b 0a20 2020 2020  (r.1 + 1);.     
-0000ba10: 2020 2020 2020 2065 7870 5b2a 722e 305d         exp[*r.0]
-0000ba20: 203d 2045 3a3a 7a65 726f 2829 3b0a 2020   = E::zero();.  
-0000ba30: 2020 2020 2020 2020 2020 6d6f 645f 7661            mod_va
-0000ba40: 7273 2e70 7573 6828 7661 725f 706f 7729  rs.push(var_pow)
-0000ba50: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
-0000ba60: 2020 2020 2065 7870 5b6c 6173 745f 7661       exp[last_va
-0000ba70: 725d 203d 2045 3a3a 6f6e 6528 293b 0a20  r] = E::one();. 
-0000ba80: 2020 2020 2020 206c 6574 2076 6172 5f70         let var_p
-0000ba90: 6f77 203d 2065 7272 6f72 0a20 2020 2020  ow = error.     
-0000baa0: 2020 2020 2020 202e 6d6f 6e6f 6d69 616c         .monomial
-0000bab0: 2865 7272 6f72 2e66 6965 6c64 2e6f 6e65  (error.field.one
-0000bac0: 2829 2c20 6578 7029 0a20 2020 2020 2020  (), exp).       
-0000bad0: 2020 2020 202e 7368 6966 745f 7661 7228       .shift_var(
-0000bae0: 6c61 7374 5f76 6172 2c20 2665 7272 6f72  last_var, &error
-0000baf0: 2e66 6965 6c64 2e6e 6567 2873 6869 6674  .field.neg(shift
-0000bb00: 2929 3b0a 2020 2020 2020 2020 6c65 7420  ));.        let 
-0000bb10: 6d75 7420 6375 725f 6578 706f 6e65 6e74  mut cur_exponent
-0000bb20: 3b0a 2020 2020 2020 2020 6c65 7420 6d75  ;.        let mu
-0000bb30: 7420 6e65 7874 5f65 7870 6f6e 656e 7420  t next_exponent 
-0000bb40: 3d20 7661 725f 706f 772e 636c 6f6e 6528  = var_pow.clone(
-0000bb50: 293b 0a0a 2020 2020 2020 2020 666f 7220  );..        for 
-0000bb60: 6a20 696e 2031 2e2e 3d2a 6465 6772 6565  j in 1..=*degree
-0000bb70: 732e 6c61 7374 2829 2e75 6e77 7261 7028  s.last().unwrap(
-0000bb80: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-0000bb90: 6375 725f 6578 706f 6e65 6e74 203d 206e  cur_exponent = n
-0000bba0: 6578 745f 6578 706f 6e65 6e74 2e63 6c6f  ext_exponent.clo
-0000bbb0: 6e65 2829 3b0a 2020 2020 2020 2020 2020  ne();.          
-0000bbc0: 2020 6e65 7874 5f65 7870 6f6e 656e 7420    next_exponent 
-0000bbd0: 3d20 266e 6578 745f 6578 706f 6e65 6e74  = &next_exponent
-0000bbe0: 202a 2026 7661 725f 706f 773b 0a0a 2020   * &var_pow;..  
-0000bbf0: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
-0000bc00: 7420 6520 3d20 6572 726f 722e 636c 6f6e  t e = error.clon
-0000bc10: 6528 293b 0a20 2020 2020 2020 2020 2020  e();.           
-0000bc20: 2066 6f72 2028 642c 2070 2920 696e 2064   for (d, p) in d
-0000bc30: 656c 7461 732e 6974 6572 2829 2e7a 6970  eltas.iter().zip
-0000bc40: 2870 726f 6473 2920 7b0a 2020 2020 2020  (prods) {.      
-0000bc50: 2020 2020 2020 2020 2020 6465 6275 6721            debug!
-0000bc60: 2822 6465 6c74 6120 7b7d 2070 207b 7d22  ("delta {} p {}"
-0000bc70: 2c20 642c 2070 293b 0a20 2020 2020 2020  , d, p);.       
-0000bc80: 2020 2020 2020 2020 2065 203d 2026 6520           e = &e 
-0000bc90: 2d20 2628 6420 2a20 7029 3b0a 0a20 2020  - &(d * p);..   
-0000bca0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-0000bcb0: 206d 2069 6e20 266d 6f64 5f76 6172 7320   m in &mod_vars 
-0000bcc0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000bcd0: 2020 2020 2020 2f2f 2054 4f44 4f3a 2066        // TODO: f
-0000bce0: 6173 7465 7220 696d 706c 656d 656e 7461  aster implementa
-0000bcf0: 7469 6f6e 2066 6f72 2075 6e69 7661 7269  tion for univari
-0000bd00: 6174 6520 6469 7669 736f 7220 706f 7373  ate divisor poss
-0000bd10: 6962 6c65 3f0a 2020 2020 2020 2020 2020  ible?.          
-0000bd20: 2020 2020 2020 2020 2020 6520 3d20 652e            e = e.
-0000bd30: 7175 6f74 5f72 656d 286d 2c20 6661 6c73  quot_rem(m, fals
-0000bd40: 6529 2e31 3b0a 2020 2020 2020 2020 2020  e).1;.          
-0000bd50: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-0000bd60: 2020 2020 2020 2020 202f 2f20 544f 444f           // TODO
-0000bd70: 3a20 6d6f 6420 7769 7468 2028 782d 7368  : mod with (x-sh
-0000bd80: 6966 7429 5e28 6a2b 3129 3f0a 2020 2020  ift)^(j+1)?.    
-0000bd90: 2020 2020 2020 2020 2020 2020 2f2f 2074              // t
-0000bda0: 6865 6e20 7765 2063 616e 6e6f 7420 6272  hen we cannot br
-0000bdb0: 6561 6b20 6f6e 2030 2065 7272 6f72 0a20  eak on 0 error. 
-0000bdc0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-0000bdd0: 2020 2020 2020 2020 2020 6465 6275 6721            debug!
-0000bde0: 2822 6469 6f70 6820 2065 2061 7420 787b  ("dioph  e at x{
-0000bdf0: 7d5e 7b7d 203d 207b 7d22 2c20 6c61 7374  }^{} = {}", last
-0000be00: 5f76 6172 2c20 6a2c 2065 293b 0a0a 2020  _var, j, e);..  
-0000be10: 2020 2020 2020 2020 2020 6966 2065 2e69            if e.i
-0000be20: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
-0000be30: 2020 2020 2020 2020 2020 2062 7265 616b             break
-0000be40: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
-0000be50: 0a20 2020 2020 2020 2020 2020 202f 2f20  .            // 
-0000be60: 7461 6b65 2074 6865 206a 7468 2070 6f77  take the jth pow
-0000be70: 6572 206f 6620 7661 7220 2d20 7368 6966  er of var - shif
-0000be80: 7420 696e 2074 6865 2065 7272 6f72 0a20  t in the error. 
-0000be90: 2020 2020 2020 2020 2020 206c 6574 206d             let m
-0000bea0: 7574 2065 5f6d 6f64 203d 2065 0a20 2020  ut e_mod = e.   
-0000beb0: 2020 2020 2020 2020 2020 2020 202e 7368               .sh
-0000bec0: 6966 745f 7661 7228 6c61 7374 5f76 6172  ift_var(last_var
-0000bed0: 2c20 7368 6966 7429 0a20 2020 2020 2020  , shift).       
-0000bee0: 2020 2020 2020 2020 202e 6d6f 645f 7661           .mod_va
-0000bef0: 7228 6c61 7374 5f76 6172 2c20 453a 3a66  r(last_var, E::f
-0000bf00: 726f 6d5f 7533 3228 6a20 6173 2075 3332  rom_u32(j as u32
-0000bf10: 202b 2031 2929 3b0a 2020 2020 2020 2020   + 1));.        
-0000bf20: 2020 2020 666f 7220 6520 696e 2065 5f6d      for e in e_m
-0000bf30: 6f64 2e65 7870 6f6e 656e 7473 2e63 6875  od.exponents.chu
-0000bf40: 6e6b 735f 6d75 7428 655f 6d6f 642e 6e76  nks_mut(e_mod.nv
-0000bf50: 6172 7329 207b 0a20 2020 2020 2020 2020  ars) {.         
-0000bf60: 2020 2020 2020 2064 6562 7567 5f61 7373         debug_ass
-0000bf70: 6572 745f 6571 2128 655b 6c61 7374 5f76  ert_eq!(e[last_v
-0000bf80: 6172 5d2c 2045 3a3a 6672 6f6d 5f75 3332  ar], E::from_u32
-0000bf90: 286a 2061 7320 7533 3229 293b 0a20 2020  (j as u32));.   
-0000bfa0: 2020 2020 2020 2020 2020 2020 2065 5b6c               e[l
-0000bfb0: 6173 745f 7661 725d 203d 2045 3a3a 7a65  ast_var] = E::ze
-0000bfc0: 726f 2829 3b0a 2020 2020 2020 2020 2020  ro();.          
-0000bfd0: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-0000bfe0: 2064 6562 7567 2128 2264 696f 7068 2020   debug!("dioph  
-0000bff0: 655b 787b 7d5e 7b7d 5d20 3d20 7b7d 222c  e[x{}^{}] = {}",
-0000c000: 206c 6173 745f 7661 722c 206a 2c20 655f   last_var, j, e_
-0000c010: 6d6f 6429 3b0a 0a20 2020 2020 2020 2020  mod);..         
-0000c020: 2020 2069 6620 655f 6d6f 642e 6973 5f7a     if e_mod.is_z
-0000c030: 6572 6f28 2920 7b0a 2020 2020 2020 2020  ero() {.        
-0000c040: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
-0000c050: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
-0000c060: 0a20 2020 2020 2020 2020 2020 206c 6574  .            let
-0000c070: 206d 7574 206e 6577 5f64 656c 7461 7320   mut new_deltas 
-0000c080: 3d20 5365 6c66 3a3a 6d75 6c74 6976 6172  = Self::multivar
-0000c090: 6961 7465 5f64 696f 7068 616e 7469 6e65  iate_diophantine
-0000c0a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000c0b0: 2020 756e 6976 6172 6961 7465 5f64 656c    univariate_del
-0000c0c0: 7461 732c 0a20 2020 2020 2020 2020 2020  tas,.           
-0000c0d0: 2020 2020 2075 6e69 7661 7269 6174 655f       univariate_
-0000c0e0: 6661 6374 6f72 732c 0a20 2020 2020 2020  factors,.       
-0000c0f0: 2020 2020 2020 2020 2026 7072 6f64 735f           &prods_
-0000c100: 6d6f 642c 0a20 2020 2020 2020 2020 2020  mod,.           
-0000c110: 2020 2020 2026 655f 6d6f 642c 0a20 2020       &e_mod,.   
-0000c120: 2020 2020 2020 2020 2020 2020 2026 6f72               &or
-0000c130: 6465 725b 2e2e 6f72 6465 722e 6c65 6e28  der[..order.len(
-0000c140: 2920 2d20 315d 2c0a 2020 2020 2020 2020  ) - 1],.        
-0000c150: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
-0000c160: 6f69 6e74 732c 0a20 2020 2020 2020 2020  oints,.         
-0000c170: 2020 2020 2020 2026 6465 6772 6565 735b         &degrees[
-0000c180: 2e2e 6f72 6465 722e 6c65 6e28 2920 2d20  ..order.len() - 
-0000c190: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
-0000c1a0: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-0000c1b0: 666f 7220 2864 2c20 6e64 2920 696e 2064  for (d, nd) in d
-0000c1c0: 656c 7461 732e 6974 6572 5f6d 7574 2829  eltas.iter_mut()
-0000c1d0: 2e7a 6970 2826 6d75 7420 6e65 775f 6465  .zip(&mut new_de
-0000c1e0: 6c74 6173 2920 7b0a 2020 2020 2020 2020  ltas) {.        
-0000c1f0: 2020 2020 2020 2020 6465 6275 6721 2822          debug!("
-0000c200: 6469 6f70 6820 2064 5b78 7b7d 5e7b 7d5d  dioph  d[x{}^{}]
-0000c210: 203d 207b 7d22 2c20 6c61 7374 5f76 6172   = {}", last_var
-0000c220: 2c20 6a2c 206e 6429 3b0a 0a20 2020 2020  , j, nd);..     
-0000c230: 2020 2020 2020 2020 2020 202f 2f20 6d75             // mu
-0000c240: 6c74 6970 6c79 2028 792d 7329 5e6a 2061  ltiply (y-s)^j a
-0000c250: 6e64 206d 6f64 2077 7274 2061 6c6c 2076  nd mod wrt all v
-0000c260: 6172 730a 2020 2020 2020 2020 2020 2020  ars.            
-0000c270: 2020 2020 6c65 7420 6e64 203d 2026 2a6e      let nd = &*n
-0000c280: 6420 2a20 2663 7572 5f65 7870 6f6e 656e  d * &cur_exponen
-0000c290: 743b 0a20 2020 2020 2020 2020 2020 2020  t;.             
-0000c2a0: 2020 202a 6420 3d20 262a 6420 2b20 266e     *d = &*d + &n
-0000c2b0: 643b 0a0a 2020 2020 2020 2020 2020 2020  d;..            
-0000c2c0: 2020 2020 666f 7220 6d20 696e 2026 6d6f      for m in &mo
-0000c2d0: 645f 7661 7273 207b 0a20 2020 2020 2020  d_vars {.       
-0000c2e0: 2020 2020 2020 2020 2020 2020 2065 203d               e =
-0000c2f0: 2065 2e71 756f 745f 7265 6d28 6d2c 2066   e.quot_rem(m, f
-0000c300: 616c 7365 292e 313b 0a20 2020 2020 2020  alse).1;.       
-0000c310: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-0000c320: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000c330: 207d 0a0a 2020 2020 2020 2020 6465 6c74   }..        delt
-0000c340: 6173 0a20 2020 207d 0a0a 2020 2020 666e  as.    }..    fn
-0000c350: 206d 756c 7469 7661 7269 6174 655f 6865   multivariate_he
-0000c360: 6e73 656c 5f6c 6966 7469 6e67 280a 2020  nsel_lifting(.  
-0000c370: 2020 2020 2020 2673 656c 662c 0a20 2020        &self,.   
-0000c380: 2020 2020 2066 6163 746f 7273 3a20 265b       factors: &[
-0000c390: 5365 6c66 5d2c 0a20 2020 2020 2020 2075  Self],.        u
-0000c3a0: 6e69 7661 7269 6174 655f 6661 6374 6f72  nivariate_factor
-0000c3b0: 733a 2026 6d75 7420 5b53 656c 665d 2c0a  s: &mut [Self],.
-0000c3c0: 2020 2020 2020 2020 756e 6976 6172 6961          univaria
-0000c3d0: 7465 5f64 656c 7461 733a 2026 5b53 656c  te_deltas: &[Sel
-0000c3e0: 665d 2c0a 2020 2020 2020 2020 7361 6d70  f],.        samp
-0000c3f0: 6c65 5f70 6f69 6e74 733a 2026 5b28 7573  le_points: &[(us
-0000c400: 697a 652c 2046 3a3a 456c 656d 656e 7429  ize, F::Element)
-0000c410: 5d2c 0a20 2020 2020 2020 2074 7275 655f  ],.        true_
-0000c420: 6c63 6f65 6666 733a 204f 7074 696f 6e3c  lcoeffs: Option<
-0000c430: 265b 5365 6c66 5d3e 2c0a 2020 2020 2020  &[Self]>,.      
-0000c440: 2020 6f72 6465 723a 2026 5b75 7369 7a65    order: &[usize
-0000c450: 5d2c 0a20 2020 2020 2020 2073 7461 7274  ],.        start
-0000c460: 5f69 6e64 6578 3a20 7573 697a 652c 0a20  _index: usize,. 
-0000c470: 2020 2029 202d 3e20 5665 633c 5365 6c66     ) -> Vec<Self
-0000c480: 3e20 7b0a 2020 2020 2020 2020 6465 6275  > {.        debu
-0000c490: 6721 2822 4865 6e73 656c 206c 6966 7420  g!("Hensel lift 
-0000c4a0: 7b7d 2077 6974 6820 6f72 6465 7220 7b3a  {} with order {:
-0000c4b0: 3f7d 222c 2073 656c 662c 206f 7264 6572  ?}", self, order
-0000c4c0: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
-0000c4d0: 6d75 7420 6465 6772 6565 733a 2056 6563  mut degrees: Vec
-0000c4e0: 3c5f 3e20 3d20 6f72 6465 720a 2020 2020  <_> = order.    
-0000c4f0: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
-0000c500: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
-0000c510: 287c 767c 2073 656c 662e 6465 6772 6565  (|v| self.degree
-0000c520: 282a 7629 2e74 6f5f 7533 3228 2920 6173  (*v).to_u32() as
-0000c530: 2075 7369 7a65 290a 2020 2020 2020 2020   usize).        
-0000c540: 2020 2020 2e63 6f6c 6c65 6374 2829 3b0a      .collect();.
-0000c550: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-0000c560: 2072 6563 6f6e 7374 7275 6374 6564 5f66   reconstructed_f
-0000c570: 6163 746f 7273 203d 2066 6163 746f 7273  actors = factors
-0000c580: 2e74 6f5f 7665 6328 293b 0a20 2020 2020  .to_vec();.     
-0000c590: 2020 2066 6f72 2076 2069 6e20 7374 6172     for v in star
-0000c5a0: 745f 696e 6465 782e 2e6f 7264 6572 2e6c  t_index..order.l
-0000c5b0: 656e 2829 207b 0a20 2020 2020 2020 2020  en() {.         
-0000c5c0: 2020 202f 2f20 7265 706c 6163 6520 7468     // replace th
-0000c5d0: 6520 6c63 6f65 6666 2069 6e20 7830 2077  e lcoeff in x0 w
-0000c5e0: 6974 6820 7468 6520 7072 6f70 6572 206c  ith the proper l
-0000c5f0: 636f 6566 660a 2020 2020 2020 2020 2020  coeff.          
-0000c600: 2020 6c65 7420 6d75 7420 6661 6374 6f72    let mut factor
-0000c610: 735f 7769 7468 5f74 7275 655f 6c63 6f65  s_with_true_lcoe
-0000c620: 6666 203d 2076 6563 215b 5d3b 0a0a 2020  ff = vec![];..  
-0000c630: 2020 2020 2020 2020 2020 6966 206c 6574            if let
-0000c640: 2053 6f6d 6528 7472 7565 5f6c 636f 6566   Some(true_lcoef
-0000c650: 6673 2920 3d20 7472 7565 5f6c 636f 6566  fs) = true_lcoef
-0000c660: 6673 207b 0a20 2020 2020 2020 2020 2020  fs {.           
-0000c670: 2020 2020 2066 6f72 2028 622c 206c 2920       for (b, l) 
-0000c680: 696e 2072 6563 6f6e 7374 7275 6374 6564  in reconstructed
-0000c690: 5f66 6163 746f 7273 2e69 7465 7228 292e  _factors.iter().
-0000c6a0: 7a69 7028 7472 7565 5f6c 636f 6566 6673  zip(true_lcoeffs
-0000c6b0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-0000c6c0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-0000c6d0: 6c63 6f65 6666 203d 206c 2e63 6c6f 6e65  lcoeff = l.clone
-0000c6e0: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-0000c6f0: 2020 2020 2020 2020 666f 7220 6a20 696e          for j in
-0000c700: 2076 202b 2031 2e2e 6f72 6465 722e 6c65   v + 1..order.le
-0000c710: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
-0000c720: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000c730: 7220 7320 696e 2073 616d 706c 655f 706f  r s in sample_po
-0000c740: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
-0000c750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c760: 2020 2069 6620 732e 3020 3d3d 206f 7264     if s.0 == ord
-0000c770: 6572 5b6a 5d20 7b0a 2020 2020 2020 2020  er[j] {.        
-0000c780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c790: 2020 2020 2020 2020 6c63 6f65 6666 203d          lcoeff =
-0000c7a0: 206c 636f 6566 662e 7265 706c 6163 6528   lcoeff.replace(
-0000c7b0: 732e 302c 2026 732e 3129 3b0a 2020 2020  s.0, &s.1);.    
-0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7d0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-0000c7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7f0: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-0000c800: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-0000c810: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000c820: 6574 206d 7574 2062 7320 3d20 622e 746f  et mut bs = b.to
-0000c830: 5f75 6e69 7661 7269 6174 655f 706f 6c79  _univariate_poly
-0000c840: 6e6f 6d69 616c 5f6c 6973 7428 6f72 6465  nomial_list(orde
-0000c850: 725b 305d 293b 0a20 2020 2020 2020 2020  r[0]);.         
-0000c860: 2020 2020 2020 2020 2020 2062 732e 6c61             bs.la
-0000c870: 7374 5f6d 7574 2829 2e75 6e77 7261 7028  st_mut().unwrap(
-0000c880: 292e 3020 3d20 6c63 6f65 6666 3b0a 0a20  ).0 = lcoeff;.. 
-0000c890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8a0: 2020 206c 6574 206d 7574 2066 6978 6564     let mut fixed
-0000c8b0: 5f66 6163 203d 2073 656c 662e 7a65 726f  _fac = self.zero
-0000c8c0: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-0000c8d0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-0000c8e0: 6578 7020 3d20 7665 6321 5b45 3a3a 7a65  exp = vec![E::ze
-0000c8f0: 726f 2829 3b20 7365 6c66 2e6e 7661 7273  ro(); self.nvars
-0000c900: 5d3b 0a20 2020 2020 2020 2020 2020 2020  ];.             
-0000c910: 2020 2020 2020 2066 6f72 2028 702c 2065         for (p, e
-0000c920: 2920 696e 2062 7320 7b0a 2020 2020 2020  ) in bs {.      
-0000c930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c940: 2020 6578 705b 6f72 6465 725b 305d 5d20    exp[order[0]] 
-0000c950: 3d20 653b 0a20 2020 2020 2020 2020 2020  = e;.           
-0000c960: 2020 2020 2020 2020 2020 2020 2066 6978               fix
-0000c970: 6564 5f66 6163 203d 2066 6978 6564 5f66  ed_fac = fixed_f
-0000c980: 6163 202b 2070 2e6d 756c 5f65 7870 2826  ac + p.mul_exp(&
-0000c990: 6578 7029 3b0a 2020 2020 2020 2020 2020  exp);.          
-0000c9a0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+0000adf0: 2053 6f6d 6528 6d61 785f 6269 7629 2c0a   Some(max_biv),.
+0000ae00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae10: 2020 2020 293b 0a20 2020 2020 2020 2020      );.         
+0000ae20: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+0000ae30: 2020 2020 207d 3b0a 0a20 2020 2020 2020       };..       
+0000ae40: 2066 6f72 2028 622c 206c 2920 696e 2073   for (b, l) in s
+0000ae50: 6f72 7465 645f 6269 765f 6661 6374 6f72  orted_biv_factor
+0000ae60: 732e 6974 6572 2829 2e7a 6970 2826 7472  s.iter().zip(&tr
+0000ae70: 7565 5f6c 636f 6566 6673 2920 7b0a 2020  ue_lcoeffs) {.  
+0000ae80: 2020 2020 2020 2020 2020 6465 6275 6721            debug!
+0000ae90: 2822 4269 7661 7269 6174 6520 6661 6374  ("Bivariate fact
+0000aea0: 6f72 207b 7d20 7769 7468 2074 7275 6520  or {} with true 
+0000aeb0: 6c63 6f65 6666 207b 7d22 2c20 622c 206c  lcoeff {}", b, l
+0000aec0: 293b 0a20 2020 2020 2020 207d 0a0a 2020  );.        }..  
+0000aed0: 2020 2020 2020 6c65 7420 286d 7574 2075        let (mut u
+0000aee0: 6e69 2c20 6465 6c74 6129 203d 204d 756c  ni, delta) = Mul
+0000aef0: 7469 7661 7269 6174 6550 6f6c 796e 6f6d  tivariatePolynom
+0000af00: 6961 6c3a 3a75 6e69 7661 7269 6174 655f  ial::univariate_
+0000af10: 6469 6f70 6861 6e74 696e 655f 6669 656c  diophantine_fiel
+0000af20: 6428 0a20 2020 2020 2020 2020 2020 2026  d(.            &
+0000af30: 736f 7274 6564 5f62 6976 5f66 6163 746f  sorted_biv_facto
+0000af40: 7273 2c0a 2020 2020 2020 2020 2020 2020  rs,.            
+0000af50: 6f72 6465 722c 0a20 2020 2020 2020 2020  order,.         
+0000af60: 2020 2026 7361 6d70 6c65 5f70 6f69 6e74     &sample_point
+0000af70: 732c 0a20 2020 2020 2020 2029 3b0a 0a20  s,.        );.. 
+0000af80: 2020 2020 2020 206c 6574 2066 6163 746f         let facto
+0000af90: 7269 7a61 7469 6f6e 203d 2073 656c 662e  rization = self.
+0000afa0: 6d75 6c74 6976 6172 6961 7465 5f68 656e  multivariate_hen
+0000afb0: 7365 6c5f 6c69 6674 696e 6728 0a20 2020  sel_lifting(.   
+0000afc0: 2020 2020 2020 2020 2026 736f 7274 6564           &sorted
+0000afd0: 5f62 6976 5f66 6163 746f 7273 2c0a 2020  _biv_factors,.  
+0000afe0: 2020 2020 2020 2020 2020 266d 7574 2075            &mut u
+0000aff0: 6e69 2c0a 2020 2020 2020 2020 2020 2020  ni,.            
+0000b000: 2664 656c 7461 2c0a 2020 2020 2020 2020  &delta,.        
+0000b010: 2020 2020 2673 616d 706c 655f 706f 696e      &sample_poin
+0000b020: 7473 2c0a 2020 2020 2020 2020 2020 2020  ts,.            
+0000b030: 536f 6d65 2826 7472 7565 5f6c 636f 6566  Some(&true_lcoef
+0000b040: 6673 292c 0a20 2020 2020 2020 2020 2020  fs),.           
+0000b050: 206f 7264 6572 2c0a 2020 2020 2020 2020   order,.        
+0000b060: 2020 2020 322c 0a20 2020 2020 2020 2029      2,.        )
+0000b070: 3b0a 0a20 2020 2020 2020 202f 2f20 7465  ;..        // te
+0000b080: 7374 2074 6865 2066 6163 746f 7269 7a61  st the factoriza
+0000b090: 7469 6f6e 0a20 2020 2020 2020 206c 6574  tion.        let
+0000b0a0: 206d 7574 2074 6573 7420 3d20 7365 6c66   mut test = self
+0000b0b0: 2e6f 6e65 2829 3b0a 2020 2020 2020 2020  .one();.        
+0000b0c0: 666f 7220 6620 696e 2026 6661 6374 6f72  for f in &factor
+0000b0d0: 697a 6174 696f 6e20 7b0a 2020 2020 2020  ization {.      
+0000b0e0: 2020 2020 2020 6465 6275 6721 2822 4661        debug!("Fa
+0000b0f0: 6374 6f72 203d 207b 7d22 2c20 6629 3b0a  ctor = {}", f);.
+0000b100: 2020 2020 2020 2020 2020 2020 7465 7374              test
+0000b110: 203d 2026 7465 7374 202a 2066 3b0a 2020   = &test * f;.  
+0000b120: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+0000b130: 2069 6620 2674 6573 7420 3d3d 2073 656c   if &test == sel
+0000b140: 6620 7b0a 2020 2020 2020 2020 2020 2020  f {.            
+0000b150: 6661 6374 6f72 697a 6174 696f 6e0a 2020  factorization.  
+0000b160: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
+0000b170: 2020 2020 2020 2020 2020 2064 6562 7567             debug
+0000b180: 2128 0a20 2020 2020 2020 2020 2020 2020  !(.             
+0000b190: 2020 2022 4e6f 2069 6d6d 6564 6961 7465     "No immediate
+0000b1a0: 2066 6163 746f 7269 7a61 7469 6f6e 206f   factorization o
+0000b1b0: 6620 7b7d 2066 6f72 2073 616d 706c 6520  f {} for sample 
+0000b1c0: 706f 696e 7473 207b 3a3f 7d22 2c0a 2020  points {:?}",.  
+0000b1d0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000b1e0: 6c66 2c20 7361 6d70 6c65 5f70 6f69 6e74  lf, sample_point
+0000b1f0: 730a 2020 2020 2020 2020 2020 2020 293b  s.            );
+0000b200: 0a0a 2020 2020 2020 2020 2020 2020 2f2f  ..            //
+0000b210: 2074 6865 2062 6976 6172 6961 7465 2066   the bivariate f
+0000b220: 6163 746f 7269 7a61 7469 6f6e 2068 6173  actorization has
+0000b230: 2074 6f6f 206d 616e 7920 6661 6374 6f72   too many factor
+0000b240: 732c 2074 7279 2061 6761 696e 2077 6974  s, try again wit
+0000b250: 6820 6f74 6865 7220 7361 6d70 6c65 2070  h other sample p
+0000b260: 6f69 6e74 730a 2020 2020 2020 2020 2020  oints.          
+0000b270: 2020 7365 6c66 2e6d 756c 7469 7661 7269    self.multivari
+0000b280: 6174 655f 6661 6374 6f72 697a 6174 696f  ate_factorizatio
+0000b290: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+0000b2a0: 2020 206f 7264 6572 2c0a 2020 2020 2020     order,.      
+0000b2b0: 2020 2020 2020 2020 2020 636f 6566 6669            coeffi
+0000b2c0: 6369 656e 745f 7570 7065 725f 626f 756e  cient_upper_boun
+0000b2d0: 6420 2b20 312c 0a20 2020 2020 2020 2020  d + 1,.         
+0000b2e0: 2020 2020 2020 2053 6f6d 6528 6d61 785f         Some(max_
+0000b2f0: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+0000b300: 732e 756e 7772 6170 5f6f 7228 6269 7661  s.unwrap_or(biva
+0000b310: 7269 6174 655f 6661 6374 6f72 732e 6c65  riate_factors.le
+0000b320: 6e28 2929 202d 2031 292c 0a20 2020 2020  n()) - 1),.     
+0000b330: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000b340: 207d 0a20 2020 207d 0a7d 0a0a 696d 706c   }.    }.}..impl
+0000b350: 3c46 3a20 4669 656c 642c 2045 3a20 4578  <F: Field, E: Ex
+0000b360: 706f 6e65 6e74 3e20 4d75 6c74 6976 6172  ponent> Multivar
+0000b370: 6961 7465 506f 6c79 6e6f 6d69 616c 3c46  iatePolynomial<F
+0000b380: 2c20 452c 204c 6578 4f72 6465 723e 207b  , E, LexOrder> {
+0000b390: 0a20 2020 2066 6e20 6d75 6c74 6976 6172  .    fn multivar
+0000b3a0: 6961 7465 5f64 696f 7068 616e 7469 6e65  iate_diophantine
+0000b3b0: 280a 2020 2020 2020 2020 756e 6976 6172  (.        univar
+0000b3c0: 6961 7465 5f64 656c 7461 733a 2026 5b53  iate_deltas: &[S
+0000b3d0: 656c 665d 2c0a 2020 2020 2020 2020 756e  elf],.        un
+0000b3e0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+0000b3f0: 3a20 266d 7574 205b 5365 6c66 5d2c 0a20  : &mut [Self],. 
+0000b400: 2020 2020 2020 2070 726f 6473 3a20 265b         prods: &[
+0000b410: 5365 6c66 5d2c 0a20 2020 2020 2020 2065  Self],.        e
+0000b420: 7272 6f72 3a20 2653 656c 662c 0a20 2020  rror: &Self,.   
+0000b430: 2020 2020 206f 7264 6572 3a20 265b 7573       order: &[us
+0000b440: 697a 655d 2c0a 2020 2020 2020 2020 7361  ize],.        sa
+0000b450: 6d70 6c65 5f70 6f69 6e74 733a 2026 5b28  mple_points: &[(
+0000b460: 7573 697a 652c 2046 3a3a 456c 656d 656e  usize, F::Elemen
+0000b470: 7429 5d2c 0a20 2020 2020 2020 2064 6567  t)],.        deg
+0000b480: 7265 6573 3a20 265b 7573 697a 655d 2c0a  rees: &[usize],.
+0000b490: 2020 2020 2920 2d3e 2056 6563 3c53 656c      ) -> Vec<Sel
+0000b4a0: 663e 207b 0a20 2020 2020 2020 2069 6620  f> {.        if 
+0000b4b0: 6f72 6465 722e 6c65 6e28 2920 3d3d 2031  order.len() == 1
+0000b4c0: 207b 0a20 2020 2020 2020 2020 2020 2072   {.            r
+0000b4d0: 6574 7572 6e20 756e 6976 6172 6961 7465  eturn univariate
+0000b4e0: 5f64 656c 7461 730a 2020 2020 2020 2020  _deltas.        
+0000b4f0: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
+0000b500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b510: 2e7a 6970 2875 6e69 7661 7269 6174 655f  .zip(univariate_
+0000b520: 6661 6374 6f72 7329 0a20 2020 2020 2020  factors).       
+0000b530: 2020 2020 2020 2020 202e 6d61 7028 7c28           .map(|(
+0000b540: 642c 2066 297c 2028 6420 2a20 6572 726f  d, f)| (d * erro
+0000b550: 7229 2e71 756f 745f 7265 6d5f 756e 6976  r).quot_rem_univ
+0000b560: 6172 6961 7465 2866 292e 3129 0a20 2020  ariate(f).1).   
+0000b570: 2020 2020 2020 2020 2020 2020 202e 636f               .co
+0000b580: 6c6c 6563 7428 293b 0a20 2020 2020 2020  llect();.       
+0000b590: 207d 0a0a 2020 2020 2020 2020 6c65 7420   }..        let 
+0000b5a0: 6c61 7374 5f76 6172 203d 202a 6f72 6465  last_var = *orde
+0000b5b0: 722e 6c61 7374 2829 2e75 6e77 7261 7028  r.last().unwrap(
+0000b5c0: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
+0000b5d0: 7368 6966 7420 3d20 2673 616d 706c 655f  shift = &sample_
+0000b5e0: 706f 696e 7473 2e69 7465 7228 292e 6669  points.iter().fi
+0000b5f0: 6e64 287c 737c 2073 2e30 203d 3d20 6c61  nd(|s| s.0 == la
+0000b600: 7374 5f76 6172 292e 756e 7772 6170 2829  st_var).unwrap()
+0000b610: 2e31 3b0a 0a20 2020 2020 2020 206c 6574  .1;..        let
+0000b620: 2070 726f 6473 5f6d 6f64 203d 2070 726f   prods_mod = pro
+0000b630: 6473 0a20 2020 2020 2020 2020 2020 202e  ds.            .
+0000b640: 6974 6572 2829 0a20 2020 2020 2020 2020  iter().         
+0000b650: 2020 202e 6d61 7028 7c66 7c20 662e 7265     .map(|f| f.re
+0000b660: 706c 6163 6528 6c61 7374 5f76 6172 2c20  place(last_var, 
+0000b670: 7368 6966 7429 290a 2020 2020 2020 2020  shift)).        
+0000b680: 2020 2020 2e63 6f6c 6c65 6374 3a3a 3c56      .collect::<V
+0000b690: 6563 3c5f 3e3e 2829 3b0a 2020 2020 2020  ec<_>>();.      
+0000b6a0: 2020 6c65 7420 6572 726f 725f 6d6f 6420    let error_mod 
+0000b6b0: 3d20 6572 726f 722e 7265 706c 6163 6528  = error.replace(
+0000b6c0: 6c61 7374 5f76 6172 2c20 7368 6966 7429  last_var, shift)
+0000b6d0: 3b0a 0a20 2020 2020 2020 2064 6562 7567  ;..        debug
+0000b6e0: 2128 2264 696f 7068 2065 5b78 7b7d 5e30  !("dioph e[x{}^0
+0000b6f0: 5d20 3d20 7b7d 222c 206c 6173 745f 7661  ] = {}", last_va
+0000b700: 722c 2065 7272 6f72 5f6d 6f64 293b 0a0a  r, error_mod);..
+0000b710: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0000b720: 6465 6c74 6173 203d 2053 656c 663a 3a6d  deltas = Self::m
+0000b730: 756c 7469 7661 7269 6174 655f 6469 6f70  ultivariate_diop
+0000b740: 6861 6e74 696e 6528 0a20 2020 2020 2020  hantine(.       
+0000b750: 2020 2020 2075 6e69 7661 7269 6174 655f       univariate_
+0000b760: 6465 6c74 6173 2c0a 2020 2020 2020 2020  deltas,.        
+0000b770: 2020 2020 756e 6976 6172 6961 7465 5f66      univariate_f
+0000b780: 6163 746f 7273 2c0a 2020 2020 2020 2020  actors,.        
+0000b790: 2020 2020 2670 726f 6473 5f6d 6f64 2c0a      &prods_mod,.
+0000b7a0: 2020 2020 2020 2020 2020 2020 2665 7272              &err
+0000b7b0: 6f72 5f6d 6f64 2c0a 2020 2020 2020 2020  or_mod,.        
+0000b7c0: 2020 2020 266f 7264 6572 5b2e 2e6f 7264      &order[..ord
+0000b7d0: 6572 2e6c 656e 2829 202d 2031 5d2c 0a20  er.len() - 1],. 
+0000b7e0: 2020 2020 2020 2020 2020 2073 616d 706c             sampl
+0000b7f0: 655f 706f 696e 7473 2c0a 2020 2020 2020  e_points,.      
+0000b800: 2020 2020 2020 2664 6567 7265 6573 5b2e        &degrees[.
+0000b810: 2e6f 7264 6572 2e6c 656e 2829 202d 2031  .order.len() - 1
+0000b820: 5d2c 0a20 2020 2020 2020 2029 3b0a 0a20  ],.        );.. 
+0000b830: 2020 2020 2020 202f 2f20 544f 444f 3a20         // TODO: 
+0000b840: 7072 6563 6f6d 7075 7465 0a20 2020 2020  precompute.     
+0000b850: 2020 206c 6574 206d 7574 206d 6f64 5f76     let mut mod_v
+0000b860: 6172 7320 3d20 5665 633a 3a77 6974 685f  ars = Vec::with_
+0000b870: 6361 7061 6369 7479 286f 7264 6572 2e6c  capacity(order.l
+0000b880: 656e 2829 202d 2032 293b 0a20 2020 2020  en() - 2);.     
+0000b890: 2020 206c 6574 206d 7574 2065 7870 203d     let mut exp =
+0000b8a0: 2076 6563 215b 453a 3a7a 6572 6f28 293b   vec![E::zero();
+0000b8b0: 2065 7272 6f72 2e6e 7661 7273 2829 5d3b   error.nvars()];
+0000b8c0: 0a20 2020 2020 2020 2066 6f72 2072 2069  .        for r i
+0000b8d0: 6e20 6f72 6465 725b 312e 2e6f 7264 6572  n order[1..order
+0000b8e0: 2e6c 656e 2829 202d 2031 5d2e 6974 6572  .len() - 1].iter
+0000b8f0: 2829 2e7a 6970 2826 6465 6772 6565 735b  ().zip(&degrees[
+0000b900: 312e 2e5d 2920 7b0a 2020 2020 2020 2020  1..]) {.        
+0000b910: 2020 2020 6c65 7420 7368 6966 7420 3d20      let shift = 
+0000b920: 2673 616d 706c 655f 706f 696e 7473 2e69  &sample_points.i
+0000b930: 7465 7228 292e 6669 6e64 287c 737c 2073  ter().find(|s| s
+0000b940: 2e30 203d 3d20 2a72 2e30 292e 756e 7772  .0 == *r.0).unwr
+0000b950: 6170 2829 2e31 3b0a 2020 2020 2020 2020  ap().1;.        
+0000b960: 2020 2020 6578 705b 2a72 2e30 5d20 3d20      exp[*r.0] = 
+0000b970: 453a 3a6f 6e65 2829 3b0a 2020 2020 2020  E::one();.      
+0000b980: 2020 2020 2020 6c65 7420 7661 725f 706f        let var_po
+0000b990: 7720 3d20 6572 726f 720a 2020 2020 2020  w = error.      
+0000b9a0: 2020 2020 2020 2020 2020 2e6d 6f6e 6f6d            .monom
+0000b9b0: 6961 6c28 6572 726f 722e 6669 656c 642e  ial(error.field.
+0000b9c0: 6f6e 6528 292c 2065 7870 2e63 6c6f 6e65  one(), exp.clone
+0000b9d0: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
+0000b9e0: 2020 2020 2e73 6869 6674 5f76 6172 282a      .shift_var(*
+0000b9f0: 722e 302c 2026 6572 726f 722e 6669 656c  r.0, &error.fiel
+0000ba00: 642e 6e65 6728 7368 6966 7429 290a 2020  d.neg(shift)).  
+0000ba10: 2020 2020 2020 2020 2020 2020 2020 2e70                .p
+0000ba20: 6f77 2872 2e31 202b 2031 293b 0a20 2020  ow(r.1 + 1);.   
+0000ba30: 2020 2020 2020 2020 2065 7870 5b2a 722e           exp[*r.
+0000ba40: 305d 203d 2045 3a3a 7a65 726f 2829 3b0a  0] = E::zero();.
+0000ba50: 2020 2020 2020 2020 2020 2020 6d6f 645f              mod_
+0000ba60: 7661 7273 2e70 7573 6828 7661 725f 706f  vars.push(var_po
+0000ba70: 7729 3b0a 2020 2020 2020 2020 7d0a 0a20  w);.        }.. 
+0000ba80: 2020 2020 2020 2065 7870 5b6c 6173 745f         exp[last_
+0000ba90: 7661 725d 203d 2045 3a3a 6f6e 6528 293b  var] = E::one();
+0000baa0: 0a20 2020 2020 2020 206c 6574 2076 6172  .        let var
+0000bab0: 5f70 6f77 203d 2065 7272 6f72 0a20 2020  _pow = error.   
+0000bac0: 2020 2020 2020 2020 202e 6d6f 6e6f 6d69           .monomi
+0000bad0: 616c 2865 7272 6f72 2e66 6965 6c64 2e6f  al(error.field.o
+0000bae0: 6e65 2829 2c20 6578 7029 0a20 2020 2020  ne(), exp).     
+0000baf0: 2020 2020 2020 202e 7368 6966 745f 7661         .shift_va
+0000bb00: 7228 6c61 7374 5f76 6172 2c20 2665 7272  r(last_var, &err
+0000bb10: 6f72 2e66 6965 6c64 2e6e 6567 2873 6869  or.field.neg(shi
+0000bb20: 6674 2929 3b0a 2020 2020 2020 2020 6c65  ft));.        le
+0000bb30: 7420 6d75 7420 6375 725f 6578 706f 6e65  t mut cur_expone
+0000bb40: 6e74 3b0a 2020 2020 2020 2020 6c65 7420  nt;.        let 
+0000bb50: 6d75 7420 6e65 7874 5f65 7870 6f6e 656e  mut next_exponen
+0000bb60: 7420 3d20 7661 725f 706f 772e 636c 6f6e  t = var_pow.clon
+0000bb70: 6528 293b 0a0a 2020 2020 2020 2020 666f  e();..        fo
+0000bb80: 7220 6a20 696e 2031 2e2e 3d2a 6465 6772  r j in 1..=*degr
+0000bb90: 6565 732e 6c61 7374 2829 2e75 6e77 7261  ees.last().unwra
+0000bba0: 7028 2920 7b0a 2020 2020 2020 2020 2020  p() {.          
+0000bbb0: 2020 6375 725f 6578 706f 6e65 6e74 203d    cur_exponent =
+0000bbc0: 206e 6578 745f 6578 706f 6e65 6e74 2e63   next_exponent.c
+0000bbd0: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
+0000bbe0: 2020 2020 6e65 7874 5f65 7870 6f6e 656e      next_exponen
+0000bbf0: 7420 3d20 266e 6578 745f 6578 706f 6e65  t = &next_expone
+0000bc00: 6e74 202a 2026 7661 725f 706f 773b 0a0a  nt * &var_pow;..
+0000bc10: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+0000bc20: 6d75 7420 6520 3d20 6572 726f 722e 636c  mut e = error.cl
+0000bc30: 6f6e 6528 293b 0a20 2020 2020 2020 2020  one();.         
+0000bc40: 2020 2066 6f72 2028 642c 2070 2920 696e     for (d, p) in
+0000bc50: 2064 656c 7461 732e 6974 6572 2829 2e7a   deltas.iter().z
+0000bc60: 6970 2870 726f 6473 2920 7b0a 2020 2020  ip(prods) {.    
+0000bc70: 2020 2020 2020 2020 2020 2020 6465 6275              debu
+0000bc80: 6721 2822 6465 6c74 6120 7b7d 2070 207b  g!("delta {} p {
+0000bc90: 7d22 2c20 642c 2070 293b 0a20 2020 2020  }", d, p);.     
+0000bca0: 2020 2020 2020 2020 2020 2065 203d 2026             e = &
+0000bcb0: 6520 2d20 2628 6420 2a20 7029 3b0a 0a20  e - &(d * p);.. 
+0000bcc0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000bcd0: 6f72 206d 2069 6e20 266d 6f64 5f76 6172  or m in &mod_var
+0000bce0: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
+0000bcf0: 2020 2020 2020 2020 2f2f 2054 4f44 4f3a          // TODO:
+0000bd00: 2066 6173 7465 7220 696d 706c 656d 656e   faster implemen
+0000bd10: 7461 7469 6f6e 2066 6f72 2075 6e69 7661  tation for univa
+0000bd20: 7269 6174 6520 6469 7669 736f 7220 706f  riate divisor po
+0000bd30: 7373 6962 6c65 3f0a 2020 2020 2020 2020  ssible?.        
+0000bd40: 2020 2020 2020 2020 2020 2020 6520 3d20              e = 
+0000bd50: 652e 7175 6f74 5f72 656d 286d 2c20 6661  e.quot_rem(m, fa
+0000bd60: 6c73 6529 2e31 3b0a 2020 2020 2020 2020  lse).1;.        
+0000bd70: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+0000bd80: 2020 2020 2020 2020 2020 202f 2f20 544f             // TO
+0000bd90: 444f 3a20 6d6f 6420 7769 7468 2028 782d  DO: mod with (x-
+0000bda0: 7368 6966 7429 5e28 6a2b 3129 3f0a 2020  shift)^(j+1)?.  
+0000bdb0: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
+0000bdc0: 2074 6865 6e20 7765 2063 616e 6e6f 7420   then we cannot 
+0000bdd0: 6272 6561 6b20 6f6e 2030 2065 7272 6f72  break on 0 error
+0000bde0: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+0000bdf0: 2020 2020 2020 2020 2020 2020 6465 6275              debu
+0000be00: 6721 2822 6469 6f70 6820 2065 2061 7420  g!("dioph  e at 
+0000be10: 787b 7d5e 7b7d 203d 207b 7d22 2c20 6c61  x{}^{} = {}", la
+0000be20: 7374 5f76 6172 2c20 6a2c 2065 293b 0a0a  st_var, j, e);..
+0000be30: 2020 2020 2020 2020 2020 2020 6966 2065              if e
+0000be40: 2e69 735f 7a65 726f 2829 207b 0a20 2020  .is_zero() {.   
+0000be50: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+0000be60: 616b 3b0a 2020 2020 2020 2020 2020 2020  ak;.            
+0000be70: 7d0a 0a20 2020 2020 2020 2020 2020 202f  }..            /
+0000be80: 2f20 7461 6b65 2074 6865 206a 7468 2070  / take the jth p
+0000be90: 6f77 6572 206f 6620 7661 7220 2d20 7368  ower of var - sh
+0000bea0: 6966 7420 696e 2074 6865 2065 7272 6f72  ift in the error
+0000beb0: 0a20 2020 2020 2020 2020 2020 206c 6574  .            let
+0000bec0: 206d 7574 2065 5f6d 6f64 203d 2065 0a20   mut e_mod = e. 
+0000bed0: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+0000bee0: 7368 6966 745f 7661 7228 6c61 7374 5f76  shift_var(last_v
+0000bef0: 6172 2c20 7368 6966 7429 0a20 2020 2020  ar, shift).     
+0000bf00: 2020 2020 2020 2020 2020 202e 6d6f 645f             .mod_
+0000bf10: 7661 7228 6c61 7374 5f76 6172 2c20 453a  var(last_var, E:
+0000bf20: 3a66 726f 6d5f 7533 3228 6a20 6173 2075  :from_u32(j as u
+0000bf30: 3332 202b 2031 2929 3b0a 2020 2020 2020  32 + 1));.      
+0000bf40: 2020 2020 2020 666f 7220 6520 696e 2065        for e in e
+0000bf50: 5f6d 6f64 2e65 7870 6f6e 656e 7473 5f69  _mod.exponents_i
+0000bf60: 7465 725f 6d75 7428 2920 7b0a 2020 2020  ter_mut() {.    
+0000bf70: 2020 2020 2020 2020 2020 2020 6465 6275              debu
+0000bf80: 675f 6173 7365 7274 5f65 7121 2865 5b6c  g_assert_eq!(e[l
+0000bf90: 6173 745f 7661 725d 2c20 453a 3a66 726f  ast_var], E::fro
+0000bfa0: 6d5f 7533 3228 6a20 6173 2075 3332 2929  m_u32(j as u32))
+0000bfb0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+0000bfc0: 2020 655b 6c61 7374 5f76 6172 5d20 3d20    e[last_var] = 
+0000bfd0: 453a 3a7a 6572 6f28 293b 0a20 2020 2020  E::zero();.     
+0000bfe0: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+0000bff0: 2020 2020 2020 6465 6275 6721 2822 6469        debug!("di
+0000c000: 6f70 6820 2065 5b78 7b7d 5e7b 7d5d 203d  oph  e[x{}^{}] =
+0000c010: 207b 7d22 2c20 6c61 7374 5f76 6172 2c20   {}", last_var, 
+0000c020: 6a2c 2065 5f6d 6f64 293b 0a0a 2020 2020  j, e_mod);..    
+0000c030: 2020 2020 2020 2020 6966 2065 5f6d 6f64          if e_mod
+0000c040: 2e69 735f 7a65 726f 2829 207b 0a20 2020  .is_zero() {.   
+0000c050: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+0000c060: 7469 6e75 653b 0a20 2020 2020 2020 2020  tinue;.         
+0000c070: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+0000c080: 2020 6c65 7420 6d75 7420 6e65 775f 6465    let mut new_de
+0000c090: 6c74 6173 203d 2053 656c 663a 3a6d 756c  ltas = Self::mul
+0000c0a0: 7469 7661 7269 6174 655f 6469 6f70 6861  tivariate_diopha
+0000c0b0: 6e74 696e 6528 0a20 2020 2020 2020 2020  ntine(.         
+0000c0c0: 2020 2020 2020 2075 6e69 7661 7269 6174         univariat
+0000c0d0: 655f 6465 6c74 6173 2c0a 2020 2020 2020  e_deltas,.      
+0000c0e0: 2020 2020 2020 2020 2020 756e 6976 6172            univar
+0000c0f0: 6961 7465 5f66 6163 746f 7273 2c0a 2020  iate_factors,.  
+0000c100: 2020 2020 2020 2020 2020 2020 2020 2670                &p
+0000c110: 726f 6473 5f6d 6f64 2c0a 2020 2020 2020  rods_mod,.      
+0000c120: 2020 2020 2020 2020 2020 2665 5f6d 6f64            &e_mod
+0000c130: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000c140: 2020 266f 7264 6572 5b2e 2e6f 7264 6572    &order[..order
+0000c150: 2e6c 656e 2829 202d 2031 5d2c 0a20 2020  .len() - 1],.   
+0000c160: 2020 2020 2020 2020 2020 2020 2073 616d               sam
+0000c170: 706c 655f 706f 696e 7473 2c0a 2020 2020  ple_points,.    
+0000c180: 2020 2020 2020 2020 2020 2020 2664 6567              &deg
+0000c190: 7265 6573 5b2e 2e6f 7264 6572 2e6c 656e  rees[..order.len
+0000c1a0: 2829 202d 2031 5d2c 0a20 2020 2020 2020  () - 1],.       
+0000c1b0: 2020 2020 2029 3b0a 0a20 2020 2020 2020       );..       
+0000c1c0: 2020 2020 2066 6f72 2028 642c 206e 6429       for (d, nd)
+0000c1d0: 2069 6e20 6465 6c74 6173 2e69 7465 725f   in deltas.iter_
+0000c1e0: 6d75 7428 292e 7a69 7028 266d 7574 206e  mut().zip(&mut n
+0000c1f0: 6577 5f64 656c 7461 7329 207b 0a20 2020  ew_deltas) {.   
+0000c200: 2020 2020 2020 2020 2020 2020 2064 6562               deb
+0000c210: 7567 2128 2264 696f 7068 2020 645b 787b  ug!("dioph  d[x{
+0000c220: 7d5e 7b7d 5d20 3d20 7b7d 222c 206c 6173  }^{}] = {}", las
+0000c230: 745f 7661 722c 206a 2c20 6e64 293b 0a0a  t_var, j, nd);..
+0000c240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c250: 2f2f 206d 756c 7469 706c 7920 2879 2d73  // multiply (y-s
+0000c260: 295e 6a20 616e 6420 6d6f 6420 7772 7420  )^j and mod wrt 
+0000c270: 616c 6c20 7661 7273 0a20 2020 2020 2020  all vars.       
+0000c280: 2020 2020 2020 2020 206c 6574 206e 6420           let nd 
+0000c290: 3d20 262a 6e64 202a 2026 6375 725f 6578  = &*nd * &cur_ex
+0000c2a0: 706f 6e65 6e74 3b0a 2020 2020 2020 2020  ponent;.        
+0000c2b0: 2020 2020 2020 2020 2a64 203d 2026 2a64          *d = &*d
+0000c2c0: 202b 2026 6e64 3b0a 0a20 2020 2020 2020   + &nd;..       
+0000c2d0: 2020 2020 2020 2020 2066 6f72 206d 2069           for m i
+0000c2e0: 6e20 266d 6f64 5f76 6172 7320 7b0a 2020  n &mod_vars {.  
+0000c2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c300: 2020 6520 3d20 652e 7175 6f74 5f72 656d    e = e.quot_rem
+0000c310: 286d 2c20 6661 6c73 6529 2e31 3b0a 2020  (m, false).1;.  
+0000c320: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+0000c330: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+0000c340: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+0000c350: 2064 656c 7461 730a 2020 2020 7d0a 0a20   deltas.    }.. 
+0000c360: 2020 2066 6e20 6d75 6c74 6976 6172 6961     fn multivaria
+0000c370: 7465 5f68 656e 7365 6c5f 6c69 6674 696e  te_hensel_liftin
+0000c380: 6728 0a20 2020 2020 2020 2026 7365 6c66  g(.        &self
+0000c390: 2c0a 2020 2020 2020 2020 6661 6374 6f72  ,.        factor
+0000c3a0: 733a 2026 5b53 656c 665d 2c0a 2020 2020  s: &[Self],.    
+0000c3b0: 2020 2020 756e 6976 6172 6961 7465 5f66      univariate_f
+0000c3c0: 6163 746f 7273 3a20 266d 7574 205b 5365  actors: &mut [Se
+0000c3d0: 6c66 5d2c 0a20 2020 2020 2020 2075 6e69  lf],.        uni
+0000c3e0: 7661 7269 6174 655f 6465 6c74 6173 3a20  variate_deltas: 
+0000c3f0: 265b 5365 6c66 5d2c 0a20 2020 2020 2020  &[Self],.       
+0000c400: 2073 616d 706c 655f 706f 696e 7473 3a20   sample_points: 
+0000c410: 265b 2875 7369 7a65 2c20 463a 3a45 6c65  &[(usize, F::Ele
+0000c420: 6d65 6e74 295d 2c0a 2020 2020 2020 2020  ment)],.        
+0000c430: 7472 7565 5f6c 636f 6566 6673 3a20 4f70  true_lcoeffs: Op
+0000c440: 7469 6f6e 3c26 5b53 656c 665d 3e2c 0a20  tion<&[Self]>,. 
+0000c450: 2020 2020 2020 206f 7264 6572 3a20 265b         order: &[
+0000c460: 7573 697a 655d 2c0a 2020 2020 2020 2020  usize],.        
+0000c470: 7374 6172 745f 696e 6465 783a 2075 7369  start_index: usi
+0000c480: 7a65 2c0a 2020 2020 2920 2d3e 2056 6563  ze,.    ) -> Vec
+0000c490: 3c53 656c 663e 207b 0a20 2020 2020 2020  <Self> {.       
+0000c4a0: 2064 6562 7567 2128 2248 656e 7365 6c20   debug!("Hensel 
+0000c4b0: 6c69 6674 207b 7d20 7769 7468 206f 7264  lift {} with ord
+0000c4c0: 6572 207b 3a3f 7d22 2c20 7365 6c66 2c20  er {:?}", self, 
+0000c4d0: 6f72 6465 7229 3b0a 0a20 2020 2020 2020  order);..       
+0000c4e0: 206c 6574 206d 7574 2064 6567 7265 6573   let mut degrees
+0000c4f0: 3a20 5665 633c 5f3e 203d 206f 7264 6572  : Vec<_> = order
+0000c500: 0a20 2020 2020 2020 2020 2020 202e 6974  .            .it
+0000c510: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
+0000c520: 202e 6d61 7028 7c76 7c20 7365 6c66 2e64   .map(|v| self.d
+0000c530: 6567 7265 6528 2a76 292e 746f 5f75 3332  egree(*v).to_u32
+0000c540: 2829 2061 7320 7573 697a 6529 0a20 2020  () as usize).   
+0000c550: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
+0000c560: 7428 293b 0a0a 2020 2020 2020 2020 6c65  t();..        le
+0000c570: 7420 6d75 7420 7265 636f 6e73 7472 7563  t mut reconstruc
+0000c580: 7465 645f 6661 6374 6f72 7320 3d20 6661  ted_factors = fa
+0000c590: 6374 6f72 732e 746f 5f76 6563 2829 3b0a  ctors.to_vec();.
+0000c5a0: 2020 2020 2020 2020 666f 7220 7620 696e          for v in
+0000c5b0: 2073 7461 7274 5f69 6e64 6578 2e2e 6f72   start_index..or
+0000c5c0: 6465 722e 6c65 6e28 2920 7b0a 2020 2020  der.len() {.    
+0000c5d0: 2020 2020 2020 2020 2f2f 2072 6570 6c61          // repla
+0000c5e0: 6365 2074 6865 206c 636f 6566 6620 696e  ce the lcoeff in
+0000c5f0: 2078 3020 7769 7468 2074 6865 2070 726f   x0 with the pro
+0000c600: 7065 7220 6c63 6f65 6666 0a20 2020 2020  per lcoeff.     
+0000c610: 2020 2020 2020 206c 6574 206d 7574 2066         let mut f
+0000c620: 6163 746f 7273 5f77 6974 685f 7472 7565  actors_with_true
+0000c630: 5f6c 636f 6566 6620 3d20 7665 6321 5b5d  _lcoeff = vec![]
+0000c640: 3b0a 0a20 2020 2020 2020 2020 2020 2069  ;..            i
+0000c650: 6620 6c65 7420 536f 6d65 2874 7275 655f  f let Some(true_
+0000c660: 6c63 6f65 6666 7329 203d 2074 7275 655f  lcoeffs) = true_
+0000c670: 6c63 6f65 6666 7320 7b0a 2020 2020 2020  lcoeffs {.      
+0000c680: 2020 2020 2020 2020 2020 666f 7220 2862            for (b
+0000c690: 2c20 6c29 2069 6e20 7265 636f 6e73 7472  , l) in reconstr
+0000c6a0: 7563 7465 645f 6661 6374 6f72 732e 6974  ucted_factors.it
+0000c6b0: 6572 2829 2e7a 6970 2874 7275 655f 6c63  er().zip(true_lc
+0000c6c0: 6f65 6666 7329 207b 0a20 2020 2020 2020  oeffs) {.       
+0000c6d0: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0000c6e0: 206d 7574 206c 636f 6566 6620 3d20 6c2e   mut lcoeff = l.
+0000c6f0: 636c 6f6e 6528 293b 0a20 2020 2020 2020  clone();.       
+0000c700: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0000c710: 206a 2069 6e20 7620 2b20 312e 2e6f 7264   j in v + 1..ord
+0000c720: 6572 2e6c 656e 2829 207b 0a20 2020 2020  er.len() {.     
+0000c730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c740: 2020 2066 6f72 2073 2069 6e20 7361 6d70     for s in samp
+0000c750: 6c65 5f70 6f69 6e74 7320 7b0a 2020 2020  le_points {.    
+0000c760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c770: 2020 2020 2020 2020 6966 2073 2e30 203d          if s.0 =
+0000c780: 3d20 6f72 6465 725b 6a5d 207b 0a20 2020  = order[j] {.   
+0000c790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7a0: 2020 2020 2020 2020 2020 2020 206c 636f               lco
+0000c7b0: 6566 6620 3d20 6c63 6f65 6666 2e72 6570  eff = lcoeff.rep
+0000c7c0: 6c61 6365 2873 2e30 2c20 2673 2e31 293b  lace(s.0, &s.1);
+0000c7d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c7e0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+0000c7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c800: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+0000c810: 2020 2020 2020 2020 2020 2020 207d 0a0a               }..
+0000c820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c830: 2020 2020 6c65 7420 6d75 7420 6273 203d      let mut bs =
+0000c840: 2062 2e74 6f5f 756e 6976 6172 6961 7465   b.to_univariate
+0000c850: 5f70 6f6c 796e 6f6d 6961 6c5f 6c69 7374  _polynomial_list
+0000c860: 286f 7264 6572 5b30 5d29 3b0a 2020 2020  (order[0]);.    
+0000c870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c880: 6273 2e6c 6173 745f 6d75 7428 292e 756e  bs.last_mut().un
+0000c890: 7772 6170 2829 2e30 203d 206c 636f 6566  wrap().0 = lcoef
+0000c8a0: 663b 0a0a 2020 2020 2020 2020 2020 2020  f;..            
+0000c8b0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0000c8c0: 6669 7865 645f 6661 6320 3d20 7365 6c66  fixed_fac = self
+0000c8d0: 2e7a 6572 6f28 293b 0a20 2020 2020 2020  .zero();.       
+0000c8e0: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0000c8f0: 206d 7574 2065 7870 203d 2076 6563 215b   mut exp = vec![
+0000c900: 453a 3a7a 6572 6f28 293b 2073 656c 662e  E::zero(); self.
+0000c910: 6e76 6172 7328 295d 3b0a 2020 2020 2020  nvars()];.      
+0000c920: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+0000c930: 7220 2870 2c20 6529 2069 6e20 6273 207b  r (p, e) in bs {
+0000c940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c950: 2020 2020 2020 2020 2065 7870 5b6f 7264           exp[ord
+0000c960: 6572 5b30 5d5d 203d 2065 3b0a 2020 2020  er[0]] = e;.    
+0000c970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c980: 2020 2020 6669 7865 645f 6661 6320 3d20      fixed_fac = 
+0000c990: 6669 7865 645f 6661 6320 2b20 702e 6d75  fixed_fac + p.mu
+0000c9a0: 6c5f 6578 7028 2665 7870 293b 0a20 2020  l_exp(&exp);.   
 0000c9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9c0: 2066 6163 746f 7273 5f77 6974 685f 7472   factors_with_tr
-0000c9d0: 7565 5f6c 636f 6566 662e 7075 7368 2866  ue_lcoeff.push(f
-0000c9e0: 6978 6564 5f66 6163 293b 0a20 2020 2020  ixed_fac);.     
-0000c9f0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-0000ca00: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
-0000ca10: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000ca20: 2020 6661 6374 6f72 735f 7769 7468 5f74    factors_with_t
-0000ca30: 7275 655f 6c63 6f65 6666 2e65 7874 656e  rue_lcoeff.exten
-0000ca40: 6428 7265 636f 6e73 7472 7563 7465 645f  d(reconstructed_
-0000ca50: 6661 6374 6f72 7329 3b0a 2020 2020 2020  factors);.      
-0000ca60: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-0000ca70: 2020 2020 206c 6574 206d 7574 2066 203d       let mut f =
-0000ca80: 2073 656c 662e 636c 6f6e 6528 293b 0a20   self.clone();. 
-0000ca90: 2020 2020 2020 2020 2020 2066 6f72 206a             for j
-0000caa0: 2069 6e20 7620 2b20 312e 2e6f 7264 6572   in v + 1..order
-0000cab0: 2e6c 656e 2829 207b 0a20 2020 2020 2020  .len() {.       
-0000cac0: 2020 2020 2020 2020 2066 6f72 2073 2069           for s i
-0000cad0: 6e20 7361 6d70 6c65 5f70 6f69 6e74 7320  n sample_points 
-0000cae0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000caf0: 2020 2020 2020 6966 2073 2e30 203d 3d20        if s.0 == 
-0000cb00: 6f72 6465 725b 6a5d 207b 0a20 2020 2020  order[j] {.     
-0000cb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb20: 2020 2066 203d 2066 2e72 6570 6c61 6365     f = f.replace
-0000cb30: 2873 2e30 2c20 2673 2e31 293b 0a20 2020  (s.0, &s.1);.   
-0000cb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb50: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
-0000cb60: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-0000cb70: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
-0000cb80: 2f2f 2073 6869 6674 2074 6865 2070 6f6c  // shift the pol
-0000cb90: 796e 6f6d 6961 6c20 7375 6368 2074 6861  ynomial such tha
-0000cba0: 7420 7468 6520 6576 616c 7561 7469 6f6e  t the evaluation
-0000cbb0: 2070 6f69 6e74 2069 7320 6e6f 7720 6174   point is now at
-0000cbc0: 2030 0a20 2020 2020 2020 2020 2020 202f   0.            /
-0000cbd0: 2f20 736f 2074 6861 7420 7765 2063 616e  / so that we can
-0000cbe0: 2075 7365 2061 2063 6f6e 766f 6c75 7469   use a convoluti
-0000cbf0: 6f6e 2066 6f72 2066 6173 7420 6572 726f  on for fast erro
-0000cc00: 7220 636f 6d70 7574 6174 696f 6e0a 2020  r computation.  
-0000cc10: 2020 2020 2020 2020 2020 6c65 7420 7368            let sh
-0000cc20: 6966 7420 3d20 2673 616d 706c 655f 706f  ift = &sample_po
-0000cc30: 696e 7473 2e69 7465 7228 292e 6669 6e64  ints.iter().find
-0000cc40: 287c 737c 2073 2e30 203d 3d20 6f72 6465  (|s| s.0 == orde
-0000cc50: 725b 765d 292e 756e 7772 6170 2829 2e31  r[v]).unwrap().1
-0000cc60: 3b0a 2020 2020 2020 2020 2020 2020 6620  ;.            f 
-0000cc70: 3d20 662e 7368 6966 745f 7661 7228 6f72  = f.shift_var(or
-0000cc80: 6465 725b 765d 2c20 7368 6966 7429 3b0a  der[v], shift);.
-0000cc90: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000cca0: 2066 2069 6e20 266d 7574 2066 6163 746f   f in &mut facto
-0000ccb0: 7273 5f77 6974 685f 7472 7565 5f6c 636f  rs_with_true_lco
-0000ccc0: 6566 6620 7b0a 2020 2020 2020 2020 2020  eff {.          
-0000ccd0: 2020 2020 2020 2a66 203d 2066 2e73 6869        *f = f.shi
-0000cce0: 6674 5f76 6172 286f 7264 6572 5b76 5d2c  ft_var(order[v],
-0000ccf0: 2073 6869 6674 293b 0a20 2020 2020 2020   shift);.       
-0000cd00: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-0000cd10: 2020 2020 6c65 7420 6d75 7420 746f 7420      let mut tot 
-0000cd20: 3d20 7365 6c66 2e6f 6e65 2829 3b0a 2020  = self.one();.  
-0000cd30: 2020 2020 2020 2020 2020 666f 7220 6220            for b 
-0000cd40: 696e 2026 6661 6374 6f72 735f 7769 7468  in &factors_with
-0000cd50: 5f74 7275 655f 6c63 6f65 6666 207b 0a20  _true_lcoeff {. 
-0000cd60: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000cd70: 6f74 203d 2074 6f74 202a 2062 3b0a 2020  ot = tot * b;.  
-0000cd80: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-0000cd90: 2020 2020 2020 2020 6c65 7420 6661 6374          let fact
-0000cda0: 6f72 5f70 726f 6475 6374 733a 2056 6563  or_products: Vec
-0000cdb0: 3c5f 3e20 3d0a 2020 2020 2020 2020 2020  <_> =.          
-0000cdc0: 2020 2020 2020 6661 6374 6f72 735f 7769        factors_wi
-0000cdd0: 7468 5f74 7275 655f 6c63 6f65 6666 2e69  th_true_lcoeff.i
-0000cde0: 7465 7228 292e 6d61 7028 7c66 7c20 2674  ter().map(|f| &t
-0000cdf0: 6f74 202f 2066 292e 636f 6c6c 6563 7428  ot / f).collect(
-0000ce00: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-0000ce10: 7265 636f 6e73 7472 7563 7465 645f 6661  reconstructed_fa
-0000ce20: 6374 6f72 7320 3d20 662e 6d75 6c74 6976  ctors = f.multiv
-0000ce30: 6172 6961 7465 5f68 656e 7365 6c5f 7374  ariate_hensel_st
-0000ce40: 6570 280a 2020 2020 2020 2020 2020 2020  ep(.            
-0000ce50: 2020 2020 756e 6976 6172 6961 7465 5f64      univariate_d
-0000ce60: 656c 7461 732c 0a20 2020 2020 2020 2020  eltas,.         
-0000ce70: 2020 2020 2020 2075 6e69 7661 7269 6174         univariat
-0000ce80: 655f 6661 6374 6f72 732c 0a20 2020 2020  e_factors,.     
-0000ce90: 2020 2020 2020 2020 2020 2073 616d 706c             sampl
-0000cea0: 655f 706f 696e 7473 2c0a 2020 2020 2020  e_points,.      
-0000ceb0: 2020 2020 2020 2020 2020 266d 7574 2066            &mut f
-0000cec0: 6163 746f 7273 5f77 6974 685f 7472 7565  actors_with_true
-0000ced0: 5f6c 636f 6566 662c 0a20 2020 2020 2020  _lcoeff,.       
-0000cee0: 2020 2020 2020 2020 2026 6661 6374 6f72           &factor
-0000cef0: 5f70 726f 6475 6374 732c 0a20 2020 2020  _products,.     
-0000cf00: 2020 2020 2020 2020 2020 2026 6f72 6465             &orde
-0000cf10: 725b 2e2e 3d76 5d2c 0a20 2020 2020 2020  r[..=v],.       
-0000cf20: 2020 2020 2020 2020 2026 6d75 7420 6465           &mut de
-0000cf30: 6772 6565 735b 2e2e 3d76 5d2c 0a20 2020  grees[..=v],.   
-0000cf40: 2020 2020 2020 2020 2029 3b0a 0a20 2020           );..   
-0000cf50: 2020 2020 2020 2020 2066 6f72 2066 2069           for f i
-0000cf60: 6e20 266d 7574 2072 6563 6f6e 7374 7275  n &mut reconstru
-0000cf70: 6374 6564 5f66 6163 746f 7273 207b 0a20  cted_factors {. 
-0000cf80: 2020 2020 2020 2020 2020 2020 2020 202a                 *
-0000cf90: 6620 3d20 662e 7368 6966 745f 7661 7228  f = f.shift_var(
-0000cfa0: 6f72 6465 725b 765d 2c20 2673 656c 662e  order[v], &self.
-0000cfb0: 6669 656c 642e 6e65 6728 7368 6966 7429  field.neg(shift)
-0000cfc0: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
-0000cfd0: 0a0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-0000cfe0: 7220 6620 696e 2026 7265 636f 6e73 7472  r f in &reconstr
-0000cff0: 7563 7465 645f 6661 6374 6f72 7320 7b0a  ucted_factors {.
-0000d000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d010: 6465 6275 6721 2822 5265 636f 6e73 7472  debug!("Reconstr
-0000d020: 7563 7465 6420 6661 6374 6f72 207b 7d22  ucted factor {}"
-0000d030: 2c20 6629 3b0a 2020 2020 2020 2020 2020  , f);.          
-0000d040: 2020 7d0a 2020 2020 2020 2020 7d0a 0a20    }.        }.. 
-0000d050: 2020 2020 2020 2072 6563 6f6e 7374 7275         reconstru
-0000d060: 6374 6564 5f66 6163 746f 7273 0a20 2020  cted_factors.   
-0000d070: 207d 0a0a 2020 2020 666e 206d 756c 7469   }..    fn multi
-0000d080: 7661 7269 6174 655f 6865 6e73 656c 5f73  variate_hensel_s
-0000d090: 7465 7028 0a20 2020 2020 2020 2026 7365  tep(.        &se
-0000d0a0: 6c66 2c0a 2020 2020 2020 2020 756e 6976  lf,.        univ
-0000d0b0: 6172 6961 7465 5f64 656c 7461 733a 2026  ariate_deltas: &
-0000d0c0: 5b53 656c 665d 2c0a 2020 2020 2020 2020  [Self],.        
-0000d0d0: 756e 6976 6172 6961 7465 5f66 6163 746f  univariate_facto
-0000d0e0: 7273 3a20 266d 7574 205b 5365 6c66 5d2c  rs: &mut [Self],
-0000d0f0: 0a20 2020 2020 2020 2073 616d 706c 655f  .        sample_
-0000d100: 706f 696e 7473 3a20 265b 2875 7369 7a65  points: &[(usize
-0000d110: 2c20 463a 3a45 6c65 6d65 6e74 295d 2c0a  , F::Element)],.
-0000d120: 2020 2020 2020 2020 6661 6374 6f72 733a          factors:
-0000d130: 2026 6d75 7420 5b53 656c 665d 2c0a 2020   &mut [Self],.  
-0000d140: 2020 2020 2020 7072 6f64 733a 2026 5b53        prods: &[S
-0000d150: 656c 665d 2c0a 2020 2020 2020 2020 6f72  elf],.        or
-0000d160: 6465 723a 2026 5b75 7369 7a65 5d2c 0a20  der: &[usize],. 
-0000d170: 2020 2020 2020 2064 6567 7265 6573 3a20         degrees: 
-0000d180: 266d 7574 205b 7573 697a 655d 2c0a 2020  &mut [usize],.  
-0000d190: 2020 2920 2d3e 2056 6563 3c53 656c 663e    ) -> Vec<Self>
-0000d1a0: 207b 0a20 2020 2020 2020 206c 6574 206c   {.        let l
-0000d1b0: 6173 745f 7661 7220 3d20 2a6f 7264 6572  ast_var = *order
-0000d1c0: 2e6c 6173 7428 292e 756e 7772 6170 2829  .last().unwrap()
-0000d1d0: 3b0a 2020 2020 2020 2020 6c65 7420 6c61  ;.        let la
-0000d1e0: 7374 5f64 6567 7265 6520 3d20 2a64 6567  st_degree = *deg
-0000d1f0: 7265 6573 2e6c 6173 7428 292e 756e 7772  rees.last().unwr
-0000d200: 6170 2829 3b0a 2020 2020 2020 2020 6c65  ap();.        le
-0000d210: 7420 795f 706f 6c79 203d 2073 656c 662e  t y_poly = self.
-0000d220: 746f 5f75 6e69 7661 7269 6174 655f 706f  to_univariate_po
-0000d230: 6c79 6e6f 6d69 616c 5f6c 6973 7428 6c61  lynomial_list(la
-0000d240: 7374 5f76 6172 293b 0a0a 2020 2020 2020  st_var);..      
-0000d250: 2020 2f2f 2065 7874 7261 6374 2063 6f65    // extract coe
-0000d260: 6666 6963 6965 6e74 7320 696e 206c 6173  fficients in las
-0000d270: 745f 7661 720a 2020 2020 2020 2020 6c65  t_var.        le
-0000d280: 7420 6d75 7420 753a 2056 6563 3c5f 3e20  t mut u: Vec<_> 
-0000d290: 3d20 6661 6374 6f72 730a 2020 2020 2020  = factors.      
-0000d2a0: 2020 2020 2020 2e69 7465 7228 290a 2020        .iter().  
-0000d2b0: 2020 2020 2020 2020 2020 2e6d 6170 287c            .map(|
-0000d2c0: 667c 207b 0a20 2020 2020 2020 2020 2020  f| {.           
-0000d2d0: 2020 2020 206c 6574 206d 7574 2064 656e       let mut den
-0000d2e0: 7365 203d 2076 6563 215b 7365 6c66 2e7a  se = vec![self.z
-0000d2f0: 6572 6f28 293b 206c 6173 745f 6465 6772  ero(); last_degr
-0000d300: 6565 202b 2031 5d3b 0a0a 2020 2020 2020  ee + 1];..      
-0000d310: 2020 2020 2020 2020 2020 666f 7220 2870            for (p
-0000d320: 2c20 6529 2069 6e20 662e 746f 5f75 6e69  , e) in f.to_uni
-0000d330: 7661 7269 6174 655f 706f 6c79 6e6f 6d69  variate_polynomi
-0000d340: 616c 5f6c 6973 7428 6c61 7374 5f76 6172  al_list(last_var
-0000d350: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-0000d360: 2020 2020 2020 2020 6465 6e73 655b 652e          dense[e.
-0000d370: 746f 5f75 3332 2829 2061 7320 7573 697a  to_u32() as usiz
-0000d380: 655d 203d 2070 3b0a 2020 2020 2020 2020  e] = p;.        
-0000d390: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-0000d3a0: 2020 2020 2020 2020 2020 2064 656e 7365             dense
-0000d3b0: 0a20 2020 2020 2020 2020 2020 207d 290a  .            }).
-0000d3c0: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
-0000d3d0: 6c65 6374 2829 3b0a 0a20 2020 2020 2020  lect();..       
-0000d3e0: 202f 2f20 544f 444f 3a20 646f 2065 6e74   // TODO: do ent
-0000d3f0: 6972 6520 696e 6974 6961 6c69 7a61 7469  ire initializati
-0000d400: 6f6e 2068 6572 653f 0a20 2020 2020 2020  on here?.       
-0000d410: 202f 2f20 7468 6520 6c6f 6f70 2062 656c   // the loop bel
-0000d420: 6f77 2063 616e 6e6f 7420 6265 2063 7574  ow cannot be cut
-0000d430: 2073 686f 7274 2061 6e79 7761 792c 2073   short anyway, s
-0000d440: 6f20 6974 2773 206e 6f74 2065 7874 7261  o it's not extra
-0000d450: 2077 6f72 6b20 746f 2064 6f20 6974 2061   work to do it a
-0000d460: 6c6c 2068 6572 650a 2020 2020 2020 2020  ll here.        
-0000d470: 6c65 7420 6d75 7420 7020 3d20 752e 636c  let mut p = u.cl
-0000d480: 6f6e 6528 293b 0a20 2020 2020 2020 206c  one();.        l
-0000d490: 6574 206d 7574 2063 7572 5f70 203d 2070  et mut cur_p = p
-0000d4a0: 5b30 5d5b 305d 2e63 6c6f 6e65 2829 3b0a  [0][0].clone();.
-0000d4b0: 2020 2020 2020 2020 666f 7220 7820 696e          for x in
-0000d4c0: 2026 6d75 7420 702e 6974 6572 5f6d 7574   &mut p.iter_mut
-0000d4d0: 2829 2e73 6b69 7028 3129 207b 0a20 2020  ().skip(1) {.   
-0000d4e0: 2020 2020 2020 2020 2066 6f72 206a 2069           for j i
-0000d4f0: 6e20 266d 7574 202a 7820 7b0a 2020 2020  n &mut *x {.    
-0000d500: 2020 2020 2020 2020 2020 2020 2a6a 203d              *j =
-0000d510: 2026 2a6a 202a 2026 6375 725f 703b 0a20   &*j * &cur_p;. 
-0000d520: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-0000d530: 2020 2020 2020 2020 2020 6375 725f 7020            cur_p 
-0000d540: 3d20 785b 305d 2e63 6c6f 6e65 2829 3b0a  = x[0].clone();.
-0000d550: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-0000d560: 2020 206c 6574 2070 726f 645f 6d6f 6420     let prod_mod 
-0000d570: 3d20 7072 6f64 730a 2020 2020 2020 2020  = prods.        
-0000d580: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
-0000d590: 2020 2020 2020 2020 2e6d 6170 287c 667c          .map(|f|
-0000d5a0: 2066 2e72 6570 6c61 6365 286c 6173 745f   f.replace(last_
-0000d5b0: 7661 722c 2026 7365 6c66 2e66 6965 6c64  var, &self.field
-0000d5c0: 2e7a 6572 6f28 2929 290a 2020 2020 2020  .zero())).      
-0000d5d0: 2020 2020 2020 2e63 6f6c 6c65 6374 3a3a        .collect::
-0000d5e0: 3c56 6563 3c5f 3e3e 2829 3b0a 0a20 2020  <Vec<_>>();..   
-0000d5f0: 2020 2020 2064 6562 7567 2128 2269 6e20       debug!("in 
-0000d600: 7368 6966 7420 7b7d 222c 2073 656c 6629  shift {}", self)
-0000d610: 3b0a 2020 2020 2020 2020 6465 6275 6721  ;.        debug!
-0000d620: 2822 6465 6720 7b3a 3f7d 222c 2064 6567  ("deg {:?}", deg
-0000d630: 7265 6573 293b 0a0a 2020 2020 2020 2020  rees);..        
-0000d640: 666f 7220 6b20 696e 2031 2e2e 3d6c 6173  for k in 1..=las
-0000d650: 745f 6465 6772 6565 207b 0a20 2020 2020  t_degree {.     
-0000d660: 2020 2020 2020 202f 2f20 6578 7472 6163         // extrac
-0000d670: 7420 7468 6520 636f 6566 6669 6369 656e  t the coefficien
-0000d680: 7420 7265 7175 6972 6564 2074 6f20 636f  t required to co
-0000d690: 6d70 7574 6520 7468 6520 6572 726f 7220  mpute the error 
-0000d6a0: 696e 2079 5e6b 0a20 2020 2020 2020 2020  in y^k.         
-0000d6b0: 2020 202f 2f20 636f 6d70 7574 6564 2075     // computed u
-0000d6c0: 7369 6e67 2061 2063 6f6e 766f 6c75 7469  sing a convoluti
-0000d6d0: 6f6e 0a20 2020 2020 2020 2020 2020 2066  on.            f
-0000d6e0: 6f72 2069 2069 6e20 312e 2e66 6163 746f  or i in 1..facto
-0000d6f0: 7273 2e6c 656e 2829 207b 0a20 2020 2020  rs.len() {.     
-0000d700: 2020 2020 2020 2020 2020 2066 6f72 206a             for j
-0000d710: 2069 6e20 302e 2e6b 207b 0a20 2020 2020   in 0..k {.     
-0000d720: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000d730: 5b69 5d5b 6b5d 203d 2026 705b 695d 5b6b  [i][k] = &p[i][k
-0000d740: 5d20 2b20 2628 2670 5b69 202d 2031 5d5b  ] + &(&p[i - 1][
-0000d750: 6b20 2d20 6a5d 202a 2026 755b 695d 5b6a  k - j] * &u[i][j
-0000d760: 5d29 3b0a 2020 2020 2020 2020 2020 2020  ]);.            
-0000d770: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-0000d780: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-0000d790: 202f 2f20 6669 6e64 2074 6865 206b 7468   // find the kth
-0000d7a0: 2070 6f77 6572 206f 6620 7920 696e 2066   power of y in f
-0000d7b0: 0a20 2020 2020 2020 2020 2020 202f 2f20  .            // 
-0000d7c0: 7369 6e63 6520 7765 2063 6f6d 7075 7465  since we compute
-0000d7d0: 2074 6865 2065 7272 6f72 2070 6572 2070   the error per p
-0000d7e0: 6f77 6572 206f 6620 792c 2077 6520 6361  ower of y, we ca
-0000d7f0: 6e6e 6f74 2073 746f 7020 6f6e 2061 2030  nnot stop on a 0
-0000d800: 2065 7272 6f72 0a20 2020 2020 2020 2020   error.         
-0000d810: 2020 206c 6574 2065 203d 2069 6620 6c65     let e = if le
-0000d820: 7420 536f 6d65 2828 762c 205f 2929 203d  t Some((v, _)) =
-0000d830: 2079 5f70 6f6c 792e 6974 6572 2829 2e66   y_poly.iter().f
-0000d840: 696e 6428 7c65 7c20 652e 312e 746f 5f75  ind(|e| e.1.to_u
-0000d850: 3332 2829 2061 7320 7573 697a 6520 3d3d  32() as usize ==
-0000d860: 206b 2920 7b0a 2020 2020 2020 2020 2020   k) {.          
-0000d870: 2020 2020 2020 7620 2d20 2670 2e6c 6173        v - &p.las
-0000d880: 7428 292e 756e 7772 6170 2829 5b6b 5d0a  t().unwrap()[k].
-0000d890: 2020 2020 2020 2020 2020 2020 7d20 656c              } el
-0000d8a0: 7365 207b 0a20 2020 2020 2020 2020 2020  se {.           
-0000d8b0: 2020 2020 202d 702e 6c61 7374 2829 2e75       -p.last().u
-0000d8c0: 6e77 7261 7028 295b 6b5d 2e63 6c6f 6e65  nwrap()[k].clone
-0000d8d0: 2829 0a20 2020 2020 2020 2020 2020 207d  ().            }
-0000d8e0: 3b0a 0a20 2020 2020 2020 2020 2020 2064  ;..            d
-0000d8f0: 6562 7567 2128 2268 656e 7365 6c20 655b  ebug!("hensel e[
-0000d900: 787b 7d5e 7b7d 5d20 3d20 7b7d 222c 206c  x{}^{}] = {}", l
-0000d910: 6173 745f 7661 722c 206b 2c20 6529 3b0a  ast_var, k, e);.
-0000d920: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000d930: 652e 6973 5f7a 6572 6f28 2920 7b0a 2020  e.is_zero() {.  
-0000d940: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0000d950: 6e74 696e 7565 3b0a 2020 2020 2020 2020  ntinue;.        
-0000d960: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
-0000d970: 2020 206c 6574 206e 6577 5f64 656c 7461     let new_delta
-0000d980: 203d 2053 656c 663a 3a6d 756c 7469 7661   = Self::multiva
-0000d990: 7269 6174 655f 6469 6f70 6861 6e74 696e  riate_diophantin
-0000d9a0: 6528 0a20 2020 2020 2020 2020 2020 2020  e(.             
-0000d9b0: 2020 2075 6e69 7661 7269 6174 655f 6465     univariate_de
-0000d9c0: 6c74 6173 2c0a 2020 2020 2020 2020 2020  ltas,.          
-0000d9d0: 2020 2020 2020 756e 6976 6172 6961 7465        univariate
-0000d9e0: 5f66 6163 746f 7273 2c0a 2020 2020 2020  _factors,.      
-0000d9f0: 2020 2020 2020 2020 2020 2670 726f 645f            &prod_
-0000da00: 6d6f 642c 0a20 2020 2020 2020 2020 2020  mod,.           
-0000da10: 2020 2020 2026 652c 0a20 2020 2020 2020       &e,.       
-0000da20: 2020 2020 2020 2020 2026 6f72 6465 725b           &order[
-0000da30: 2e2e 6f72 6465 722e 6c65 6e28 2920 2d20  ..order.len() - 
-0000da40: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
-0000da50: 2020 2020 7361 6d70 6c65 5f70 6f69 6e74      sample_point
-0000da60: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
-0000da70: 2020 2026 6465 6772 6565 735b 2e2e 6f72     &degrees[..or
-0000da80: 6465 722e 6c65 6e28 2920 2d20 315d 2c0a  der.len() - 1],.
-0000da90: 2020 2020 2020 2020 2020 2020 293b 0a0a              );..
-0000daa0: 2020 2020 2020 2020 2020 2020 2f2f 2075              // u
-0000dab0: 7064 6174 6520 7468 6520 636f 6566 6669  pdate the coeffi
-0000dac0: 6369 656e 7473 2077 6974 6820 7468 6520  cients with the 
-0000dad0: 6e65 7720 795e 6b20 636f 6e74 7269 6275  new y^k contribu
-0000dae0: 7469 6f6e 730a 2020 2020 2020 2020 2020  tions.          
-0000daf0: 2020 6c65 7420 6d75 7420 7420 3d20 7365    let mut t = se
-0000db00: 6c66 2e7a 6572 6f28 293b 0a0a 2020 2020  lf.zero();..    
-0000db10: 2020 2020 2020 2020 666f 7220 2869 2c20          for (i, 
-0000db20: 2864 752c 2064 2929 2069 6e20 752e 6974  (du, d)) in u.it
-0000db30: 6572 5f6d 7574 2829 2e7a 6970 2826 6e65  er_mut().zip(&ne
-0000db40: 775f 6465 6c74 6129 2e65 6e75 6d65 7261  w_delta).enumera
-0000db50: 7465 2829 207b 0a20 2020 2020 2020 2020  te() {.         
-0000db60: 2020 2020 2020 2064 6562 7567 2128 2268         debug!("h
-0000db70: 656e 7365 6c20 645b 787b 7d5e 7b7d 5d20  ensel d[x{}^{}] 
-0000db80: 3d20 7b7d 222c 206c 6173 745f 7661 722c  = {}", last_var,
-0000db90: 206b 2c20 6429 3b0a 2020 2020 2020 2020   k, d);.        
-0000dba0: 2020 2020 2020 2020 6475 5b6b 5d20 3d20          du[k] = 
-0000dbb0: 2664 755b 6b5d 202b 2064 3b0a 0a20 2020  &du[k] + d;..   
-0000dbc0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000dbd0: 6920 3e20 3020 7b0a 2020 2020 2020 2020  i > 0 {.        
-0000dbe0: 2020 2020 2020 2020 2020 2020 7420 3d20              t = 
-0000dbf0: 2664 755b 305d 202a 2026 7420 2b20 6420  &du[0] * &t + d 
-0000dc00: 2a20 2670 5b69 202d 2031 5d5b 305d 3b0a  * &p[i - 1][0];.
-0000dc10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc20: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
-0000dc30: 2020 2020 2020 2020 2020 2020 2074 203d               t =
-0000dc40: 2026 7420 2b20 643b 0a20 2020 2020 2020   &t + d;.       
-0000dc50: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
-0000dc60: 2020 2020 2020 2020 2020 2020 705b 695d              p[i]
-0000dc70: 5b6b 5d20 3d20 2670 5b69 5d5b 6b5d 202b  [k] = &p[i][k] +
-0000dc80: 2026 743b 0a20 2020 2020 2020 2020 2020   &t;.           
-0000dc90: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
-0000dca0: 2020 2020 2020 2f2f 2063 6f6e 7665 7274        // convert
-0000dcb0: 2064 656e 7365 2070 6f6c 796e 6f6d 6961   dense polynomia
-0000dcc0: 6c73 2074 6f20 6d75 6c74 6976 6172 6961  ls to multivaria
-0000dcd0: 7465 2070 6f6c 796e 6f6d 6961 6c73 0a20  te polynomials. 
-0000dce0: 2020 2020 2020 2075 2e69 6e74 6f5f 6974         u.into_it
-0000dcf0: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
-0000dd00: 202e 6d61 7028 7c74 737c 207b 0a20 2020   .map(|ts| {.   
-0000dd10: 2020 2020 2020 2020 2020 2020 206c 6574               let
-0000dd20: 206d 7574 206e 6577 5f70 6f6c 7920 3d20   mut new_poly = 
-0000dd30: 7365 6c66 2e7a 6572 6f5f 7769 7468 5f63  self.zero_with_c
-0000dd40: 6170 6163 6974 7928 7473 2e6c 656e 2829  apacity(ts.len()
-0000dd50: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000dd60: 2020 2066 6f72 2028 692c 206d 7574 2066     for (i, mut f
-0000dd70: 2920 696e 2074 732e 696e 746f 5f69 7465  ) in ts.into_ite
-0000dd80: 7228 292e 656e 756d 6572 6174 6528 2920  r().enumerate() 
-0000dd90: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000dda0: 2020 2020 2020 666f 7220 7820 696e 2066        for x in f
-0000ddb0: 2e65 7870 6f6e 656e 7473 2e63 6875 6e6b  .exponents.chunk
-0000ddc0: 735f 6d75 7428 662e 6e76 6172 7329 207b  s_mut(f.nvars) {
-0000ddd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dde0: 2020 2020 2020 2020 2064 6562 7567 5f61           debug_a
-0000ddf0: 7373 6572 745f 6571 2128 785b 6c61 7374  ssert_eq!(x[last
-0000de00: 5f76 6172 5d2c 2045 3a3a 7a65 726f 2829  _var], E::zero()
-0000de10: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000de20: 2020 2020 2020 2020 2020 2078 5b6c 6173             x[las
-0000de30: 745f 7661 725d 203d 2045 3a3a 6672 6f6d  t_var] = E::from
-0000de40: 5f75 3332 2869 2061 7320 7533 3229 3b0a  _u32(i as u32);.
-0000de50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de60: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-0000de70: 2020 2020 2020 2020 2020 6e65 775f 706f            new_po
-0000de80: 6c79 203d 206e 6577 5f70 6f6c 7920 2b20  ly = new_poly + 
-0000de90: 663b 0a20 2020 2020 2020 2020 2020 2020  f;.             
-0000dea0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-0000deb0: 2020 2020 206e 6577 5f70 6f6c 790a 2020       new_poly.  
-0000dec0: 2020 2020 2020 2020 2020 7d29 0a20 2020            }).   
-0000ded0: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-0000dee0: 7428 290a 2020 2020 7d0a 7d0a 0a69 6d70  t().    }.}..imp
-0000def0: 6c3c 453a 2045 7870 6f6e 656e 743e 204d  l<E: Exponent> M
-0000df00: 756c 7469 7661 7269 6174 6550 6f6c 796e  ultivariatePolyn
-0000df10: 6f6d 6961 6c3c 496e 7465 6765 7252 696e  omial<IntegerRin
-0000df20: 672c 2045 2c20 4c65 784f 7264 6572 3e20  g, E, LexOrder> 
-0000df30: 7b0a 2020 2020 2f2f 2f20 4865 6e73 656c  {.    /// Hensel
-0000df40: 206c 6966 7420 6120 736f 6c75 7469 6f6e   lift a solution
-0000df50: 206f 6620 6073 656c 6620 3d20 7520 2a20   of `self = u * 
-0000df60: 7720 6d6f 6420 7060 2074 6f20 6073 656c  w mod p` to `sel
-0000df70: 6620 3d20 7520 2a20 7720 6d6f 6420 6d61  f = u * w mod ma
-0000df80: 785f 7060 0a20 2020 202f 2f2f 2077 6865  x_p`.    /// whe
-0000df90: 7265 2060 6d61 785f 7060 2069 7320 6120  re `max_p` is a 
-0000dfa0: 706f 7765 7220 6f66 2060 7060 2e0a 2020  power of `p`..  
-0000dfb0: 2020 2f2f 2f0a 2020 2020 2f2f 2f20 4966    ///.    /// If
-0000dfc0: 2074 6865 206c 6966 7469 6e67 2069 7320   the lifting is 
-0000dfd0: 7375 6363 6573 7366 756c 2c20 692e 652e  successful, i.e.
-0000dfe0: 2074 6865 2065 7272 6f72 2069 7320 3020   the error is 0 
-0000dff0: 6174 2073 6f6d 6520 7374 6167 652c 0a20  at some stage,. 
-0000e000: 2020 202f 2f2f 2069 7420 7769 6c6c 2072     /// it will r
-0000e010: 6574 7572 6e20 604f 6b28 2875 2c77 2929  eturn `Ok((u,w))
-0000e020: 6020 7768 6572 6520 6075 6020 616e 6420  ` where `u` and 
-0000e030: 6077 6020 6172 6520 7468 6520 7472 7565  `w` are the true
-0000e040: 2066 6163 746f 7273 206f 7665 720a 2020   factors over.  
-0000e050: 2020 2f2f 2f20 7468 6520 696e 7465 6765    /// the intege
-0000e060: 7273 2e20 4966 2061 2074 7275 6520 6661  rs. If a true fa
-0000e070: 6374 6f72 697a 6174 696f 6e20 6973 206e  ctorization is n
-0000e080: 6f74 2070 6f73 7369 626c 652c 2069 7420  ot possible, it 
-0000e090: 7265 7475 726e 730a 2020 2020 2f2f 2f20  returns.    /// 
-0000e0a0: 6045 7272 2828 752c 7729 2960 2077 6865  `Err((u,w))` whe
-0000e0b0: 7265 2060 7560 2061 6e64 2060 7760 2061  re `u` and `w` a
-0000e0c0: 7265 206d 6f6e 6963 2e0a 2020 2020 7075  re monic..    pu
-0000e0d0: 6220 666e 2068 656e 7365 6c5f 6c69 6674  b fn hensel_lift
-0000e0e0: 3c55 4669 656c 643a 2046 696e 6974 6546  <UField: FiniteF
-0000e0f0: 6965 6c64 576f 726b 7370 6163 653e 280a  ieldWorkspace>(.
-0000e100: 2020 2020 2020 2020 2673 656c 662c 0a20          &self,. 
-0000e110: 2020 2020 2020 206d 7574 2075 3a20 4d75         mut u: Mu
-0000e120: 6c74 6976 6172 6961 7465 506f 6c79 6e6f  ltivariatePolyno
-0000e130: 6d69 616c 3c46 696e 6974 6546 6965 6c64  mial<FiniteField
-0000e140: 3c55 4669 656c 643e 2c20 452c 204c 6578  <UField>, E, Lex
-0000e150: 4f72 6465 723e 2c0a 2020 2020 2020 2020  Order>,.        
-0000e160: 6d75 7420 773a 204d 756c 7469 7661 7269  mut w: Multivari
-0000e170: 6174 6550 6f6c 796e 6f6d 6961 6c3c 4669  atePolynomial<Fi
-0000e180: 6e69 7465 4669 656c 643c 5546 6965 6c64  niteField<UField
-0000e190: 3e2c 2045 2c20 4c65 784f 7264 6572 3e2c  >, E, LexOrder>,
-0000e1a0: 0a20 2020 2020 2020 2067 616d 6d61 3a20  .        gamma: 
-0000e1b0: 4f70 7469 6f6e 3c49 6e74 6567 6572 3e2c  Option<Integer>,
-0000e1c0: 0a20 2020 2020 2020 206d 6178 5f70 3a20  .        max_p: 
-0000e1d0: 2649 6e74 6567 6572 2c0a 2020 2020 2920  &Integer,.    ) 
-0000e1e0: 2d3e 2052 6573 756c 743c 2853 656c 662c  -> Result<(Self,
-0000e1f0: 2053 656c 6629 2c20 2853 656c 662c 2053   Self), (Self, S
-0000e200: 656c 6629 3e0a 2020 2020 7768 6572 650a  elf)>.    where.
-0000e210: 2020 2020 2020 2020 4669 6e69 7465 4669          FiniteFi
-0000e220: 656c 643c 5546 6965 6c64 3e3a 2046 6965  eld<UField>: Fie
-0000e230: 6c64 202b 2050 6f6c 796e 6f6d 6961 6c47  ld + PolynomialG
-0000e240: 4344 3c45 3e20 2b20 4669 6e69 7465 4669  CD<E> + FiniteFi
-0000e250: 656c 6443 6f72 653c 5546 6965 6c64 3e2c  eldCore<UField>,
-0000e260: 0a20 2020 2020 2020 2049 6e74 6567 6572  .        Integer
-0000e270: 3a20 546f 4669 6e69 7465 4669 656c 643c  : ToFiniteField<
-0000e280: 5546 6965 6c64 3e2c 0a20 2020 207b 0a20  UField>,.    {. 
-0000e290: 2020 2020 2020 206c 6574 206c 636f 6566         let lcoef
-0000e2a0: 6620 3d20 7365 6c66 2e6c 636f 6566 6628  f = self.lcoeff(
-0000e2b0: 293b 202f 2f20 6c63 6f65 6666 2025 2070  ); // lcoeff % p
-0000e2c0: 2021 3d20 300a 2020 2020 2020 2020 6c65   != 0.        le
-0000e2d0: 7420 6d75 7420 6761 6d6d 6120 3d20 6761  t mut gamma = ga
-0000e2e0: 6d6d 612e 756e 7772 6170 5f6f 7228 6c63  mma.unwrap_or(lc
-0000e2f0: 6f65 6666 2e63 6c6f 6e65 2829 293b 0a20  oeff.clone());. 
-0000e300: 2020 2020 2020 206c 6574 206c 636f 6566         let lcoef
-0000e310: 665f 7020 3d20 6c63 6f65 6666 2e74 6f5f  f_p = lcoeff.to_
-0000e320: 6669 6e69 7465 5f66 6965 6c64 2826 752e  finite_field(&u.
-0000e330: 6669 656c 6429 3b0a 2020 2020 2020 2020  field);.        
-0000e340: 6c65 7420 6761 6d6d 615f 7020 3d20 6761  let gamma_p = ga
-0000e350: 6d6d 612e 746f 5f66 696e 6974 655f 6669  mma.to_finite_fi
-0000e360: 656c 6428 2675 2e66 6965 6c64 293b 0a20  eld(&u.field);. 
-0000e370: 2020 2020 2020 206c 6574 2066 6965 6c64         let field
-0000e380: 203d 2075 2e66 6965 6c64 2e63 6c6f 6e65   = u.field.clone
-0000e390: 2829 3b0a 2020 2020 2020 2020 6c65 7420  ();.        let 
-0000e3a0: 7020 3d20 496e 7465 6765 723a 3a66 726f  p = Integer::fro
-0000e3b0: 6d28 6669 656c 642e 6765 745f 7072 696d  m(field.get_prim
-0000e3c0: 6528 292e 746f 5f75 3634 2829 293b 0a0a  e().to_u64());..
-0000e3d0: 2020 2020 2020 2020 6c65 7420 6120 3d20          let a = 
-0000e3e0: 7365 6c66 2e63 6c6f 6e65 2829 2e6d 756c  self.clone().mul
-0000e3f0: 5f63 6f65 6666 2867 616d 6d61 2e63 6c6f  _coeff(gamma.clo
-0000e400: 6e65 2829 293b 0a0a 2020 2020 2020 2020  ne());..        
-0000e410: 7520 3d20 752e 6d61 6b65 5f6d 6f6e 6963  u = u.make_monic
-0000e420: 2829 2e6d 756c 5f63 6f65 6666 2867 616d  ().mul_coeff(gam
-0000e430: 6d61 5f70 2e63 6c6f 6e65 2829 293b 0a20  ma_p.clone());. 
-0000e440: 2020 2020 2020 2077 203d 2077 2e6d 616b         w = w.mak
-0000e450: 655f 6d6f 6e69 6328 292e 6d75 6c5f 636f  e_monic().mul_co
-0000e460: 6566 6628 6c63 6f65 6666 5f70 2e63 6c6f  eff(lcoeff_p.clo
-0000e470: 6e65 2829 293b 0a0a 2020 2020 2020 2020  ne());..        
-0000e480: 6c65 7420 285f 2c20 732c 2074 2920 3d20  let (_, s, t) = 
-0000e490: 752e 6565 615f 756e 6976 6172 6961 7465  u.eea_univariate
-0000e4a0: 2826 7729 3b0a 0a20 2020 2020 2020 2064  (&w);..        d
-0000e4b0: 6562 7567 5f61 7373 6572 7421 2828 2673  ebug_assert!((&s
-0000e4c0: 202a 2026 7520 2b20 2674 202a 2026 7729   * &u + &t * &w)
-0000e4d0: 2e69 735f 6f6e 6528 2929 3b0a 0a20 2020  .is_one());..   
-0000e4e0: 2020 2020 206c 6574 206d 7574 2075 5f69       let mut u_i
-0000e4f0: 203d 2075 2e6d 6170 5f63 6f65 6666 287c   = u.map_coeff(|
-0000e500: 637c 2066 6965 6c64 2e74 6f5f 7379 6d6d  c| field.to_symm
-0000e510: 6574 7269 635f 696e 7465 6765 7228 6329  etric_integer(c)
-0000e520: 2c20 496e 7465 6765 7252 696e 673a 3a6e  , IntegerRing::n
-0000e530: 6577 2829 293b 0a20 2020 2020 2020 206c  ew());.        l
-0000e540: 6574 206d 7574 2077 5f69 203d 2077 2e6d  et mut w_i = w.m
-0000e550: 6170 5f63 6f65 6666 287c 637c 2066 6965  ap_coeff(|c| fie
-0000e560: 6c64 2e74 6f5f 7379 6d6d 6574 7269 635f  ld.to_symmetric_
-0000e570: 696e 7465 6765 7228 6329 2c20 496e 7465  integer(c), Inte
-0000e580: 6765 7252 696e 673a 3a6e 6577 2829 293b  gerRing::new());
-0000e590: 0a0a 2020 2020 2020 2020 2f2f 206f 6e6c  ..        // onl
-0000e5a0: 7920 7265 706c 6163 6520 7468 6520 6c65  y replace the le
-0000e5b0: 6164 696e 6720 636f 6566 6669 6369 656e  ading coefficien
-0000e5c0: 740a 2020 2020 2020 2020 2a75 5f69 2e63  t.        *u_i.c
-0000e5d0: 6f65 6666 6963 6965 6e74 732e 6c61 7374  oefficients.last
-0000e5e0: 5f6d 7574 2829 2e75 6e77 7261 7028 2920  _mut().unwrap() 
-0000e5f0: 3d20 6761 6d6d 612e 636c 6f6e 6528 293b  = gamma.clone();
-0000e600: 0a20 2020 2020 2020 202a 775f 692e 636f  .        *w_i.co
-0000e610: 6566 6669 6369 656e 7473 2e6c 6173 745f  efficients.last_
-0000e620: 6d75 7428 292e 756e 7772 6170 2829 203d  mut().unwrap() =
-0000e630: 206c 636f 6566 663b 0a0a 2020 2020 2020   lcoeff;..      
-0000e640: 2020 6c65 7420 6d75 7420 6520 3d20 2661    let mut e = &a
-0000e650: 202d 2026 2826 755f 6920 2a20 2677 5f69   - &(&u_i * &w_i
-0000e660: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
-0000e670: 6d75 7420 6d20 3d20 702e 636c 6f6e 6528  mut m = p.clone(
-0000e680: 293b 0a0a 2020 2020 2020 2020 7768 696c  );..        whil
-0000e690: 6520 2165 2e69 735f 7a65 726f 2829 2026  e !e.is_zero() &
-0000e6a0: 2620 266d 203c 3d20 6d61 785f 7020 7b0a  & &m <= max_p {.
-0000e6b0: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-0000e6c0: 655f 7020 3d20 652e 6d61 705f 636f 6566  e_p = e.map_coef
-0000e6d0: 6628 7c63 7c20 2863 202f 2026 6d29 2e74  f(|c| (c / &m).t
-0000e6e0: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
-0000e6f0: 6669 656c 6429 2c20 6669 656c 642e 636c  field), field.cl
-0000e700: 6f6e 6528 2929 3b0a 2020 2020 2020 2020  one());.        
-0000e710: 2020 2020 6c65 7420 2871 2c20 7229 203d      let (q, r) =
-0000e720: 2028 2665 5f70 202a 2026 7329 2e71 756f   (&e_p * &s).quo
-0000e730: 745f 7265 6d5f 756e 6976 6172 6961 7465  t_rem_univariate
-0000e740: 2826 6d75 7420 7729 3b0a 2020 2020 2020  (&mut w);.      
-0000e750: 2020 2020 2020 6c65 7420 7461 7520 3d20        let tau = 
-0000e760: 2665 5f70 202a 2026 7420 2b20 7120 2a20  &e_p * &t + q * 
-0000e770: 2675 3b0a 0a20 2020 2020 2020 2020 2020  &u;..           
-0000e780: 2075 5f69 203d 2075 5f69 0a20 2020 2020   u_i = u_i.     
-0000e790: 2020 2020 2020 2020 2020 202b 2074 6175             + tau
-0000e7a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e7b0: 2020 2020 202e 6d61 705f 636f 6566 6628       .map_coeff(
-0000e7c0: 7c63 7c20 6669 656c 642e 746f 5f73 796d  |c| field.to_sym
-0000e7d0: 6d65 7472 6963 5f69 6e74 6567 6572 2863  metric_integer(c
-0000e7e0: 292c 2049 6e74 6567 6572 5269 6e67 3a3a  ), IntegerRing::
-0000e7f0: 6e65 7728 2929 0a20 2020 2020 2020 2020  new()).         
-0000e800: 2020 2020 2020 2020 2020 202e 6d75 6c5f             .mul_
-0000e810: 636f 6566 6628 6d2e 636c 6f6e 6528 2929  coeff(m.clone())
-0000e820: 3b0a 2020 2020 2020 2020 2020 2020 775f  ;.            w_
-0000e830: 6920 3d20 775f 690a 2020 2020 2020 2020  i = w_i.        
-0000e840: 2020 2020 2020 2020 2b20 722e 6d61 705f          + r.map_
-0000e850: 636f 6566 6628 7c63 7c20 6669 656c 642e  coeff(|c| field.
-0000e860: 746f 5f73 796d 6d65 7472 6963 5f69 6e74  to_symmetric_int
-0000e870: 6567 6572 2863 292c 2049 6e74 6567 6572  eger(c), Integer
-0000e880: 5269 6e67 3a3a 6e65 7728 2929 0a20 2020  Ring::new()).   
-0000e890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e8a0: 202e 6d75 6c5f 636f 6566 6628 6d2e 636c   .mul_coeff(m.cl
-0000e8b0: 6f6e 6528 2929 3b0a 2020 2020 2020 2020  one());.        
-0000e8c0: 2020 2020 6520 3d20 2661 202d 2026 2826      e = &a - &(&
-0000e8d0: 755f 6920 2a20 2677 5f69 293b 0a0a 2020  u_i * &w_i);..  
-0000e8e0: 2020 2020 2020 2020 2020 6d20 3d20 266d            m = &m
-0000e8f0: 202a 2026 703b 0a20 2020 2020 2020 207d   * &p;.        }
-0000e900: 0a0a 2020 2020 2020 2020 6966 2065 2e69  ..        if e.i
-0000e910: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
-0000e920: 2020 2020 2020 206c 6574 2063 6f6e 7465         let conte
-0000e930: 6e74 203d 2075 5f69 2e63 6f6e 7465 6e74  nt = u_i.content
-0000e940: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-0000e950: 6966 2021 636f 6e74 656e 742e 6973 5f6f  if !content.is_o
-0000e960: 6e65 2829 207b 0a20 2020 2020 2020 2020  ne() {.         
-0000e970: 2020 2020 2020 2075 5f69 203d 2075 5f69         u_i = u_i
-0000e980: 2e64 6976 5f63 6f65 6666 2826 636f 6e74  .div_coeff(&cont
-0000e990: 656e 7429 3b0a 2020 2020 2020 2020 2020  ent);.          
-0000e9a0: 2020 2020 2020 6761 6d6d 6120 3d20 2667        gamma = &g
-0000e9b0: 616d 6d61 202f 2026 636f 6e74 656e 743b  amma / &content;
-0000e9c0: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
-0000e9d0: 2020 2020 2020 2020 2020 2020 6966 2021              if !
-0000e9e0: 6761 6d6d 612e 6973 5f6f 6e65 2829 207b  gamma.is_one() {
-0000e9f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ea00: 2077 5f69 203d 2077 5f69 2e64 6976 5f63   w_i = w_i.div_c
-0000ea10: 6f65 6666 2826 6761 6d6d 6129 3b20 2f2f  oeff(&gamma); //
-0000ea20: 2074 7275 6520 6469 7669 7369 6f6e 2069   true division i
-0000ea30: 7320 706f 7373 6962 6c65 2069 6e20 7468  s possible in th
-0000ea40: 6973 2063 6173 650a 2020 2020 2020 2020  is case.        
-0000ea50: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
-0000ea60: 2020 204f 6b28 2875 5f69 2c20 775f 6929     Ok((u_i, w_i)
-0000ea70: 290a 2020 2020 2020 2020 7d20 656c 7365  ).        } else
-0000ea80: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
-0000ea90: 6620 2175 5f69 2e6c 636f 6566 6628 292e  f !u_i.lcoeff().
-0000eaa0: 6973 5f6f 6e65 2829 207b 0a20 2020 2020  is_one() {.     
-0000eab0: 2020 2020 2020 2020 2020 206c 6574 2069             let i
-0000eac0: 6e76 203d 2075 5f69 2e6c 636f 6566 6628  nv = u_i.lcoeff(
-0000ead0: 292e 6d6f 645f 696e 7665 7273 6528 266d  ).mod_inverse(&m
-0000eae0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000eaf0: 2020 2075 5f69 203d 2075 5f69 2e6d 6170     u_i = u_i.map
-0000eb00: 5f63 6f65 6666 287c 637c 2028 6320 2a20  _coeff(|c| (c * 
-0000eb10: 2669 6e76 292e 7379 6d6d 6574 7269 635f  &inv).symmetric_
-0000eb20: 6d6f 6428 266d 292c 2049 6e74 6567 6572  mod(&m), Integer
-0000eb30: 5269 6e67 3a3a 6e65 7728 2929 3b0a 2020  Ring::new());.  
-0000eb40: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
-0000eb50: 2020 2020 2020 2020 2069 6620 2177 5f69           if !w_i
-0000eb60: 2e6c 636f 6566 6628 292e 6973 5f6f 6e65  .lcoeff().is_one
-0000eb70: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-0000eb80: 2020 2020 206c 6574 2069 6e76 203d 2077       let inv = w
-0000eb90: 5f69 2e6c 636f 6566 6628 292e 6d6f 645f  _i.lcoeff().mod_
-0000eba0: 696e 7665 7273 6528 266d 293b 0a20 2020  inverse(&m);.   
-0000ebb0: 2020 2020 2020 2020 2020 2020 2077 5f69               w_i
-0000ebc0: 203d 2077 5f69 2e6d 6170 5f63 6f65 6666   = w_i.map_coeff
-0000ebd0: 287c 637c 2028 6320 2a20 2669 6e76 292e  (|c| (c * &inv).
-0000ebe0: 7379 6d6d 6574 7269 635f 6d6f 6428 266d  symmetric_mod(&m
-0000ebf0: 292c 2049 6e74 6567 6572 5269 6e67 3a3a  ), IntegerRing::
-0000ec00: 6e65 7728 2929 3b0a 2020 2020 2020 2020  new());.        
-0000ec10: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
-0000ec20: 2020 2045 7272 2828 755f 692c 2077 5f69     Err((u_i, w_i
-0000ec30: 2929 0a20 2020 2020 2020 207d 0a20 2020  )).        }.   
-0000ec40: 207d 0a0a 2020 2020 2f2f 2f20 4c69 6674   }..    /// Lift
-0000ec50: 206d 756c 7469 706c 6520 6661 6374 6f72   multiple factor
-0000ec60: 7320 6279 2063 7265 6174 696e 6720 6120  s by creating a 
-0000ec70: 6269 6e61 7279 2074 7265 6520 616e 6420  binary tree and 
-0000ec80: 6c69 6674 696e 6720 6561 6368 2070 726f  lifting each pro
-0000ec90: 6475 6374 2e0a 2020 2020 666e 206d 756c  duct..    fn mul
-0000eca0: 7469 5f66 6163 746f 725f 6865 6e73 656c  ti_factor_hensel
-0000ecb0: 5f6c 6966 7428 0a20 2020 2020 2020 2026  _lift(.        &
-0000ecc0: 7365 6c66 2c0a 2020 2020 2020 2020 6873  self,.        hs
-0000ecd0: 3a20 265b 4d75 6c74 6976 6172 6961 7465  : &[Multivariate
-0000ece0: 506f 6c79 6e6f 6d69 616c 3c46 696e 6974  Polynomial<Finit
-0000ecf0: 6546 6965 6c64 3c75 3332 3e2c 2045 2c20  eField<u32>, E, 
-0000ed00: 4c65 784f 7264 6572 3e5d 2c0a 2020 2020  LexOrder>],.    
-0000ed10: 2020 2020 6d61 785f 703a 2026 496e 7465      max_p: &Inte
-0000ed20: 6765 722c 0a20 2020 2029 202d 3e20 5665  ger,.    ) -> Ve
-0000ed30: 633c 5365 6c66 3e20 7b0a 2020 2020 2020  c<Self> {.      
-0000ed40: 2020 6966 2068 732e 6c65 6e28 2920 3d3d    if hs.len() ==
-0000ed50: 2031 207b 0a20 2020 2020 2020 2020 2020   1 {.           
-0000ed60: 2069 6620 7365 6c66 2e6c 636f 6566 6628   if self.lcoeff(
-0000ed70: 292e 6973 5f6f 6e65 2829 207b 0a20 2020  ).is_one() {.   
-0000ed80: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000ed90: 7572 6e20 7665 6321 5b73 656c 662e 636c  urn vec![self.cl
-0000eda0: 6f6e 6528 295d 3b0a 2020 2020 2020 2020  one()];.        
-0000edb0: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
-0000edc0: 2020 2020 2020 2020 2020 2020 206c 6574               let
-0000edd0: 2069 6e76 203d 2073 656c 662e 6c63 6f65   inv = self.lcoe
-0000ede0: 6666 2829 2e6d 6f64 5f69 6e76 6572 7365  ff().mod_inverse
-0000edf0: 286d 6178 5f70 293b 0a20 2020 2020 2020  (max_p);.       
-0000ee00: 2020 2020 2020 2020 206c 6574 2072 203d           let r =
-0000ee10: 2073 656c 662e 6d61 705f 636f 6566 6628   self.map_coeff(
-0000ee20: 7c63 7c20 2863 202a 2026 696e 7629 2e73  |c| (c * &inv).s
-0000ee30: 796d 6d65 7472 6963 5f6d 6f64 286d 6178  ymmetric_mod(max
-0000ee40: 5f70 292c 2049 6e74 6567 6572 5269 6e67  _p), IntegerRing
-0000ee50: 3a3a 6e65 7728 2929 3b0a 2020 2020 2020  ::new());.      
-0000ee60: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000ee70: 2076 6563 215b 725d 3b0a 2020 2020 2020   vec![r];.      
-0000ee80: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-0000ee90: 7d0a 0a20 2020 2020 2020 206c 6574 2028  }..        let (
-0000eea0: 6773 2c20 6873 2920 3d20 6873 2e73 706c  gs, hs) = hs.spl
-0000eeb0: 6974 5f61 7428 6873 2e6c 656e 2829 202f  it_at(hs.len() /
-0000eec0: 2032 293b 0a0a 2020 2020 2020 2020 6c65   2);..        le
-0000eed0: 7420 6d75 7420 6720 3d20 6773 5b30 5d2e  t mut g = gs[0].
-0000eee0: 6f6e 6528 293b 0a20 2020 2020 2020 2066  one();.        f
-0000eef0: 6f72 2078 2069 6e20 6773 207b 0a20 2020  or x in gs {.   
-0000ef00: 2020 2020 2020 2020 2067 203d 2067 202a           g = g *
-0000ef10: 2078 3b0a 2020 2020 2020 2020 7d0a 0a20   x;.        }.. 
-0000ef20: 2020 2020 2020 206c 6574 206d 7574 2068         let mut h
-0000ef30: 203d 2068 735b 305d 2e6f 6e65 2829 3b0a   = hs[0].one();.
-0000ef40: 2020 2020 2020 2020 666f 7220 7820 696e          for x in
-0000ef50: 2068 7320 7b0a 2020 2020 2020 2020 2020   hs {.          
-0000ef60: 2020 6820 3d20 6820 2a20 783b 0a20 2020    h = h * x;.   
-0000ef70: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-0000ef80: 6c65 7420 2867 5f69 2c20 685f 6929 203d  let (g_i, h_i) =
-0000ef90: 2073 656c 662e 6865 6e73 656c 5f6c 6966   self.hensel_lif
-0000efa0: 7428 672c 2068 2c20 4e6f 6e65 2c20 6d61  t(g, h, None, ma
-0000efb0: 785f 7029 2e75 6e77 7261 705f 6f72 5f65  x_p).unwrap_or_e
-0000efc0: 6c73 6528 7c65 7c20 6529 3b0a 0a20 2020  lse(|e| e);..   
-0000efd0: 2020 2020 206c 6574 206d 7574 2066 6163       let mut fac
-0000efe0: 746f 7273 203d 2067 5f69 2e6d 756c 7469  tors = g_i.multi
-0000eff0: 5f66 6163 746f 725f 6865 6e73 656c 5f6c  _factor_hensel_l
-0000f000: 6966 7428 6773 2c20 6d61 785f 7029 3b0a  ift(gs, max_p);.
-0000f010: 2020 2020 2020 2020 6661 6374 6f72 732e          factors.
-0000f020: 6578 7465 6e64 2868 5f69 2e6d 756c 7469  extend(h_i.multi
-0000f030: 5f66 6163 746f 725f 6865 6e73 656c 5f6c  _factor_hensel_l
-0000f040: 6966 7428 6873 2c20 6d61 785f 7029 293b  ift(hs, max_p));
-0000f050: 0a20 2020 2020 2020 2066 6163 746f 7273  .        factors
-0000f060: 0a20 2020 207d 0a0a 2020 2020 2f2f 2f20  .    }..    /// 
-0000f070: 4661 6374 6f72 2061 2073 7175 6172 652d  Factor a square-
-0000f080: 6672 6565 2075 6e69 7661 7269 6174 6520  free univariate 
-0000f090: 706f 6c79 6e6f 6d69 616c 206f 7665 7220  polynomial over 
-0000f0a0: 7468 6520 696e 7465 6765 7273 2062 7920  the integers by 
-0000f0b0: 4865 6e73 656c 206c 6966 7469 6e67 2066  Hensel lifting f
-0000f0c0: 6163 746f 7273 2063 6f6d 7075 7465 6420  actors computed 
-0000f0d0: 6f76 6572 0a20 2020 202f 2f2f 2061 2066  over.    /// a f
-0000f0e0: 696e 6974 6520 6669 656c 6420 696d 6167  inite field imag
-0000f0f0: 6520 6f66 2074 6865 2070 6f6c 796e 6f6d  e of the polynom
-0000f100: 6961 6c2e 0a20 2020 2066 6e20 6661 6374  ial..    fn fact
-0000f110: 6f72 5f72 6563 6f6e 7374 7275 6374 2826  or_reconstruct(&
-0000f120: 7365 6c66 2920 2d3e 2056 6563 3c53 656c  self) -> Vec<Sel
-0000f130: 663e 207b 0a20 2020 2020 2020 206c 6574  f> {.        let
-0000f140: 2053 6f6d 6528 7661 7229 203d 2073 656c   Some(var) = sel
-0000f150: 662e 6c61 7374 5f65 7870 6f6e 656e 7473  f.last_exponents
-0000f160: 2829 2e69 7465 7228 292e 706f 7369 7469  ().iter().positi
-0000f170: 6f6e 287c 787c 202a 7820 3e20 453a 3a7a  on(|x| *x > E::z
-0000f180: 6572 6f28 2929 2065 6c73 6520 7b0a 2020  ero()) else {.  
-0000f190: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000f1a0: 2076 6563 215b 7365 6c66 2e63 6c6f 6e65   vec![self.clone
-0000f1b0: 2829 5d3b 202f 2f20 636f 6e73 7461 6e74  ()]; // constant
-0000f1c0: 2070 6f6c 796e 6f6d 6961 6c0a 2020 2020   polynomial.    
-0000f1d0: 2020 2020 7d3b 0a20 2020 2020 2020 206c      };.        l
-0000f1e0: 6574 2064 203d 2073 656c 662e 6465 6772  et d = self.degr
-0000f1f0: 6565 2876 6172 292e 746f 5f75 3332 2829  ee(var).to_u32()
-0000f200: 3b0a 0a20 2020 2020 2020 2069 6620 6420  ;..        if d 
-0000f210: 3d3d 2031 207b 0a20 2020 2020 2020 2020  == 1 {.         
-0000f220: 2020 2072 6574 7572 6e20 7665 6321 5b73     return vec![s
-0000f230: 656c 662e 636c 6f6e 6528 295d 3b0a 2020  elf.clone()];.  
-0000f240: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-0000f250: 202f 2f20 7365 6c65 6374 2061 2073 7569   // select a sui
-0000f260: 7461 626c 6520 7072 696d 650a 2020 2020  table prime.    
-0000f270: 2020 2020 2f2f 2077 6520 7472 7920 736d      // we try sm
-0000f280: 616c 6c20 7072 696d 6573 2066 6972 7374  all primes first
-0000f290: 2061 7320 7468 6520 6469 7374 696e 6374   as the distinct
-0000f2a0: 2061 6e64 2065 7175 616c 2064 6567 7265   and equal degre
-0000f2b0: 6520 616c 676f 7269 7468 6d73 0a20 2020  e algorithms.   
-0000f2c0: 2020 2020 202f 2f20 7363 616c 6520 6173       // scale as
-0000f2d0: 206c 6f67 2870 290a 2020 2020 2020 2020   log(p).        
-0000f2e0: 6c65 7420 6d75 7420 6669 656c 643b 0a20  let mut field;. 
-0000f2f0: 2020 2020 2020 206c 6574 206d 7574 2066         let mut f
-0000f300: 5f70 3b0a 2020 2020 2020 2020 6c65 7420  _p;.        let 
-0000f310: 6d75 7420 7069 203d 2050 7269 6d65 4974  mut pi = PrimeIt
-0000f320: 6572 6174 6f72 5536 343a 3a6e 6577 2831  eratorU64::new(1
-0000f330: 3031 293b 0a20 2020 2020 2020 206c 6f6f  01);.        loo
-0000f340: 7020 7b0a 2020 2020 2020 2020 2020 2020  p {.            
-0000f350: 6c65 7420 7020 3d20 7069 2e6e 6578 7428  let p = pi.next(
-0000f360: 292e 756e 7772 6170 2829 3b0a 2020 2020  ).unwrap();.    
-0000f370: 2020 2020 2020 2020 6966 2070 203e 2075          if p > u
-0000f380: 3332 3a3a 4d41 5820 6173 2075 3634 207b  32::MAX as u64 {
-0000f390: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f3a0: 2070 616e 6963 2128 2252 616e 206f 7574   panic!("Ran out
-0000f3b0: 206f 6620 7072 696d 6573 2064 7572 696e   of primes durin
-0000f3c0: 6720 6661 6374 6f72 697a 6174 696f 6e20  g factorization 
-0000f3d0: 6f66 207b 7d22 2c20 7365 6c66 293b 0a20  of {}", self);. 
-0000f3e0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-0000f3f0: 2020 2020 2020 2020 206c 6574 2070 203d           let p =
-0000f400: 2070 2061 7320 7533 323b 0a0a 2020 2020   p as u32;..    
-0000f410: 2020 2020 2020 2020 6966 2028 2673 656c          if (&sel
-0000f420: 662e 6c63 6f65 6666 2829 2025 2026 496e  f.lcoeff() % &In
-0000f430: 7465 6765 723a 3a4e 6174 7572 616c 2870  teger::Natural(p
-0000f440: 2061 7320 6936 3429 292e 6973 5f7a 6572   as i64)).is_zer
-0000f450: 6f28 2920 7b0a 2020 2020 2020 2020 2020  o() {.          
-0000f460: 2020 2020 2020 636f 6e74 696e 7565 3b0a        continue;.
-0000f470: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
-0000f480: 2020 2020 2020 2020 2020 2066 6965 6c64             field
-0000f490: 203d 2046 696e 6974 6546 6965 6c64 3a3a   = FiniteField::
-0000f4a0: 3c75 3332 3e3a 3a6e 6577 2870 293b 0a20  <u32>::new(p);. 
-0000f4b0: 2020 2020 2020 2020 2020 2066 5f70 203d             f_p =
-0000f4c0: 2073 656c 662e 6d61 705f 636f 6566 6628   self.map_coeff(
-0000f4d0: 7c66 7c20 662e 746f 5f66 696e 6974 655f  |f| f.to_finite_
-0000f4e0: 6669 656c 6428 2666 6965 6c64 292c 2066  field(&field), f
-0000f4f0: 6965 6c64 2e63 6c6f 6e65 2829 293b 0a20  ield.clone());. 
-0000f500: 2020 2020 2020 2020 2020 206c 6574 2064             let d
-0000f510: 665f 7020 3d20 665f 702e 6465 7269 7661  f_p = f_p.deriva
-0000f520: 7469 7665 2876 6172 293b 0a0a 2020 2020  tive(var);..    
-0000f530: 2020 2020 2020 2020 2f2f 2063 6865 636b          // check
-0000f540: 2069 7320 665f 7020 7265 6d61 696e 7320   is f_p remains 
-0000f550: 7371 7561 7265 2d66 7265 650a 2020 2020  square-free.    
-0000f560: 2020 2020 2020 2020 6966 2066 5f70 2e67          if f_p.g
-0000f570: 6364 2826 6466 5f70 292e 6973 5f6f 6e65  cd(&df_p).is_one
-0000f580: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-0000f590: 2020 2020 2062 7265 616b 3b0a 2020 2020       break;.    
-0000f5a0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-0000f5b0: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
-0000f5c0: 2068 733a 2056 6563 3c5f 3e20 3d20 665f   hs: Vec<_> = f_
-0000f5d0: 702e 6661 6374 6f72 5f64 6973 7469 6e63  p.factor_distinc
-0000f5e0: 745f 6571 7561 6c5f 6465 6772 6565 2829  t_equal_degree()
-0000f5f0: 3b0a 0a20 2020 2020 2020 2069 6620 6873  ;..        if hs
-0000f600: 2e6c 656e 2829 203d 3d20 3120 7b0a 2020  .len() == 1 {.  
-0000f610: 2020 2020 2020 2020 2020 2f2f 2074 6865            // the
-0000f620: 2070 6f6c 796e 6f6d 6961 6c20 6973 2069   polynomial is i
-0000f630: 7272 6564 7563 6962 6c65 0a20 2020 2020  rreducible.     
-0000f640: 2020 2020 2020 2072 6574 7572 6e20 7665         return ve
-0000f650: 6321 5b73 656c 662e 636c 6f6e 6528 295d  c![self.clone()]
-0000f660: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
-0000f670: 2020 2020 206c 6574 2062 6f75 6e64 203d       let bound =
-0000f680: 2073 656c 662e 636f 6566 6669 6369 656e   self.coefficien
-0000f690: 745f 626f 756e 6428 293b 0a20 2020 2020  t_bound();.     
-0000f6a0: 2020 206c 6574 2070 3a20 496e 7465 6765     let p: Intege
-0000f6b0: 7220 3d20 2866 6965 6c64 2e67 6574 5f70  r = (field.get_p
-0000f6c0: 7269 6d65 2829 2e74 6f5f 7533 3228 2920  rime().to_u32() 
-0000f6d0: 6173 2069 3634 292e 696e 746f 2829 3b0a  as i64).into();.
-0000f6e0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-0000f6f0: 6d61 785f 7020 3d20 702e 636c 6f6e 6528  max_p = p.clone(
-0000f700: 293b 0a20 2020 2020 2020 2077 6869 6c65  );.        while
-0000f710: 206d 6178 5f70 203c 2062 6f75 6e64 207b   max_p < bound {
-0000f720: 0a20 2020 2020 2020 2020 2020 206d 6178  .            max
-0000f730: 5f70 203d 2026 6d61 785f 7020 2a20 2670  _p = &max_p * &p
-0000f740: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
-0000f750: 2020 2020 206c 6574 206d 7574 2066 6163       let mut fac
-0000f760: 746f 7273 203d 2073 656c 662e 6d75 6c74  tors = self.mult
-0000f770: 695f 6661 6374 6f72 5f68 656e 7365 6c5f  i_factor_hensel_
-0000f780: 6c69 6674 2826 6873 2c20 266d 6178 5f70  lift(&hs, &max_p
-0000f790: 293b 0a0a 2020 2020 2020 2020 235b 6366  );..        #[cf
-0000f7a0: 6728 6465 6275 675f 6173 7365 7274 696f  g(debug_assertio
-0000f7b0: 6e73 295d 0a20 2020 2020 2020 2066 6f72  ns)].        for
-0000f7c0: 2028 682c 2068 5f70 2920 696e 2066 6163   (h, h_p) in fac
-0000f7d0: 746f 7273 2e69 7465 7228 292e 7a69 7028  tors.iter().zip(
-0000f7e0: 2668 7329 207b 0a20 2020 2020 2020 2020  &hs) {.         
-0000f7f0: 2020 206c 6574 2068 685f 7020 3d20 680a     let hh_p = h.
-0000f800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f810: 2e6d 6170 5f63 6f65 6666 287c 637c 2063  .map_coeff(|c| c
-0000f820: 2e74 6f5f 6669 6e69 7465 5f66 6965 6c64  .to_finite_field
-0000f830: 2826 6669 656c 6429 2c20 6669 656c 642e  (&field), field.
-0000f840: 636c 6f6e 6528 2929 0a20 2020 2020 2020  clone()).       
-0000f850: 2020 2020 2020 2020 202e 6d61 6b65 5f6d           .make_m
-0000f860: 6f6e 6963 2829 3b0a 2020 2020 2020 2020  onic();.        
-0000f870: 2020 2020 6966 2026 6868 5f70 2021 3d20      if &hh_p != 
-0000f880: 685f 7020 7b0a 2020 2020 2020 2020 2020  h_p {.          
-0000f890: 2020 2020 2020 7061 6e69 6321 2822 4d69        panic!("Mi
-0000f8a0: 736d 6174 6368 206f 6620 6c69 6674 6564  smatch of lifted
-0000f8b0: 2066 6163 746f 723a 207b 7d20 7673 207b   factor: {} vs {
-0000f8c0: 7d20 696e 207b 7d22 2c20 6868 5f70 2c20  } in {}", hh_p, 
-0000f8d0: 685f 702c 2073 656c 6629 3b0a 2020 2020  h_p, self);.    
-0000f8e0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-0000f8f0: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
-0000f900: 206d 7574 2072 6563 5f66 6163 746f 7273   mut rec_factors
-0000f910: 203d 2076 6563 215b 5d3b 0a20 2020 2020   = vec![];.     
-0000f920: 2020 202f 2f20 6661 6374 6f72 2072 6563     // factor rec
-0000f930: 6f6d 6269 6e61 7469 6f6e 0a20 2020 2020  ombination.     
-0000f940: 2020 206c 6574 206d 7574 2073 203d 2031     let mut s = 1
-0000f950: 3b0a 0a20 2020 2020 2020 206c 6574 206d  ;..        let m
-0000f960: 7574 2072 6573 7420 3d20 7365 6c66 2e63  ut rest = self.c
-0000f970: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
-0000f980: 276c 656e 3a20 7768 696c 6520 3220 2a20  'len: while 2 * 
-0000f990: 7320 3c3d 2066 6163 746f 7273 2e6c 656e  s <= factors.len
-0000f9a0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-0000f9b0: 206c 6574 206d 7574 2066 7320 3d20 436f   let mut fs = Co
-0000f9c0: 6d62 696e 6174 696f 6e49 7465 7261 746f  mbinationIterato
-0000f9d0: 723a 3a6e 6577 2866 6163 746f 7273 2e6c  r::new(factors.l
-0000f9e0: 656e 2829 2c20 7329 3b0a 2020 2020 2020  en(), s);.      
-0000f9f0: 2020 2020 2020 7768 696c 6520 6c65 7420        while let 
-0000fa00: 536f 6d65 2863 7329 203d 2066 732e 6e65  Some(cs) = fs.ne
-0000fa10: 7874 2829 207b 0a20 2020 2020 2020 2020  xt() {.         
-0000fa20: 2020 2020 2020 202f 2f20 6368 6563 6b20         // check 
-0000fa30: 6966 2074 6865 2063 6f6e 7374 616e 7420  if the constant 
-0000fa40: 7465 726d 206d 6174 6368 6573 0a20 2020  term matches.   
-0000fa50: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000fa60: 7265 7374 2e65 7870 6f6e 656e 7473 5b2e  rest.exponents[.
-0000fa70: 2e72 6573 742e 6e76 6172 735d 2e69 7465  .rest.nvars].ite
-0000fa80: 7228 292e 616c 6c28 7c65 7c20 2a65 203d  r().all(|e| *e =
-0000fa90: 3d20 453a 3a7a 6572 6f28 2929 207b 0a20  = E::zero()) {. 
-0000faa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fab0: 2020 206c 6574 206d 7574 2067 3120 3d20     let mut g1 = 
-0000fac0: 7265 7374 2e6c 636f 6566 6628 293b 0a20  rest.lcoeff();. 
-0000fad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fae0: 2020 206c 6574 206d 7574 2068 3120 3d20     let mut h1 = 
-0000faf0: 7265 7374 2e6c 636f 6566 6628 293b 0a20  rest.lcoeff();. 
-0000fb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fb10: 2020 2066 6f72 2028 692c 2066 2920 696e     for (i, f) in
-0000fb20: 2066 6163 746f 7273 2e69 7465 7228 292e   factors.iter().
-0000fb30: 656e 756d 6572 6174 6528 2920 7b0a 2020  enumerate() {.  
-0000fb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fb50: 2020 2020 2020 6966 2066 2e65 7870 6f6e        if f.expon
-0000fb60: 656e 7473 5b2e 2e72 6573 742e 6e76 6172  ents[..rest.nvar
-0000fb70: 735d 2e69 7465 7228 292e 616c 6c28 7c78  s].iter().all(|x
-0000fb80: 7c20 2a78 203d 3d20 453a 3a7a 6572 6f28  | *x == E::zero(
-0000fb90: 2929 207b 0a20 2020 2020 2020 2020 2020  )) {.           
-0000fba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fbb0: 2069 6620 6373 2e63 6f6e 7461 696e 7328   if cs.contains(
-0000fbc0: 2669 2920 7b0a 2020 2020 2020 2020 2020  &i) {.          
-0000fbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fbe0: 2020 2020 2020 6731 203d 2028 2667 3120        g1 = (&g1 
-0000fbf0: 2a20 2666 2e63 6f65 6666 6963 6965 6e74  * &f.coefficient
-0000fc00: 735b 305d 292e 7379 6d6d 6574 7269 635f  s[0]).symmetric_
-0000fc10: 6d6f 6428 266d 6178 5f70 293b 0a20 2020  mod(&max_p);.   
-0000fc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc30: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
-0000fc40: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+0000c9c0: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
+0000c9d0: 2020 2020 2020 2020 6661 6374 6f72 735f          factors_
+0000c9e0: 7769 7468 5f74 7275 655f 6c63 6f65 6666  with_true_lcoeff
+0000c9f0: 2e70 7573 6828 6669 7865 645f 6661 6329  .push(fixed_fac)
+0000ca00: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+0000ca10: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
+0000ca20: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+0000ca30: 2020 2020 2020 2020 2066 6163 746f 7273           factors
+0000ca40: 5f77 6974 685f 7472 7565 5f6c 636f 6566  _with_true_lcoef
+0000ca50: 662e 6578 7465 6e64 2872 6563 6f6e 7374  f.extend(reconst
+0000ca60: 7275 6374 6564 5f66 6163 746f 7273 293b  ructed_factors);
+0000ca70: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+0000ca80: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+0000ca90: 6d75 7420 6620 3d20 7365 6c66 2e63 6c6f  mut f = self.clo
+0000caa0: 6e65 2829 3b0a 2020 2020 2020 2020 2020  ne();.          
+0000cab0: 2020 666f 7220 6a20 696e 2076 202b 2031    for j in v + 1
+0000cac0: 2e2e 6f72 6465 722e 6c65 6e28 2920 7b0a  ..order.len() {.
+0000cad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cae0: 666f 7220 7320 696e 2073 616d 706c 655f  for s in sample_
+0000caf0: 706f 696e 7473 207b 0a20 2020 2020 2020  points {.       
+0000cb00: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000cb10: 732e 3020 3d3d 206f 7264 6572 5b6a 5d20  s.0 == order[j] 
+0000cb20: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+0000cb30: 2020 2020 2020 2020 2020 6620 3d20 662e            f = f.
+0000cb40: 7265 706c 6163 6528 732e 302c 2026 732e  replace(s.0, &s.
+0000cb50: 3129 3b0a 2020 2020 2020 2020 2020 2020  1);.            
+0000cb60: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+0000cb70: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+0000cb80: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+0000cb90: 2020 2020 2020 202f 2f20 7368 6966 7420         // shift 
+0000cba0: 7468 6520 706f 6c79 6e6f 6d69 616c 2073  the polynomial s
+0000cbb0: 7563 6820 7468 6174 2074 6865 2065 7661  uch that the eva
+0000cbc0: 6c75 6174 696f 6e20 706f 696e 7420 6973  luation point is
+0000cbd0: 206e 6f77 2061 7420 300a 2020 2020 2020   now at 0.      
+0000cbe0: 2020 2020 2020 2f2f 2073 6f20 7468 6174        // so that
+0000cbf0: 2077 6520 6361 6e20 7573 6520 6120 636f   we can use a co
+0000cc00: 6e76 6f6c 7574 696f 6e20 666f 7220 6661  nvolution for fa
+0000cc10: 7374 2065 7272 6f72 2063 6f6d 7075 7461  st error computa
+0000cc20: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+0000cc30: 206c 6574 2073 6869 6674 203d 2026 7361   let shift = &sa
+0000cc40: 6d70 6c65 5f70 6f69 6e74 732e 6974 6572  mple_points.iter
+0000cc50: 2829 2e66 696e 6428 7c73 7c20 732e 3020  ().find(|s| s.0 
+0000cc60: 3d3d 206f 7264 6572 5b76 5d29 2e75 6e77  == order[v]).unw
+0000cc70: 7261 7028 292e 313b 0a20 2020 2020 2020  rap().1;.       
+0000cc80: 2020 2020 2066 203d 2066 2e73 6869 6674       f = f.shift
+0000cc90: 5f76 6172 286f 7264 6572 5b76 5d2c 2073  _var(order[v], s
+0000cca0: 6869 6674 293b 0a0a 2020 2020 2020 2020  hift);..        
+0000ccb0: 2020 2020 666f 7220 6620 696e 2026 6d75      for f in &mu
+0000ccc0: 7420 6661 6374 6f72 735f 7769 7468 5f74  t factors_with_t
+0000ccd0: 7275 655f 6c63 6f65 6666 207b 0a20 2020  rue_lcoeff {.   
+0000cce0: 2020 2020 2020 2020 2020 2020 202a 6620               *f 
+0000ccf0: 3d20 662e 7368 6966 745f 7661 7228 6f72  = f.shift_var(or
+0000cd00: 6465 725b 765d 2c20 7368 6966 7429 3b0a  der[v], shift);.
+0000cd10: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+0000cd20: 2020 2020 2020 2020 2020 206c 6574 206d             let m
+0000cd30: 7574 2074 6f74 203d 2073 656c 662e 6f6e  ut tot = self.on
+0000cd40: 6528 293b 0a20 2020 2020 2020 2020 2020  e();.           
+0000cd50: 2066 6f72 2062 2069 6e20 2666 6163 746f   for b in &facto
+0000cd60: 7273 5f77 6974 685f 7472 7565 5f6c 636f  rs_with_true_lco
+0000cd70: 6566 6620 7b0a 2020 2020 2020 2020 2020  eff {.          
+0000cd80: 2020 2020 2020 746f 7420 3d20 746f 7420        tot = tot 
+0000cd90: 2a20 623b 0a20 2020 2020 2020 2020 2020  * b;.           
+0000cda0: 207d 0a20 2020 2020 2020 2020 2020 206c   }.            l
+0000cdb0: 6574 2066 6163 746f 725f 7072 6f64 7563  et factor_produc
+0000cdc0: 7473 3a20 5665 633c 5f3e 203d 0a20 2020  ts: Vec<_> =.   
+0000cdd0: 2020 2020 2020 2020 2020 2020 2066 6163               fac
+0000cde0: 746f 7273 5f77 6974 685f 7472 7565 5f6c  tors_with_true_l
+0000cdf0: 636f 6566 662e 6974 6572 2829 2e6d 6170  coeff.iter().map
+0000ce00: 287c 667c 2026 746f 7420 2f20 6629 2e63  (|f| &tot / f).c
+0000ce10: 6f6c 6c65 6374 2829 3b0a 0a20 2020 2020  ollect();..     
+0000ce20: 2020 2020 2020 2072 6563 6f6e 7374 7275         reconstru
+0000ce30: 6374 6564 5f66 6163 746f 7273 203d 2066  cted_factors = f
+0000ce40: 2e6d 756c 7469 7661 7269 6174 655f 6865  .multivariate_he
+0000ce50: 6e73 656c 5f73 7465 7028 0a20 2020 2020  nsel_step(.     
+0000ce60: 2020 2020 2020 2020 2020 2075 6e69 7661             univa
+0000ce70: 7269 6174 655f 6465 6c74 6173 2c0a 2020  riate_deltas,.  
+0000ce80: 2020 2020 2020 2020 2020 2020 2020 756e                un
+0000ce90: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+0000cea0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000ceb0: 2020 7361 6d70 6c65 5f70 6f69 6e74 732c    sample_points,
+0000cec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ced0: 2026 6d75 7420 6661 6374 6f72 735f 7769   &mut factors_wi
+0000cee0: 7468 5f74 7275 655f 6c63 6f65 6666 2c0a  th_true_lcoeff,.
+0000cef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf00: 2666 6163 746f 725f 7072 6f64 7563 7473  &factor_products
+0000cf10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000cf20: 2020 266f 7264 6572 5b2e 2e3d 765d 2c0a    &order[..=v],.
+0000cf30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf40: 266d 7574 2064 6567 7265 6573 5b2e 2e3d  &mut degrees[..=
+0000cf50: 765d 2c0a 2020 2020 2020 2020 2020 2020  v],.            
+0000cf60: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
+0000cf70: 666f 7220 6620 696e 2026 6d75 7420 7265  for f in &mut re
+0000cf80: 636f 6e73 7472 7563 7465 645f 6661 6374  constructed_fact
+0000cf90: 6f72 7320 7b0a 2020 2020 2020 2020 2020  ors {.          
+0000cfa0: 2020 2020 2020 2a66 203d 2066 2e73 6869        *f = f.shi
+0000cfb0: 6674 5f76 6172 286f 7264 6572 5b76 5d2c  ft_var(order[v],
+0000cfc0: 2026 7365 6c66 2e66 6965 6c64 2e6e 6567   &self.field.neg
+0000cfd0: 2873 6869 6674 2929 3b0a 2020 2020 2020  (shift));.      
+0000cfe0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+0000cff0: 2020 2020 2066 6f72 2066 2069 6e20 2672       for f in &r
+0000d000: 6563 6f6e 7374 7275 6374 6564 5f66 6163  econstructed_fac
+0000d010: 746f 7273 207b 0a20 2020 2020 2020 2020  tors {.         
+0000d020: 2020 2020 2020 2064 6562 7567 2128 2252         debug!("R
+0000d030: 6563 6f6e 7374 7275 6374 6564 2066 6163  econstructed fac
+0000d040: 746f 7220 7b7d 222c 2066 293b 0a20 2020  tor {}", f);.   
+0000d050: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+0000d060: 2020 207d 0a0a 2020 2020 2020 2020 7265     }..        re
+0000d070: 636f 6e73 7472 7563 7465 645f 6661 6374  constructed_fact
+0000d080: 6f72 730a 2020 2020 7d0a 0a20 2020 2066  ors.    }..    f
+0000d090: 6e20 6d75 6c74 6976 6172 6961 7465 5f68  n multivariate_h
+0000d0a0: 656e 7365 6c5f 7374 6570 280a 2020 2020  ensel_step(.    
+0000d0b0: 2020 2020 2673 656c 662c 0a20 2020 2020      &self,.     
+0000d0c0: 2020 2075 6e69 7661 7269 6174 655f 6465     univariate_de
+0000d0d0: 6c74 6173 3a20 265b 5365 6c66 5d2c 0a20  ltas: &[Self],. 
+0000d0e0: 2020 2020 2020 2075 6e69 7661 7269 6174         univariat
+0000d0f0: 655f 6661 6374 6f72 733a 2026 6d75 7420  e_factors: &mut 
+0000d100: 5b53 656c 665d 2c0a 2020 2020 2020 2020  [Self],.        
+0000d110: 7361 6d70 6c65 5f70 6f69 6e74 733a 2026  sample_points: &
+0000d120: 5b28 7573 697a 652c 2046 3a3a 456c 656d  [(usize, F::Elem
+0000d130: 656e 7429 5d2c 0a20 2020 2020 2020 2066  ent)],.        f
+0000d140: 6163 746f 7273 3a20 266d 7574 205b 5365  actors: &mut [Se
+0000d150: 6c66 5d2c 0a20 2020 2020 2020 2070 726f  lf],.        pro
+0000d160: 6473 3a20 265b 5365 6c66 5d2c 0a20 2020  ds: &[Self],.   
+0000d170: 2020 2020 206f 7264 6572 3a20 265b 7573       order: &[us
+0000d180: 697a 655d 2c0a 2020 2020 2020 2020 6465  ize],.        de
+0000d190: 6772 6565 733a 2026 6d75 7420 5b75 7369  grees: &mut [usi
+0000d1a0: 7a65 5d2c 0a20 2020 2029 202d 3e20 5665  ze],.    ) -> Ve
+0000d1b0: 633c 5365 6c66 3e20 7b0a 2020 2020 2020  c<Self> {.      
+0000d1c0: 2020 6c65 7420 6c61 7374 5f76 6172 203d    let last_var =
+0000d1d0: 202a 6f72 6465 722e 6c61 7374 2829 2e75   *order.last().u
+0000d1e0: 6e77 7261 7028 293b 0a20 2020 2020 2020  nwrap();.       
+0000d1f0: 206c 6574 206c 6173 745f 6465 6772 6565   let last_degree
+0000d200: 203d 202a 6465 6772 6565 732e 6c61 7374   = *degrees.last
+0000d210: 2829 2e75 6e77 7261 7028 293b 0a20 2020  ().unwrap();.   
+0000d220: 2020 2020 206c 6574 2079 5f70 6f6c 7920       let y_poly 
+0000d230: 3d20 7365 6c66 2e74 6f5f 756e 6976 6172  = self.to_univar
+0000d240: 6961 7465 5f70 6f6c 796e 6f6d 6961 6c5f  iate_polynomial_
+0000d250: 6c69 7374 286c 6173 745f 7661 7229 3b0a  list(last_var);.
+0000d260: 0a20 2020 2020 2020 202f 2f20 6578 7472  .        // extr
+0000d270: 6163 7420 636f 6566 6669 6369 656e 7473  act coefficients
+0000d280: 2069 6e20 6c61 7374 5f76 6172 0a20 2020   in last_var.   
+0000d290: 2020 2020 206c 6574 206d 7574 2075 3a20       let mut u: 
+0000d2a0: 5665 633c 5f3e 203d 2066 6163 746f 7273  Vec<_> = factors
+0000d2b0: 0a20 2020 2020 2020 2020 2020 202e 6974  .            .it
+0000d2c0: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
+0000d2d0: 202e 6d61 7028 7c66 7c20 7b0a 2020 2020   .map(|f| {.    
+0000d2e0: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+0000d2f0: 6d75 7420 6465 6e73 6520 3d20 7665 6321  mut dense = vec!
+0000d300: 5b73 656c 662e 7a65 726f 2829 3b20 6c61  [self.zero(); la
+0000d310: 7374 5f64 6567 7265 6520 2b20 315d 3b0a  st_degree + 1];.
+0000d320: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d330: 2066 6f72 2028 702c 2065 2920 696e 2066   for (p, e) in f
+0000d340: 2e74 6f5f 756e 6976 6172 6961 7465 5f70  .to_univariate_p
+0000d350: 6f6c 796e 6f6d 6961 6c5f 6c69 7374 286c  olynomial_list(l
+0000d360: 6173 745f 7661 7229 207b 0a20 2020 2020  ast_var) {.     
+0000d370: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000d380: 656e 7365 5b65 2e74 6f5f 7533 3228 2920  ense[e.to_u32() 
+0000d390: 6173 2075 7369 7a65 5d20 3d20 703b 0a20  as usize] = p;. 
+0000d3a0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+0000d3b0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000d3c0: 2020 6465 6e73 650a 2020 2020 2020 2020    dense.        
+0000d3d0: 2020 2020 7d29 0a20 2020 2020 2020 2020      }).         
+0000d3e0: 2020 202e 636f 6c6c 6563 7428 293b 0a0a     .collect();..
+0000d3f0: 2020 2020 2020 2020 2f2f 2054 4f44 4f3a          // TODO:
+0000d400: 2064 6f20 656e 7469 7265 2069 6e69 7469   do entire initi
+0000d410: 616c 697a 6174 696f 6e20 6865 7265 3f0a  alization here?.
+0000d420: 2020 2020 2020 2020 2f2f 2074 6865 206c          // the l
+0000d430: 6f6f 7020 6265 6c6f 7720 6361 6e6e 6f74  oop below cannot
+0000d440: 2062 6520 6375 7420 7368 6f72 7420 616e   be cut short an
+0000d450: 7977 6179 2c20 736f 2069 7427 7320 6e6f  yway, so it's no
+0000d460: 7420 6578 7472 6120 776f 726b 2074 6f20  t extra work to 
+0000d470: 646f 2069 7420 616c 6c20 6865 7265 0a20  do it all here. 
+0000d480: 2020 2020 2020 206c 6574 206d 7574 2070         let mut p
+0000d490: 203d 2075 2e63 6c6f 6e65 2829 3b0a 2020   = u.clone();.  
+0000d4a0: 2020 2020 2020 6c65 7420 6d75 7420 6375        let mut cu
+0000d4b0: 725f 7020 3d20 705b 305d 5b30 5d2e 636c  r_p = p[0][0].cl
+0000d4c0: 6f6e 6528 293b 0a20 2020 2020 2020 2066  one();.        f
+0000d4d0: 6f72 2078 2069 6e20 266d 7574 2070 2e69  or x in &mut p.i
+0000d4e0: 7465 725f 6d75 7428 292e 736b 6970 2831  ter_mut().skip(1
+0000d4f0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+0000d500: 666f 7220 6a20 696e 2026 6d75 7420 2a78  for j in &mut *x
+0000d510: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+0000d520: 2020 202a 6a20 3d20 262a 6a20 2a20 2663     *j = &*j * &c
+0000d530: 7572 5f70 3b0a 2020 2020 2020 2020 2020  ur_p;.          
+0000d540: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
+0000d550: 2063 7572 5f70 203d 2078 5b30 5d2e 636c   cur_p = x[0].cl
+0000d560: 6f6e 6528 293b 0a20 2020 2020 2020 207d  one();.        }
+0000d570: 0a0a 2020 2020 2020 2020 6c65 7420 7072  ..        let pr
+0000d580: 6f64 5f6d 6f64 203d 2070 726f 6473 0a20  od_mod = prods. 
+0000d590: 2020 2020 2020 2020 2020 202e 6974 6572             .iter
+0000d5a0: 2829 0a20 2020 2020 2020 2020 2020 202e  ().            .
+0000d5b0: 6d61 7028 7c66 7c20 662e 7265 706c 6163  map(|f| f.replac
+0000d5c0: 6528 6c61 7374 5f76 6172 2c20 2673 656c  e(last_var, &sel
+0000d5d0: 662e 6669 656c 642e 7a65 726f 2829 2929  f.field.zero()))
+0000d5e0: 0a20 2020 2020 2020 2020 2020 202e 636f  .            .co
+0000d5f0: 6c6c 6563 743a 3a3c 5665 633c 5f3e 3e28  llect::<Vec<_>>(
+0000d600: 293b 0a0a 2020 2020 2020 2020 6465 6275  );..        debu
+0000d610: 6721 2822 696e 2073 6869 6674 207b 7d22  g!("in shift {}"
+0000d620: 2c20 7365 6c66 293b 0a20 2020 2020 2020  , self);.       
+0000d630: 2064 6562 7567 2128 2264 6567 207b 3a3f   debug!("deg {:?
+0000d640: 7d22 2c20 6465 6772 6565 7329 3b0a 0a20  }", degrees);.. 
+0000d650: 2020 2020 2020 2066 6f72 206b 2069 6e20         for k in 
+0000d660: 312e 2e3d 6c61 7374 5f64 6567 7265 6520  1..=last_degree 
+0000d670: 7b0a 2020 2020 2020 2020 2020 2020 2f2f  {.            //
+0000d680: 2065 7874 7261 6374 2074 6865 2063 6f65   extract the coe
+0000d690: 6666 6963 6965 6e74 2072 6571 7569 7265  fficient require
+0000d6a0: 6420 746f 2063 6f6d 7075 7465 2074 6865  d to compute the
+0000d6b0: 2065 7272 6f72 2069 6e20 795e 6b0a 2020   error in y^k.  
+0000d6c0: 2020 2020 2020 2020 2020 2f2f 2063 6f6d            // com
+0000d6d0: 7075 7465 6420 7573 696e 6720 6120 636f  puted using a co
+0000d6e0: 6e76 6f6c 7574 696f 6e0a 2020 2020 2020  nvolution.      
+0000d6f0: 2020 2020 2020 666f 7220 6920 696e 2031        for i in 1
+0000d700: 2e2e 6661 6374 6f72 732e 6c65 6e28 2920  ..factors.len() 
+0000d710: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+0000d720: 2020 666f 7220 6a20 696e 2030 2e2e 6b20    for j in 0..k 
+0000d730: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+0000d740: 2020 2020 2020 705b 695d 5b6b 5d20 3d20        p[i][k] = 
+0000d750: 2670 5b69 5d5b 6b5d 202b 2026 2826 705b  &p[i][k] + &(&p[
+0000d760: 6920 2d20 315d 5b6b 202d 206a 5d20 2a20  i - 1][k - j] * 
+0000d770: 2675 5b69 5d5b 6a5d 293b 0a20 2020 2020  &u[i][j]);.     
+0000d780: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+0000d790: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+0000d7a0: 2020 2020 2020 2020 2f2f 2066 696e 6420          // find 
+0000d7b0: 7468 6520 6b74 6820 706f 7765 7220 6f66  the kth power of
+0000d7c0: 2079 2069 6e20 660a 2020 2020 2020 2020   y in f.        
+0000d7d0: 2020 2020 2f2f 2073 696e 6365 2077 6520      // since we 
+0000d7e0: 636f 6d70 7574 6520 7468 6520 6572 726f  compute the erro
+0000d7f0: 7220 7065 7220 706f 7765 7220 6f66 2079  r per power of y
+0000d800: 2c20 7765 2063 616e 6e6f 7420 7374 6f70  , we cannot stop
+0000d810: 206f 6e20 6120 3020 6572 726f 720a 2020   on a 0 error.  
+0000d820: 2020 2020 2020 2020 2020 6c65 7420 6520            let e 
+0000d830: 3d20 6966 206c 6574 2053 6f6d 6528 2876  = if let Some((v
+0000d840: 2c20 5f29 2920 3d20 795f 706f 6c79 2e69  , _)) = y_poly.i
+0000d850: 7465 7228 292e 6669 6e64 287c 657c 2065  ter().find(|e| e
+0000d860: 2e31 2e74 6f5f 7533 3228 2920 6173 2075  .1.to_u32() as u
+0000d870: 7369 7a65 203d 3d20 6b29 207b 0a20 2020  size == k) {.   
+0000d880: 2020 2020 2020 2020 2020 2020 2076 202d               v -
+0000d890: 2026 702e 6c61 7374 2829 2e75 6e77 7261   &p.last().unwra
+0000d8a0: 7028 295b 6b5d 0a20 2020 2020 2020 2020  p()[k].         
+0000d8b0: 2020 207d 2065 6c73 6520 7b0a 2020 2020     } else {.    
+0000d8c0: 2020 2020 2020 2020 2020 2020 2d70 2e6c              -p.l
+0000d8d0: 6173 7428 292e 756e 7772 6170 2829 5b6b  ast().unwrap()[k
+0000d8e0: 5d2e 636c 6f6e 6528 290a 2020 2020 2020  ].clone().      
+0000d8f0: 2020 2020 2020 7d3b 0a0a 2020 2020 2020        };..      
+0000d900: 2020 2020 2020 6465 6275 6721 2822 6865        debug!("he
+0000d910: 6e73 656c 2065 5b78 7b7d 5e7b 7d5d 203d  nsel e[x{}^{}] =
+0000d920: 207b 7d22 2c20 6c61 7374 5f76 6172 2c20   {}", last_var, 
+0000d930: 6b2c 2065 293b 0a0a 2020 2020 2020 2020  k, e);..        
+0000d940: 2020 2020 6966 2065 2e69 735f 7a65 726f      if e.is_zero
+0000d950: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+0000d960: 2020 2020 2063 6f6e 7469 6e75 653b 0a20       continue;. 
+0000d970: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+0000d980: 2020 2020 2020 2020 2020 6c65 7420 6e65            let ne
+0000d990: 775f 6465 6c74 6120 3d20 5365 6c66 3a3a  w_delta = Self::
+0000d9a0: 6d75 6c74 6976 6172 6961 7465 5f64 696f  multivariate_dio
+0000d9b0: 7068 616e 7469 6e65 280a 2020 2020 2020  phantine(.      
+0000d9c0: 2020 2020 2020 2020 2020 756e 6976 6172            univar
+0000d9d0: 6961 7465 5f64 656c 7461 732c 0a20 2020  iate_deltas,.   
+0000d9e0: 2020 2020 2020 2020 2020 2020 2075 6e69               uni
+0000d9f0: 7661 7269 6174 655f 6661 6374 6f72 732c  variate_factors,
+0000da00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000da10: 2026 7072 6f64 5f6d 6f64 2c0a 2020 2020   &prod_mod,.    
+0000da20: 2020 2020 2020 2020 2020 2020 2665 2c0a              &e,.
+0000da30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da40: 266f 7264 6572 5b2e 2e6f 7264 6572 2e6c  &order[..order.l
+0000da50: 656e 2829 202d 2031 5d2c 0a20 2020 2020  en() - 1],.     
+0000da60: 2020 2020 2020 2020 2020 2073 616d 706c             sampl
+0000da70: 655f 706f 696e 7473 2c0a 2020 2020 2020  e_points,.      
+0000da80: 2020 2020 2020 2020 2020 2664 6567 7265            &degre
+0000da90: 6573 5b2e 2e6f 7264 6572 2e6c 656e 2829  es[..order.len()
+0000daa0: 202d 2031 5d2c 0a20 2020 2020 2020 2020   - 1],.         
+0000dab0: 2020 2029 3b0a 0a20 2020 2020 2020 2020     );..         
+0000dac0: 2020 202f 2f20 7570 6461 7465 2074 6865     // update the
+0000dad0: 2063 6f65 6666 6963 6965 6e74 7320 7769   coefficients wi
+0000dae0: 7468 2074 6865 206e 6577 2079 5e6b 2063  th the new y^k c
+0000daf0: 6f6e 7472 6962 7574 696f 6e73 0a20 2020  ontributions.   
+0000db00: 2020 2020 2020 2020 206c 6574 206d 7574           let mut
+0000db10: 2074 203d 2073 656c 662e 7a65 726f 2829   t = self.zero()
+0000db20: 3b0a 0a20 2020 2020 2020 2020 2020 2066  ;..            f
+0000db30: 6f72 2028 692c 2028 6475 2c20 6429 2920  or (i, (du, d)) 
+0000db40: 696e 2075 2e69 7465 725f 6d75 7428 292e  in u.iter_mut().
+0000db50: 7a69 7028 266e 6577 5f64 656c 7461 292e  zip(&new_delta).
+0000db60: 656e 756d 6572 6174 6528 2920 7b0a 2020  enumerate() {.  
+0000db70: 2020 2020 2020 2020 2020 2020 2020 6465                de
+0000db80: 6275 6721 2822 6865 6e73 656c 2064 5b78  bug!("hensel d[x
+0000db90: 7b7d 5e7b 7d5d 203d 207b 7d22 2c20 6c61  {}^{}] = {}", la
+0000dba0: 7374 5f76 6172 2c20 6b2c 2064 293b 0a20  st_var, k, d);. 
+0000dbb0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000dbc0: 755b 6b5d 203d 2026 6475 5b6b 5d20 2b20  u[k] = &du[k] + 
+0000dbd0: 643b 0a0a 2020 2020 2020 2020 2020 2020  d;..            
+0000dbe0: 2020 2020 6966 2069 203e 2030 207b 0a20      if i > 0 {. 
+0000dbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc00: 2020 2074 203d 2026 6475 5b30 5d20 2a20     t = &du[0] * 
+0000dc10: 2674 202b 2064 202a 2026 705b 6920 2d20  &t + d * &p[i - 
+0000dc20: 315d 5b30 5d3b 0a20 2020 2020 2020 2020  1][0];.         
+0000dc30: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
+0000dc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc50: 2020 2020 7420 3d20 2674 202b 2064 3b0a      t = &t + d;.
+0000dc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc70: 7d0a 0a20 2020 2020 2020 2020 2020 2020  }..             
+0000dc80: 2020 2070 5b69 5d5b 6b5d 203d 2026 705b     p[i][k] = &p[
+0000dc90: 695d 5b6b 5d20 2b20 2674 3b0a 2020 2020  i][k] + &t;.    
+0000dca0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+0000dcb0: 2020 7d0a 0a20 2020 2020 2020 202f 2f20    }..        // 
+0000dcc0: 636f 6e76 6572 7420 6465 6e73 6520 706f  convert dense po
+0000dcd0: 6c79 6e6f 6d69 616c 7320 746f 206d 756c  lynomials to mul
+0000dce0: 7469 7661 7269 6174 6520 706f 6c79 6e6f  tivariate polyno
+0000dcf0: 6d69 616c 730a 2020 2020 2020 2020 752e  mials.        u.
+0000dd00: 696e 746f 5f69 7465 7228 290a 2020 2020  into_iter().    
+0000dd10: 2020 2020 2020 2020 2e6d 6170 287c 7473          .map(|ts
+0000dd20: 7c20 7b0a 2020 2020 2020 2020 2020 2020  | {.            
+0000dd30: 2020 2020 6c65 7420 6d75 7420 6e65 775f      let mut new_
+0000dd40: 706f 6c79 203d 2073 656c 662e 7a65 726f  poly = self.zero
+0000dd50: 5f77 6974 685f 6361 7061 6369 7479 2874  _with_capacity(t
+0000dd60: 732e 6c65 6e28 2929 3b0a 2020 2020 2020  s.len());.      
+0000dd70: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
+0000dd80: 2c20 6d75 7420 6629 2069 6e20 7473 2e69  , mut f) in ts.i
+0000dd90: 6e74 6f5f 6974 6572 2829 2e65 6e75 6d65  nto_iter().enume
+0000dda0: 7261 7465 2829 207b 0a20 2020 2020 2020  rate() {.       
+0000ddb0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0000ddc0: 2078 2069 6e20 662e 6578 706f 6e65 6e74   x in f.exponent
+0000ddd0: 735f 6974 6572 5f6d 7574 2829 207b 0a20  s_iter_mut() {. 
+0000dde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddf0: 2020 2020 2020 2064 6562 7567 5f61 7373         debug_ass
+0000de00: 6572 745f 6571 2128 785b 6c61 7374 5f76  ert_eq!(x[last_v
+0000de10: 6172 5d2c 2045 3a3a 7a65 726f 2829 293b  ar], E::zero());
+0000de20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000de30: 2020 2020 2020 2020 2078 5b6c 6173 745f           x[last_
+0000de40: 7661 725d 203d 2045 3a3a 6672 6f6d 5f75  var] = E::from_u
+0000de50: 3332 2869 2061 7320 7533 3229 3b0a 2020  32(i as u32);.  
+0000de60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de70: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
+0000de80: 2020 2020 2020 2020 6e65 775f 706f 6c79          new_poly
+0000de90: 203d 206e 6577 5f70 6f6c 7920 2b20 663b   = new_poly + f;
+0000dea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000deb0: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+0000dec0: 2020 206e 6577 5f70 6f6c 790a 2020 2020     new_poly.    
+0000ded0: 2020 2020 2020 2020 7d29 0a20 2020 2020          }).     
+0000dee0: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+0000def0: 290a 2020 2020 7d0a 7d0a 0a69 6d70 6c3c  ).    }.}..impl<
+0000df00: 453a 2045 7870 6f6e 656e 743e 204d 756c  E: Exponent> Mul
+0000df10: 7469 7661 7269 6174 6550 6f6c 796e 6f6d  tivariatePolynom
+0000df20: 6961 6c3c 496e 7465 6765 7252 696e 672c  ial<IntegerRing,
+0000df30: 2045 2c20 4c65 784f 7264 6572 3e20 7b0a   E, LexOrder> {.
+0000df40: 2020 2020 2f2f 2f20 4865 6e73 656c 206c      /// Hensel l
+0000df50: 6966 7420 6120 736f 6c75 7469 6f6e 206f  ift a solution o
+0000df60: 6620 6073 656c 6620 3d20 7520 2a20 7720  f `self = u * w 
+0000df70: 6d6f 6420 7060 2074 6f20 6073 656c 6620  mod p` to `self 
+0000df80: 3d20 7520 2a20 7720 6d6f 6420 6d61 785f  = u * w mod max_
+0000df90: 7060 0a20 2020 202f 2f2f 2077 6865 7265  p`.    /// where
+0000dfa0: 2060 6d61 785f 7060 2069 7320 6120 706f   `max_p` is a po
+0000dfb0: 7765 7220 6f66 2060 7060 2e0a 2020 2020  wer of `p`..    
+0000dfc0: 2f2f 2f0a 2020 2020 2f2f 2f20 4966 2074  ///.    /// If t
+0000dfd0: 6865 206c 6966 7469 6e67 2069 7320 7375  he lifting is su
+0000dfe0: 6363 6573 7366 756c 2c20 692e 652e 2074  ccessful, i.e. t
+0000dff0: 6865 2065 7272 6f72 2069 7320 3020 6174  he error is 0 at
+0000e000: 2073 6f6d 6520 7374 6167 652c 0a20 2020   some stage,.   
+0000e010: 202f 2f2f 2069 7420 7769 6c6c 2072 6574   /// it will ret
+0000e020: 7572 6e20 604f 6b28 2875 2c77 2929 6020  urn `Ok((u,w))` 
+0000e030: 7768 6572 6520 6075 6020 616e 6420 6077  where `u` and `w
+0000e040: 6020 6172 6520 7468 6520 7472 7565 2066  ` are the true f
+0000e050: 6163 746f 7273 206f 7665 720a 2020 2020  actors over.    
+0000e060: 2f2f 2f20 7468 6520 696e 7465 6765 7273  /// the integers
+0000e070: 2e20 4966 2061 2074 7275 6520 6661 6374  . If a true fact
+0000e080: 6f72 697a 6174 696f 6e20 6973 206e 6f74  orization is not
+0000e090: 2070 6f73 7369 626c 652c 2069 7420 7265   possible, it re
+0000e0a0: 7475 726e 730a 2020 2020 2f2f 2f20 6045  turns.    /// `E
+0000e0b0: 7272 2828 752c 7729 2960 2077 6865 7265  rr((u,w))` where
+0000e0c0: 2060 7560 2061 6e64 2060 7760 2061 7265   `u` and `w` are
+0000e0d0: 206d 6f6e 6963 2e0a 2020 2020 7075 6220   monic..    pub 
+0000e0e0: 666e 2068 656e 7365 6c5f 6c69 6674 3c55  fn hensel_lift<U
+0000e0f0: 4669 656c 643a 2046 696e 6974 6546 6965  Field: FiniteFie
+0000e100: 6c64 576f 726b 7370 6163 653e 280a 2020  ldWorkspace>(.  
+0000e110: 2020 2020 2020 2673 656c 662c 0a20 2020        &self,.   
+0000e120: 2020 2020 206d 7574 2075 3a20 4d75 6c74       mut u: Mult
+0000e130: 6976 6172 6961 7465 506f 6c79 6e6f 6d69  ivariatePolynomi
+0000e140: 616c 3c46 696e 6974 6546 6965 6c64 3c55  al<FiniteField<U
+0000e150: 4669 656c 643e 2c20 452c 204c 6578 4f72  Field>, E, LexOr
+0000e160: 6465 723e 2c0a 2020 2020 2020 2020 6d75  der>,.        mu
+0000e170: 7420 773a 204d 756c 7469 7661 7269 6174  t w: Multivariat
+0000e180: 6550 6f6c 796e 6f6d 6961 6c3c 4669 6e69  ePolynomial<Fini
+0000e190: 7465 4669 656c 643c 5546 6965 6c64 3e2c  teField<UField>,
+0000e1a0: 2045 2c20 4c65 784f 7264 6572 3e2c 0a20   E, LexOrder>,. 
+0000e1b0: 2020 2020 2020 2067 616d 6d61 3a20 4f70         gamma: Op
+0000e1c0: 7469 6f6e 3c49 6e74 6567 6572 3e2c 0a20  tion<Integer>,. 
+0000e1d0: 2020 2020 2020 206d 6178 5f70 3a20 2649         max_p: &I
+0000e1e0: 6e74 6567 6572 2c0a 2020 2020 2920 2d3e  nteger,.    ) ->
+0000e1f0: 2052 6573 756c 743c 2853 656c 662c 2053   Result<(Self, S
+0000e200: 656c 6629 2c20 2853 656c 662c 2053 656c  elf), (Self, Sel
+0000e210: 6629 3e0a 2020 2020 7768 6572 650a 2020  f)>.    where.  
+0000e220: 2020 2020 2020 4669 6e69 7465 4669 656c        FiniteFiel
+0000e230: 643c 5546 6965 6c64 3e3a 2046 6965 6c64  d<UField>: Field
+0000e240: 202b 2050 6f6c 796e 6f6d 6961 6c47 4344   + PolynomialGCD
+0000e250: 3c45 3e20 2b20 4669 6e69 7465 4669 656c  <E> + FiniteFiel
+0000e260: 6443 6f72 653c 5546 6965 6c64 3e2c 0a20  dCore<UField>,. 
+0000e270: 2020 2020 2020 2049 6e74 6567 6572 3a20         Integer: 
+0000e280: 546f 4669 6e69 7465 4669 656c 643c 5546  ToFiniteField<UF
+0000e290: 6965 6c64 3e2c 0a20 2020 207b 0a20 2020  ield>,.    {.   
+0000e2a0: 2020 2020 206c 6574 206c 636f 6566 6620       let lcoeff 
+0000e2b0: 3d20 7365 6c66 2e6c 636f 6566 6628 293b  = self.lcoeff();
+0000e2c0: 202f 2f20 6c63 6f65 6666 2025 2070 2021   // lcoeff % p !
+0000e2d0: 3d20 300a 2020 2020 2020 2020 6c65 7420  = 0.        let 
+0000e2e0: 6d75 7420 6761 6d6d 6120 3d20 6761 6d6d  mut gamma = gamm
+0000e2f0: 612e 756e 7772 6170 5f6f 7228 6c63 6f65  a.unwrap_or(lcoe
+0000e300: 6666 2e63 6c6f 6e65 2829 293b 0a20 2020  ff.clone());.   
+0000e310: 2020 2020 206c 6574 206c 636f 6566 665f       let lcoeff_
+0000e320: 7020 3d20 6c63 6f65 6666 2e74 6f5f 6669  p = lcoeff.to_fi
+0000e330: 6e69 7465 5f66 6965 6c64 2826 752e 6669  nite_field(&u.fi
+0000e340: 656c 6429 3b0a 2020 2020 2020 2020 6c65  eld);.        le
+0000e350: 7420 6761 6d6d 615f 7020 3d20 6761 6d6d  t gamma_p = gamm
+0000e360: 612e 746f 5f66 696e 6974 655f 6669 656c  a.to_finite_fiel
+0000e370: 6428 2675 2e66 6965 6c64 293b 0a20 2020  d(&u.field);.   
+0000e380: 2020 2020 206c 6574 2066 6965 6c64 203d       let field =
+0000e390: 2075 2e66 6965 6c64 2e63 6c6f 6e65 2829   u.field.clone()
+0000e3a0: 3b0a 2020 2020 2020 2020 6c65 7420 7020  ;.        let p 
+0000e3b0: 3d20 496e 7465 6765 723a 3a66 726f 6d28  = Integer::from(
+0000e3c0: 6669 656c 642e 6765 745f 7072 696d 6528  field.get_prime(
+0000e3d0: 292e 746f 5f75 3634 2829 293b 0a0a 2020  ).to_u64());..  
+0000e3e0: 2020 2020 2020 6c65 7420 6120 3d20 7365        let a = se
+0000e3f0: 6c66 2e63 6c6f 6e65 2829 2e6d 756c 5f63  lf.clone().mul_c
+0000e400: 6f65 6666 2867 616d 6d61 2e63 6c6f 6e65  oeff(gamma.clone
+0000e410: 2829 293b 0a0a 2020 2020 2020 2020 7520  ());..        u 
+0000e420: 3d20 752e 6d61 6b65 5f6d 6f6e 6963 2829  = u.make_monic()
+0000e430: 2e6d 756c 5f63 6f65 6666 2867 616d 6d61  .mul_coeff(gamma
+0000e440: 5f70 2e63 6c6f 6e65 2829 293b 0a20 2020  _p.clone());.   
+0000e450: 2020 2020 2077 203d 2077 2e6d 616b 655f       w = w.make_
+0000e460: 6d6f 6e69 6328 292e 6d75 6c5f 636f 6566  monic().mul_coef
+0000e470: 6628 6c63 6f65 6666 5f70 2e63 6c6f 6e65  f(lcoeff_p.clone
+0000e480: 2829 293b 0a0a 2020 2020 2020 2020 6c65  ());..        le
+0000e490: 7420 285f 2c20 732c 2074 2920 3d20 752e  t (_, s, t) = u.
+0000e4a0: 6565 615f 756e 6976 6172 6961 7465 2826  eea_univariate(&
+0000e4b0: 7729 3b0a 0a20 2020 2020 2020 2064 6562  w);..        deb
+0000e4c0: 7567 5f61 7373 6572 7421 2828 2673 202a  ug_assert!((&s *
+0000e4d0: 2026 7520 2b20 2674 202a 2026 7729 2e69   &u + &t * &w).i
+0000e4e0: 735f 6f6e 6528 2929 3b0a 0a20 2020 2020  s_one());..     
+0000e4f0: 2020 206c 6574 206d 7574 2075 5f69 203d     let mut u_i =
+0000e500: 2075 2e6d 6170 5f63 6f65 6666 287c 637c   u.map_coeff(|c|
+0000e510: 2066 6965 6c64 2e74 6f5f 7379 6d6d 6574   field.to_symmet
+0000e520: 7269 635f 696e 7465 6765 7228 6329 2c20  ric_integer(c), 
+0000e530: 5a29 3b0a 2020 2020 2020 2020 6c65 7420  Z);.        let 
+0000e540: 6d75 7420 775f 6920 3d20 772e 6d61 705f  mut w_i = w.map_
+0000e550: 636f 6566 6628 7c63 7c20 6669 656c 642e  coeff(|c| field.
+0000e560: 746f 5f73 796d 6d65 7472 6963 5f69 6e74  to_symmetric_int
+0000e570: 6567 6572 2863 292c 205a 293b 0a0a 2020  eger(c), Z);..  
+0000e580: 2020 2020 2020 2f2f 206f 6e6c 7920 7265        // only re
+0000e590: 706c 6163 6520 7468 6520 6c65 6164 696e  place the leadin
+0000e5a0: 6720 636f 6566 6669 6369 656e 740a 2020  g coefficient.  
+0000e5b0: 2020 2020 2020 2a75 5f69 2e63 6f65 6666        *u_i.coeff
+0000e5c0: 6963 6965 6e74 732e 6c61 7374 5f6d 7574  icients.last_mut
+0000e5d0: 2829 2e75 6e77 7261 7028 2920 3d20 6761  ().unwrap() = ga
+0000e5e0: 6d6d 612e 636c 6f6e 6528 293b 0a20 2020  mma.clone();.   
+0000e5f0: 2020 2020 202a 775f 692e 636f 6566 6669       *w_i.coeffi
+0000e600: 6369 656e 7473 2e6c 6173 745f 6d75 7428  cients.last_mut(
+0000e610: 292e 756e 7772 6170 2829 203d 206c 636f  ).unwrap() = lco
+0000e620: 6566 663b 0a0a 2020 2020 2020 2020 6c65  eff;..        le
+0000e630: 7420 6d75 7420 6520 3d20 2661 202d 2026  t mut e = &a - &
+0000e640: 2826 755f 6920 2a20 2677 5f69 293b 0a0a  (&u_i * &w_i);..
+0000e650: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0000e660: 6d20 3d20 702e 636c 6f6e 6528 293b 0a0a  m = p.clone();..
+0000e670: 2020 2020 2020 2020 7768 696c 6520 2165          while !e
+0000e680: 2e69 735f 7a65 726f 2829 2026 2620 266d  .is_zero() && &m
+0000e690: 203c 3d20 6d61 785f 7020 7b0a 2020 2020   <= max_p {.    
+0000e6a0: 2020 2020 2020 2020 6c65 7420 655f 7020          let e_p 
+0000e6b0: 3d20 652e 6d61 705f 636f 6566 6628 7c63  = e.map_coeff(|c
+0000e6c0: 7c20 2863 202f 2026 6d29 2e74 6f5f 6669  | (c / &m).to_fi
+0000e6d0: 6e69 7465 5f66 6965 6c64 2826 6669 656c  nite_field(&fiel
+0000e6e0: 6429 2c20 6669 656c 642e 636c 6f6e 6528  d), field.clone(
+0000e6f0: 2929 3b0a 2020 2020 2020 2020 2020 2020  ));.            
+0000e700: 6c65 7420 2871 2c20 7229 203d 2028 2665  let (q, r) = (&e
+0000e710: 5f70 202a 2026 7329 2e71 756f 745f 7265  _p * &s).quot_re
+0000e720: 6d5f 756e 6976 6172 6961 7465 2826 6d75  m_univariate(&mu
+0000e730: 7420 7729 3b0a 2020 2020 2020 2020 2020  t w);.          
+0000e740: 2020 6c65 7420 7461 7520 3d20 2665 5f70    let tau = &e_p
+0000e750: 202a 2026 7420 2b20 7120 2a20 2675 3b0a   * &t + q * &u;.
+0000e760: 0a20 2020 2020 2020 2020 2020 2075 5f69  .            u_i
+0000e770: 203d 2075 5f69 0a20 2020 2020 2020 2020   = u_i.         
+0000e780: 2020 2020 2020 202b 2074 6175 0a20 2020         + tau.   
+0000e790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e7a0: 202e 6d61 705f 636f 6566 6628 7c63 7c20   .map_coeff(|c| 
+0000e7b0: 6669 656c 642e 746f 5f73 796d 6d65 7472  field.to_symmetr
+0000e7c0: 6963 5f69 6e74 6567 6572 2863 292c 205a  ic_integer(c), Z
+0000e7d0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000e7e0: 2020 2020 2020 2e6d 756c 5f63 6f65 6666        .mul_coeff
+0000e7f0: 286d 2e63 6c6f 6e65 2829 293b 0a20 2020  (m.clone());.   
+0000e800: 2020 2020 2020 2020 2077 5f69 203d 2077           w_i = w
+0000e810: 5f69 0a20 2020 2020 2020 2020 2020 2020  _i.             
+0000e820: 2020 202b 2072 2e6d 6170 5f63 6f65 6666     + r.map_coeff
+0000e830: 287c 637c 2066 6965 6c64 2e74 6f5f 7379  (|c| field.to_sy
+0000e840: 6d6d 6574 7269 635f 696e 7465 6765 7228  mmetric_integer(
+0000e850: 6329 2c20 5a29 0a20 2020 2020 2020 2020  c), Z).         
+0000e860: 2020 2020 2020 2020 2020 202e 6d75 6c5f             .mul_
+0000e870: 636f 6566 6628 6d2e 636c 6f6e 6528 2929  coeff(m.clone())
+0000e880: 3b0a 2020 2020 2020 2020 2020 2020 6520  ;.            e 
+0000e890: 3d20 2661 202d 2026 2826 755f 6920 2a20  = &a - &(&u_i * 
+0000e8a0: 2677 5f69 293b 0a0a 2020 2020 2020 2020  &w_i);..        
+0000e8b0: 2020 2020 6d20 3d20 266d 202a 2026 703b      m = &m * &p;
+0000e8c0: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
+0000e8d0: 2020 2020 6966 2065 2e69 735f 7a65 726f      if e.is_zero
+0000e8e0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+0000e8f0: 206c 6574 2063 6f6e 7465 6e74 203d 2075   let content = u
+0000e900: 5f69 2e63 6f6e 7465 6e74 2829 3b0a 2020  _i.content();.  
+0000e910: 2020 2020 2020 2020 2020 6966 2021 636f            if !co
+0000e920: 6e74 656e 742e 6973 5f6f 6e65 2829 207b  ntent.is_one() {
+0000e930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e940: 2075 5f69 203d 2075 5f69 2e64 6976 5f63   u_i = u_i.div_c
+0000e950: 6f65 6666 2826 636f 6e74 656e 7429 3b0a  oeff(&content);.
+0000e960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e970: 6761 6d6d 6120 3d20 2667 616d 6d61 202f  gamma = &gamma /
+0000e980: 2026 636f 6e74 656e 743b 0a20 2020 2020   &content;.     
+0000e990: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+0000e9a0: 2020 2020 2020 6966 2021 6761 6d6d 612e        if !gamma.
+0000e9b0: 6973 5f6f 6e65 2829 207b 0a20 2020 2020  is_one() {.     
+0000e9c0: 2020 2020 2020 2020 2020 2077 5f69 203d             w_i =
+0000e9d0: 2077 5f69 2e64 6976 5f63 6f65 6666 2826   w_i.div_coeff(&
+0000e9e0: 6761 6d6d 6129 3b20 2f2f 2074 7275 6520  gamma); // true 
+0000e9f0: 6469 7669 7369 6f6e 2069 7320 706f 7373  division is poss
+0000ea00: 6962 6c65 2069 6e20 7468 6973 2063 6173  ible in this cas
+0000ea10: 650a 2020 2020 2020 2020 2020 2020 7d0a  e.            }.
+0000ea20: 0a20 2020 2020 2020 2020 2020 204f 6b28  .            Ok(
+0000ea30: 2875 5f69 2c20 775f 6929 290a 2020 2020  (u_i, w_i)).    
+0000ea40: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
+0000ea50: 2020 2020 2020 2020 2069 6620 2175 5f69           if !u_i
+0000ea60: 2e6c 636f 6566 6628 292e 6973 5f6f 6e65  .lcoeff().is_one
+0000ea70: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+0000ea80: 2020 2020 206c 6574 2069 6e76 203d 2075       let inv = u
+0000ea90: 5f69 2e6c 636f 6566 6628 292e 6d6f 645f  _i.lcoeff().mod_
+0000eaa0: 696e 7665 7273 6528 266d 293b 0a20 2020  inverse(&m);.   
+0000eab0: 2020 2020 2020 2020 2020 2020 2075 5f69               u_i
+0000eac0: 203d 2075 5f69 2e6d 6170 5f63 6f65 6666   = u_i.map_coeff
+0000ead0: 287c 637c 2028 6320 2a20 2669 6e76 292e  (|c| (c * &inv).
+0000eae0: 7379 6d6d 6574 7269 635f 6d6f 6428 266d  symmetric_mod(&m
+0000eaf0: 292c 205a 293b 0a20 2020 2020 2020 2020  ), Z);.         
+0000eb00: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+0000eb10: 2020 6966 2021 775f 692e 6c63 6f65 6666    if !w_i.lcoeff
+0000eb20: 2829 2e69 735f 6f6e 6528 2920 7b0a 2020  ().is_one() {.  
+0000eb30: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+0000eb40: 7420 696e 7620 3d20 775f 692e 6c63 6f65  t inv = w_i.lcoe
+0000eb50: 6666 2829 2e6d 6f64 5f69 6e76 6572 7365  ff().mod_inverse
+0000eb60: 2826 6d29 3b0a 2020 2020 2020 2020 2020  (&m);.          
+0000eb70: 2020 2020 2020 775f 6920 3d20 775f 692e        w_i = w_i.
+0000eb80: 6d61 705f 636f 6566 6628 7c63 7c20 2863  map_coeff(|c| (c
+0000eb90: 202a 2026 696e 7629 2e73 796d 6d65 7472   * &inv).symmetr
+0000eba0: 6963 5f6d 6f64 2826 6d29 2c20 5a29 3b0a  ic_mod(&m), Z);.
+0000ebb0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+0000ebc0: 2020 2020 2020 2020 2020 2045 7272 2828             Err((
+0000ebd0: 755f 692c 2077 5f69 2929 0a20 2020 2020  u_i, w_i)).     
+0000ebe0: 2020 207d 0a20 2020 207d 0a0a 2020 2020     }.    }..    
+0000ebf0: 2f2f 2f20 4c69 6674 206d 756c 7469 706c  /// Lift multipl
+0000ec00: 6520 6661 6374 6f72 7320 6279 2063 7265  e factors by cre
+0000ec10: 6174 696e 6720 6120 6269 6e61 7279 2074  ating a binary t
+0000ec20: 7265 6520 616e 6420 6c69 6674 696e 6720  ree and lifting 
+0000ec30: 6561 6368 2070 726f 6475 6374 2e0a 2020  each product..  
+0000ec40: 2020 666e 206d 756c 7469 5f66 6163 746f    fn multi_facto
+0000ec50: 725f 6865 6e73 656c 5f6c 6966 7428 0a20  r_hensel_lift(. 
+0000ec60: 2020 2020 2020 2026 7365 6c66 2c0a 2020         &self,.  
+0000ec70: 2020 2020 2020 6873 3a20 265b 4d75 6c74        hs: &[Mult
+0000ec80: 6976 6172 6961 7465 506f 6c79 6e6f 6d69  ivariatePolynomi
+0000ec90: 616c 3c5a 702c 2045 2c20 4c65 784f 7264  al<Zp, E, LexOrd
+0000eca0: 6572 3e5d 2c0a 2020 2020 2020 2020 6d61  er>],.        ma
+0000ecb0: 785f 703a 2026 496e 7465 6765 722c 0a20  x_p: &Integer,. 
+0000ecc0: 2020 2029 202d 3e20 5665 633c 5365 6c66     ) -> Vec<Self
+0000ecd0: 3e20 7b0a 2020 2020 2020 2020 6966 2068  > {.        if h
+0000ece0: 732e 6c65 6e28 2920 3d3d 2031 207b 0a20  s.len() == 1 {. 
+0000ecf0: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+0000ed00: 6c66 2e6c 636f 6566 6628 292e 6973 5f6f  lf.lcoeff().is_o
+0000ed10: 6e65 2829 207b 0a20 2020 2020 2020 2020  ne() {.         
+0000ed20: 2020 2020 2020 2072 6574 7572 6e20 7665         return ve
+0000ed30: 6321 5b73 656c 662e 636c 6f6e 6528 295d  c![self.clone()]
+0000ed40: 3b0a 2020 2020 2020 2020 2020 2020 7d20  ;.            } 
+0000ed50: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
+0000ed60: 2020 2020 2020 206c 6574 2069 6e76 203d         let inv =
+0000ed70: 2073 656c 662e 6c63 6f65 6666 2829 2e6d   self.lcoeff().m
+0000ed80: 6f64 5f69 6e76 6572 7365 286d 6178 5f70  od_inverse(max_p
+0000ed90: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+0000eda0: 2020 206c 6574 2072 203d 2073 656c 662e     let r = self.
+0000edb0: 6d61 705f 636f 6566 6628 7c63 7c20 2863  map_coeff(|c| (c
+0000edc0: 202a 2026 696e 7629 2e73 796d 6d65 7472   * &inv).symmetr
+0000edd0: 6963 5f6d 6f64 286d 6178 5f70 292c 205a  ic_mod(max_p), Z
+0000ede0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+0000edf0: 2020 2072 6574 7572 6e20 7665 6321 5b72     return vec![r
+0000ee00: 5d3b 0a20 2020 2020 2020 2020 2020 207d  ];.            }
+0000ee10: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
+0000ee20: 2020 2020 6c65 7420 2867 732c 2068 7329      let (gs, hs)
+0000ee30: 203d 2068 732e 7370 6c69 745f 6174 2868   = hs.split_at(h
+0000ee40: 732e 6c65 6e28 2920 2f20 3229 3b0a 0a20  s.len() / 2);.. 
+0000ee50: 2020 2020 2020 206c 6574 206d 7574 2067         let mut g
+0000ee60: 203d 2067 735b 305d 2e6f 6e65 2829 3b0a   = gs[0].one();.
+0000ee70: 2020 2020 2020 2020 666f 7220 7820 696e          for x in
+0000ee80: 2067 7320 7b0a 2020 2020 2020 2020 2020   gs {.          
+0000ee90: 2020 6720 3d20 6720 2a20 783b 0a20 2020    g = g * x;.   
+0000eea0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+0000eeb0: 6c65 7420 6d75 7420 6820 3d20 6873 5b30  let mut h = hs[0
+0000eec0: 5d2e 6f6e 6528 293b 0a20 2020 2020 2020  ].one();.       
+0000eed0: 2066 6f72 2078 2069 6e20 6873 207b 0a20   for x in hs {. 
+0000eee0: 2020 2020 2020 2020 2020 2068 203d 2068             h = h
+0000eef0: 202a 2078 3b0a 2020 2020 2020 2020 7d0a   * x;.        }.
+0000ef00: 0a20 2020 2020 2020 206c 6574 2028 675f  .        let (g_
+0000ef10: 692c 2068 5f69 2920 3d20 7365 6c66 2e68  i, h_i) = self.h
+0000ef20: 656e 7365 6c5f 6c69 6674 2867 2c20 682c  ensel_lift(g, h,
+0000ef30: 204e 6f6e 652c 206d 6178 5f70 292e 756e   None, max_p).un
+0000ef40: 7772 6170 5f6f 725f 656c 7365 287c 657c  wrap_or_else(|e|
+0000ef50: 2065 293b 0a0a 2020 2020 2020 2020 6c65   e);..        le
+0000ef60: 7420 6d75 7420 6661 6374 6f72 7320 3d20  t mut factors = 
+0000ef70: 675f 692e 6d75 6c74 695f 6661 6374 6f72  g_i.multi_factor
+0000ef80: 5f68 656e 7365 6c5f 6c69 6674 2867 732c  _hensel_lift(gs,
+0000ef90: 206d 6178 5f70 293b 0a20 2020 2020 2020   max_p);.       
+0000efa0: 2066 6163 746f 7273 2e65 7874 656e 6428   factors.extend(
+0000efb0: 685f 692e 6d75 6c74 695f 6661 6374 6f72  h_i.multi_factor
+0000efc0: 5f68 656e 7365 6c5f 6c69 6674 2868 732c  _hensel_lift(hs,
+0000efd0: 206d 6178 5f70 2929 3b0a 2020 2020 2020   max_p));.      
+0000efe0: 2020 6661 6374 6f72 730a 2020 2020 7d0a    factors.    }.
+0000eff0: 0a20 2020 202f 2f2f 2046 6163 746f 7220  .    /// Factor 
+0000f000: 6120 7371 7561 7265 2d66 7265 6520 756e  a square-free un
+0000f010: 6976 6172 6961 7465 2070 6f6c 796e 6f6d  ivariate polynom
+0000f020: 6961 6c20 6f76 6572 2074 6865 2069 6e74  ial over the int
+0000f030: 6567 6572 7320 6279 2048 656e 7365 6c20  egers by Hensel 
+0000f040: 6c69 6674 696e 6720 6661 6374 6f72 7320  lifting factors 
+0000f050: 636f 6d70 7574 6564 206f 7665 720a 2020  computed over.  
+0000f060: 2020 2f2f 2f20 6120 6669 6e69 7465 2066    /// a finite f
+0000f070: 6965 6c64 2069 6d61 6765 206f 6620 7468  ield image of th
+0000f080: 6520 706f 6c79 6e6f 6d69 616c 2e0a 2020  e polynomial..  
+0000f090: 2020 666e 2066 6163 746f 725f 7265 636f    fn factor_reco
+0000f0a0: 6e73 7472 7563 7428 2673 656c 6629 202d  nstruct(&self) -
+0000f0b0: 3e20 5665 633c 5365 6c66 3e20 7b0a 2020  > Vec<Self> {.  
+0000f0c0: 2020 2020 2020 6c65 7420 536f 6d65 2876        let Some(v
+0000f0d0: 6172 2920 3d20 7365 6c66 2e6c 6173 745f  ar) = self.last_
+0000f0e0: 6578 706f 6e65 6e74 7328 292e 6974 6572  exponents().iter
+0000f0f0: 2829 2e70 6f73 6974 696f 6e28 7c78 7c20  ().position(|x| 
+0000f100: 2a78 203e 2045 3a3a 7a65 726f 2829 2920  *x > E::zero()) 
+0000f110: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
+0000f120: 2020 2072 6574 7572 6e20 7665 6321 5b73     return vec![s
+0000f130: 656c 662e 636c 6f6e 6528 295d 3b20 2f2f  elf.clone()]; //
+0000f140: 2063 6f6e 7374 616e 7420 706f 6c79 6e6f   constant polyno
+0000f150: 6d69 616c 0a20 2020 2020 2020 207d 3b0a  mial.        };.
+0000f160: 2020 2020 2020 2020 6c65 7420 6420 3d20          let d = 
+0000f170: 7365 6c66 2e64 6567 7265 6528 7661 7229  self.degree(var)
+0000f180: 2e74 6f5f 7533 3228 293b 0a0a 2020 2020  .to_u32();..    
+0000f190: 2020 2020 6966 2064 203d 3d20 3120 7b0a      if d == 1 {.
+0000f1a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000f1b0: 726e 2076 6563 215b 7365 6c66 2e63 6c6f  rn vec![self.clo
+0000f1c0: 6e65 2829 5d3b 0a20 2020 2020 2020 207d  ne()];.        }
+0000f1d0: 0a0a 2020 2020 2020 2020 2f2f 2073 656c  ..        // sel
+0000f1e0: 6563 7420 6120 7375 6974 6162 6c65 2070  ect a suitable p
+0000f1f0: 7269 6d65 0a20 2020 2020 2020 202f 2f20  rime.        // 
+0000f200: 7765 2074 7279 2073 6d61 6c6c 2070 7269  we try small pri
+0000f210: 6d65 7320 6669 7273 7420 6173 2074 6865  mes first as the
+0000f220: 2064 6973 7469 6e63 7420 616e 6420 6571   distinct and eq
+0000f230: 7561 6c20 6465 6772 6565 2061 6c67 6f72  ual degree algor
+0000f240: 6974 686d 730a 2020 2020 2020 2020 2f2f  ithms.        //
+0000f250: 2073 6361 6c65 2061 7320 6c6f 6728 7029   scale as log(p)
+0000f260: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+0000f270: 2066 6965 6c64 3b0a 2020 2020 2020 2020   field;.        
+0000f280: 6c65 7420 6d75 7420 665f 703b 0a20 2020  let mut f_p;.   
+0000f290: 2020 2020 206c 6574 206d 7574 2070 6920       let mut pi 
+0000f2a0: 3d20 5072 696d 6549 7465 7261 746f 7255  = PrimeIteratorU
+0000f2b0: 3634 3a3a 6e65 7728 3130 3129 3b0a 2020  64::new(101);.  
+0000f2c0: 2020 2020 2020 6c6f 6f70 207b 0a20 2020        loop {.   
+0000f2d0: 2020 2020 2020 2020 206c 6574 2070 203d           let p =
+0000f2e0: 2070 692e 6e65 7874 2829 2e75 6e77 7261   pi.next().unwra
+0000f2f0: 7028 293b 0a20 2020 2020 2020 2020 2020  p();.           
+0000f300: 2069 6620 7020 3e20 7533 323a 3a4d 4158   if p > u32::MAX
+0000f310: 2061 7320 7536 3420 7b0a 2020 2020 2020   as u64 {.      
+0000f320: 2020 2020 2020 2020 2020 7061 6e69 6321            panic!
+0000f330: 2822 5261 6e20 6f75 7420 6f66 2070 7269  ("Ran out of pri
+0000f340: 6d65 7320 6475 7269 6e67 2066 6163 746f  mes during facto
+0000f350: 7269 7a61 7469 6f6e 206f 6620 7b7d 222c  rization of {}",
+0000f360: 2073 656c 6629 3b0a 2020 2020 2020 2020   self);.        
+0000f370: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+0000f380: 2020 6c65 7420 7020 3d20 7020 6173 2075    let p = p as u
+0000f390: 3332 3b0a 0a20 2020 2020 2020 2020 2020  32;..           
+0000f3a0: 2069 6620 2826 7365 6c66 2e6c 636f 6566   if (&self.lcoef
+0000f3b0: 6628 2920 2520 2649 6e74 6567 6572 3a3a  f() % &Integer::
+0000f3c0: 4e61 7475 7261 6c28 7020 6173 2069 3634  Natural(p as i64
+0000f3d0: 2929 2e69 735f 7a65 726f 2829 207b 0a20  )).is_zero() {. 
+0000f3e0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000f3f0: 6f6e 7469 6e75 653b 0a20 2020 2020 2020  ontinue;.       
+0000f400: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+0000f410: 2020 2020 6669 656c 6420 3d20 5a70 3a3a      field = Zp::
+0000f420: 6e65 7728 7029 3b0a 2020 2020 2020 2020  new(p);.        
+0000f430: 2020 2020 665f 7020 3d20 7365 6c66 2e6d      f_p = self.m
+0000f440: 6170 5f63 6f65 6666 287c 667c 2066 2e74  ap_coeff(|f| f.t
+0000f450: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
+0000f460: 6669 656c 6429 2c20 6669 656c 642e 636c  field), field.cl
+0000f470: 6f6e 6528 2929 3b0a 2020 2020 2020 2020  one());.        
+0000f480: 2020 2020 6c65 7420 6466 5f70 203d 2066      let df_p = f
+0000f490: 5f70 2e64 6572 6976 6174 6976 6528 7661  _p.derivative(va
+0000f4a0: 7229 3b0a 0a20 2020 2020 2020 2020 2020  r);..           
+0000f4b0: 202f 2f20 6368 6563 6b20 6973 2066 5f70   // check is f_p
+0000f4c0: 2072 656d 6169 6e73 2073 7175 6172 652d   remains square-
+0000f4d0: 6672 6565 0a20 2020 2020 2020 2020 2020  free.           
+0000f4e0: 2069 6620 665f 702e 6763 6428 2664 665f   if f_p.gcd(&df_
+0000f4f0: 7029 2e69 735f 6f6e 6528 2920 7b0a 2020  p).is_one() {.  
+0000f500: 2020 2020 2020 2020 2020 2020 2020 6272                br
+0000f510: 6561 6b3b 0a20 2020 2020 2020 2020 2020  eak;.           
+0000f520: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
+0000f530: 2020 2020 2020 6c65 7420 6873 3a20 5665        let hs: Ve
+0000f540: 633c 5f3e 203d 2066 5f70 2e66 6163 746f  c<_> = f_p.facto
+0000f550: 725f 6469 7374 696e 6374 5f65 7175 616c  r_distinct_equal
+0000f560: 5f64 6567 7265 6528 293b 0a0a 2020 2020  _degree();..    
+0000f570: 2020 2020 6966 2068 732e 6c65 6e28 2920      if hs.len() 
+0000f580: 3d3d 2031 207b 0a20 2020 2020 2020 2020  == 1 {.         
+0000f590: 2020 202f 2f20 7468 6520 706f 6c79 6e6f     // the polyno
+0000f5a0: 6d69 616c 2069 7320 6972 7265 6475 6369  mial is irreduci
+0000f5b0: 626c 650a 2020 2020 2020 2020 2020 2020  ble.            
+0000f5c0: 7265 7475 726e 2076 6563 215b 7365 6c66  return vec![self
+0000f5d0: 2e63 6c6f 6e65 2829 5d3b 0a20 2020 2020  .clone()];.     
+0000f5e0: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
+0000f5f0: 7420 626f 756e 6420 3d20 7365 6c66 2e63  t bound = self.c
+0000f600: 6f65 6666 6963 6965 6e74 5f62 6f75 6e64  oefficient_bound
+0000f610: 2829 3b0a 2020 2020 2020 2020 6c65 7420  ();.        let 
+0000f620: 703a 2049 6e74 6567 6572 203d 2028 6669  p: Integer = (fi
+0000f630: 656c 642e 6765 745f 7072 696d 6528 292e  eld.get_prime().
+0000f640: 746f 5f75 3332 2829 2061 7320 6936 3429  to_u32() as i64)
+0000f650: 2e69 6e74 6f28 293b 0a20 2020 2020 2020  .into();.       
+0000f660: 206c 6574 206d 7574 206d 6178 5f70 203d   let mut max_p =
+0000f670: 2070 2e63 6c6f 6e65 2829 3b0a 2020 2020   p.clone();.    
+0000f680: 2020 2020 7768 696c 6520 6d61 785f 7020      while max_p 
+0000f690: 3c20 626f 756e 6420 7b0a 2020 2020 2020  < bound {.      
+0000f6a0: 2020 2020 2020 6d61 785f 7020 3d20 266d        max_p = &m
+0000f6b0: 6178 5f70 202a 2026 703b 0a20 2020 2020  ax_p * &p;.     
+0000f6c0: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
+0000f6d0: 7420 6d75 7420 6661 6374 6f72 7320 3d20  t mut factors = 
+0000f6e0: 7365 6c66 2e6d 756c 7469 5f66 6163 746f  self.multi_facto
+0000f6f0: 725f 6865 6e73 656c 5f6c 6966 7428 2668  r_hensel_lift(&h
+0000f700: 732c 2026 6d61 785f 7029 3b0a 0a20 2020  s, &max_p);..   
+0000f710: 2020 2020 2023 5b63 6667 2864 6562 7567       #[cfg(debug
+0000f720: 5f61 7373 6572 7469 6f6e 7329 5d0a 2020  _assertions)].  
+0000f730: 2020 2020 2020 666f 7220 2868 2c20 685f        for (h, h_
+0000f740: 7029 2069 6e20 6661 6374 6f72 732e 6974  p) in factors.it
+0000f750: 6572 2829 2e7a 6970 2826 6873 2920 7b0a  er().zip(&hs) {.
+0000f760: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+0000f770: 6868 5f70 203d 2068 0a20 2020 2020 2020  hh_p = h.       
+0000f780: 2020 2020 2020 2020 202e 6d61 705f 636f           .map_co
+0000f790: 6566 6628 7c63 7c20 632e 746f 5f66 696e  eff(|c| c.to_fin
+0000f7a0: 6974 655f 6669 656c 6428 2666 6965 6c64  ite_field(&field
+0000f7b0: 292c 2066 6965 6c64 2e63 6c6f 6e65 2829  ), field.clone()
+0000f7c0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000f7d0: 2020 2e6d 616b 655f 6d6f 6e69 6328 293b    .make_monic();
+0000f7e0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000f7f0: 2668 685f 7020 213d 2068 5f70 207b 0a20  &hh_p != h_p {. 
+0000f800: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000f810: 616e 6963 2128 224d 6973 6d61 7463 6820  anic!("Mismatch 
+0000f820: 6f66 206c 6966 7465 6420 6661 6374 6f72  of lifted factor
+0000f830: 3a20 7b7d 2076 7320 7b7d 2069 6e20 7b7d  : {} vs {} in {}
+0000f840: 222c 2068 685f 702c 2068 5f70 2c20 7365  ", hh_p, h_p, se
+0000f850: 6c66 293b 0a20 2020 2020 2020 2020 2020  lf);.           
+0000f860: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
+0000f870: 2020 2020 2020 6c65 7420 6d75 7420 7265        let mut re
+0000f880: 635f 6661 6374 6f72 7320 3d20 7665 6321  c_factors = vec!
+0000f890: 5b5d 3b0a 2020 2020 2020 2020 2f2f 2066  [];.        // f
+0000f8a0: 6163 746f 7220 7265 636f 6d62 696e 6174  actor recombinat
+0000f8b0: 696f 6e0a 2020 2020 2020 2020 6c65 7420  ion.        let 
+0000f8c0: 6d75 7420 7320 3d20 313b 0a0a 2020 2020  mut s = 1;..    
+0000f8d0: 2020 2020 6c65 7420 6d75 7420 7265 7374      let mut rest
+0000f8e0: 203d 2073 656c 662e 636c 6f6e 6528 293b   = self.clone();
+0000f8f0: 0a20 2020 2020 2020 2027 6c65 6e3a 2077  .        'len: w
+0000f900: 6869 6c65 2032 202a 2073 203c 3d20 6661  hile 2 * s <= fa
+0000f910: 6374 6f72 732e 6c65 6e28 2920 7b0a 2020  ctors.len() {.  
+0000f920: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
+0000f930: 7420 6673 203d 2043 6f6d 6269 6e61 7469  t fs = Combinati
+0000f940: 6f6e 4974 6572 6174 6f72 3a3a 6e65 7728  onIterator::new(
+0000f950: 6661 6374 6f72 732e 6c65 6e28 292c 2073  factors.len(), s
+0000f960: 293b 0a20 2020 2020 2020 2020 2020 2077  );.            w
+0000f970: 6869 6c65 206c 6574 2053 6f6d 6528 6373  hile let Some(cs
+0000f980: 2920 3d20 6673 2e6e 6578 7428 2920 7b0a  ) = fs.next() {.
+0000f990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f9a0: 2f2f 2063 6865 636b 2069 6620 7468 6520  // check if the 
+0000f9b0: 636f 6e73 7461 6e74 2074 6572 6d20 6d61  constant term ma
+0000f9c0: 7463 6865 730a 2020 2020 2020 2020 2020  tches.          
+0000f9d0: 2020 2020 2020 6966 2072 6573 742e 6578        if rest.ex
+0000f9e0: 706f 6e65 6e74 735b 2e2e 7265 7374 2e6e  ponents[..rest.n
+0000f9f0: 7661 7273 2829 5d0a 2020 2020 2020 2020  vars()].        
+0000fa00: 2020 2020 2020 2020 2020 2020 2e69 7465              .ite
+0000fa10: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
+0000fa20: 2020 2020 2020 2020 2e61 6c6c 287c 657c          .all(|e|
+0000fa30: 202a 6520 3d3d 2045 3a3a 7a65 726f 2829   *e == E::zero()
+0000fa40: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000fa50: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
+0000fa60: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0000fa70: 6731 203d 2072 6573 742e 6c63 6f65 6666  g1 = rest.lcoeff
+0000fa80: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
+0000fa90: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0000faa0: 6831 203d 2072 6573 742e 6c63 6f65 6666  h1 = rest.lcoeff
+0000fab0: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
+0000fac0: 2020 2020 2020 2020 666f 7220 2869 2c20          for (i, 
+0000fad0: 6629 2069 6e20 6661 6374 6f72 732e 6974  f) in factors.it
+0000fae0: 6572 2829 2e65 6e75 6d65 7261 7465 2829  er().enumerate()
+0000faf0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+0000fb00: 2020 2020 2020 2020 2020 2069 6620 662e             if f.
+0000fb10: 6578 706f 6e65 6e74 735b 2e2e 7265 7374  exponents[..rest
+0000fb20: 2e6e 7661 7273 2829 5d2e 6974 6572 2829  .nvars()].iter()
+0000fb30: 2e61 6c6c 287c 787c 202a 7820 3d3d 2045  .all(|x| *x == E
+0000fb40: 3a3a 7a65 726f 2829 2920 7b0a 2020 2020  ::zero()) {.    
+0000fb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb60: 2020 2020 2020 2020 6966 2063 732e 636f          if cs.co
+0000fb70: 6e74 6169 6e73 2826 6929 207b 0a20 2020  ntains(&i) {.   
+0000fb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb90: 2020 2020 2020 2020 2020 2020 2067 3120               g1 
+0000fba0: 3d20 2826 6731 202a 2026 662e 636f 6566  = (&g1 * &f.coef
+0000fbb0: 6669 6369 656e 7473 5b30 5d29 2e73 796d  ficients[0]).sym
+0000fbc0: 6d65 7472 6963 5f6d 6f64 2826 6d61 785f  metric_mod(&max_
+0000fbd0: 7029 3b0a 2020 2020 2020 2020 2020 2020  p);.            
+0000fbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fbf0: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+0000fc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc10: 2020 2020 2020 2020 2068 3120 3d20 2826           h1 = (&
+0000fc20: 6831 202a 2026 662e 636f 6566 6669 6369  h1 * &f.coeffici
+0000fc30: 656e 7473 5b30 5d29 2e73 796d 6d65 7472  ents[0]).symmetr
+0000fc40: 6963 5f6d 6f64 2826 6d61 785f 7029 3b0a  ic_mod(&max_p);.
 0000fc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc60: 2020 6831 203d 2028 2668 3120 2a20 2666    h1 = (&h1 * &f
-0000fc70: 2e63 6f65 6666 6963 6965 6e74 735b 305d  .coefficients[0]
-0000fc80: 292e 7379 6d6d 6574 7269 635f 6d6f 6428  ).symmetric_mod(
-0000fc90: 266d 6178 5f70 293b 0a20 2020 2020 2020  &max_p);.       
+0000fc60: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+0000fc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc80: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+0000fc90: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
 0000fca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fcb0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-0000fcc0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-0000fcd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fce0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-0000fcf0: 2020 2020 2020 2020 2020 2020 2f2f 2054              // T
-0000fd00: 4f44 4f3a 2069 6d70 726f 7665 2063 6865  ODO: improve che
-0000fd10: 636b 0a20 2020 2020 2020 2020 2020 2020  ck.             
-0000fd20: 2020 2020 2020 202f 2f20 666f 7220 6d6f         // for mo
-0000fd30: 6e69 6320 6661 6374 6f72 7320 7765 2063  nic factors we c
-0000fd40: 616e 2064 6f20 2667 3120 2a20 2668 3120  an do &g1 * &h1 
-0000fd50: 213d 2026 7265 7374 2e6c 636f 6566 6628  != &rest.lcoeff(
-0000fd60: 2920 2a20 2672 6573 742e 636f 6566 6669  ) * &rest.coeffi
-0000fd70: 6369 656e 7473 5b30 5d0a 2020 2020 2020  cients[0].      
-0000fd80: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000fd90: 2028 2667 3120 2a20 2668 3129 2e61 6273   (&g1 * &h1).abs
-0000fda0: 2829 203e 2062 6f75 6e64 207b 0a20 2020  () > bound {.   
-0000fdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fdc0: 2020 2020 2063 6f6e 7469 6e75 653b 0a20       continue;. 
-0000fdd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fde0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-0000fdf0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-0000fe00: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-0000fe10: 6720 3d20 7265 7374 2e63 6f6e 7374 616e  g = rest.constan
-0000fe20: 7428 7265 7374 2e6c 636f 6566 6628 2929  t(rest.lcoeff())
-0000fe30: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000fe40: 2020 666f 7220 2869 2c20 6629 2069 6e20    for (i, f) in 
-0000fe50: 6661 6374 6f72 732e 6974 6572 2829 2e65  factors.iter().e
-0000fe60: 6e75 6d65 7261 7465 2829 207b 0a20 2020  numerate() {.   
-0000fe70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe80: 2069 6620 6373 2e63 6f6e 7461 696e 7328   if cs.contains(
-0000fe90: 2669 2920 7b0a 2020 2020 2020 2020 2020  &i) {.          
-0000fea0: 2020 2020 2020 2020 2020 2020 2020 6720                g 
-0000feb0: 3d20 2826 6720 2a20 6629 2e6d 6170 5f63  = (&g * f).map_c
-0000fec0: 6f65 6666 287c 697c 2069 2e73 796d 6d65  oeff(|i| i.symme
-0000fed0: 7472 6963 5f6d 6f64 2826 6d61 785f 7029  tric_mod(&max_p)
-0000fee0: 2c20 496e 7465 6765 7252 696e 673a 3a6e  , IntegerRing::n
-0000fef0: 6577 2829 293b 0a20 2020 2020 2020 2020  ew());.         
-0000ff00: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-0000ff10: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
-0000ff20: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000ff30: 6574 2063 203d 2067 2e63 6f6e 7465 6e74  et c = g.content
-0000ff40: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
-0000ff50: 2020 2020 6720 3d20 672e 6469 765f 636f      g = g.div_co
-0000ff60: 6566 6628 2663 293b 0a0a 2020 2020 2020  eff(&c);..      
-0000ff70: 2020 2020 2020 2020 2020 6c65 7420 2868            let (h
-0000ff80: 2c20 7229 203d 2072 6573 742e 7175 6f74  , r) = rest.quot
-0000ff90: 5f72 656d 2826 672c 2074 7275 6529 3b0a  _rem(&g, true);.
-0000ffa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ffb0: 2069 6620 722e 6973 5f7a 6572 6f28 2920   if r.is_zero() 
-0000ffc0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000ffd0: 2020 2020 2020 2f2f 2073 686f 756c 6420        // should 
-0000ffe0: 616c 7761 7973 2068 6170 7065 6e20 6861  always happen ha
-0000fff0: 7070 656e 2077 6865 6e20 7c67 317c 5f31  ppen when |g1|_1
-00010000: 202a 207c 6831 7c5f 3120 3c3d 2062 6f75   * |h1|_1 <= bou
-00010010: 6e64 0a20 2020 2020 2020 2020 2020 2020  nd.             
-00010020: 2020 2020 2020 2072 6563 5f66 6163 746f         rec_facto
-00010030: 7273 2e70 7573 6828 6729 3b0a 0a20 2020  rs.push(g);..   
+0000fcb0: 2020 202f 2f20 544f 444f 3a20 696d 7072     // TODO: impr
+0000fcc0: 6f76 6520 6368 6563 6b0a 2020 2020 2020  ove check.      
+0000fcd0: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
+0000fce0: 2066 6f72 206d 6f6e 6963 2066 6163 746f   for monic facto
+0000fcf0: 7273 2077 6520 6361 6e20 646f 2026 6731  rs we can do &g1
+0000fd00: 202a 2026 6831 2021 3d20 2672 6573 742e   * &h1 != &rest.
+0000fd10: 6c63 6f65 6666 2829 202a 2026 7265 7374  lcoeff() * &rest
+0000fd20: 2e63 6f65 6666 6963 6965 6e74 735b 305d  .coefficients[0]
+0000fd30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fd40: 2020 2020 2069 6620 2826 6731 202a 2026       if (&g1 * &
+0000fd50: 6831 292e 6162 7328 2920 3e20 626f 756e  h1).abs() > boun
+0000fd60: 6420 7b0a 2020 2020 2020 2020 2020 2020  d {.            
+0000fd70: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+0000fd80: 696e 7565 3b0a 2020 2020 2020 2020 2020  inue;.          
+0000fd90: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+0000fda0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+0000fdb0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000fdc0: 6574 206d 7574 2067 203d 2072 6573 742e  et mut g = rest.
+0000fdd0: 636f 6e73 7461 6e74 2872 6573 742e 6c63  constant(rest.lc
+0000fde0: 6f65 6666 2829 293b 0a20 2020 2020 2020  oeff());.       
+0000fdf0: 2020 2020 2020 2020 2066 6f72 2028 692c           for (i,
+0000fe00: 2066 2920 696e 2066 6163 746f 7273 2e69   f) in factors.i
+0000fe10: 7465 7228 292e 656e 756d 6572 6174 6528  ter().enumerate(
+0000fe20: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+0000fe30: 2020 2020 2020 2020 6966 2063 732e 636f          if cs.co
+0000fe40: 6e74 6169 6e73 2826 6929 207b 0a20 2020  ntains(&i) {.   
+0000fe50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fe60: 2020 2020 2067 203d 2028 2667 202a 2066       g = (&g * f
+0000fe70: 292e 6d61 705f 636f 6566 6628 7c69 7c20  ).map_coeff(|i| 
+0000fe80: 692e 7379 6d6d 6574 7269 635f 6d6f 6428  i.symmetric_mod(
+0000fe90: 266d 6178 5f70 292c 205a 293b 0a20 2020  &max_p), Z);.   
+0000fea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000feb0: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+0000fec0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+0000fed0: 2020 2020 206c 6574 2063 203d 2067 2e63       let c = g.c
+0000fee0: 6f6e 7465 6e74 2829 3b0a 2020 2020 2020  ontent();.      
+0000fef0: 2020 2020 2020 2020 2020 6720 3d20 672e            g = g.
+0000ff00: 6469 765f 636f 6566 6628 2663 293b 0a0a  div_coeff(&c);..
+0000ff10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ff20: 6c65 7420 2868 2c20 7229 203d 2072 6573  let (h, r) = res
+0000ff30: 742e 7175 6f74 5f72 656d 2826 672c 2074  t.quot_rem(&g, t
+0000ff40: 7275 6529 3b0a 0a20 2020 2020 2020 2020  rue);..         
+0000ff50: 2020 2020 2020 2069 6620 722e 6973 5f7a         if r.is_z
+0000ff60: 6572 6f28 2920 7b0a 2020 2020 2020 2020  ero() {.        
+0000ff70: 2020 2020 2020 2020 2020 2020 2f2f 2073              // s
+0000ff80: 686f 756c 6420 616c 7761 7973 2068 6170  hould always hap
+0000ff90: 7065 6e20 6861 7070 656e 2077 6865 6e20  pen happen when 
+0000ffa0: 7c67 317c 5f31 202a 207c 6831 7c5f 3120  |g1|_1 * |h1|_1 
+0000ffb0: 3c3d 2062 6f75 6e64 0a20 2020 2020 2020  <= bound.       
+0000ffc0: 2020 2020 2020 2020 2020 2020 2072 6563               rec
+0000ffd0: 5f66 6163 746f 7273 2e70 7573 6828 6729  _factors.push(g)
+0000ffe0: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
+0000fff0: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+00010000: 6373 2e69 7465 7228 292e 7265 7628 2920  cs.iter().rev() 
+00010010: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00010020: 2020 2020 2020 2020 2020 6661 6374 6f72            factor
+00010030: 732e 7265 6d6f 7665 282a 6929 3b0a 2020  s.remove(*i);.  
 00010040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010050: 2066 6f72 2069 2069 6e20 6373 2e69 7465   for i in cs.ite
-00010060: 7228 292e 7265 7628 2920 7b0a 2020 2020  r().rev() {.    
-00010070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010080: 2020 2020 6661 6374 6f72 732e 7265 6d6f      factors.remo
-00010090: 7665 282a 6929 3b0a 2020 2020 2020 2020  ve(*i);.        
-000100a0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
-000100b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000100c0: 2020 206c 6574 2063 203d 2068 2e63 6f6e     let c = h.con
-000100d0: 7465 6e74 2829 3b0a 2020 2020 2020 2020  tent();.        
-000100e0: 2020 2020 2020 2020 2020 2020 7265 7374              rest
-000100f0: 203d 2068 2e64 6976 5f63 6f65 6666 2826   = h.div_coeff(&
-00010100: 6329 3b0a 0a20 2020 2020 2020 2020 2020  c);..           
-00010110: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-00010120: 6520 276c 656e 3b0a 2020 2020 2020 2020  e 'len;.        
-00010130: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00010140: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00010150: 2020 2020 2073 202b 3d20 313b 0a20 2020       s += 1;.   
-00010160: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-00010170: 7265 635f 6661 6374 6f72 732e 7075 7368  rec_factors.push
-00010180: 2872 6573 7429 3b0a 2020 2020 2020 2020  (rest);.        
-00010190: 7265 635f 6661 6374 6f72 730a 2020 2020  rec_factors.    
-000101a0: 7d0a 0a20 2020 202f 2f2f 204c 6966 7420  }..    /// Lift 
-000101b0: 6120 736f 6c75 7469 6f6e 206f 6620 6070  a solution of `p
-000101c0: 6f6c 7920 e289 a120 6c63 6f65 6666 202a  oly ... lcoeff *
-000101d0: 2075 6e69 7661 7269 6174 655f 6661 6374   univariate_fact
-000101e0: 6f72 7320 6d6f 6420 7920 6d6f 6420 705e  ors mod y mod p^
-000101f0: 6b60 0a20 2020 202f 2f2f 2074 6f20 606d  k`.    /// to `m
-00010200: 6f64 2079 5e69 7465 7261 7469 6f6e 7320  od y^iterations 
-00010210: 6d6f 6420 705e 6b60 2e0a 2020 2020 2f2f  mod p^k`..    //
-00010220: 2f0a 2020 2020 2f2f 2f20 556e 6976 6172  /.    /// Univar
-00010230: 6961 7465 2066 6163 746f 7273 206d 7573  iate factors mus
-00010240: 7420 6265 206d 6f6e 6963 2061 6e64 2060  t be monic and `
-00010250: 6c63 6f65 6666 5f79 3d30 6020 7368 6f75  lcoeff_y=0` shou
-00010260: 6c64 2062 6520 6173 2077 656c 6c2e 0a20  ld be as well.. 
-00010270: 2020 2066 6e20 6269 7661 7269 6174 655f     fn bivariate_
-00010280: 6865 6e73 656c 5f6c 6966 745f 6265 726e  hensel_lift_bern
-00010290: 6172 6469 6e28 0a20 2020 2020 2020 2070  ardin(.        p
-000102a0: 6f6c 793a 2026 4d75 6c74 6976 6172 6961  oly: &Multivaria
-000102b0: 7465 506f 6c79 6e6f 6d69 616c 3c46 696e  tePolynomial<Fin
-000102c0: 6974 6546 6965 6c64 3c49 6e74 6567 6572  iteField<Integer
-000102d0: 3e2c 2045 2c20 4c65 784f 7264 6572 3e2c  >, E, LexOrder>,
-000102e0: 0a20 2020 2020 2020 2069 6e74 6572 706f  .        interpo
-000102f0: 6c61 7469 6f6e 5f76 6172 3a20 7573 697a  lation_var: usiz
-00010300: 652c 0a20 2020 2020 2020 206c 636f 6566  e,.        lcoef
-00010310: 663a 2026 4d75 6c74 6976 6172 6961 7465  f: &Multivariate
-00010320: 506f 6c79 6e6f 6d69 616c 3c46 696e 6974  Polynomial<Finit
-00010330: 6546 6965 6c64 3c49 6e74 6567 6572 3e2c  eField<Integer>,
-00010340: 2045 2c20 4c65 784f 7264 6572 3e2c 0a20   E, LexOrder>,. 
-00010350: 2020 2020 2020 2075 6e69 7661 7269 6174         univariat
-00010360: 655f 6661 6374 6f72 733a 2026 5b4d 756c  e_factors: &[Mul
-00010370: 7469 7661 7269 6174 6550 6f6c 796e 6f6d  tivariatePolynom
-00010380: 6961 6c3c 4669 6e69 7465 4669 656c 643c  ial<FiniteField<
-00010390: 496e 7465 6765 723e 2c20 452c 204c 6578  Integer>, E, Lex
-000103a0: 4f72 6465 723e 5d2c 0a20 2020 2020 2020  Order>],.       
-000103b0: 2069 7465 7261 7469 6f6e 733a 2075 7369   iterations: usi
-000103c0: 7a65 2c0a 2020 2020 2020 2020 703a 2075  ze,.        p: u
-000103d0: 3332 2c0a 2020 2020 2020 2020 6b3a 2075  32,.        k: u
-000103e0: 7369 7a65 2c0a 2020 2020 2920 2d3e 2056  size,.    ) -> V
-000103f0: 6563 3c4d 756c 7469 7661 7269 6174 6550  ec<MultivariateP
-00010400: 6f6c 796e 6f6d 6961 6c3c 4669 6e69 7465  olynomial<Finite
-00010410: 4669 656c 643c 496e 7465 6765 723e 2c20  Field<Integer>, 
-00010420: 452c 204c 6578 4f72 6465 723e 3e20 7b0a  E, LexOrder>> {.
-00010430: 2020 2020 2020 2020 6c65 7420 6669 6e69          let fini
-00010440: 7465 5f66 6965 6c64 203d 2046 696e 6974  te_field = Finit
-00010450: 6546 6965 6c64 3a3a 3c75 3332 3e3a 3a6e  eField::<u32>::n
-00010460: 6577 2870 293b 0a0a 2020 2020 2020 2020  ew(p);..        
-00010470: 2f2f 2061 6464 2074 6865 206c 6561 6469  // add the leadi
-00010480: 6e67 2063 6f65 6666 6963 6965 6e74 2061  ng coefficient a
-00010490: 7320 6120 6669 7273 7420 6661 6374 6f72  s a first factor
-000104a0: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-000104b0: 2066 6163 746f 7273 203d 2076 6563 215b   factors = vec![
-000104c0: 6c63 6f65 6666 2e72 6570 6c61 6365 2869  lcoeff.replace(i
-000104d0: 6e74 6572 706f 6c61 7469 6f6e 5f76 6172  nterpolation_var
-000104e0: 2c20 2670 6f6c 792e 6669 656c 642e 7a65  , &poly.field.ze
-000104f0: 726f 2829 295d 3b0a 0a20 2020 2020 2020  ro())];..       
-00010500: 2066 6f72 2066 2069 6e20 756e 6976 6172   for f in univar
-00010510: 6961 7465 5f66 6163 746f 7273 207b 0a20  iate_factors {. 
-00010520: 2020 2020 2020 2020 2020 2066 6163 746f             facto
-00010530: 7273 2e70 7573 6828 662e 636c 6f6e 6528  rs.push(f.clone(
-00010540: 2929 3b0a 2020 2020 2020 2020 7d0a 0a20  ));.        }.. 
-00010550: 2020 2020 2020 206c 6574 2064 656c 7461         let delta
-00010560: 203d 2053 656c 663a 3a6c 6966 745f 6469   = Self::lift_di
-00010570: 6f70 6861 6e74 696e 655f 756e 6976 6172  ophantine_univar
-00010580: 6961 7465 280a 2020 2020 2020 2020 2020  iate(.          
-00010590: 2020 266d 7574 2066 6163 746f 7273 2c0a    &mut factors,.
-000105a0: 2020 2020 2020 2020 2020 2020 2670 6f6c              &pol
-000105b0: 792e 636f 6e73 7461 6e74 2870 6f6c 792e  y.constant(poly.
-000105c0: 6669 656c 642e 6f6e 6528 2929 2c0a 2020  field.one()),.  
-000105d0: 2020 2020 2020 2020 2020 6669 6e69 7465            finite
-000105e0: 5f66 6965 6c64 2e67 6574 5f70 7269 6d65  _field.get_prime
-000105f0: 2829 2c0a 2020 2020 2020 2020 2020 2020  (),.            
-00010600: 6b2c 0a20 2020 2020 2020 2029 3b0a 0a20  k,.        );.. 
-00010610: 2020 2020 2020 206c 6574 2079 5f70 6f6c         let y_pol
-00010620: 7920 3d20 706f 6c79 2e74 6f5f 756e 6976  y = poly.to_univ
-00010630: 6172 6961 7465 5f70 6f6c 796e 6f6d 6961  ariate_polynomia
-00010640: 6c5f 6c69 7374 2869 6e74 6572 706f 6c61  l_list(interpola
-00010650: 7469 6f6e 5f76 6172 293b 0a0a 2020 2020  tion_var);..    
-00010660: 2020 2020 2f2f 2065 7874 7261 6374 2063      // extract c
-00010670: 6f65 6666 6963 6965 6e74 7320 696e 2079  oefficients in y
-00010680: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-00010690: 2075 3a20 5665 633c 5f3e 203d 2066 6163   u: Vec<_> = fac
-000106a0: 746f 7273 0a20 2020 2020 2020 2020 2020  tors.           
-000106b0: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
-000106c0: 2020 2020 202e 6d61 7028 7c66 7c20 7b0a       .map(|f| {.
-000106d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000106e0: 6c65 7420 6d75 7420 6465 6e73 6520 3d20  let mut dense = 
-000106f0: 7665 6321 5b70 6f6c 792e 7a65 726f 2829  vec![poly.zero()
-00010700: 3b20 6974 6572 6174 696f 6e73 202b 2031  ; iterations + 1
-00010710: 5d3b 0a20 2020 2020 2020 2020 2020 2020  ];.             
-00010720: 2020 2064 656e 7365 5b30 5d20 3d20 662e     dense[0] = f.
-00010730: 636c 6f6e 6528 293b 0a20 2020 2020 2020  clone();.       
-00010740: 2020 2020 2020 2020 2064 656e 7365 0a20           dense. 
-00010750: 2020 2020 2020 2020 2020 207d 290a 2020             }).  
-00010760: 2020 2020 2020 2020 2020 2e63 6f6c 6c65            .colle
-00010770: 6374 2829 3b0a 0a20 2020 2020 2020 202f  ct();..        /
-00010780: 2f20 7570 6461 7465 2074 6865 2066 6972  / update the fir
-00010790: 7374 2070 6f6c 796e 6f6d 6961 6c20 6173  st polynomial as
-000107a0: 2069 7420 6d61 7920 636f 6e74 6169 6e20   it may contain 
-000107b0: 792c 2073 696e 6365 2069 7427 7320 6c63  y, since it's lc
-000107c0: 6f65 6666 0a20 2020 2020 2020 206c 6574  oeff.        let
-000107d0: 2079 5f6c 636f 6566 6620 3d20 6c63 6f65   y_lcoeff = lcoe
-000107e0: 6666 2e74 6f5f 756e 6976 6172 6961 7465  ff.to_univariate
-000107f0: 5f70 6f6c 796e 6f6d 6961 6c5f 6c69 7374  _polynomial_list
-00010800: 2869 6e74 6572 706f 6c61 7469 6f6e 5f76  (interpolation_v
-00010810: 6172 293b 0a20 2020 2020 2020 2066 6f72  ar);.        for
-00010820: 2028 702c 2065 2920 696e 2079 5f6c 636f   (p, e) in y_lco
-00010830: 6566 6620 7b0a 2020 2020 2020 2020 2020  eff {.          
-00010840: 2020 755b 305d 5b65 2e74 6f5f 7533 3228    u[0][e.to_u32(
-00010850: 2920 6173 2075 7369 7a65 5d20 3d20 703b  ) as usize] = p;
-00010860: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-00010870: 2020 2020 6c65 7420 6d75 7420 7020 3d20      let mut p = 
-00010880: 752e 636c 6f6e 6528 293b 0a20 2020 2020  u.clone();.     
-00010890: 2020 206c 6574 206d 7574 2063 7572 5f70     let mut cur_p
-000108a0: 203d 2070 5b30 5d5b 305d 2e63 6c6f 6e65   = p[0][0].clone
-000108b0: 2829 3b0a 2020 2020 2020 2020 666f 7220  ();.        for 
-000108c0: 7820 696e 2026 6d75 7420 702e 6974 6572  x in &mut p.iter
-000108d0: 5f6d 7574 2829 2e73 6b69 7028 3129 207b  _mut().skip(1) {
-000108e0: 0a20 2020 2020 2020 2020 2020 2063 7572  .            cur
-000108f0: 5f70 203d 2063 7572 5f70 202a 2026 785b  _p = cur_p * &x[
-00010900: 305d 3b0a 2020 2020 2020 2020 2020 2020  0];.            
-00010910: 785b 305d 203d 2063 7572 5f70 2e63 6c6f  x[0] = cur_p.clo
-00010920: 6e65 2829 3b0a 2020 2020 2020 2020 7d0a  ne();.        }.
-00010930: 0a20 2020 2020 2020 2066 6f72 206b 2069  .        for k i
-00010940: 6e20 312e 2e69 7465 7261 7469 6f6e 7320  n 1..iterations 
-00010950: 7b0a 2020 2020 2020 2020 2020 2020 2f2f  {.            //
-00010960: 2065 7874 7261 6374 2074 6865 2063 6f65   extract the coe
-00010970: 6666 6963 6965 6e74 2072 6571 7569 7265  fficient require
-00010980: 6420 746f 2063 6f6d 7075 7465 2074 6865  d to compute the
-00010990: 2065 7272 6f72 2069 6e20 795e 6b0a 2020   error in y^k.  
-000109a0: 2020 2020 2020 2020 2020 2f2f 2063 6f6d            // com
-000109b0: 7075 7465 6420 7573 696e 6720 6120 636f  puted using a co
-000109c0: 6e76 6f6c 7574 696f 6e0a 2020 2020 2020  nvolution.      
-000109d0: 2020 2020 2020 705b 305d 5b6b 5d20 3d20        p[0][k] = 
-000109e0: 755b 305d 5b6b 5d2e 636c 6f6e 6528 293b  u[0][k].clone();
-000109f0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00010a00: 2069 2069 6e20 312e 2e66 6163 746f 7273   i in 1..factors
-00010a10: 2e6c 656e 2829 207b 0a20 2020 2020 2020  .len() {.       
-00010a20: 2020 2020 2020 2020 2066 6f72 206a 2069           for j i
-00010a30: 6e20 302e 2e6b 207b 0a20 2020 2020 2020  n 0..k {.       
-00010a40: 2020 2020 2020 2020 2020 2020 2070 5b69               p[i
-00010a50: 5d5b 6b5d 203d 2026 705b 695d 5b6b 5d20  ][k] = &p[i][k] 
-00010a60: 2b20 2628 2670 5b69 202d 2031 5d5b 6b20  + &(&p[i - 1][k 
-00010a70: 2d20 6a5d 202a 2026 755b 695d 5b6a 5d29  - j] * &u[i][j])
-00010a80: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00010a90: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-00010aa0: 7d0a 0a20 2020 2020 2020 2020 2020 202f  }..            /
-00010ab0: 2f20 6669 6e64 2074 6865 206b 7468 2070  / find the kth p
-00010ac0: 6f77 6572 206f 6620 7920 696e 2066 0a20  ower of y in f. 
-00010ad0: 2020 2020 2020 2020 2020 202f 2f20 7369             // si
-00010ae0: 6e63 6520 7765 2063 6f6d 7075 7465 2074  nce we compute t
-00010af0: 6865 2065 7272 6f72 2070 6572 2070 6f77  he error per pow
-00010b00: 6572 206f 6620 792c 2077 6520 6361 6e6e  er of y, we cann
-00010b10: 6f74 2073 746f 7020 6f6e 2061 2030 2065  ot stop on a 0 e
-00010b20: 7272 6f72 0a20 2020 2020 2020 2020 2020  rror.           
-00010b30: 206c 6574 2065 203d 2069 6620 6c65 7420   let e = if let 
-00010b40: 536f 6d65 2828 762c 205f 2929 203d 2079  Some((v, _)) = y
-00010b50: 5f70 6f6c 792e 6974 6572 2829 2e66 696e  _poly.iter().fin
-00010b60: 6428 7c65 7c20 652e 312e 746f 5f75 3332  d(|e| e.1.to_u32
-00010b70: 2829 2061 7320 7573 697a 6520 3d3d 206b  () as usize == k
-00010b80: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00010b90: 2020 2020 7620 2d20 2670 2e6c 6173 7428      v - &p.last(
-00010ba0: 292e 756e 7772 6170 2829 5b6b 5d0a 2020  ).unwrap()[k].  
-00010bb0: 2020 2020 2020 2020 2020 7d20 656c 7365            } else
-00010bc0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00010bd0: 2020 202d 702e 6c61 7374 2829 2e75 6e77     -p.last().unw
-00010be0: 7261 7028 295b 6b5d 2e63 6c6f 6e65 2829  rap()[k].clone()
-00010bf0: 0a20 2020 2020 2020 2020 2020 207d 3b0a  .            };.
-00010c00: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00010c10: 652e 6973 5f7a 6572 6f28 2920 7b0a 2020  e.is_zero() {.  
-00010c20: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00010c30: 6e74 696e 7565 3b0a 2020 2020 2020 2020  ntinue;.        
-00010c40: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
-00010c50: 2020 2066 6f72 2028 2864 702c 2066 292c     for ((dp, f),
-00010c60: 2064 2920 696e 2075 2e69 7465 725f 6d75   d) in u.iter_mu
-00010c70: 7428 292e 7a69 7028 6661 6374 6f72 732e  t().zip(factors.
-00010c80: 6974 6572 2829 292e 7a69 7028 2664 656c  iter()).zip(&del
-00010c90: 7461 2920 7b0a 2020 2020 2020 2020 2020  ta) {.          
-00010ca0: 2020 2020 2020 6470 5b6b 5d20 3d20 2664        dp[k] = &d
-00010cb0: 705b 6b5d 202b 2026 2864 202a 2026 6529  p[k] + &(d * &e)
-00010cc0: 2e71 756f 745f 7265 6d5f 756e 6976 6172  .quot_rem_univar
-00010cd0: 6961 7465 5f6d 6f6e 6963 2866 292e 313b  iate_monic(f).1;
-00010ce0: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
-00010cf0: 2020 2020 2020 2020 2020 2020 2f2f 2075              // u
-00010d00: 7064 6174 6520 7468 6520 636f 6566 6669  pdate the coeffi
-00010d10: 6369 656e 7473 2077 6974 6820 7468 6520  cients with the 
-00010d20: 6e65 7720 795e 6b20 636f 6e74 7269 6275  new y^k contribu
-00010d30: 7469 6f6e 730a 2020 2020 2020 2020 2020  tions.          
-00010d40: 2020 2f2f 206e 6f74 6520 7468 6174 2074    // note that t
-00010d50: 6865 206c 636f 6566 665b 6b5d 2063 6f6e  he lcoeff[k] con
-00010d60: 7472 6962 7574 696f 6e20 6973 206e 6f74  tribution is not
-00010d70: 206e 6577 0a20 2020 2020 2020 2020 2020   new.           
-00010d80: 206c 6574 206d 7574 2074 203d 2070 6f6c   let mut t = pol
-00010d90: 792e 7a65 726f 2829 3b0a 2020 2020 2020  y.zero();.      
-00010da0: 2020 2020 2020 666f 7220 6920 696e 2031        for i in 1
-00010db0: 2e2e 6661 6374 6f72 732e 6c65 6e28 2920  ..factors.len() 
-00010dc0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00010dd0: 2020 7420 3d20 2675 5b69 5d5b 305d 202a    t = &u[i][0] *
-00010de0: 2026 7420 2b20 2675 5b69 5d5b 6b5d 202a   &t + &u[i][k] *
-00010df0: 2026 705b 6920 2d20 315d 5b30 5d3b 0a20   &p[i - 1][0];. 
-00010e00: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00010e10: 5b69 5d5b 6b5d 203d 2026 705b 695d 5b6b  [i][k] = &p[i][k
-00010e20: 5d20 2b20 2674 3b0a 2020 2020 2020 2020  ] + &t;.        
-00010e30: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
-00010e40: 0a20 2020 2020 2020 202f 2f20 636f 6e76  .        // conv
-00010e50: 6572 7420 6465 6e73 6520 706f 6c79 6e6f  ert dense polyno
-00010e60: 6d69 616c 7320 746f 206d 756c 7469 7661  mials to multiva
-00010e70: 7269 6174 6520 706f 6c79 6e6f 6d69 616c  riate polynomial
-00010e80: 730a 2020 2020 2020 2020 752e 696e 746f  s.        u.into
-00010e90: 5f69 7465 7228 290a 2020 2020 2020 2020  _iter().        
-00010ea0: 2020 2020 2e6d 6170 287c 7473 7c20 7b0a      .map(|ts| {.
-00010eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010ec0: 6c65 7420 6d75 7420 6e65 775f 706f 6c79  let mut new_poly
-00010ed0: 203d 2070 6f6c 792e 7a65 726f 5f77 6974   = poly.zero_wit
-00010ee0: 685f 6361 7061 6369 7479 2874 732e 6c65  h_capacity(ts.le
-00010ef0: 6e28 2929 3b0a 2020 2020 2020 2020 2020  n());.          
-00010f00: 2020 2020 2020 666f 7220 2869 2c20 6d75        for (i, mu
-00010f10: 7420 6629 2069 6e20 7473 2e69 6e74 6f5f  t f) in ts.into_
-00010f20: 6974 6572 2829 2e65 6e75 6d65 7261 7465  iter().enumerate
-00010f30: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00010f40: 2020 2020 2020 2020 2066 6f72 2078 2069           for x i
-00010f50: 6e20 662e 6578 706f 6e65 6e74 732e 6368  n f.exponents.ch
-00010f60: 756e 6b73 5f6d 7574 2866 2e6e 7661 7273  unks_mut(f.nvars
-00010f70: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00010f80: 2020 2020 2020 2020 2020 2020 785b 696e              x[in
-00010f90: 7465 7270 6f6c 6174 696f 6e5f 7661 725d  terpolation_var]
-00010fa0: 203d 2045 3a3a 6672 6f6d 5f75 3332 2869   = E::from_u32(i
-00010fb0: 2061 7320 7533 3229 3b0a 2020 2020 2020   as u32);.      
-00010fc0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-00010fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010fe0: 2020 2020 6e65 775f 706f 6c79 203d 206e      new_poly = n
-00010ff0: 6577 5f70 6f6c 7920 2b20 663b 0a20 2020  ew_poly + f;.   
-00011000: 2020 2020 2020 2020 2020 2020 207d 0a0a               }..
-00011010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011020: 6e65 775f 706f 6c79 0a20 2020 2020 2020  new_poly.       
-00011030: 2020 2020 207d 290a 2020 2020 2020 2020       }).        
-00011040: 2020 2020 2e63 6f6c 6c65 6374 2829 0a20      .collect(). 
-00011050: 2020 207d 0a0a 2020 2020 2f2f 2f20 4661     }..    /// Fa
-00011060: 6374 6f72 2061 2073 7175 6172 652d 6672  ctor a square-fr
-00011070: 6565 2062 6976 6172 6961 7465 2070 6f6c  ee bivariate pol
-00011080: 796e 6f6d 6961 6c20 6f76 6572 2074 6865  ynomial over the
-00011090: 2069 6e74 6567 6572 732e 0a20 2020 2066   integers..    f
-000110a0: 6e20 6269 7661 7269 6174 655f 6661 6374  n bivariate_fact
-000110b0: 6f72 5f72 6563 6f6e 7374 7275 6374 2826  or_reconstruct(&
-000110c0: 7365 6c66 2c20 6d61 696e 5f76 6172 3a20  self, main_var: 
-000110d0: 7573 697a 652c 2069 6e74 6572 706f 6c61  usize, interpola
-000110e0: 7469 6f6e 5f76 6172 3a20 7573 697a 6529  tion_var: usize)
-000110f0: 202d 3e20 5665 633c 5365 6c66 3e20 7b0a   -> Vec<Self> {.
-00011100: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00011110: 6269 7661 7269 6174 655f 6972 7265 6475  bivariate_irredu
-00011120: 6369 6269 6c69 7479 5f74 6573 7428 2920  cibility_test() 
-00011130: 7b0a 2020 2020 2020 2020 2020 2020 7265  {.            re
-00011140: 7475 726e 2076 6563 215b 7365 6c66 2e63  turn vec![self.c
-00011150: 6c6f 6e65 2829 5d3b 0a20 2020 2020 2020  lone()];.       
-00011160: 207d 0a0a 2020 2020 2020 2020 6c65 7420   }..        let 
-00011170: 6432 203d 2073 656c 662e 6465 6772 6565  d2 = self.degree
-00011180: 2869 6e74 6572 706f 6c61 7469 6f6e 5f76  (interpolation_v
-00011190: 6172 292e 746f 5f75 3332 2829 3b0a 0a20  ar).to_u32();.. 
-000111a0: 2020 2020 2020 202f 2f20 7365 6c65 6374         // select
-000111b0: 2061 2073 7569 7461 626c 6520 6576 616c   a suitable eval
-000111c0: 7561 7469 6f6e 2070 6f69 6e74 2c20 6173  uation point, as
-000111d0: 2073 6d61 6c6c 2061 7320 706f 7373 6962   small as possib
-000111e0: 6c65 2061 7320 746f 206e 6f74 2063 6861  le as to not cha
-000111f0: 6e67 6520 7468 6520 636f 6566 6669 6369  nge the coeffici
-00011200: 656e 7420 626f 756e 640a 2020 2020 2020  ent bound.      
-00011210: 2020 6c65 7420 6d75 7420 7361 6d70 6c65    let mut sample
-00011220: 5f70 6f69 6e74 3b0a 2020 2020 2020 2020  _point;.        
-00011230: 6c65 7420 6d75 7420 756e 695f 663b 0a20  let mut uni_f;. 
-00011240: 2020 2020 2020 206c 6574 206d 7574 2069         let mut i
-00011250: 203d 2030 7536 343b 0a20 2020 2020 2020   = 0u64;.       
-00011260: 206c 6f6f 7020 7b0a 2020 2020 2020 2020   loop {.        
-00011270: 2020 2020 7361 6d70 6c65 5f70 6f69 6e74      sample_point
-00011280: 203d 2069 2e69 6e74 6f28 293b 0a20 2020   = i.into();.   
-00011290: 2020 2020 2020 2020 2075 6e69 5f66 203d           uni_f =
-000112a0: 2073 656c 662e 7265 706c 6163 6528 696e   self.replace(in
-000112b0: 7465 7270 6f6c 6174 696f 6e5f 7661 722c  terpolation_var,
-000112c0: 2026 7361 6d70 6c65 5f70 6f69 6e74 293b   &sample_point);
-000112d0: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-000112e0: 2073 656c 662e 6465 6772 6565 286d 6169   self.degree(mai
-000112f0: 6e5f 7661 7229 203d 3d20 756e 695f 662e  n_var) == uni_f.
-00011300: 6465 6772 6565 286d 6169 6e5f 7661 7229  degree(main_var)
-00011310: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011320: 2026 2620 756e 695f 662e 6763 6428 2675   && uni_f.gcd(&u
-00011330: 6e69 5f66 2e64 6572 6976 6174 6976 6528  ni_f.derivative(
-00011340: 6d61 696e 5f76 6172 2929 2e69 735f 636f  main_var)).is_co
-00011350: 6e73 7461 6e74 2829 0a20 2020 2020 2020  nstant().       
-00011360: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
-00011370: 2020 2020 2020 2062 7265 616b 3b0a 2020         break;.  
-00011380: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
-00011390: 2020 2020 2020 2020 2069 202b 3d20 313b           i += 1;
-000113a0: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-000113b0: 2020 2020 2f2f 2066 6163 746f 7220 7468      // factor th
-000113c0: 6520 756e 6976 6172 6961 7465 2070 6f6c  e univariate pol
-000113d0: 796e 6f6d 6961 6c0a 2020 2020 2020 2020  ynomial.        
-000113e0: 6c65 7420 6d75 7420 756e 695f 6673 3a20  let mut uni_fs: 
-000113f0: 5665 633c 5f3e 203d 2075 6e69 5f66 0a20  Vec<_> = uni_f. 
-00011400: 2020 2020 2020 2020 2020 202e 6661 6374             .fact
-00011410: 6f72 2829 0a20 2020 2020 2020 2020 2020  or().           
-00011420: 202e 696e 746f 5f69 7465 7228 290a 2020   .into_iter().  
-00011430: 2020 2020 2020 2020 2020 2e6d 6170 287c            .map(|
-00011440: 2866 2c20 7029 7c20 7b0a 2020 2020 2020  (f, p)| {.      
-00011450: 2020 2020 2020 2020 2020 6465 6275 675f            debug_
-00011460: 6173 7365 7274 5f65 7121 2870 2c20 3129  assert_eq!(p, 1)
-00011470: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00011480: 2020 660a 2020 2020 2020 2020 2020 2020    f.            
-00011490: 7d29 0a20 2020 2020 2020 2020 2020 202e  }).            .
-000114a0: 636f 6c6c 6563 7428 293b 0a0a 2020 2020  collect();..    
-000114b0: 2020 2020 2f2f 2073 7472 6970 2070 6f74      // strip pot
-000114c0: 656e 7469 616c 2063 6f6e 7465 6e74 0a20  ential content. 
-000114d0: 2020 2020 2020 2075 6e69 5f66 732e 7265         uni_fs.re
-000114e0: 7461 696e 5f6d 7574 287c 667c 2021 662e  tain_mut(|f| !f.
-000114f0: 6973 5f63 6f6e 7374 616e 7428 2929 3b0a  is_constant());.
-00011500: 0a20 2020 2020 2020 202f 2f20 7365 6c65  .        // sele
-00011510: 6374 2061 2073 7569 7461 626c 6520 7072  ct a suitable pr
-00011520: 696d 650a 2020 2020 2020 2020 2f2f 2077  ime.        // w
-00011530: 6520 7472 7920 736d 616c 6c20 7072 696d  e try small prim
-00011540: 6573 2066 6972 7374 2061 7320 7468 6520  es first as the 
-00011550: 6469 7374 696e 6374 2061 6e64 2065 7175  distinct and equ
-00011560: 616c 2064 6567 7265 6520 616c 676f 7269  al degree algori
-00011570: 7468 6d73 0a20 2020 2020 2020 202f 2f20  thms.        // 
-00011580: 7363 616c 6520 6173 206c 6f67 2870 290a  scale as log(p).
-00011590: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-000115a0: 7069 203d 2050 7269 6d65 4974 6572 6174  pi = PrimeIterat
-000115b0: 6f72 5536 343a 3a6e 6577 2831 3031 293b  orU64::new(101);
-000115c0: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
-000115d0: 2066 6965 6c64 3b0a 2020 2020 2020 2020   field;.        
-000115e0: 276e 6577 5f70 7269 6d65 3a20 6c6f 6f70  'new_prime: loop
-000115f0: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
-00011600: 202b 3d20 313b 0a0a 2020 2020 2020 2020   += 1;..        
-00011610: 2020 2020 6c65 7420 7020 3d20 7069 2e6e      let p = pi.n
-00011620: 6578 7428 292e 756e 7772 6170 2829 3b0a  ext().unwrap();.
-00011630: 2020 2020 2020 2020 2020 2020 6966 2070              if p
-00011640: 203e 2075 3332 3a3a 4d41 5820 6173 2075   > u32::MAX as u
-00011650: 3634 207b 0a20 2020 2020 2020 2020 2020  64 {.           
-00011660: 2020 2020 2070 616e 6963 2128 2252 616e       panic!("Ran
-00011670: 206f 7574 206f 6620 7072 696d 6573 2064   out of primes d
-00011680: 7572 696e 6720 6661 6374 6f72 697a 6174  uring factorizat
-00011690: 696f 6e20 6f66 207b 7d22 2c20 7365 6c66  ion of {}", self
-000116a0: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
-000116b0: 0a20 2020 2020 2020 2020 2020 206c 6574  .            let
-000116c0: 2070 203d 2070 2061 7320 7533 323b 0a0a   p = p as u32;..
-000116d0: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-000116e0: 2675 6e69 5f66 2e6c 636f 6566 6628 2920  &uni_f.lcoeff() 
-000116f0: 2520 2649 6e74 6567 6572 3a3a 4e61 7475  % &Integer::Natu
-00011700: 7261 6c28 7020 6173 2069 3634 2929 2e69  ral(p as i64)).i
-00011710: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
-00011720: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00011730: 6e75 653b 0a20 2020 2020 2020 2020 2020  nue;.           
-00011740: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
-00011750: 6669 656c 6420 3d20 4669 6e69 7465 4669  field = FiniteFi
-00011760: 656c 643a 3a3c 7533 323e 3a3a 6e65 7728  eld::<u32>::new(
-00011770: 7029 3b0a 0a20 2020 2020 2020 2020 2020  p);..           
-00011780: 202f 2f20 6d61 6b65 2073 7572 6520 7468   // make sure th
-00011790: 6520 6661 6374 6f72 7320 7374 6179 2063  e factors stay c
-000117a0: 6f70 7269 6d65 0a20 2020 2020 2020 2020  oprime.         
-000117b0: 2020 206c 6574 2066 735f 703a 2056 6563     let fs_p: Vec
-000117c0: 3c5f 3e20 3d20 756e 695f 6673 0a20 2020  <_> = uni_fs.   
-000117d0: 2020 2020 2020 2020 2020 2020 202e 6974               .it
-000117e0: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
-000117f0: 2020 2020 202e 6d61 7028 7c66 7c20 662e       .map(|f| f.
-00011800: 6d61 705f 636f 6566 6628 7c63 7c20 632e  map_coeff(|c| c.
-00011810: 746f 5f66 696e 6974 655f 6669 656c 6428  to_finite_field(
-00011820: 2666 6965 6c64 292c 2066 6965 6c64 2e63  &field), field.c
-00011830: 6c6f 6e65 2829 2929 0a20 2020 2020 2020  lone())).       
-00011840: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-00011850: 7428 293b 0a0a 2020 2020 2020 2020 2020  t();..          
-00011860: 2020 666f 7220 286a 2c20 6629 2069 6e20    for (j, f) in 
-00011870: 6673 5f70 2e69 7465 7228 292e 656e 756d  fs_p.iter().enum
-00011880: 6572 6174 6528 2920 7b0a 2020 2020 2020  erate() {.      
-00011890: 2020 2020 2020 2020 2020 666f 7220 6720            for g 
-000118a0: 696e 2026 6673 5f70 5b6a 202b 2031 2e2e  in &fs_p[j + 1..
-000118b0: 5d20 7b0a 2020 2020 2020 2020 2020 2020  ] {.            
-000118c0: 2020 2020 2020 2020 6966 2021 662e 6763          if !f.gc
-000118d0: 6428 6729 2e69 735f 6f6e 6528 2920 7b0a  d(g).is_one() {.
-000118e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000118f0: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
-00011900: 2027 6e65 775f 7072 696d 653b 0a20 2020   'new_prime;.   
-00011910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011920: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
-00011930: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00011940: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
-00011950: 6272 6561 6b3b 0a20 2020 2020 2020 207d  break;.        }
-00011960: 0a0a 2020 2020 2020 2020 6c65 7420 7368  ..        let sh
-00011970: 6966 7465 645f 706f 6c79 203d 2069 6620  ifted_poly = if 
-00011980: 2173 616d 706c 655f 706f 696e 742e 6973  !sample_point.is
-00011990: 5f7a 6572 6f28 2920 7b0a 2020 2020 2020  _zero() {.      
-000119a0: 2020 2020 2020 7365 6c66 2e73 6869 6674        self.shift
-000119b0: 5f76 6172 2869 6e74 6572 706f 6c61 7469  _var(interpolati
-000119c0: 6f6e 5f76 6172 2c20 2673 616d 706c 655f  on_var, &sample_
-000119d0: 706f 696e 7429 0a20 2020 2020 2020 207d  point).        }
-000119e0: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
-000119f0: 2020 2020 7365 6c66 2e63 6c6f 6e65 2829      self.clone()
-00011a00: 0a20 2020 2020 2020 207d 3b0a 0a20 2020  .        };..   
-00011a10: 2020 2020 202f 2f20 544f 444f 3a20 6966       // TODO: if
-00011a20: 2062 6f75 6e64 2069 7320 6c65 7373 2074   bound is less t
-00011a30: 6861 6e20 7536 342c 2077 6520 6d61 7920  han u64, we may 
-00011a40: 616c 736f 2075 7365 2046 696e 6974 6546  also use FiniteF
-00011a50: 6965 6c64 3c75 3634 3e20 666f 7220 7468  ield<u64> for th
-00011a60: 6520 636f 6d70 7574 6174 696f 6e0a 2020  e computation.  
-00011a70: 2020 2020 2020 6c65 7420 626f 756e 6420        let bound 
-00011a80: 3d20 7368 6966 7465 645f 706f 6c79 2e63  = shifted_poly.c
-00011a90: 6f65 6666 6963 6965 6e74 5f62 6f75 6e64  oefficient_bound
-00011aa0: 2829 3b0a 0a20 2020 2020 2020 206c 6574  ();..        let
-00011ab0: 2070 203d 2049 6e74 6567 6572 3a3a 6672   p = Integer::fr
-00011ac0: 6f6d 2866 6965 6c64 2e67 6574 5f70 7269  om(field.get_pri
-00011ad0: 6d65 2829 2e74 6f5f 7536 3428 2929 3b0a  me().to_u64());.
-00011ae0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
-00011af0: 6d61 785f 7020 3d20 702e 636c 6f6e 6528  max_p = p.clone(
-00011b00: 293b 0a20 2020 2020 2020 206c 6574 206d  );.        let m
-00011b10: 7574 206b 203d 2031 3b0a 2020 2020 2020  ut k = 1;.      
-00011b20: 2020 7768 696c 6520 266d 6178 5f70 202a    while &max_p *
-00011b30: 2032 203c 2062 6f75 6e64 207b 0a20 2020   2 < bound {.   
-00011b40: 2020 2020 2020 2020 206d 6178 5f70 203d           max_p =
-00011b50: 2026 6d61 785f 7020 2a20 2670 3b0a 2020   &max_p * &p;.  
-00011b60: 2020 2020 2020 2020 2020 6b20 2b3d 2031            k += 1
-00011b70: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
-00011b80: 2020 2020 206c 6574 206d 6f64 5f66 6965       let mod_fie
-00011b90: 6c64 203d 2046 696e 6974 6546 6965 6c64  ld = FiniteField
-00011ba0: 3a3a 3c49 6e74 6567 6572 3e3a 3a6e 6577  ::<Integer>::new
-00011bb0: 286d 6178 5f70 2e63 6c6f 6e65 2829 293b  (max_p.clone());
-00011bc0: 0a0a 2020 2020 2020 2020 2f2f 206d 616b  ..        // mak
-00011bd0: 6520 616c 6c20 6661 6374 6f72 7320 6d6f  e all factors mo
-00011be0: 6e69 632c 2074 6869 7320 6973 2070 6f73  nic, this is pos
-00011bf0: 7369 626c 6520 7369 6e63 6520 7468 6520  sible since the 
-00011c00: 6c63 6f65 6666 2069 7320 696e 7665 7274  lcoeff is invert
-00011c10: 6962 6c65 206d 6f64 2070 5e6b 0a20 2020  ible mod p^k.   
-00011c20: 2020 2020 206c 6574 2075 6e69 5f66 735f       let uni_fs_
-00011c30: 6d6f 643a 2056 6563 3c5f 3e20 3d20 756e  mod: Vec<_> = un
-00011c40: 695f 6673 0a20 2020 2020 2020 2020 2020  i_fs.           
-00011c50: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
-00011c60: 2020 2020 202e 6d61 7028 7c66 7c20 7b0a       .map(|f| {.
-00011c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011c80: 6c65 7420 6631 203d 2066 2e6d 6170 5f63  let f1 = f.map_c
-00011c90: 6f65 6666 287c 637c 206d 6f64 5f66 6965  oeff(|c| mod_fie
-00011ca0: 6c64 2e74 6f5f 656c 656d 656e 7428 632e  ld.to_element(c.
-00011cb0: 636c 6f6e 6528 2929 2c20 6d6f 645f 6669  clone()), mod_fi
-00011cc0: 656c 642e 636c 6f6e 6528 2929 3b0a 2020  eld.clone());.  
-00011cd0: 2020 2020 2020 2020 2020 2020 2020 6631                f1
-00011ce0: 2e6d 616b 655f 6d6f 6e69 6328 290a 2020  .make_monic().  
-00011cf0: 2020 2020 2020 2020 2020 7d29 0a20 2020            }).   
-00011d00: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-00011d10: 7428 293b 0a0a 2020 2020 2020 2020 6c65  t();..        le
-00011d20: 7420 6d75 7420 665f 6d6f 6420 3d20 7368  t mut f_mod = sh
-00011d30: 6966 7465 645f 706f 6c79 2e6d 6170 5f63  ifted_poly.map_c
-00011d40: 6f65 6666 287c 637c 2063 2e73 796d 6d65  oeff(|c| c.symme
-00011d50: 7472 6963 5f6d 6f64 2826 6d61 785f 7029  tric_mod(&max_p)
-00011d60: 2c20 6d6f 645f 6669 656c 642e 636c 6f6e  , mod_field.clon
-00011d70: 6528 2929 3b0a 0a20 2020 2020 2020 202f  e());..        /
-00011d80: 2f20 6d61 6b65 2073 7572 6520 7468 6520  / make sure the 
-00011d90: 6c63 6f65 6666 2069 7320 6d6f 6e69 6320  lcoeff is monic 
-00011da0: 6174 2079 3d30 0a20 2020 2020 2020 206c  at y=0.        l
-00011db0: 6574 2069 6e76 5f63 6f65 6666 203d 206d  et inv_coeff = m
-00011dc0: 6f64 5f66 6965 6c64 2e69 6e76 2826 756e  od_field.inv(&un
-00011dd0: 695f 662e 6c63 6f65 6666 2829 293b 0a20  i_f.lcoeff());. 
-00011de0: 2020 2020 2020 206c 6574 2066 5f6d 6f64         let f_mod
-00011df0: 5f6d 6f6e 6963 203d 2066 5f6d 6f64 2e63  _monic = f_mod.c
-00011e00: 6c6f 6e65 2829 2e6d 756c 5f63 6f65 6666  lone().mul_coeff
-00011e10: 2869 6e76 5f63 6f65 6666 293b 0a20 2020  (inv_coeff);.   
-00011e20: 2020 2020 206c 6574 206c 636f 6566 665f       let lcoeff_
-00011e30: 6d6f 6e69 6320 3d20 665f 6d6f 645f 6d6f  monic = f_mod_mo
-00011e40: 6e69 632e 6c63 6f65 6666 5f6c 6173 745f  nic.lcoeff_last_
-00011e50: 7661 726f 7264 6572 2826 5b6d 6169 6e5f  varorder(&[main_
-00011e60: 7661 722c 2069 6e74 6572 706f 6c61 7469  var, interpolati
-00011e70: 6f6e 5f76 6172 5d29 3b0a 0a20 2020 2020  on_var]);..     
-00011e80: 2020 206c 6574 206d 7574 2066 6163 746f     let mut facto
-00011e90: 7273 203d 2053 656c 663a 3a62 6976 6172  rs = Self::bivar
-00011ea0: 6961 7465 5f68 656e 7365 6c5f 6c69 6674  iate_hensel_lift
-00011eb0: 5f62 6572 6e61 7264 696e 280a 2020 2020  _bernardin(.    
-00011ec0: 2020 2020 2020 2020 2666 5f6d 6f64 5f6d          &f_mod_m
-00011ed0: 6f6e 6963 2c0a 2020 2020 2020 2020 2020  onic,.          
-00011ee0: 2020 696e 7465 7270 6f6c 6174 696f 6e5f    interpolation_
-00011ef0: 7661 722c 0a20 2020 2020 2020 2020 2020  var,.           
-00011f00: 2026 6c63 6f65 6666 5f6d 6f6e 6963 2c0a   &lcoeff_monic,.
-00011f10: 2020 2020 2020 2020 2020 2020 2675 6e69              &uni
-00011f20: 5f66 735f 6d6f 642c 0a20 2020 2020 2020  _fs_mod,.       
-00011f30: 2020 2020 2028 6432 202b 2031 2920 6173       (d2 + 1) as
-00011f40: 2075 7369 7a65 2c0a 2020 2020 2020 2020   usize,.        
-00011f50: 2020 2020 6669 656c 642e 6765 745f 7072      field.get_pr
-00011f60: 696d 6528 292c 0a20 2020 2020 2020 2020  ime(),.         
-00011f70: 2020 206b 2c0a 2020 2020 2020 2020 293b     k,.        );
-00011f80: 0a0a 2020 2020 2020 2020 6661 6374 6f72  ..        factor
-00011f90: 732e 7377 6170 5f72 656d 6f76 6528 3029  s.swap_remove(0)
-00011fa0: 3b20 2f2f 2072 656d 6f76 6520 7468 6520  ; // remove the 
-00011fb0: 6c63 6f65 6666 0a0a 2020 2020 2020 2020  lcoeff..        
-00011fc0: 6c65 7420 6d75 7420 7265 635f 6661 6374  let mut rec_fact
-00011fd0: 6f72 7320 3d20 7665 6321 5b5d 3b0a 2020  ors = vec![];.  
-00011fe0: 2020 2020 2020 2f2f 2066 6163 746f 7220        // factor 
-00011ff0: 7265 636f 6d62 696e 6174 696f 6e0a 2020  recombination.  
-00012000: 2020 2020 2020 6c65 7420 6d75 7420 7320        let mut s 
-00012010: 3d20 313b 0a0a 2020 2020 2020 2020 6c65  = 1;..        le
-00012020: 7420 6d75 7420 6c63 6f65 6666 203d 2066  t mut lcoeff = f
-00012030: 5f6d 6f64 2e6c 636f 6566 665f 6c61 7374  _mod.lcoeff_last
-00012040: 5f76 6172 6f72 6465 7228 265b 6d61 696e  _varorder(&[main
-00012050: 5f76 6172 2c20 696e 7465 7270 6f6c 6174  _var, interpolat
-00012060: 696f 6e5f 7661 725d 293b 0a20 2020 2020  ion_var]);.     
-00012070: 2020 206c 6574 206d 7574 2072 6573 7420     let mut rest 
-00012080: 3d20 7368 6966 7465 645f 706f 6c79 3b0a  = shifted_poly;.
-00012090: 2020 2020 2020 2020 276c 656e 3a20 7768          'len: wh
-000120a0: 696c 6520 3220 2a20 7320 3c3d 2066 6163  ile 2 * s <= fac
-000120b0: 746f 7273 2e6c 656e 2829 207b 0a20 2020  tors.len() {.   
-000120c0: 2020 2020 2020 2020 206c 6574 206d 7574           let mut
-000120d0: 2066 7320 3d20 436f 6d62 696e 6174 696f   fs = Combinatio
-000120e0: 6e49 7465 7261 746f 723a 3a6e 6577 2866  nIterator::new(f
-000120f0: 6163 746f 7273 2e6c 656e 2829 2c20 7329  actors.len(), s)
-00012100: 3b0a 2020 2020 2020 2020 2020 2020 7768  ;.            wh
-00012110: 696c 6520 6c65 7420 536f 6d65 2863 7329  ile let Some(cs)
-00012120: 203d 2066 732e 6e65 7874 2829 207b 0a20   = fs.next() {. 
-00012130: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00012140: 6574 206d 7574 2067 203d 206c 636f 6566  et mut g = lcoef
-00012150: 662e 636c 6f6e 6528 293b 0a20 2020 2020  f.clone();.     
-00012160: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-00012170: 692c 2066 2920 696e 2066 6163 746f 7273  i, f) in factors
-00012180: 2e69 7465 7228 292e 656e 756d 6572 6174  .iter().enumerat
-00012190: 6528 2920 7b0a 2020 2020 2020 2020 2020  e() {.          
-000121a0: 2020 2020 2020 2020 2020 6966 2063 732e            if cs.
-000121b0: 636f 6e74 6169 6e73 2826 6929 207b 0a20  contains(&i) {. 
-000121c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000121d0: 2020 2020 2020 2067 203d 2028 2667 202a         g = (&g *
-000121e0: 2066 292e 6d6f 645f 7661 7228 696e 7465   f).mod_var(inte
-000121f0: 7270 6f6c 6174 696f 6e5f 7661 722c 2045  rpolation_var, E
-00012200: 3a3a 6672 6f6d 5f75 3332 2864 3220 2b20  ::from_u32(d2 + 
-00012210: 3129 293b 0a20 2020 2020 2020 2020 2020  1));.           
-00012220: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00012230: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-00012240: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
-00012250: 2063 6f6e 7665 7274 2074 6f20 696e 7465   convert to inte
-00012260: 6765 720a 2020 2020 2020 2020 2020 2020  ger.            
-00012270: 2020 2020 6c65 7420 6d75 7420 675f 696e      let mut g_in
-00012280: 7420 3d0a 2020 2020 2020 2020 2020 2020  t =.            
-00012290: 2020 2020 2020 2020 672e 6d61 705f 636f          g.map_co
-000122a0: 6566 6628 7c63 7c20 6d6f 645f 6669 656c  eff(|c| mod_fiel
-000122b0: 642e 746f 5f73 796d 6d65 7472 6963 5f69  d.to_symmetric_i
-000122c0: 6e74 6567 6572 2863 292c 2049 6e74 6567  nteger(c), Integ
-000122d0: 6572 5269 6e67 3a3a 6e65 7728 2929 3b0a  erRing::new());.
-000122e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000122f0: 206c 6574 2063 6f6e 7465 6e74 203d 2067   let content = g
-00012300: 5f69 6e74 2e75 6e69 7661 7269 6174 655f  _int.univariate_
-00012310: 636f 6e74 656e 7428 6d61 696e 5f76 6172  content(main_var
-00012320: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00012330: 2020 2067 5f69 6e74 203d 2026 675f 696e     g_int = &g_in
-00012340: 7420 2f20 2663 6f6e 7465 6e74 3b0a 0a20  t / &content;.. 
-00012350: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00012360: 6574 2028 682c 2072 2920 3d20 7265 7374  et (h, r) = rest
-00012370: 2e71 756f 745f 7265 6d28 2667 5f69 6e74  .quot_rem(&g_int
-00012380: 2c20 7472 7565 293b 0a0a 2020 2020 2020  , true);..      
-00012390: 2020 2020 2020 2020 2020 6966 2072 2e69            if r.i
-000123a0: 735f 7a65 726f 2829 207b 0a20 2020 2020  s_zero() {.     
-000123b0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000123c0: 6563 5f66 6163 746f 7273 2e70 7573 6828  ec_factors.push(
-000123d0: 675f 696e 7429 3b0a 0a20 2020 2020 2020  g_int);..       
-000123e0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-000123f0: 2069 2069 6e20 6373 2e69 7465 7228 292e   i in cs.iter().
-00012400: 7265 7628 2920 7b0a 2020 2020 2020 2020  rev() {.        
-00012410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012420: 6661 6374 6f72 732e 7265 6d6f 7665 282a  factors.remove(*
-00012430: 6929 3b0a 2020 2020 2020 2020 2020 2020  i);.            
-00012440: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00012450: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00012460: 6573 7420 3d20 683b 0a20 2020 2020 2020  est = h;.       
-00012470: 2020 2020 2020 2020 2020 2020 2066 5f6d               f_m
-00012480: 6f64 203d 2072 6573 742e 6d61 705f 636f  od = rest.map_co
-00012490: 6566 6628 7c63 7c20 6d6f 645f 6669 656c  eff(|c| mod_fiel
-000124a0: 642e 746f 5f65 6c65 6d65 6e74 2863 2e63  d.to_element(c.c
-000124b0: 6c6f 6e65 2829 292c 206d 6f64 5f66 6965  lone()), mod_fie
-000124c0: 6c64 2e63 6c6f 6e65 2829 293b 0a20 2020  ld.clone());.   
-000124d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124e0: 206c 636f 6566 6620 3d20 665f 6d6f 642e   lcoeff = f_mod.
-000124f0: 6c63 6f65 6666 5f6c 6173 745f 7661 726f  lcoeff_last_varo
-00012500: 7264 6572 2826 5b6d 6169 6e5f 7661 722c  rder(&[main_var,
-00012510: 2069 6e74 6572 706f 6c61 7469 6f6e 5f76   interpolation_v
-00012520: 6172 5d29 3b0a 0a20 2020 2020 2020 2020  ar]);..         
-00012530: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00012540: 6e75 6520 276c 656e 3b0a 2020 2020 2020  nue 'len;.      
-00012550: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00012560: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00012570: 2020 2020 2020 2073 202b 3d20 313b 0a20         s += 1;. 
-00012580: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
-00012590: 2020 7265 635f 6661 6374 6f72 732e 7075    rec_factors.pu
-000125a0: 7368 2872 6573 7429 3b0a 0a20 2020 2020  sh(rest);..     
-000125b0: 2020 2069 6620 2173 616d 706c 655f 706f     if !sample_po
-000125c0: 696e 742e 6973 5f7a 6572 6f28 2920 7b0a  int.is_zero() {.
-000125d0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-000125e0: 7820 696e 2026 6d75 7420 7265 635f 6661  x in &mut rec_fa
-000125f0: 6374 6f72 7320 7b0a 2020 2020 2020 2020  ctors {.        
-00012600: 2020 2020 2020 2020 2f2f 2073 6869 6674          // shift
-00012610: 2074 6865 2070 6f6c 796e 6f6d 6961 6c20   the polynomial 
-00012620: 746f 2079 202d 2073 616d 706c 650a 2020  to y - sample.  
-00012630: 2020 2020 2020 2020 2020 2020 2020 2a78                *x
-00012640: 203d 2078 2e73 6869 6674 5f76 6172 2869   = x.shift_var(i
-00012650: 6e74 6572 706f 6c61 7469 6f6e 5f76 6172  nterpolation_var
-00012660: 2c20 2673 656c 662e 6669 656c 642e 6e65  , &self.field.ne
-00012670: 6728 2673 616d 706c 655f 706f 696e 7429  g(&sample_point)
-00012680: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
-00012690: 0a20 2020 2020 2020 207d 0a0a 2020 2020  .        }..    
-000126a0: 2020 2020 7265 635f 6661 6374 6f72 730a      rec_factors.
-000126b0: 2020 2020 7d0a 0a20 2020 202f 2f2f 2053      }..    /// S
-000126c0: 6f6c 7665 2061 2044 696f 7068 616e 7469  olve a Diophanti
-000126d0: 6e65 2065 7175 6174 696f 6e20 6f76 6572  ne equation over
-000126e0: 2074 6865 2072 696e 6720 605a 5f70 5e6b   the ring `Z_p^k
-000126f0: 6020 7573 696e 6720 4e65 7774 6f6e 2069  ` using Newton i
-00012700: 7465 7261 7469 6f6e 2e0a 2020 2020 2f2f  teration..    //
-00012710: 2f20 416c 6c20 6661 6374 6f72 7320 6d75  / All factors mu
-00012720: 7374 2062 6520 6d6f 6e69 632e 0a20 2020  st be monic..   
-00012730: 2066 6e20 6c69 6674 5f64 696f 7068 616e   fn lift_diophan
-00012740: 7469 6e65 5f75 6e69 7661 7269 6174 6528  tine_univariate(
-00012750: 0a20 2020 2020 2020 2066 6163 746f 7273  .        factors
-00012760: 3a20 266d 7574 205b 4d75 6c74 6976 6172  : &mut [Multivar
+00010050: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
+00010060: 2020 2020 2020 2020 206c 6574 2063 203d           let c =
+00010070: 2068 2e63 6f6e 7465 6e74 2829 3b0a 2020   h.content();.  
+00010080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010090: 2020 7265 7374 203d 2068 2e64 6976 5f63    rest = h.div_c
+000100a0: 6f65 6666 2826 6329 3b0a 0a20 2020 2020  oeff(&c);..     
+000100b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000100c0: 6f6e 7469 6e75 6520 276c 656e 3b0a 2020  ontinue 'len;.  
+000100d0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+000100e0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+000100f0: 2020 2020 2020 2020 2020 2073 202b 3d20             s += 
+00010100: 313b 0a20 2020 2020 2020 207d 0a0a 2020  1;.        }..  
+00010110: 2020 2020 2020 7265 635f 6661 6374 6f72        rec_factor
+00010120: 732e 7075 7368 2872 6573 7429 3b0a 2020  s.push(rest);.  
+00010130: 2020 2020 2020 7265 635f 6661 6374 6f72        rec_factor
+00010140: 730a 2020 2020 7d0a 0a20 2020 202f 2f2f  s.    }..    ///
+00010150: 204c 6966 7420 6120 736f 6c75 7469 6f6e   Lift a solution
+00010160: 206f 6620 6070 6f6c 7920 e289 a120 6c63   of `poly ... lc
+00010170: 6f65 6666 202a 2075 6e69 7661 7269 6174  oeff * univariat
+00010180: 655f 6661 6374 6f72 7320 6d6f 6420 7920  e_factors mod y 
+00010190: 6d6f 6420 705e 6b60 0a20 2020 202f 2f2f  mod p^k`.    ///
+000101a0: 2074 6f20 606d 6f64 2079 5e69 7465 7261   to `mod y^itera
+000101b0: 7469 6f6e 7320 6d6f 6420 705e 6b60 2e0a  tions mod p^k`..
+000101c0: 2020 2020 2f2f 2f0a 2020 2020 2f2f 2f20      ///.    /// 
+000101d0: 556e 6976 6172 6961 7465 2066 6163 746f  Univariate facto
+000101e0: 7273 206d 7573 7420 6265 206d 6f6e 6963  rs must be monic
+000101f0: 2061 6e64 2060 6c63 6f65 6666 5f79 3d30   and `lcoeff_y=0
+00010200: 6020 7368 6f75 6c64 2062 6520 6173 2077  ` should be as w
+00010210: 656c 6c2e 0a20 2020 2066 6e20 6269 7661  ell..    fn biva
+00010220: 7269 6174 655f 6865 6e73 656c 5f6c 6966  riate_hensel_lif
+00010230: 745f 6265 726e 6172 6469 6e28 0a20 2020  t_bernardin(.   
+00010240: 2020 2020 2070 6f6c 793a 2026 4d75 6c74       poly: &Mult
+00010250: 6976 6172 6961 7465 506f 6c79 6e6f 6d69  ivariatePolynomi
+00010260: 616c 3c46 696e 6974 6546 6965 6c64 3c49  al<FiniteField<I
+00010270: 6e74 6567 6572 3e2c 2045 2c20 4c65 784f  nteger>, E, LexO
+00010280: 7264 6572 3e2c 0a20 2020 2020 2020 2069  rder>,.        i
+00010290: 6e74 6572 706f 6c61 7469 6f6e 5f76 6172  nterpolation_var
+000102a0: 3a20 7573 697a 652c 0a20 2020 2020 2020  : usize,.       
+000102b0: 206c 636f 6566 663a 2026 4d75 6c74 6976   lcoeff: &Multiv
+000102c0: 6172 6961 7465 506f 6c79 6e6f 6d69 616c  ariatePolynomial
+000102d0: 3c46 696e 6974 6546 6965 6c64 3c49 6e74  <FiniteField<Int
+000102e0: 6567 6572 3e2c 2045 2c20 4c65 784f 7264  eger>, E, LexOrd
+000102f0: 6572 3e2c 0a20 2020 2020 2020 2075 6e69  er>,.        uni
+00010300: 7661 7269 6174 655f 6661 6374 6f72 733a  variate_factors:
+00010310: 2026 5b4d 756c 7469 7661 7269 6174 6550   &[MultivariateP
+00010320: 6f6c 796e 6f6d 6961 6c3c 4669 6e69 7465  olynomial<Finite
+00010330: 4669 656c 643c 496e 7465 6765 723e 2c20  Field<Integer>, 
+00010340: 452c 204c 6578 4f72 6465 723e 5d2c 0a20  E, LexOrder>],. 
+00010350: 2020 2020 2020 2069 7465 7261 7469 6f6e         iteration
+00010360: 733a 2075 7369 7a65 2c0a 2020 2020 2020  s: usize,.      
+00010370: 2020 703a 2075 3332 2c0a 2020 2020 2020    p: u32,.      
+00010380: 2020 6b3a 2075 7369 7a65 2c0a 2020 2020    k: usize,.    
+00010390: 2920 2d3e 2056 6563 3c4d 756c 7469 7661  ) -> Vec<Multiva
+000103a0: 7269 6174 6550 6f6c 796e 6f6d 6961 6c3c  riatePolynomial<
+000103b0: 4669 6e69 7465 4669 656c 643c 496e 7465  FiniteField<Inte
+000103c0: 6765 723e 2c20 452c 204c 6578 4f72 6465  ger>, E, LexOrde
+000103d0: 723e 3e20 7b0a 2020 2020 2020 2020 6c65  r>> {.        le
+000103e0: 7420 6669 6e69 7465 5f66 6965 6c64 203d  t finite_field =
+000103f0: 205a 703a 3a6e 6577 2870 293b 0a0a 2020   Zp::new(p);..  
+00010400: 2020 2020 2020 2f2f 2061 6464 2074 6865        // add the
+00010410: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
+00010420: 6965 6e74 2061 7320 6120 6669 7273 7420  ient as a first 
+00010430: 6661 6374 6f72 0a20 2020 2020 2020 206c  factor.        l
+00010440: 6574 206d 7574 2066 6163 746f 7273 203d  et mut factors =
+00010450: 2076 6563 215b 6c63 6f65 6666 2e72 6570   vec![lcoeff.rep
+00010460: 6c61 6365 2869 6e74 6572 706f 6c61 7469  lace(interpolati
+00010470: 6f6e 5f76 6172 2c20 2670 6f6c 792e 6669  on_var, &poly.fi
+00010480: 656c 642e 7a65 726f 2829 295d 3b0a 0a20  eld.zero())];.. 
+00010490: 2020 2020 2020 2066 6f72 2066 2069 6e20         for f in 
+000104a0: 756e 6976 6172 6961 7465 5f66 6163 746f  univariate_facto
+000104b0: 7273 207b 0a20 2020 2020 2020 2020 2020  rs {.           
+000104c0: 2066 6163 746f 7273 2e70 7573 6828 662e   factors.push(f.
+000104d0: 636c 6f6e 6528 2929 3b0a 2020 2020 2020  clone());.      
+000104e0: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
+000104f0: 2064 656c 7461 203d 2053 656c 663a 3a6c   delta = Self::l
+00010500: 6966 745f 6469 6f70 6861 6e74 696e 655f  ift_diophantine_
+00010510: 756e 6976 6172 6961 7465 280a 2020 2020  univariate(.    
+00010520: 2020 2020 2020 2020 266d 7574 2066 6163          &mut fac
+00010530: 746f 7273 2c0a 2020 2020 2020 2020 2020  tors,.          
+00010540: 2020 2670 6f6c 792e 636f 6e73 7461 6e74    &poly.constant
+00010550: 2870 6f6c 792e 6669 656c 642e 6f6e 6528  (poly.field.one(
+00010560: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+00010570: 6669 6e69 7465 5f66 6965 6c64 2e67 6574  finite_field.get
+00010580: 5f70 7269 6d65 2829 2c0a 2020 2020 2020  _prime(),.      
+00010590: 2020 2020 2020 6b2c 0a20 2020 2020 2020        k,.       
+000105a0: 2029 3b0a 0a20 2020 2020 2020 206c 6574   );..        let
+000105b0: 2079 5f70 6f6c 7920 3d20 706f 6c79 2e74   y_poly = poly.t
+000105c0: 6f5f 756e 6976 6172 6961 7465 5f70 6f6c  o_univariate_pol
+000105d0: 796e 6f6d 6961 6c5f 6c69 7374 2869 6e74  ynomial_list(int
+000105e0: 6572 706f 6c61 7469 6f6e 5f76 6172 293b  erpolation_var);
+000105f0: 0a0a 2020 2020 2020 2020 2f2f 2065 7874  ..        // ext
+00010600: 7261 6374 2063 6f65 6666 6963 6965 6e74  ract coefficient
+00010610: 7320 696e 2079 0a20 2020 2020 2020 206c  s in y.        l
+00010620: 6574 206d 7574 2075 3a20 5665 633c 5f3e  et mut u: Vec<_>
+00010630: 203d 2066 6163 746f 7273 0a20 2020 2020   = factors.     
+00010640: 2020 2020 2020 202e 6974 6572 2829 0a20         .iter(). 
+00010650: 2020 2020 2020 2020 2020 202e 6d61 7028             .map(
+00010660: 7c66 7c20 7b0a 2020 2020 2020 2020 2020  |f| {.          
+00010670: 2020 2020 2020 6c65 7420 6d75 7420 6465        let mut de
+00010680: 6e73 6520 3d20 7665 6321 5b70 6f6c 792e  nse = vec![poly.
+00010690: 7a65 726f 2829 3b20 6974 6572 6174 696f  zero(); iteratio
+000106a0: 6e73 202b 2031 5d3b 0a20 2020 2020 2020  ns + 1];.       
+000106b0: 2020 2020 2020 2020 2064 656e 7365 5b30           dense[0
+000106c0: 5d20 3d20 662e 636c 6f6e 6528 293b 0a20  ] = f.clone();. 
+000106d0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+000106e0: 656e 7365 0a20 2020 2020 2020 2020 2020  ense.           
+000106f0: 207d 290a 2020 2020 2020 2020 2020 2020   }).            
+00010700: 2e63 6f6c 6c65 6374 2829 3b0a 0a20 2020  .collect();..   
+00010710: 2020 2020 202f 2f20 7570 6461 7465 2074       // update t
+00010720: 6865 2066 6972 7374 2070 6f6c 796e 6f6d  he first polynom
+00010730: 6961 6c20 6173 2069 7420 6d61 7920 636f  ial as it may co
+00010740: 6e74 6169 6e20 792c 2073 696e 6365 2069  ntain y, since i
+00010750: 7427 7320 6c63 6f65 6666 0a20 2020 2020  t's lcoeff.     
+00010760: 2020 206c 6574 2079 5f6c 636f 6566 6620     let y_lcoeff 
+00010770: 3d20 6c63 6f65 6666 2e74 6f5f 756e 6976  = lcoeff.to_univ
+00010780: 6172 6961 7465 5f70 6f6c 796e 6f6d 6961  ariate_polynomia
+00010790: 6c5f 6c69 7374 2869 6e74 6572 706f 6c61  l_list(interpola
+000107a0: 7469 6f6e 5f76 6172 293b 0a20 2020 2020  tion_var);.     
+000107b0: 2020 2066 6f72 2028 702c 2065 2920 696e     for (p, e) in
+000107c0: 2079 5f6c 636f 6566 6620 7b0a 2020 2020   y_lcoeff {.    
+000107d0: 2020 2020 2020 2020 755b 305d 5b65 2e74          u[0][e.t
+000107e0: 6f5f 7533 3228 2920 6173 2075 7369 7a65  o_u32() as usize
+000107f0: 5d20 3d20 703b 0a20 2020 2020 2020 207d  ] = p;.        }
+00010800: 0a0a 2020 2020 2020 2020 6c65 7420 6d75  ..        let mu
+00010810: 7420 7020 3d20 752e 636c 6f6e 6528 293b  t p = u.clone();
+00010820: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00010830: 2063 7572 5f70 203d 2070 5b30 5d5b 305d   cur_p = p[0][0]
+00010840: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
+00010850: 2020 666f 7220 7820 696e 2026 6d75 7420    for x in &mut 
+00010860: 702e 6974 6572 5f6d 7574 2829 2e73 6b69  p.iter_mut().ski
+00010870: 7028 3129 207b 0a20 2020 2020 2020 2020  p(1) {.         
+00010880: 2020 2063 7572 5f70 203d 2063 7572 5f70     cur_p = cur_p
+00010890: 202a 2026 785b 305d 3b0a 2020 2020 2020   * &x[0];.      
+000108a0: 2020 2020 2020 785b 305d 203d 2063 7572        x[0] = cur
+000108b0: 5f70 2e63 6c6f 6e65 2829 3b0a 2020 2020  _p.clone();.    
+000108c0: 2020 2020 7d0a 0a20 2020 2020 2020 2066      }..        f
+000108d0: 6f72 206b 2069 6e20 312e 2e69 7465 7261  or k in 1..itera
+000108e0: 7469 6f6e 7320 7b0a 2020 2020 2020 2020  tions {.        
+000108f0: 2020 2020 2f2f 2065 7874 7261 6374 2074      // extract t
+00010900: 6865 2063 6f65 6666 6963 6965 6e74 2072  he coefficient r
+00010910: 6571 7569 7265 6420 746f 2063 6f6d 7075  equired to compu
+00010920: 7465 2074 6865 2065 7272 6f72 2069 6e20  te the error in 
+00010930: 795e 6b0a 2020 2020 2020 2020 2020 2020  y^k.            
+00010940: 2f2f 2063 6f6d 7075 7465 6420 7573 696e  // computed usin
+00010950: 6720 6120 636f 6e76 6f6c 7574 696f 6e0a  g a convolution.
+00010960: 2020 2020 2020 2020 2020 2020 705b 305d              p[0]
+00010970: 5b6b 5d20 3d20 755b 305d 5b6b 5d2e 636c  [k] = u[0][k].cl
+00010980: 6f6e 6528 293b 0a20 2020 2020 2020 2020  one();.         
+00010990: 2020 2066 6f72 2069 2069 6e20 312e 2e66     for i in 1..f
+000109a0: 6163 746f 7273 2e6c 656e 2829 207b 0a20  actors.len() {. 
+000109b0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000109c0: 6f72 206a 2069 6e20 302e 2e6b 207b 0a20  or j in 0..k {. 
+000109d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000109e0: 2020 2070 5b69 5d5b 6b5d 203d 2026 705b     p[i][k] = &p[
+000109f0: 695d 5b6b 5d20 2b20 2628 2670 5b69 202d  i][k] + &(&p[i -
+00010a00: 2031 5d5b 6b20 2d20 6a5d 202a 2026 755b   1][k - j] * &u[
+00010a10: 695d 5b6a 5d29 3b0a 2020 2020 2020 2020  i][j]);.        
+00010a20: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00010a30: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00010a40: 2020 2020 202f 2f20 6669 6e64 2074 6865       // find the
+00010a50: 206b 7468 2070 6f77 6572 206f 6620 7920   kth power of y 
+00010a60: 696e 2066 0a20 2020 2020 2020 2020 2020  in f.           
+00010a70: 202f 2f20 7369 6e63 6520 7765 2063 6f6d   // since we com
+00010a80: 7075 7465 2074 6865 2065 7272 6f72 2070  pute the error p
+00010a90: 6572 2070 6f77 6572 206f 6620 792c 2077  er power of y, w
+00010aa0: 6520 6361 6e6e 6f74 2073 746f 7020 6f6e  e cannot stop on
+00010ab0: 2061 2030 2065 7272 6f72 0a20 2020 2020   a 0 error.     
+00010ac0: 2020 2020 2020 206c 6574 2065 203d 2069         let e = i
+00010ad0: 6620 6c65 7420 536f 6d65 2828 762c 205f  f let Some((v, _
+00010ae0: 2929 203d 2079 5f70 6f6c 792e 6974 6572  )) = y_poly.iter
+00010af0: 2829 2e66 696e 6428 7c65 7c20 652e 312e  ().find(|e| e.1.
+00010b00: 746f 5f75 3332 2829 2061 7320 7573 697a  to_u32() as usiz
+00010b10: 6520 3d3d 206b 2920 7b0a 2020 2020 2020  e == k) {.      
+00010b20: 2020 2020 2020 2020 2020 7620 2d20 2670            v - &p
+00010b30: 2e6c 6173 7428 292e 756e 7772 6170 2829  .last().unwrap()
+00010b40: 5b6b 5d0a 2020 2020 2020 2020 2020 2020  [k].            
+00010b50: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+00010b60: 2020 2020 2020 2020 202d 702e 6c61 7374           -p.last
+00010b70: 2829 2e75 6e77 7261 7028 295b 6b5d 2e63  ().unwrap()[k].c
+00010b80: 6c6f 6e65 2829 0a20 2020 2020 2020 2020  lone().         
+00010b90: 2020 207d 3b0a 0a20 2020 2020 2020 2020     };..         
+00010ba0: 2020 2069 6620 652e 6973 5f7a 6572 6f28     if e.is_zero(
+00010bb0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00010bc0: 2020 2020 636f 6e74 696e 7565 3b0a 2020      continue;.  
+00010bd0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+00010be0: 2020 2020 2020 2020 2066 6f72 2028 2864           for ((d
+00010bf0: 702c 2066 292c 2064 2920 696e 2075 2e69  p, f), d) in u.i
+00010c00: 7465 725f 6d75 7428 292e 7a69 7028 6661  ter_mut().zip(fa
+00010c10: 6374 6f72 732e 6974 6572 2829 292e 7a69  ctors.iter()).zi
+00010c20: 7028 2664 656c 7461 2920 7b0a 2020 2020  p(&delta) {.    
+00010c30: 2020 2020 2020 2020 2020 2020 6470 5b6b              dp[k
+00010c40: 5d20 3d20 2664 705b 6b5d 202b 2026 2864  ] = &dp[k] + &(d
+00010c50: 202a 2026 6529 2e71 756f 745f 7265 6d5f   * &e).quot_rem_
+00010c60: 756e 6976 6172 6961 7465 5f6d 6f6e 6963  univariate_monic
+00010c70: 2866 292e 313b 0a20 2020 2020 2020 2020  (f).1;.         
+00010c80: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+00010c90: 2020 2f2f 2075 7064 6174 6520 7468 6520    // update the 
+00010ca0: 636f 6566 6669 6369 656e 7473 2077 6974  coefficients wit
+00010cb0: 6820 7468 6520 6e65 7720 795e 6b20 636f  h the new y^k co
+00010cc0: 6e74 7269 6275 7469 6f6e 730a 2020 2020  ntributions.    
+00010cd0: 2020 2020 2020 2020 2f2f 206e 6f74 6520          // note 
+00010ce0: 7468 6174 2074 6865 206c 636f 6566 665b  that the lcoeff[
+00010cf0: 6b5d 2063 6f6e 7472 6962 7574 696f 6e20  k] contribution 
+00010d00: 6973 206e 6f74 206e 6577 0a20 2020 2020  is not new.     
+00010d10: 2020 2020 2020 206c 6574 206d 7574 2074         let mut t
+00010d20: 203d 2070 6f6c 792e 7a65 726f 2829 3b0a   = poly.zero();.
+00010d30: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00010d40: 6920 696e 2031 2e2e 6661 6374 6f72 732e  i in 1..factors.
+00010d50: 6c65 6e28 2920 7b0a 2020 2020 2020 2020  len() {.        
+00010d60: 2020 2020 2020 2020 7420 3d20 2675 5b69          t = &u[i
+00010d70: 5d5b 305d 202a 2026 7420 2b20 2675 5b69  ][0] * &t + &u[i
+00010d80: 5d5b 6b5d 202a 2026 705b 6920 2d20 315d  ][k] * &p[i - 1]
+00010d90: 5b30 5d3b 0a20 2020 2020 2020 2020 2020  [0];.           
+00010da0: 2020 2020 2070 5b69 5d5b 6b5d 203d 2026       p[i][k] = &
+00010db0: 705b 695d 5b6b 5d20 2b20 2674 3b0a 2020  p[i][k] + &t;.  
+00010dc0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00010dd0: 2020 2020 7d0a 0a20 2020 2020 2020 202f      }..        /
+00010de0: 2f20 636f 6e76 6572 7420 6465 6e73 6520  / convert dense 
+00010df0: 706f 6c79 6e6f 6d69 616c 7320 746f 206d  polynomials to m
+00010e00: 756c 7469 7661 7269 6174 6520 706f 6c79  ultivariate poly
+00010e10: 6e6f 6d69 616c 730a 2020 2020 2020 2020  nomials.        
+00010e20: 752e 696e 746f 5f69 7465 7228 290a 2020  u.into_iter().  
+00010e30: 2020 2020 2020 2020 2020 2e6d 6170 287c            .map(|
+00010e40: 7473 7c20 7b0a 2020 2020 2020 2020 2020  ts| {.          
+00010e50: 2020 2020 2020 6c65 7420 6d75 7420 6e65        let mut ne
+00010e60: 775f 706f 6c79 203d 2070 6f6c 792e 7a65  w_poly = poly.ze
+00010e70: 726f 5f77 6974 685f 6361 7061 6369 7479  ro_with_capacity
+00010e80: 2874 732e 6c65 6e28 2929 3b0a 2020 2020  (ts.len());.    
+00010e90: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00010ea0: 2869 2c20 6d75 7420 6629 2069 6e20 7473  (i, mut f) in ts
+00010eb0: 2e69 6e74 6f5f 6974 6572 2829 2e65 6e75  .into_iter().enu
+00010ec0: 6d65 7261 7465 2829 207b 0a20 2020 2020  merate() {.     
+00010ed0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00010ee0: 6f72 2078 2069 6e20 662e 6578 706f 6e65  or x in f.expone
+00010ef0: 6e74 735f 6974 6572 5f6d 7574 2829 207b  nts_iter_mut() {
+00010f00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010f10: 2020 2020 2020 2020 2078 5b69 6e74 6572           x[inter
+00010f20: 706f 6c61 7469 6f6e 5f76 6172 5d20 3d20  polation_var] = 
+00010f30: 453a 3a66 726f 6d5f 7533 3228 6920 6173  E::from_u32(i as
+00010f40: 2075 3332 293b 0a20 2020 2020 2020 2020   u32);.         
+00010f50: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00010f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f70: 206e 6577 5f70 6f6c 7920 3d20 6e65 775f   new_poly = new_
+00010f80: 706f 6c79 202b 2066 3b0a 2020 2020 2020  poly + f;.      
+00010f90: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+00010fa0: 2020 2020 2020 2020 2020 2020 206e 6577               new
+00010fb0: 5f70 6f6c 790a 2020 2020 2020 2020 2020  _poly.          
+00010fc0: 2020 7d29 0a20 2020 2020 2020 2020 2020    }).           
+00010fd0: 202e 636f 6c6c 6563 7428 290a 2020 2020   .collect().    
+00010fe0: 7d0a 0a20 2020 202f 2f2f 2046 6163 746f  }..    /// Facto
+00010ff0: 7220 6120 7371 7561 7265 2d66 7265 6520  r a square-free 
+00011000: 6269 7661 7269 6174 6520 706f 6c79 6e6f  bivariate polyno
+00011010: 6d69 616c 206f 7665 7220 7468 6520 696e  mial over the in
+00011020: 7465 6765 7273 2e0a 2020 2020 666e 2062  tegers..    fn b
+00011030: 6976 6172 6961 7465 5f66 6163 746f 725f  ivariate_factor_
+00011040: 7265 636f 6e73 7472 7563 7428 2673 656c  reconstruct(&sel
+00011050: 662c 206d 6169 6e5f 7661 723a 2075 7369  f, main_var: usi
+00011060: 7a65 2c20 696e 7465 7270 6f6c 6174 696f  ze, interpolatio
+00011070: 6e5f 7661 723a 2075 7369 7a65 2920 2d3e  n_var: usize) ->
+00011080: 2056 6563 3c53 656c 663e 207b 0a20 2020   Vec<Self> {.   
+00011090: 2020 2020 2069 6620 7365 6c66 2e62 6976       if self.biv
+000110a0: 6172 6961 7465 5f69 7272 6564 7563 6962  ariate_irreducib
+000110b0: 696c 6974 795f 7465 7374 2829 207b 0a20  ility_test() {. 
+000110c0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000110d0: 6e20 7665 6321 5b73 656c 662e 636c 6f6e  n vec![self.clon
+000110e0: 6528 295d 3b0a 2020 2020 2020 2020 7d0a  e()];.        }.
+000110f0: 0a20 2020 2020 2020 206c 6574 2064 3220  .        let d2 
+00011100: 3d20 7365 6c66 2e64 6567 7265 6528 696e  = self.degree(in
+00011110: 7465 7270 6f6c 6174 696f 6e5f 7661 7229  terpolation_var)
+00011120: 2e74 6f5f 7533 3228 293b 0a0a 2020 2020  .to_u32();..    
+00011130: 2020 2020 2f2f 2073 656c 6563 7420 6120      // select a 
+00011140: 7375 6974 6162 6c65 2065 7661 6c75 6174  suitable evaluat
+00011150: 696f 6e20 706f 696e 742c 2061 7320 736d  ion point, as sm
+00011160: 616c 6c20 6173 2070 6f73 7369 626c 6520  all as possible 
+00011170: 6173 2074 6f20 6e6f 7420 6368 616e 6765  as to not change
+00011180: 2074 6865 2063 6f65 6666 6963 6965 6e74   the coefficient
+00011190: 2062 6f75 6e64 0a20 2020 2020 2020 206c   bound.        l
+000111a0: 6574 206d 7574 2073 616d 706c 655f 706f  et mut sample_po
+000111b0: 696e 743b 0a20 2020 2020 2020 206c 6574  int;.        let
+000111c0: 206d 7574 2075 6e69 5f66 3b0a 2020 2020   mut uni_f;.    
+000111d0: 2020 2020 6c65 7420 6d75 7420 6920 3d20      let mut i = 
+000111e0: 3075 3634 3b0a 2020 2020 2020 2020 6c6f  0u64;.        lo
+000111f0: 6f70 207b 0a20 2020 2020 2020 2020 2020  op {.           
+00011200: 2073 616d 706c 655f 706f 696e 7420 3d20   sample_point = 
+00011210: 692e 696e 746f 2829 3b0a 2020 2020 2020  i.into();.      
+00011220: 2020 2020 2020 756e 695f 6620 3d20 7365        uni_f = se
+00011230: 6c66 2e72 6570 6c61 6365 2869 6e74 6572  lf.replace(inter
+00011240: 706f 6c61 7469 6f6e 5f76 6172 2c20 2673  polation_var, &s
+00011250: 616d 706c 655f 706f 696e 7429 3b0a 0a20  ample_point);.. 
+00011260: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00011270: 6c66 2e64 6567 7265 6528 6d61 696e 5f76  lf.degree(main_v
+00011280: 6172 2920 3d3d 2075 6e69 5f66 2e64 6567  ar) == uni_f.deg
+00011290: 7265 6528 6d61 696e 5f76 6172 290a 2020  ree(main_var).  
+000112a0: 2020 2020 2020 2020 2020 2020 2020 2626                &&
+000112b0: 2075 6e69 5f66 2e67 6364 2826 756e 695f   uni_f.gcd(&uni_
+000112c0: 662e 6465 7269 7661 7469 7665 286d 6169  f.derivative(mai
+000112d0: 6e5f 7661 7229 292e 6973 5f63 6f6e 7374  n_var)).is_const
+000112e0: 616e 7428 290a 2020 2020 2020 2020 2020  ant().          
+000112f0: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
+00011300: 2020 2020 6272 6561 6b3b 0a20 2020 2020      break;.     
+00011310: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+00011320: 2020 2020 2020 6920 2b3d 2031 3b0a 2020        i += 1;.  
+00011330: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00011340: 202f 2f20 6661 6374 6f72 2074 6865 2075   // factor the u
+00011350: 6e69 7661 7269 6174 6520 706f 6c79 6e6f  nivariate polyno
+00011360: 6d69 616c 0a20 2020 2020 2020 206c 6574  mial.        let
+00011370: 206d 7574 2075 6e69 5f66 733a 2056 6563   mut uni_fs: Vec
+00011380: 3c5f 3e20 3d20 756e 695f 660a 2020 2020  <_> = uni_f.    
+00011390: 2020 2020 2020 2020 2e66 6163 746f 7228          .factor(
+000113a0: 290a 2020 2020 2020 2020 2020 2020 2e69  ).            .i
+000113b0: 6e74 6f5f 6974 6572 2829 0a20 2020 2020  nto_iter().     
+000113c0: 2020 2020 2020 202e 6d61 7028 7c28 662c         .map(|(f,
+000113d0: 2070 297c 207b 0a20 2020 2020 2020 2020   p)| {.         
+000113e0: 2020 2020 2020 2064 6562 7567 5f61 7373         debug_ass
+000113f0: 6572 745f 6571 2128 702c 2031 293b 0a20  ert_eq!(p, 1);. 
+00011400: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00011410: 0a20 2020 2020 2020 2020 2020 207d 290a  .            }).
+00011420: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
+00011430: 6c65 6374 2829 3b0a 0a20 2020 2020 2020  lect();..       
+00011440: 202f 2f20 7374 7269 7020 706f 7465 6e74   // strip potent
+00011450: 6961 6c20 636f 6e74 656e 740a 2020 2020  ial content.    
+00011460: 2020 2020 756e 695f 6673 2e72 6574 6169      uni_fs.retai
+00011470: 6e5f 6d75 7428 7c66 7c20 2166 2e69 735f  n_mut(|f| !f.is_
+00011480: 636f 6e73 7461 6e74 2829 293b 0a0a 2020  constant());..  
+00011490: 2020 2020 2020 2f2f 2073 656c 6563 7420        // select 
+000114a0: 6120 7375 6974 6162 6c65 2070 7269 6d65  a suitable prime
+000114b0: 0a20 2020 2020 2020 202f 2f20 7765 2074  .        // we t
+000114c0: 7279 2073 6d61 6c6c 2070 7269 6d65 7320  ry small primes 
+000114d0: 6669 7273 7420 6173 2074 6865 2064 6973  first as the dis
+000114e0: 7469 6e63 7420 616e 6420 6571 7561 6c20  tinct and equal 
+000114f0: 6465 6772 6565 2061 6c67 6f72 6974 686d  degree algorithm
+00011500: 730a 2020 2020 2020 2020 2f2f 2073 6361  s.        // sca
+00011510: 6c65 2061 7320 6c6f 6728 7029 0a20 2020  le as log(p).   
+00011520: 2020 2020 206c 6574 206d 7574 2070 6920       let mut pi 
+00011530: 3d20 5072 696d 6549 7465 7261 746f 7255  = PrimeIteratorU
+00011540: 3634 3a3a 6e65 7728 3130 3129 3b0a 2020  64::new(101);.  
+00011550: 2020 2020 2020 6c65 7420 6d75 7420 6669        let mut fi
+00011560: 656c 643b 0a20 2020 2020 2020 2027 6e65  eld;.        'ne
+00011570: 775f 7072 696d 653a 206c 6f6f 7020 7b0a  w_prime: loop {.
+00011580: 2020 2020 2020 2020 2020 2020 6920 2b3d              i +=
+00011590: 2031 3b0a 0a20 2020 2020 2020 2020 2020   1;..           
+000115a0: 206c 6574 2070 203d 2070 692e 6e65 7874   let p = pi.next
+000115b0: 2829 2e75 6e77 7261 7028 293b 0a20 2020  ().unwrap();.   
+000115c0: 2020 2020 2020 2020 2069 6620 7020 3e20           if p > 
+000115d0: 7533 323a 3a4d 4158 2061 7320 7536 3420  u32::MAX as u64 
+000115e0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+000115f0: 2020 7061 6e69 6321 2822 5261 6e20 6f75    panic!("Ran ou
+00011600: 7420 6f66 2070 7269 6d65 7320 6475 7269  t of primes duri
+00011610: 6e67 2066 6163 746f 7269 7a61 7469 6f6e  ng factorization
+00011620: 206f 6620 7b7d 222c 2073 656c 6629 3b0a   of {}", self);.
+00011630: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00011640: 2020 2020 2020 2020 2020 6c65 7420 7020            let p 
+00011650: 3d20 7020 6173 2075 3332 3b0a 0a20 2020  = p as u32;..   
+00011660: 2020 2020 2020 2020 2069 6620 2826 756e           if (&un
+00011670: 695f 662e 6c63 6f65 6666 2829 2025 2026  i_f.lcoeff() % &
+00011680: 496e 7465 6765 723a 3a4e 6174 7572 616c  Integer::Natural
+00011690: 2870 2061 7320 6936 3429 292e 6973 5f7a  (p as i64)).is_z
+000116a0: 6572 6f28 2920 7b0a 2020 2020 2020 2020  ero() {.        
+000116b0: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+000116c0: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
+000116d0: 0a20 2020 2020 2020 2020 2020 2066 6965  .            fie
+000116e0: 6c64 203d 205a 703a 3a6e 6577 2870 293b  ld = Zp::new(p);
+000116f0: 0a0a 2020 2020 2020 2020 2020 2020 2f2f  ..            //
+00011700: 206d 616b 6520 7375 7265 2074 6865 2066   make sure the f
+00011710: 6163 746f 7273 2073 7461 7920 636f 7072  actors stay copr
+00011720: 696d 650a 2020 2020 2020 2020 2020 2020  ime.            
+00011730: 6c65 7420 6673 5f70 3a20 5665 633c 5f3e  let fs_p: Vec<_>
+00011740: 203d 2075 6e69 5f66 730a 2020 2020 2020   = uni_fs.      
+00011750: 2020 2020 2020 2020 2020 2e69 7465 7228            .iter(
+00011760: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00011770: 2020 2e6d 6170 287c 667c 2066 2e6d 6170    .map(|f| f.map
+00011780: 5f63 6f65 6666 287c 637c 2063 2e74 6f5f  _coeff(|c| c.to_
+00011790: 6669 6e69 7465 5f66 6965 6c64 2826 6669  finite_field(&fi
+000117a0: 656c 6429 2c20 6669 656c 642e 636c 6f6e  eld), field.clon
+000117b0: 6528 2929 290a 2020 2020 2020 2020 2020  e())).          
+000117c0: 2020 2020 2020 2e63 6f6c 6c65 6374 2829        .collect()
+000117d0: 3b0a 0a20 2020 2020 2020 2020 2020 2066  ;..            f
+000117e0: 6f72 2028 6a2c 2066 2920 696e 2066 735f  or (j, f) in fs_
+000117f0: 702e 6974 6572 2829 2e65 6e75 6d65 7261  p.iter().enumera
+00011800: 7465 2829 207b 0a20 2020 2020 2020 2020  te() {.         
+00011810: 2020 2020 2020 2066 6f72 2067 2069 6e20         for g in 
+00011820: 2666 735f 705b 6a20 2b20 312e 2e5d 207b  &fs_p[j + 1..] {
+00011830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011840: 2020 2020 2069 6620 2166 2e67 6364 2867       if !f.gcd(g
+00011850: 292e 6973 5f6f 6e65 2829 207b 0a20 2020  ).is_one() {.   
+00011860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011870: 2020 2020 2063 6f6e 7469 6e75 6520 276e       continue 'n
+00011880: 6577 5f70 7269 6d65 3b0a 2020 2020 2020  ew_prime;.      
+00011890: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+000118a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000118b0: 7d0a 2020 2020 2020 2020 2020 2020 7d0a  }.            }.
+000118c0: 0a20 2020 2020 2020 2020 2020 2062 7265  .            bre
+000118d0: 616b 3b0a 2020 2020 2020 2020 7d0a 0a20  ak;.        }.. 
+000118e0: 2020 2020 2020 206c 6574 2073 6869 6674         let shift
+000118f0: 6564 5f70 6f6c 7920 3d20 6966 2021 7361  ed_poly = if !sa
+00011900: 6d70 6c65 5f70 6f69 6e74 2e69 735f 7a65  mple_point.is_ze
+00011910: 726f 2829 207b 0a20 2020 2020 2020 2020  ro() {.         
+00011920: 2020 2073 656c 662e 7368 6966 745f 7661     self.shift_va
+00011930: 7228 696e 7465 7270 6f6c 6174 696f 6e5f  r(interpolation_
+00011940: 7661 722c 2026 7361 6d70 6c65 5f70 6f69  var, &sample_poi
+00011950: 6e74 290a 2020 2020 2020 2020 7d20 656c  nt).        } el
+00011960: 7365 207b 0a20 2020 2020 2020 2020 2020  se {.           
+00011970: 2073 656c 662e 636c 6f6e 6528 290a 2020   self.clone().  
+00011980: 2020 2020 2020 7d3b 0a0a 2020 2020 2020        };..      
+00011990: 2020 2f2f 2054 4f44 4f3a 2069 6620 626f    // TODO: if bo
+000119a0: 756e 6420 6973 206c 6573 7320 7468 616e  und is less than
+000119b0: 2075 3634 2c20 7765 206d 6179 2061 6c73   u64, we may als
+000119c0: 6f20 7573 6520 5a70 3634 2066 6f72 2074  o use Zp64 for t
+000119d0: 6865 2063 6f6d 7075 7461 7469 6f6e 0a20  he computation. 
+000119e0: 2020 2020 2020 206c 6574 2062 6f75 6e64         let bound
+000119f0: 203d 2073 6869 6674 6564 5f70 6f6c 792e   = shifted_poly.
+00011a00: 636f 6566 6669 6369 656e 745f 626f 756e  coefficient_boun
+00011a10: 6428 293b 0a0a 2020 2020 2020 2020 6c65  d();..        le
+00011a20: 7420 7020 3d20 496e 7465 6765 723a 3a66  t p = Integer::f
+00011a30: 726f 6d28 6669 656c 642e 6765 745f 7072  rom(field.get_pr
+00011a40: 696d 6528 292e 746f 5f75 3634 2829 293b  ime().to_u64());
+00011a50: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00011a60: 206d 6178 5f70 203d 2070 2e63 6c6f 6e65   max_p = p.clone
+00011a70: 2829 3b0a 2020 2020 2020 2020 6c65 7420  ();.        let 
+00011a80: 6d75 7420 6b20 3d20 313b 0a20 2020 2020  mut k = 1;.     
+00011a90: 2020 2077 6869 6c65 2026 6d61 785f 7020     while &max_p 
+00011aa0: 2a20 3220 3c20 626f 756e 6420 7b0a 2020  * 2 < bound {.  
+00011ab0: 2020 2020 2020 2020 2020 6d61 785f 7020            max_p 
+00011ac0: 3d20 266d 6178 5f70 202a 2026 703b 0a20  = &max_p * &p;. 
+00011ad0: 2020 2020 2020 2020 2020 206b 202b 3d20             k += 
+00011ae0: 313b 0a20 2020 2020 2020 207d 0a0a 2020  1;.        }..  
+00011af0: 2020 2020 2020 6c65 7420 6d6f 645f 6669        let mod_fi
+00011b00: 656c 6420 3d20 4669 6e69 7465 4669 656c  eld = FiniteFiel
+00011b10: 643a 3a3c 496e 7465 6765 723e 3a3a 6e65  d::<Integer>::ne
+00011b20: 7728 6d61 785f 702e 636c 6f6e 6528 2929  w(max_p.clone())
+00011b30: 3b0a 0a20 2020 2020 2020 202f 2f20 6d61  ;..        // ma
+00011b40: 6b65 2061 6c6c 2066 6163 746f 7273 206d  ke all factors m
+00011b50: 6f6e 6963 2c20 7468 6973 2069 7320 706f  onic, this is po
+00011b60: 7373 6962 6c65 2073 696e 6365 2074 6865  ssible since the
+00011b70: 206c 636f 6566 6620 6973 2069 6e76 6572   lcoeff is inver
+00011b80: 7469 626c 6520 6d6f 6420 705e 6b0a 2020  tible mod p^k.  
+00011b90: 2020 2020 2020 6c65 7420 756e 695f 6673        let uni_fs
+00011ba0: 5f6d 6f64 3a20 5665 633c 5f3e 203d 2075  _mod: Vec<_> = u
+00011bb0: 6e69 5f66 730a 2020 2020 2020 2020 2020  ni_fs.          
+00011bc0: 2020 2e69 7465 7228 290a 2020 2020 2020    .iter().      
+00011bd0: 2020 2020 2020 2e6d 6170 287c 667c 207b        .map(|f| {
+00011be0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011bf0: 206c 6574 2066 3120 3d20 662e 6d61 705f   let f1 = f.map_
+00011c00: 636f 6566 6628 7c63 7c20 6d6f 645f 6669  coeff(|c| mod_fi
+00011c10: 656c 642e 746f 5f65 6c65 6d65 6e74 2863  eld.to_element(c
+00011c20: 2e63 6c6f 6e65 2829 292c 206d 6f64 5f66  .clone()), mod_f
+00011c30: 6965 6c64 2e63 6c6f 6e65 2829 293b 0a20  ield.clone());. 
+00011c40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00011c50: 312e 6d61 6b65 5f6d 6f6e 6963 2829 0a20  1.make_monic(). 
+00011c60: 2020 2020 2020 2020 2020 207d 290a 2020             }).  
+00011c70: 2020 2020 2020 2020 2020 2e63 6f6c 6c65            .colle
+00011c80: 6374 2829 3b0a 0a20 2020 2020 2020 206c  ct();..        l
+00011c90: 6574 206d 7574 2066 5f6d 6f64 203d 2073  et mut f_mod = s
+00011ca0: 6869 6674 6564 5f70 6f6c 792e 6d61 705f  hifted_poly.map_
+00011cb0: 636f 6566 6628 7c63 7c20 632e 7379 6d6d  coeff(|c| c.symm
+00011cc0: 6574 7269 635f 6d6f 6428 266d 6178 5f70  etric_mod(&max_p
+00011cd0: 292c 206d 6f64 5f66 6965 6c64 2e63 6c6f  ), mod_field.clo
+00011ce0: 6e65 2829 293b 0a0a 2020 2020 2020 2020  ne());..        
+00011cf0: 2f2f 206d 616b 6520 7375 7265 2074 6865  // make sure the
+00011d00: 206c 636f 6566 6620 6973 206d 6f6e 6963   lcoeff is monic
+00011d10: 2061 7420 793d 300a 2020 2020 2020 2020   at y=0.        
+00011d20: 6c65 7420 696e 765f 636f 6566 6620 3d20  let inv_coeff = 
+00011d30: 6d6f 645f 6669 656c 642e 696e 7628 2675  mod_field.inv(&u
+00011d40: 6e69 5f66 2e6c 636f 6566 6628 2929 3b0a  ni_f.lcoeff());.
+00011d50: 2020 2020 2020 2020 6c65 7420 665f 6d6f          let f_mo
+00011d60: 645f 6d6f 6e69 6320 3d20 665f 6d6f 642e  d_monic = f_mod.
+00011d70: 636c 6f6e 6528 292e 6d75 6c5f 636f 6566  clone().mul_coef
+00011d80: 6628 696e 765f 636f 6566 6629 3b0a 2020  f(inv_coeff);.  
+00011d90: 2020 2020 2020 6c65 7420 6c63 6f65 6666        let lcoeff
+00011da0: 5f6d 6f6e 6963 203d 2066 5f6d 6f64 5f6d  _monic = f_mod_m
+00011db0: 6f6e 6963 2e6c 636f 6566 665f 6c61 7374  onic.lcoeff_last
+00011dc0: 5f76 6172 6f72 6465 7228 265b 6d61 696e  _varorder(&[main
+00011dd0: 5f76 6172 2c20 696e 7465 7270 6f6c 6174  _var, interpolat
+00011de0: 696f 6e5f 7661 725d 293b 0a0a 2020 2020  ion_var]);..    
+00011df0: 2020 2020 6c65 7420 6d75 7420 6661 6374      let mut fact
+00011e00: 6f72 7320 3d20 5365 6c66 3a3a 6269 7661  ors = Self::biva
+00011e10: 7269 6174 655f 6865 6e73 656c 5f6c 6966  riate_hensel_lif
+00011e20: 745f 6265 726e 6172 6469 6e28 0a20 2020  t_bernardin(.   
+00011e30: 2020 2020 2020 2020 2026 665f 6d6f 645f           &f_mod_
+00011e40: 6d6f 6e69 632c 0a20 2020 2020 2020 2020  monic,.         
+00011e50: 2020 2069 6e74 6572 706f 6c61 7469 6f6e     interpolation
+00011e60: 5f76 6172 2c0a 2020 2020 2020 2020 2020  _var,.          
+00011e70: 2020 266c 636f 6566 665f 6d6f 6e69 632c    &lcoeff_monic,
+00011e80: 0a20 2020 2020 2020 2020 2020 2026 756e  .            &un
+00011e90: 695f 6673 5f6d 6f64 2c0a 2020 2020 2020  i_fs_mod,.      
+00011ea0: 2020 2020 2020 2864 3220 2b20 3129 2061        (d2 + 1) a
+00011eb0: 7320 7573 697a 652c 0a20 2020 2020 2020  s usize,.       
+00011ec0: 2020 2020 2066 6965 6c64 2e67 6574 5f70       field.get_p
+00011ed0: 7269 6d65 2829 2c0a 2020 2020 2020 2020  rime(),.        
+00011ee0: 2020 2020 6b2c 0a20 2020 2020 2020 2029      k,.        )
+00011ef0: 3b0a 0a20 2020 2020 2020 2066 6163 746f  ;..        facto
+00011f00: 7273 2e73 7761 705f 7265 6d6f 7665 2830  rs.swap_remove(0
+00011f10: 293b 202f 2f20 7265 6d6f 7665 2074 6865  ); // remove the
+00011f20: 206c 636f 6566 660a 0a20 2020 2020 2020   lcoeff..       
+00011f30: 206c 6574 206d 7574 2072 6563 5f66 6163   let mut rec_fac
+00011f40: 746f 7273 203d 2076 6563 215b 5d3b 0a20  tors = vec![];. 
+00011f50: 2020 2020 2020 202f 2f20 6661 6374 6f72         // factor
+00011f60: 2072 6563 6f6d 6269 6e61 7469 6f6e 0a20   recombination. 
+00011f70: 2020 2020 2020 206c 6574 206d 7574 2073         let mut s
+00011f80: 203d 2031 3b0a 0a20 2020 2020 2020 206c   = 1;..        l
+00011f90: 6574 206d 7574 206c 636f 6566 6620 3d20  et mut lcoeff = 
+00011fa0: 665f 6d6f 642e 6c63 6f65 6666 5f6c 6173  f_mod.lcoeff_las
+00011fb0: 745f 7661 726f 7264 6572 2826 5b6d 6169  t_varorder(&[mai
+00011fc0: 6e5f 7661 722c 2069 6e74 6572 706f 6c61  n_var, interpola
+00011fd0: 7469 6f6e 5f76 6172 5d29 3b0a 2020 2020  tion_var]);.    
+00011fe0: 2020 2020 6c65 7420 6d75 7420 7265 7374      let mut rest
+00011ff0: 203d 2073 6869 6674 6564 5f70 6f6c 793b   = shifted_poly;
+00012000: 0a20 2020 2020 2020 2027 6c65 6e3a 2077  .        'len: w
+00012010: 6869 6c65 2032 202a 2073 203c 3d20 6661  hile 2 * s <= fa
+00012020: 6374 6f72 732e 6c65 6e28 2920 7b0a 2020  ctors.len() {.  
+00012030: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
+00012040: 7420 6673 203d 2043 6f6d 6269 6e61 7469  t fs = Combinati
+00012050: 6f6e 4974 6572 6174 6f72 3a3a 6e65 7728  onIterator::new(
+00012060: 6661 6374 6f72 732e 6c65 6e28 292c 2073  factors.len(), s
+00012070: 293b 0a20 2020 2020 2020 2020 2020 2077  );.            w
+00012080: 6869 6c65 206c 6574 2053 6f6d 6528 6373  hile let Some(cs
+00012090: 2920 3d20 6673 2e6e 6578 7428 2920 7b0a  ) = fs.next() {.
+000120a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000120b0: 6c65 7420 6d75 7420 6720 3d20 6c63 6f65  let mut g = lcoe
+000120c0: 6666 2e63 6c6f 6e65 2829 3b0a 2020 2020  ff.clone();.    
+000120d0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000120e0: 2869 2c20 6629 2069 6e20 6661 6374 6f72  (i, f) in factor
+000120f0: 732e 6974 6572 2829 2e65 6e75 6d65 7261  s.iter().enumera
+00012100: 7465 2829 207b 0a20 2020 2020 2020 2020  te() {.         
+00012110: 2020 2020 2020 2020 2020 2069 6620 6373             if cs
+00012120: 2e63 6f6e 7461 696e 7328 2669 2920 7b0a  .contains(&i) {.
+00012130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012140: 2020 2020 2020 2020 6720 3d20 2826 6720          g = (&g 
+00012150: 2a20 6629 2e6d 6f64 5f76 6172 2869 6e74  * f).mod_var(int
+00012160: 6572 706f 6c61 7469 6f6e 5f76 6172 2c20  erpolation_var, 
+00012170: 453a 3a66 726f 6d5f 7533 3228 6432 202b  E::from_u32(d2 +
+00012180: 2031 2929 3b0a 2020 2020 2020 2020 2020   1));.          
+00012190: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+000121a0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+000121b0: 2020 2020 2020 2020 2020 2020 2020 202f                 /
+000121c0: 2f20 636f 6e76 6572 7420 746f 2069 6e74  / convert to int
+000121d0: 6567 6572 0a20 2020 2020 2020 2020 2020  eger.           
+000121e0: 2020 2020 206c 6574 206d 7574 2067 5f69       let mut g_i
+000121f0: 6e74 203d 2067 2e6d 6170 5f63 6f65 6666  nt = g.map_coeff
+00012200: 287c 637c 206d 6f64 5f66 6965 6c64 2e74  (|c| mod_field.t
+00012210: 6f5f 7379 6d6d 6574 7269 635f 696e 7465  o_symmetric_inte
+00012220: 6765 7228 6329 2c20 5a29 3b0a 0a20 2020  ger(c), Z);..   
+00012230: 2020 2020 2020 2020 2020 2020 206c 6574               let
+00012240: 2063 6f6e 7465 6e74 203d 2067 5f69 6e74   content = g_int
+00012250: 2e75 6e69 7661 7269 6174 655f 636f 6e74  .univariate_cont
+00012260: 656e 7428 6d61 696e 5f76 6172 293b 0a20  ent(main_var);. 
+00012270: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00012280: 5f69 6e74 203d 2026 675f 696e 7420 2f20  _int = &g_int / 
+00012290: 2663 6f6e 7465 6e74 3b0a 0a20 2020 2020  &content;..     
+000122a0: 2020 2020 2020 2020 2020 206c 6574 2028             let (
+000122b0: 682c 2072 2920 3d20 7265 7374 2e71 756f  h, r) = rest.quo
+000122c0: 745f 7265 6d28 2667 5f69 6e74 2c20 7472  t_rem(&g_int, tr
+000122d0: 7565 293b 0a0a 2020 2020 2020 2020 2020  ue);..          
+000122e0: 2020 2020 2020 6966 2072 2e69 735f 7a65        if r.is_ze
+000122f0: 726f 2829 207b 0a20 2020 2020 2020 2020  ro() {.         
+00012300: 2020 2020 2020 2020 2020 2072 6563 5f66             rec_f
+00012310: 6163 746f 7273 2e70 7573 6828 675f 696e  actors.push(g_in
+00012320: 7429 3b0a 0a20 2020 2020 2020 2020 2020  t);..           
+00012330: 2020 2020 2020 2020 2066 6f72 2069 2069           for i i
+00012340: 6e20 6373 2e69 7465 7228 292e 7265 7628  n cs.iter().rev(
+00012350: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00012360: 2020 2020 2020 2020 2020 2020 6661 6374              fact
+00012370: 6f72 732e 7265 6d6f 7665 282a 6929 3b0a  ors.remove(*i);.
+00012380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012390: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
+000123a0: 2020 2020 2020 2020 2020 2072 6573 7420             rest 
+000123b0: 3d20 683b 0a20 2020 2020 2020 2020 2020  = h;.           
+000123c0: 2020 2020 2020 2020 2066 5f6d 6f64 203d           f_mod =
+000123d0: 2072 6573 742e 6d61 705f 636f 6566 6628   rest.map_coeff(
+000123e0: 7c63 7c20 6d6f 645f 6669 656c 642e 746f  |c| mod_field.to
+000123f0: 5f65 6c65 6d65 6e74 2863 2e63 6c6f 6e65  _element(c.clone
+00012400: 2829 292c 206d 6f64 5f66 6965 6c64 2e63  ()), mod_field.c
+00012410: 6c6f 6e65 2829 293b 0a20 2020 2020 2020  lone());.       
+00012420: 2020 2020 2020 2020 2020 2020 206c 636f               lco
+00012430: 6566 6620 3d20 665f 6d6f 642e 6c63 6f65  eff = f_mod.lcoe
+00012440: 6666 5f6c 6173 745f 7661 726f 7264 6572  ff_last_varorder
+00012450: 2826 5b6d 6169 6e5f 7661 722c 2069 6e74  (&[main_var, int
+00012460: 6572 706f 6c61 7469 6f6e 5f76 6172 5d29  erpolation_var])
+00012470: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
+00012480: 2020 2020 2020 2063 6f6e 7469 6e75 6520         continue 
+00012490: 276c 656e 3b0a 2020 2020 2020 2020 2020  'len;.          
+000124a0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+000124b0: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
+000124c0: 2020 2073 202b 3d20 313b 0a20 2020 2020     s += 1;.     
+000124d0: 2020 207d 0a0a 2020 2020 2020 2020 7265     }..        re
+000124e0: 635f 6661 6374 6f72 732e 7075 7368 2872  c_factors.push(r
+000124f0: 6573 7429 3b0a 0a20 2020 2020 2020 2069  est);..        i
+00012500: 6620 2173 616d 706c 655f 706f 696e 742e  f !sample_point.
+00012510: 6973 5f7a 6572 6f28 2920 7b0a 2020 2020  is_zero() {.    
+00012520: 2020 2020 2020 2020 666f 7220 7820 696e          for x in
+00012530: 2026 6d75 7420 7265 635f 6661 6374 6f72   &mut rec_factor
+00012540: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
+00012550: 2020 2020 2f2f 2073 6869 6674 2074 6865      // shift the
+00012560: 2070 6f6c 796e 6f6d 6961 6c20 746f 2079   polynomial to y
+00012570: 202d 2073 616d 706c 650a 2020 2020 2020   - sample.      
+00012580: 2020 2020 2020 2020 2020 2a78 203d 2078            *x = x
+00012590: 2e73 6869 6674 5f76 6172 2869 6e74 6572  .shift_var(inter
+000125a0: 706f 6c61 7469 6f6e 5f76 6172 2c20 2673  polation_var, &s
+000125b0: 656c 662e 6669 656c 642e 6e65 6728 2673  elf.field.neg(&s
+000125c0: 616d 706c 655f 706f 696e 7429 293b 0a20  ample_point));. 
+000125d0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+000125e0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+000125f0: 7265 635f 6661 6374 6f72 730a 2020 2020  rec_factors.    
+00012600: 7d0a 0a20 2020 202f 2f2f 2053 6f6c 7665  }..    /// Solve
+00012610: 2061 2044 696f 7068 616e 7469 6e65 2065   a Diophantine e
+00012620: 7175 6174 696f 6e20 6f76 6572 2074 6865  quation over the
+00012630: 2072 696e 6720 605a 5f70 5e6b 6020 7573   ring `Z_p^k` us
+00012640: 696e 6720 4e65 7774 6f6e 2069 7465 7261  ing Newton itera
+00012650: 7469 6f6e 2e0a 2020 2020 2f2f 2f20 416c  tion..    /// Al
+00012660: 6c20 6661 6374 6f72 7320 6d75 7374 2062  l factors must b
+00012670: 6520 6d6f 6e69 632e 0a20 2020 2066 6e20  e monic..    fn 
+00012680: 6c69 6674 5f64 696f 7068 616e 7469 6e65  lift_diophantine
+00012690: 5f75 6e69 7661 7269 6174 6528 0a20 2020  _univariate(.   
+000126a0: 2020 2020 2066 6163 746f 7273 3a20 266d       factors: &m
+000126b0: 7574 205b 4d75 6c74 6976 6172 6961 7465  ut [Multivariate
+000126c0: 506f 6c79 6e6f 6d69 616c 3c46 696e 6974  Polynomial<Finit
+000126d0: 6546 6965 6c64 3c49 6e74 6567 6572 3e2c  eField<Integer>,
+000126e0: 2045 2c20 4c65 784f 7264 6572 3e5d 2c0a   E, LexOrder>],.
+000126f0: 2020 2020 2020 2020 7268 733a 2026 4d75          rhs: &Mu
+00012700: 6c74 6976 6172 6961 7465 506f 6c79 6e6f  ltivariatePolyno
+00012710: 6d69 616c 3c46 696e 6974 6546 6965 6c64  mial<FiniteField
+00012720: 3c49 6e74 6567 6572 3e2c 2045 2c20 4c65  <Integer>, E, Le
+00012730: 784f 7264 6572 3e2c 0a20 2020 2020 2020  xOrder>,.       
+00012740: 2070 3a20 7533 322c 0a20 2020 2020 2020   p: u32,.       
+00012750: 206b 3a20 7573 697a 652c 0a20 2020 2029   k: usize,.    )
+00012760: 202d 3e20 5665 633c 4d75 6c74 6976 6172   -> Vec<Multivar
 00012770: 6961 7465 506f 6c79 6e6f 6d69 616c 3c46  iatePolynomial<F
 00012780: 696e 6974 6546 6965 6c64 3c49 6e74 6567  initeField<Integ
 00012790: 6572 3e2c 2045 2c20 4c65 784f 7264 6572  er>, E, LexOrder
-000127a0: 3e5d 2c0a 2020 2020 2020 2020 7268 733a  >],.        rhs:
-000127b0: 2026 4d75 6c74 6976 6172 6961 7465 506f   &MultivariatePo
-000127c0: 6c79 6e6f 6d69 616c 3c46 696e 6974 6546  lynomial<FiniteF
-000127d0: 6965 6c64 3c49 6e74 6567 6572 3e2c 2045  ield<Integer>, E
-000127e0: 2c20 4c65 784f 7264 6572 3e2c 0a20 2020  , LexOrder>,.   
-000127f0: 2020 2020 2070 3a20 7533 322c 0a20 2020       p: u32,.   
-00012800: 2020 2020 206b 3a20 7573 697a 652c 0a20       k: usize,. 
-00012810: 2020 2029 202d 3e20 5665 633c 4d75 6c74     ) -> Vec<Mult
-00012820: 6976 6172 6961 7465 506f 6c79 6e6f 6d69  ivariatePolynomi
-00012830: 616c 3c46 696e 6974 6546 6965 6c64 3c49  al<FiniteField<I
-00012840: 6e74 6567 6572 3e2c 2045 2c20 4c65 784f  nteger>, E, LexO
-00012850: 7264 6572 3e3e 207b 0a20 2020 2020 2020  rder>> {.       
-00012860: 206c 6574 2066 6965 6c64 203d 2046 696e   let field = Fin
-00012870: 6974 6546 6965 6c64 3a3a 3c75 3332 3e3a  iteField::<u32>:
-00012880: 3a6e 6577 2870 293b 0a20 2020 2020 2020  :new(p);.       
-00012890: 206c 6574 2070 7269 6d65 3a20 496e 7465   let prime: Inte
-000128a0: 6765 7220 3d20 2870 2061 7320 7536 3429  ger = (p as u64)
-000128b0: 2e69 6e74 6f28 293b 0a0a 2020 2020 2020  .into();..      
-000128c0: 2020 6c65 7420 6d75 7420 665f 703a 2056    let mut f_p: V
-000128d0: 6563 3c5f 3e20 3d20 6661 6374 6f72 730a  ec<_> = factors.
-000128e0: 2020 2020 2020 2020 2020 2020 2e69 7465              .ite
-000128f0: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-00012900: 2e6d 6170 287c 667c 2066 2e6d 6170 5f63  .map(|f| f.map_c
-00012910: 6f65 6666 287c 637c 2063 2e74 6f5f 6669  oeff(|c| c.to_fi
-00012920: 6e69 7465 5f66 6965 6c64 2826 6669 656c  nite_field(&fiel
-00012930: 6429 2c20 6669 656c 642e 636c 6f6e 6528  d), field.clone(
-00012940: 2929 290a 2020 2020 2020 2020 2020 2020  ))).            
-00012950: 2e63 6f6c 6c65 6374 2829 3b0a 2020 2020  .collect();.    
-00012960: 2020 2020 6c65 7420 7268 735f 7020 3d20      let rhs_p = 
-00012970: 7268 732e 6d61 705f 636f 6566 6628 7c63  rhs.map_coeff(|c
-00012980: 7c20 632e 746f 5f66 696e 6974 655f 6669  | c.to_finite_fi
-00012990: 656c 6428 2666 6965 6c64 292c 2066 6965  eld(&field), fie
-000129a0: 6c64 2e63 6c6f 6e65 2829 293b 0a0a 2020  ld.clone());..  
-000129b0: 2020 2020 2020 2f2f 2054 4f44 4f3a 2072        // TODO: r
-000129c0: 6563 7963 6c65 2066 726f 6d20 6669 6e69  ecycle from fini
-000129d0: 7465 2066 6965 6c64 2063 6f6d 7075 7461  te field computa
-000129e0: 7469 6f6e 2074 6861 7420 6d75 7374 2068  tion that must h
-000129f0: 6176 6520 6861 7070 656e 6564 2065 6172  ave happened ear
-00012a00: 6c69 6572 0a20 2020 2020 2020 206c 6574  lier.        let
-00012a10: 206d 7574 2064 656c 7461 203d 0a20 2020   mut delta =.   
-00012a20: 2020 2020 2020 2020 204d 756c 7469 7661           Multiva
-00012a30: 7269 6174 6550 6f6c 796e 6f6d 6961 6c3a  riatePolynomial:
-00012a40: 3a3c 4669 6e69 7465 4669 656c 643c 7533  :<FiniteField<u3
-00012a50: 323e 2c20 452c 204c 6578 4f72 6465 723e  2>, E, LexOrder>
-00012a60: 3a3a 6469 6f70 6861 6e74 696e 655f 756e  ::diophantine_un
-00012a70: 6976 6172 6961 7465 280a 2020 2020 2020  ivariate(.      
-00012a80: 2020 2020 2020 2020 2020 266d 7574 2066            &mut f
-00012a90: 5f70 2c20 2672 6873 5f70 2c0a 2020 2020  _p, &rhs_p,.    
-00012aa0: 2020 2020 2020 2020 293b 0a0a 2020 2020          );..    
-00012ab0: 2020 2020 6c65 7420 6d75 7420 6465 6c74      let mut delt
-00012ac0: 6173 3a20 5665 633c 5f3e 203d 2064 656c  as: Vec<_> = del
-00012ad0: 7461 0a20 2020 2020 2020 2020 2020 202e  ta.            .
-00012ae0: 6974 6572 2829 0a20 2020 2020 2020 2020  iter().         
-00012af0: 2020 202e 6d61 7028 7c73 7c20 7b0a 2020     .map(|s| {.  
-00012b00: 2020 2020 2020 2020 2020 2020 2020 732e                s.
-00012b10: 6d61 705f 636f 6566 6628 0a20 2020 2020  map_coeff(.     
-00012b20: 2020 2020 2020 2020 2020 2020 2020 207c                 |
-00012b30: 637c 2066 6965 6c64 2e74 6f5f 7379 6d6d  c| field.to_symm
-00012b40: 6574 7269 635f 696e 7465 6765 7228 6329  etric_integer(c)
-00012b50: 2e74 6f5f 6669 6e69 7465 5f66 6965 6c64  .to_finite_field
-00012b60: 2826 7268 732e 6669 656c 6429 2c0a 2020  (&rhs.field),.  
-00012b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012b80: 2020 7268 732e 6669 656c 642e 636c 6f6e    rhs.field.clon
-00012b90: 6528 292c 0a20 2020 2020 2020 2020 2020  e(),.           
-00012ba0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00012bb0: 2020 207d 290a 2020 2020 2020 2020 2020     }).          
-00012bc0: 2020 2e63 6f6c 6c65 6374 2829 3b0a 0a20    .collect();.. 
-00012bd0: 2020 2020 2020 2069 6620 6b20 3d3d 2031         if k == 1
-00012be0: 207b 0a20 2020 2020 2020 2020 2020 2072   {.            r
-00012bf0: 6574 7572 6e20 6465 6c74 6173 3b0a 2020  eturn deltas;.  
-00012c00: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00012c10: 206c 6574 206d 7574 2074 6f74 203d 2072   let mut tot = r
-00012c20: 6873 2e63 6f6e 7374 616e 7428 7268 732e  hs.constant(rhs.
-00012c30: 6669 656c 642e 6f6e 6528 2929 3b0a 2020  field.one());.  
-00012c40: 2020 2020 2020 666f 7220 6620 696e 2066        for f in f
-00012c50: 6163 746f 7273 2e69 7465 7228 2920 7b0a  actors.iter() {.
-00012c60: 2020 2020 2020 2020 2020 2020 746f 7420              tot 
-00012c70: 3d20 2674 6f74 202a 2066 3b0a 2020 2020  = &tot * f;.    
-00012c80: 2020 2020 7d0a 0a20 2020 2020 2020 206c      }..        l
-00012c90: 6574 2070 6920 3d20 6661 6374 6f72 730a  et pi = factors.
-00012ca0: 2020 2020 2020 2020 2020 2020 2e69 7465              .ite
-00012cb0: 725f 6d75 7428 290a 2020 2020 2020 2020  r_mut().        
-00012cc0: 2020 2020 2e6d 6170 287c 667c 2074 6f74      .map(|f| tot
-00012cd0: 2e71 756f 745f 7265 6d5f 756e 6976 6172  .quot_rem_univar
-00012ce0: 6961 7465 2866 292e 3029 0a20 2020 2020  iate(f).0).     
-00012cf0: 2020 2020 2020 202e 636f 6c6c 6563 743a         .collect:
-00012d00: 3a3c 5665 633c 5f3e 3e28 293b 0a0a 2020  :<Vec<_>>();..  
-00012d10: 2020 2020 2020 6c65 7420 6d75 7420 6d20        let mut m 
-00012d20: 3d20 7072 696d 652e 636c 6f6e 6528 293b  = prime.clone();
-00012d30: 0a0a 2020 2020 2020 2020 666f 7220 5f20  ..        for _ 
-00012d40: 696e 2031 2e2e 6b20 7b0a 2020 2020 2020  in 1..k {.      
-00012d50: 2020 2020 2020 2f2f 2054 4f44 4f3a 2069        // TODO: i
-00012d60: 7320 6272 6561 6b69 6e67 206f 6e20 653d  s breaking on e=
-00012d70: 3020 7361 6665 3f0a 2020 2020 2020 2020  0 safe?.        
-00012d80: 2020 2020 6c65 7420 6d75 7420 6520 3d20      let mut e = 
-00012d90: 7268 732e 636c 6f6e 6528 293b 0a20 2020  rhs.clone();.   
-00012da0: 2020 2020 2020 2020 2066 6f72 2028 6464           for (dd
-00012db0: 2c20 7070 2920 696e 2064 656c 7461 732e  , pp) in deltas.
-00012dc0: 6974 6572 5f6d 7574 2829 2e7a 6970 2826  iter_mut().zip(&
-00012dd0: 7069 2920 7b0a 2020 2020 2020 2020 2020  pi) {.          
-00012de0: 2020 2020 2020 6520 3d20 2665 202d 2026        e = &e - &
-00012df0: 2826 2a64 6420 2a20 7070 293b 0a20 2020  (&*dd * pp);.   
-00012e00: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
-00012e10: 2020 2020 2020 2020 6c65 7420 655f 6d20          let e_m 
-00012e20: 3d20 652e 6d61 705f 636f 6566 6628 7c63  = e.map_coeff(|c
-00012e30: 7c20 2863 202f 2026 6d29 2e74 6f5f 6669  | (c / &m).to_fi
-00012e40: 6e69 7465 5f66 6965 6c64 2826 6669 656c  nite_field(&fiel
-00012e50: 6429 2c20 6669 656c 642e 636c 6f6e 6528  d), field.clone(
-00012e60: 2929 3b0a 0a20 2020 2020 2020 2020 2020  ));..           
-00012e70: 2066 6f72 2028 2870 2c20 645f 6d29 2c20   for ((p, d_m), 
-00012e80: 6429 2069 6e20 665f 702e 6974 6572 5f6d  d) in f_p.iter_m
-00012e90: 7574 2829 2e7a 6970 2826 6d75 7420 6465  ut().zip(&mut de
-00012ea0: 6c74 6129 2e7a 6970 2864 656c 7461 732e  lta).zip(deltas.
-00012eb0: 6974 6572 5f6d 7574 2829 2920 7b0a 2020  iter_mut()) {.  
-00012ec0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00012ed0: 7420 6e65 775f 6465 6c74 6120 3d20 2826  t new_delta = (&
-00012ee0: 655f 6d20 2a20 262a 645f 6d29 2e71 756f  e_m * &*d_m).quo
-00012ef0: 745f 7265 6d5f 756e 6976 6172 6961 7465  t_rem_univariate
-00012f00: 2870 292e 313b 0a0a 2020 2020 2020 2020  (p).1;..        
-00012f10: 2020 2020 2020 2020 2a64 203d 2026 2a64          *d = &*d
-00012f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012f30: 2020 2020 202b 2026 6e65 775f 6465 6c74       + &new_delt
-00012f40: 612e 6d61 705f 636f 6566 6628 0a20 2020  a.map_coeff(.   
-00012f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f60: 2020 2020 207c 637c 2028 2666 6965 6c64       |c| (&field
-00012f70: 2e74 6f5f 7379 6d6d 6574 7269 635f 696e  .to_symmetric_in
-00012f80: 7465 6765 7228 6329 202a 2026 6d29 2e74  teger(c) * &m).t
-00012f90: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
-00012fa0: 7268 732e 6669 656c 6429 2c0a 2020 2020  rhs.field),.    
-00012fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012fc0: 2020 2020 7268 732e 6669 656c 642e 636c      rhs.field.cl
-00012fd0: 6f6e 6528 292c 0a20 2020 2020 2020 2020  one(),.         
-00012fe0: 2020 2020 2020 2020 2020 2029 3b0a 2020             );.  
-00012ff0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
-00013000: 2020 2020 2020 2020 206d 203d 2026 6d20           m = &m 
-00013010: 2a20 2670 7269 6d65 3b0a 2020 2020 2020  * &prime;.      
-00013020: 2020 7d0a 0a20 2020 2020 2020 2064 656c    }..        del
-00013030: 7461 730a 2020 2020 7d0a 0a20 2020 202f  tas.    }..    /
-00013040: 2f2f 2043 6f6d 7075 7465 2074 6865 2047  // Compute the G
-00013050: 656c 666f 6e64 2062 6f75 6e64 2066 6f72  elfond bound for
-00013060: 2074 6865 2063 6f65 6666 6963 6965 6e74   the coefficient
-00013070: 7320 6d61 676e 6974 7564 6520 6f66 2065  s magnitude of e
-00013080: 7665 7279 2066 6163 746f 7220 6f66 2074  very factor of t
-00013090: 6869 7320 706f 6c79 6e6f 6d69 616c 0a20  his polynomial. 
-000130a0: 2020 2066 6e20 636f 6566 6669 6369 656e     fn coefficien
-000130b0: 745f 626f 756e 6428 2673 656c 6629 202d  t_bound(&self) -
-000130c0: 3e20 496e 7465 6765 7220 7b0a 2020 2020  > Integer {.    
-000130d0: 2020 2020 6c65 7420 6d61 785f 6e6f 726d      let max_norm
-000130e0: 203d 2073 656c 662e 636f 6566 6669 6369   = self.coeffici
-000130f0: 656e 7473 2e69 7465 7228 292e 6d61 7028  ents.iter().map(
-00013100: 7c78 7c20 782e 6162 7328 2929 2e6d 6178  |x| x.abs()).max
-00013110: 2829 2e75 6e77 7261 7028 293b 0a0a 2020  ().unwrap();..  
-00013120: 2020 2020 2020 6c65 7420 6d75 7420 626f        let mut bo
-00013130: 756e 6420 3d20 496e 7465 6765 723a 3a6f  und = Integer::o
-00013140: 6e65 2829 3b0a 2020 2020 2020 2020 6c65  ne();.        le
-00013150: 7420 6d75 7420 746f 7461 6c5f 6465 6772  t mut total_degr
-00013160: 6565 203d 2030 3b0a 2020 2020 2020 2020  ee = 0;.        
-00013170: 6c65 7420 6d75 7420 6e6f 6e5f 7a65 726f  let mut non_zero
-00013180: 5f76 6172 7320 3d20 303b 0a20 2020 2020  _vars = 0;.     
-00013190: 2020 2066 6f72 2076 2069 6e20 302e 2e73     for v in 0..s
-000131a0: 656c 662e 6e76 6172 7320 7b0a 2020 2020  elf.nvars {.    
-000131b0: 2020 2020 2020 2020 6c65 7420 6420 3d20          let d = 
-000131c0: 7365 6c66 2e64 6567 7265 6528 7629 2e74  self.degree(v).t
-000131d0: 6f5f 7533 3228 2920 6173 2075 3634 3b0a  o_u32() as u64;.
-000131e0: 2020 2020 2020 2020 2020 2020 6966 2064              if d
-000131f0: 203e 2030 207b 0a20 2020 2020 2020 2020   > 0 {.         
-00013200: 2020 2020 2020 206e 6f6e 5f7a 6572 6f5f         non_zero_
-00013210: 7661 7273 202b 3d20 313b 0a20 2020 2020  vars += 1;.     
-00013220: 2020 2020 2020 2020 2020 2074 6f74 616c             total
-00013230: 5f64 6567 7265 6520 2b3d 2064 3b0a 2020  _degree += d;.  
-00013240: 2020 2020 2020 2020 2020 2020 2020 626f                bo
-00013250: 756e 6420 2a3d 2026 496e 7465 6765 723a  und *= &Integer:
-00013260: 3a66 726f 6d28 6420 2b20 3129 3b0a 2020  :from(d + 1);.  
-00013270: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00013280: 2020 2020 7d0a 0a20 2020 2020 2020 202f      }..        /
-00013290: 2f20 6d6f 7665 2074 6865 2032 5e6e 2069  / move the 2^n i
-000132a0: 6e74 6f20 7468 6520 7371 7274 2074 6f20  nto the sqrt to 
-000132b0: 7072 6576 656e 7420 7072 6563 6973 696f  prevent precisio
-000132c0: 6e20 6c6f 7373 2077 6865 6e20 636f 6e76  n loss when conv
-000132d0: 6572 7469 6e67 2074 6865 2073 7172 740a  erting the sqrt.
-000132e0: 2020 2020 2020 2020 2f2f 2074 6f20 616e          // to an
-000132f0: 2069 6e74 6567 6572 0a20 2020 2020 2020   integer.       
-00013300: 2062 6f75 6e64 203d 2026 626f 756e 6420   bound = &bound 
-00013310: 2a20 2649 6e74 6567 6572 3a3a 4e61 7475  * &Integer::Natu
-00013320: 7261 6c28 3229 2e70 6f77 2828 746f 7461  ral(2).pow((tota
-00013330: 6c5f 6465 6772 6565 202a 2032 292e 7361  l_degree * 2).sa
-00013340: 7475 7261 7469 6e67 5f73 7562 286e 6f6e  turating_sub(non
-00013350: 5f7a 6572 6f5f 7661 7273 2929 3b0a 0a20  _zero_vars));.. 
-00013360: 2020 2020 2020 2062 6f75 6e64 203d 2026         bound = &
-00013370: 6d61 7463 6820 626f 756e 6420 7b0a 2020  match bound {.  
-00013380: 2020 2020 2020 2020 2020 496e 7465 6765            Intege
-00013390: 723a 3a4e 6174 7572 616c 2862 2920 3d3e  r::Natural(b) =>
-000133a0: 2049 6e74 6567 6572 3a3a 4e61 7475 7261   Integer::Natura
-000133b0: 6c28 2862 2061 7320 6636 3429 2e73 7172  l((b as f64).sqr
-000133c0: 7428 2920 6173 2069 3634 292c 0a20 2020  t() as i64),.   
-000133d0: 2020 2020 2020 2020 2049 6e74 6567 6572           Integer
-000133e0: 3a3a 446f 7562 6c65 2862 2920 3d3e 2049  ::Double(b) => I
-000133f0: 6e74 6567 6572 3a3a 6672 6f6d 5f6c 6172  nteger::from_lar
-00013400: 6765 2872 7567 3a3a 496e 7465 6765 723a  ge(rug::Integer:
-00013410: 3a66 726f 6d28 6229 2e73 7172 7428 2929  :from(b).sqrt())
-00013420: 2c0a 2020 2020 2020 2020 2020 2020 496e  ,.            In
-00013430: 7465 6765 723a 3a4c 6172 6765 2862 2920  teger::Large(b) 
-00013440: 3d3e 2049 6e74 6567 6572 3a3a 6672 6f6d  => Integer::from
-00013450: 5f6c 6172 6765 2862 2e73 7172 7428 2929  _large(b.sqrt())
-00013460: 2c0a 2020 2020 2020 2020 7d20 2b20 2631  ,.        } + &1
-00013470: 6936 342e 696e 746f 2829 3b0a 0a20 2020  i64.into();..   
-00013480: 2020 2020 2026 626f 756e 6420 2a20 2628       &bound * &(
-00013490: 266d 6178 5f6e 6f72 6d20 2a20 2673 656c  &max_norm * &sel
-000134a0: 662e 6c63 6f65 6666 2829 2e61 6273 2829  f.lcoeff().abs()
-000134b0: 290a 2020 2020 7d0a 0a20 2020 202f 2f2f  ).    }..    ///
-000134c0: 2053 6f72 7420 7468 6520 6269 7661 7269   Sort the bivari
-000134d0: 6174 6520 6661 6374 6f72 7320 6261 7365  ate factors base
-000134e0: 6420 6f6e 2074 6865 6972 2075 6e69 7661  d on their univa
-000134f0: 7269 6174 6520 696d 6167 6520 736f 2074  riate image so t
-00013500: 6861 7420 7468 6579 2061 7265 0a20 2020  hat they are.   
-00013510: 202f 2f2f 2061 6c69 676e 6564 2062 6574   /// aligned bet
-00013520: 7765 656e 2074 6865 2064 6966 6665 7265  ween the differe
-00013530: 6e74 2076 6172 732e 0a20 2020 202f 2f20  nt vars..    // 
-00013540: 544f 444f 3a20 6d65 7267 6520 7769 7468  TODO: merge with
-00013550: 2074 6865 2069 6d70 6c65 6d65 6e74 6174   the implementat
-00013560: 696f 6e20 666f 7220 6669 6e69 7465 2066  ion for finite f
-00013570: 6965 6c64 7320 6173 2074 6865 2069 6d70  ields as the imp
-00013580: 6c65 6d65 6e74 6174 696f 6e0a 2020 2020  lementation.    
-00013590: 2f2f 2069 7320 616c 6d6f 7374 2069 6465  // is almost ide
-000135a0: 6e74 6963 616c 0a20 2020 2066 6e20 6361  ntical.    fn ca
-000135b0: 6e6f 6e69 6361 6c5f 736f 7274 280a 2020  nonical_sort(.  
-000135c0: 2020 2020 2020 6269 765f 706f 6c79 733a        biv_polys:
-000135d0: 2026 5b53 656c 665d 2c0a 2020 2020 2020   &[Self],.      
-000135e0: 2020 7265 706c 6163 655f 7661 723a 2075    replace_var: u
-000135f0: 7369 7a65 2c0a 2020 2020 2020 2020 7361  size,.        sa
-00013600: 6d70 6c65 5f70 6f69 6e74 733a 2026 5b28  mple_points: &[(
-00013610: 7573 697a 652c 2049 6e74 6567 6572 295d  usize, Integer)]
-00013620: 2c0a 2020 2020 2920 2d3e 2056 6563 3c28  ,.    ) -> Vec<(
-00013630: 5365 6c66 2c20 496e 7465 6765 722c 2053  Self, Integer, S
-00013640: 656c 6629 3e20 7b0a 2020 2020 2020 2020  elf)> {.        
-00013650: 6c65 7420 6d75 7420 756e 6976 6172 6961  let mut univaria
-00013660: 7465 5f66 6163 746f 7273 203d 2062 6976  te_factors = biv
-00013670: 5f70 6f6c 7973 0a20 2020 2020 2020 2020  _polys.         
-00013680: 2020 202e 6974 6572 2829 0a20 2020 2020     .iter().     
-00013690: 2020 2020 2020 202e 6d61 7028 7c66 7c20         .map(|f| 
-000136a0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-000136b0: 2020 6c65 7420 6d75 7420 7520 3d20 662e    let mut u = f.
-000136c0: 636c 6f6e 6528 293b 0a20 2020 2020 2020  clone();.       
-000136d0: 2020 2020 2020 2020 2066 6f72 2028 762c           for (v,
-000136e0: 2070 2920 696e 2073 616d 706c 655f 706f   p) in sample_po
-000136f0: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
-00013700: 2020 2020 2020 2020 2020 2069 6620 2a76             if *v
-00013710: 203d 3d20 7265 706c 6163 655f 7661 7220   == replace_var 
-00013720: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00013730: 2020 2020 2020 2020 2020 7520 3d20 752e            u = u.
-00013740: 7265 706c 6163 6528 2a76 2c20 7029 3b0a  replace(*v, p);.
-00013750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013760: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-00013770: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00013780: 2020 2020 2020 2020 202f 2f20 6d61 6b65           // make
-00013790: 2073 7572 6520 7468 6520 7265 7072 6573   sure the repres
-000137a0: 656e 7461 7469 7665 2069 7320 756e 6971  entative is uniq
-000137b0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-000137c0: 2020 206c 6574 206d 7574 2075 6e69 203d     let mut uni =
-000137d0: 2075 2e63 6c6f 6e65 2829 2e6d 616b 655f   u.clone().make_
-000137e0: 7072 696d 6974 6976 6528 293b 0a20 2020  primitive();.   
-000137f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00013800: 756e 692e 6c63 6f65 6666 2829 2e69 735f  uni.lcoeff().is_
-00013810: 6e65 6761 7469 7665 2829 207b 0a20 2020  negative() {.   
-00013820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013830: 2075 6e69 203d 202d 756e 693b 0a20 2020   uni = -uni;.   
-00013840: 2020 2020 2020 2020 2020 2020 207d 0a0a               }..
-00013850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013860: 2866 2e63 6c6f 6e65 2829 2c20 752e 6c63  (f.clone(), u.lc
-00013870: 6f65 6666 2829 2c20 756e 6929 0a20 2020  oeff(), uni).   
-00013880: 2020 2020 2020 2020 207d 290a 2020 2020           }).    
-00013890: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
-000138a0: 3a3a 3c56 6563 3c5f 3e3e 2829 3b0a 0a20  ::<Vec<_>>();.. 
-000138b0: 2020 2020 2020 2075 6e69 7661 7269 6174         univariat
-000138c0: 655f 6661 6374 6f72 732e 736f 7274 5f62  e_factors.sort_b
-000138d0: 7928 7c28 5f2c 205f 2c20 6129 2c20 285f  y(|(_, _, a), (_
-000138e0: 2c20 5f2c 2062 297c 207b 0a20 2020 2020  , _, b)| {.     
-000138f0: 2020 2020 2020 2061 2e65 7870 6f6e 656e         a.exponen
-00013900: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
-00013910: 2020 202e 636d 7028 2662 2e65 7870 6f6e     .cmp(&b.expon
-00013920: 656e 7473 290a 2020 2020 2020 2020 2020  ents).          
-00013930: 2020 2020 2020 2e74 6865 6e28 612e 636f        .then(a.co
-00013940: 6566 6669 6369 656e 7473 2e70 6172 7469  efficients.parti
-00013950: 616c 5f63 6d70 2826 622e 636f 6566 6669  al_cmp(&b.coeffi
-00013960: 6369 656e 7473 292e 756e 7772 6170 2829  cients).unwrap()
-00013970: 290a 2020 2020 2020 2020 7d29 3b0a 0a20  ).        });.. 
-00013980: 2020 2020 2020 2075 6e69 7661 7269 6174         univariat
-00013990: 655f 6661 6374 6f72 730a 2020 2020 7d0a  e_factors.    }.
-000139a0: 0a20 2020 202f 2f2f 2050 7265 636f 6d70  .    /// Precomp
-000139b0: 7574 6520 7468 6520 6c65 6164 696e 6720  ute the leading 
-000139c0: 636f 6566 6669 6369 656e 7473 206f 6620  coefficients of 
-000139d0: 7468 6520 706f 6c79 6e6f 6d69 616c 2066  the polynomial f
-000139e0: 6163 746f 7273 2c20 7573 696e 6720 616e  actors, using an
-000139f0: 0a20 2020 202f 2f2f 2061 6461 7074 6564  .    /// adapted
-00013a00: 2076 6572 7369 6f6e 206f 6620 4b61 6c74   version of Kalt
-00013a10: 6f66 656e 2773 2061 6c67 6f72 6974 686d  ofen's algorithm
-00013a20: 2074 6861 7420 6861 7320 6d6f 6469 6669   that has modifi
-00013a30: 6361 7469 6f6e 7320 6f66 204d 6172 7469  cations of Marti
-00013a40: 6e20 4c65 6520 616e 6420 5374 616e 6973  n Lee and Stanis
-00013a50: 6c61 7620 506f 736c 6176 736b 792e 0a20  lav Poslavsky.. 
-00013a60: 2020 202f 2f2f 0a20 2020 202f 2f20 544f     ///.    // TO
-00013a70: 444f 3a20 6d65 7267 6520 7769 7468 2074  DO: merge with t
-00013a80: 6865 2069 6d70 6c65 6d65 6e74 6174 696f  he implementatio
-00013a90: 6e20 666f 7220 6669 6e69 7465 2066 6965  n for finite fie
-00013aa0: 6c64 7320 6173 2074 6865 2069 6d70 6c65  lds as the imple
-00013ab0: 6d65 6e74 6174 696f 6e0a 2020 2020 2f2f  mentation.    //
-00013ac0: 2069 7320 616c 6d6f 7374 2069 6465 6e74   is almost ident
-00013ad0: 6963 616c 0a20 2020 2066 6e20 6c63 6f65  ical.    fn lcoe
-00013ae0: 6666 5f70 7265 636f 6d70 7574 6174 696f  ff_precomputatio
-00013af0: 6e28 0a20 2020 2020 2020 2026 7365 6c66  n(.        &self
-00013b00: 2c0a 2020 2020 2020 2020 6269 7661 7269  ,.        bivari
-00013b10: 6174 655f 6661 6374 6f72 733a 2026 5b53  ate_factors: &[S
-00013b20: 656c 665d 2c0a 2020 2020 2020 2020 7361  elf],.        sa
-00013b30: 6d70 6c65 5f70 6f69 6e74 733a 2026 5b28  mple_points: &[(
-00013b40: 7573 697a 652c 2049 6e74 6567 6572 295d  usize, Integer)]
-00013b50: 2c0a 2020 2020 2020 2020 6f72 6465 723a  ,.        order:
-00013b60: 2026 5b75 7369 7a65 5d2c 0a20 2020 2020   &[usize],.     
-00013b70: 2020 2062 6f75 6e64 3a20 496e 7465 6765     bound: Intege
-00013b80: 722c 0a20 2020 2020 2020 2070 3a20 7533  r,.        p: u3
-00013b90: 322c 0a20 2020 2020 2020 206b 3a20 7573  2,.        k: us
-00013ba0: 697a 652c 0a20 2020 2029 202d 3e20 5265  ize,.    ) -> Re
-00013bb0: 7375 6c74 3c28 5665 633c 5365 6c66 3e2c  sult<(Vec<Self>,
-00013bc0: 2056 6563 3c53 656c 663e 292c 2075 7369   Vec<Self>), usi
-00013bd0: 7a65 3e20 7b0a 2020 2020 2020 2020 6c65  ze> {.        le
-00013be0: 7420 6c63 6f65 6666 203d 2073 656c 662e  t lcoeff = self.
-00013bf0: 756e 6976 6172 6961 7465 5f6c 636f 6566  univariate_lcoef
-00013c00: 6628 6f72 6465 725b 305d 293b 0a20 2020  f(order[0]);.   
-00013c10: 2020 2020 206c 6574 2073 7166 203d 206c       let sqf = l
-00013c20: 636f 6566 662e 7371 7561 7265 5f66 7265  coeff.square_fre
-00013c30: 655f 6661 6374 6f72 697a 6174 696f 6e28  e_factorization(
-00013c40: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
-00013c50: 6d75 7420 6c63 6f65 6666 5f73 7175 6172  mut lcoeff_squar
-00013c60: 655f 6672 6565 203d 2073 656c 662e 6f6e  e_free = self.on
-00013c70: 6528 293b 0a20 2020 2020 2020 2066 6f72  e();.        for
-00013c80: 2028 662c 205f 2920 696e 2026 7371 6620   (f, _) in &sqf 
-00013c90: 7b0a 2020 2020 2020 2020 2020 2020 6c63  {.            lc
-00013ca0: 6f65 6666 5f73 7175 6172 655f 6672 6565  oeff_square_free
-00013cb0: 203d 2026 6c63 6f65 6666 5f73 7175 6172   = &lcoeff_squar
-00013cc0: 655f 6672 6565 202a 2066 3b0a 2020 2020  e_free * f;.    
-00013cd0: 2020 2020 7d0a 0a20 2020 2020 2020 206c      }..        l
-00013ce0: 6574 2073 6f72 7465 645f 6d61 696e 5f66  et sorted_main_f
-00013cf0: 6163 746f 7273 203d 2053 656c 663a 3a63  actors = Self::c
-00013d00: 616e 6f6e 6963 616c 5f73 6f72 7428 6269  anonical_sort(bi
-00013d10: 7661 7269 6174 655f 6661 6374 6f72 732c  variate_factors,
-00013d20: 206f 7264 6572 5b31 5d2c 2073 616d 706c   order[1], sampl
-00013d30: 655f 706f 696e 7473 293b 0a0a 2020 2020  e_points);..    
-00013d40: 2020 2020 6c65 7420 6d75 7420 7472 7565      let mut true
-00013d50: 5f6c 636f 6566 6673 3a20 5665 633c 5f3e  _lcoeffs: Vec<_>
-00013d60: 203d 2062 6976 6172 6961 7465 5f66 6163   = bivariate_fac
-00013d70: 746f 7273 2e69 7465 7228 292e 6d61 7028  tors.iter().map(
-00013d80: 7c5f 7c20 7365 6c66 2e6f 6e65 2829 292e  |_| self.one()).
-00013d90: 636f 6c6c 6563 7428 293b 0a0a 2020 2020  collect();..    
-00013da0: 2020 2020 6c65 7420 6d75 7420 6c63 6f65      let mut lcoe
-00013db0: 6666 5f6c 6566 7420 3d20 6c63 6f65 6666  ff_left = lcoeff
-00013dc0: 2e63 6c6f 6e65 2829 3b0a 0a20 2020 2020  .clone();..     
-00013dd0: 2020 206c 6574 206d 6169 6e5f 6269 7661     let main_biva
-00013de0: 7269 6174 655f 6661 6374 6f72 733a 2056  riate_factors: V
-00013df0: 6563 3c5f 3e20 3d0a 2020 2020 2020 2020  ec<_> =.        
-00013e00: 2020 2020 736f 7274 6564 5f6d 6169 6e5f      sorted_main_
-00013e10: 6661 6374 6f72 732e 696e 746f 5f69 7465  factors.into_ite
-00013e20: 7228 292e 6d61 7028 7c28 662c 205f 2c20  r().map(|(f, _, 
-00013e30: 5f29 7c20 6629 2e63 6f6c 6c65 6374 2829  _)| f).collect()
-00013e40: 3b0a 0a20 2020 2020 2020 202f 2f20 544f  ;..        // TO
-00013e50: 444f 3a20 736d 6172 7465 7220 6f72 6465  DO: smarter orde
-00013e60: 7269 6e67 0a20 2020 2020 2020 2066 6f72  ring.        for
-00013e70: 2028 692c 2026 7661 7229 2069 6e20 6f72   (i, &var) in or
-00013e80: 6465 725b 312e 2e5d 2e69 7465 7228 292e  der[1..].iter().
-00013e90: 656e 756d 6572 6174 6528 2920 7b0a 2020  enumerate() {.  
-00013ea0: 2020 2020 2020 2020 2020 6966 206c 636f            if lco
-00013eb0: 6566 665f 6c65 6674 2e69 735f 6f6e 6528  eff_left.is_one(
-00013ec0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00013ed0: 2020 2020 6272 6561 6b3b 0a20 2020 2020      break;.     
-00013ee0: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
-00013ef0: 2020 2020 2020 6966 206c 636f 6566 665f        if lcoeff_
-00013f00: 6c65 6674 2e64 6567 7265 6528 7661 7229  left.degree(var)
-00013f10: 2e69 735f 7a65 726f 2829 207b 0a20 2020  .is_zero() {.   
-00013f20: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00013f30: 7469 6e75 653b 0a20 2020 2020 2020 2020  tinue;.         
-00013f40: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00013f50: 2020 2f2f 206f 6e6c 7920 636f 6e73 7472    // only constr
-00013f60: 7563 7420 6661 6374 6f72 7320 7468 6174  uct factors that
-00013f70: 2064 6570 656e 6420 6f6e 2076 6172 2061   depend on var a
-00013f80: 6e64 2072 656d 6f76 6520 696e 7465 6765  nd remove intege
-00013f90: 7220 636f 6e74 656e 7420 616e 6420 756e  r content and un
-00013fa0: 6974 0a20 2020 2020 2020 2020 2020 206c  it.            l
-00013fb0: 6574 2063 203d 206c 636f 6566 665f 7371  et c = lcoeff_sq
-00013fc0: 7561 7265 5f66 7265 652e 756e 6976 6172  uare_free.univar
-00013fd0: 6961 7465 5f63 6f6e 7465 6e74 2876 6172  iate_content(var
-00013fe0: 293b 0a20 2020 2020 2020 2020 2020 206c  );.            l
-00013ff0: 6574 206d 7574 206c 636f 6566 665f 7371  et mut lcoeff_sq
-00014000: 7561 7265 5f66 7265 655f 7070 203d 2026  uare_free_pp = &
-00014010: 6c63 6f65 6666 5f73 7175 6172 655f 6672  lcoeff_square_fr
-00014020: 6565 202f 2026 633b 0a20 2020 2020 2020  ee / &c;.       
-00014030: 2020 2020 2069 6620 6c63 6f65 6666 5f73       if lcoeff_s
-00014040: 7175 6172 655f 6672 6565 5f70 702e 6c63  quare_free_pp.lc
-00014050: 6f65 6666 2829 2e69 735f 6e65 6761 7469  oeff().is_negati
-00014060: 7665 2829 207b 0a20 2020 2020 2020 2020  ve() {.         
-00014070: 2020 2020 2020 206c 636f 6566 665f 7371         lcoeff_sq
-00014080: 7561 7265 5f66 7265 655f 7070 203d 202d  uare_free_pp = -
-00014090: 6c63 6f65 6666 5f73 7175 6172 655f 6672  lcoeff_square_fr
-000140a0: 6565 5f70 703b 0a20 2020 2020 2020 2020  ee_pp;.         
-000140b0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-000140c0: 2064 6562 7567 2128 2243 6f6e 7465 6e74   debug!("Content
-000140d0: 2d66 7265 6520 6c63 7371 6620 7b7d 222c  -free lcsqf {}",
-000140e0: 206c 636f 6566 665f 7371 7561 7265 5f66   lcoeff_square_f
-000140f0: 7265 655f 7070 293b 0a0a 2020 2020 2020  ree_pp);..      
-00014100: 2020 2020 2020 2f2f 2063 6865 636b 2069        // check i
-00014110: 6620 7468 6520 6576 616c 7561 7465 6420  f the evaluated 
-00014120: 6c65 6164 696e 6720 636f 6566 6669 6369  leading coeffici
-00014130: 656e 7420 7265 6d61 696e 7320 7371 7561  ent remains squa
-00014140: 7265 2066 7265 650a 2020 2020 2020 2020  re free.        
-00014150: 2020 2020 6c65 7420 6d75 7420 706f 6c79      let mut poly
-00014160: 5f65 7661 6c20 3d20 6c63 6f65 6666 5f73  _eval = lcoeff_s
-00014170: 7175 6172 655f 6672 6565 5f70 702e 636c  quare_free_pp.cl
-00014180: 6f6e 6528 293b 0a20 2020 2020 2020 2020  one();.         
-00014190: 2020 2066 6f72 2028 762c 2070 2920 696e     for (v, p) in
-000141a0: 2073 616d 706c 655f 706f 696e 7473 207b   sample_points {
-000141b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000141c0: 2069 6620 2a76 2021 3d20 7661 7220 7b0a   if *v != var {.
-000141d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000141e0: 2020 2020 706f 6c79 5f65 7661 6c20 3d20      poly_eval = 
-000141f0: 706f 6c79 5f65 7661 6c2e 7265 706c 6163  poly_eval.replac
-00014200: 6528 2a76 2c20 7029 3b0a 2020 2020 2020  e(*v, p);.      
-00014210: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00014220: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00014230: 2020 2020 2020 6c65 7420 7371 6620 3d20        let sqf = 
-00014240: 706f 6c79 5f65 7661 6c2e 7371 7561 7265  poly_eval.square
-00014250: 5f66 7265 655f 6661 6374 6f72 697a 6174  _free_factorizat
-00014260: 696f 6e28 293b 0a20 2020 2020 2020 2020  ion();.         
-00014270: 2020 2069 6620 7371 662e 6c65 6e28 2920     if sqf.len() 
-00014280: 213d 2031 207c 7c20 7371 665b 305d 2e31  != 1 || sqf[0].1
-00014290: 2021 3d20 3120 7b0a 2020 2020 2020 2020   != 1 {.        
-000142a0: 2020 2020 2020 2020 6465 6275 6721 2822          debug!("
-000142b0: 506f 6c79 6e6f 6d69 616c 2069 7320 6e6f  Polynomial is no
-000142c0: 7420 7371 7561 7265 2066 7265 653a 207b  t square free: {
-000142d0: 7d22 2c20 706f 6c79 5f65 7661 6c29 3b0a  }", poly_eval);.
-000142e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000142f0: 7265 7475 726e 2045 7272 286d 6169 6e5f  return Err(main_
-00014300: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00014310: 732e 6c65 6e28 2929 3b0a 2020 2020 2020  s.len());.      
-00014320: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00014330: 2020 2020 206c 6574 2062 6976 6172 6961       let bivaria
-00014340: 7465 5f66 6163 746f 7273 203d 2069 6620  te_factors = if 
-00014350: 7661 7220 3d3d 206f 7264 6572 5b31 5d20  var == order[1] 
-00014360: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00014370: 2020 6d61 696e 5f62 6976 6172 6961 7465    main_bivariate
-00014380: 5f66 6163 746f 7273 2e74 6f5f 7665 6328  _factors.to_vec(
-00014390: 290a 2020 2020 2020 2020 2020 2020 7d20  ).            } 
-000143a0: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
-000143b0: 2020 2020 2020 206c 6574 206d 7574 2070         let mut p
-000143c0: 6f6c 795f 6576 616c 203d 2073 656c 662e  oly_eval = self.
-000143d0: 636c 6f6e 6528 293b 0a20 2020 2020 2020  clone();.       
-000143e0: 2020 2020 2020 2020 2066 6f72 2028 762c           for (v,
-000143f0: 2070 2920 696e 2073 616d 706c 655f 706f   p) in sample_po
-00014400: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
-00014410: 2020 2020 2020 2020 2020 2069 6620 2a76             if *v
-00014420: 2021 3d20 7661 7220 7b0a 2020 2020 2020   != var {.      
-00014430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014440: 2020 706f 6c79 5f65 7661 6c20 3d20 706f    poly_eval = po
-00014450: 6c79 5f65 7661 6c2e 7265 706c 6163 6528  ly_eval.replace(
-00014460: 2a76 2c20 7029 3b0a 2020 2020 2020 2020  *v, p);.        
-00014470: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00014480: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-00014490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000144a0: 2069 6620 706f 6c79 5f65 7661 6c2e 6465   if poly_eval.de
-000144b0: 6772 6565 286f 7264 6572 5b30 5d29 2021  gree(order[0]) !
-000144c0: 3d20 7365 6c66 2e64 6567 7265 6528 6f72  = self.degree(or
-000144d0: 6465 725b 305d 290a 2020 2020 2020 2020  der[0]).        
-000144e0: 2020 2020 2020 2020 2020 2020 7c7c 2070              || p
-000144f0: 6f6c 795f 6576 616c 2e64 6567 7265 6528  oly_eval.degree(
-00014500: 7661 7229 2021 3d20 7365 6c66 2e64 6567  var) != self.deg
-00014510: 7265 6528 7661 7229 0a20 2020 2020 2020  ree(var).       
-00014520: 2020 2020 2020 2020 2020 2020 207c 7c20               || 
-00014530: 706f 6c79 5f65 7661 6c2e 756e 6976 6172  poly_eval.univar
-00014540: 6961 7465 5f6c 636f 6566 6628 6f72 6465  iate_lcoeff(orde
-00014550: 725b 305d 292e 6465 6772 6565 2876 6172  r[0]).degree(var
-00014560: 2920 213d 206c 636f 6566 662e 6465 6772  ) != lcoeff.degr
-00014570: 6565 2876 6172 290a 2020 2020 2020 2020  ee(var).        
-00014580: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
-00014590: 2020 2020 2020 2020 2020 2020 2020 6465                de
-000145a0: 6275 6721 2822 4261 6420 7361 6d70 6c65  bug!("Bad sample
-000145b0: 2066 6f72 2072 6563 6f6e 7374 7275 6374   for reconstruct
-000145c0: 696e 6720 6c63 6f65 6666 3a20 6465 6772  ing lcoeff: degr
-000145d0: 6565 7320 646f 206e 6f74 206d 6174 6368  ees do not match
-000145e0: 2229 3b0a 2020 2020 2020 2020 2020 2020  ");.            
-000145f0: 2020 2020 2020 2020 7265 7475 726e 2045          return E
-00014600: 7272 286d 6169 6e5f 6269 7661 7269 6174  rr(main_bivariat
-00014610: 655f 6661 6374 6f72 732e 6c65 6e28 2929  e_factors.len())
-00014620: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00014630: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00014640: 2020 2020 206c 6574 2062 6976 6172 6961       let bivaria
-00014650: 7465 5f66 6163 746f 7273 3a20 5665 633c  te_factors: Vec<
-00014660: 5f3e 203d 2070 6f6c 795f 6576 616c 0a20  _> = poly_eval. 
-00014670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014680: 2020 202e 6661 6374 6f72 2829 0a20 2020     .factor().   
-00014690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000146a0: 202e 696e 746f 5f69 7465 7228 290a 2020   .into_iter().  
-000146b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000146c0: 2020 2e6d 6170 287c 2866 2c20 5f29 7c20    .map(|(f, _)| 
-000146d0: 6629 0a20 2020 2020 2020 2020 2020 2020  f).             
-000146e0: 2020 2020 2020 202f 2f20 7265 6d6f 7665         // remove
-000146f0: 2073 7075 7269 6f75 7320 636f 6e74 656e   spurious conten
-00014700: 7420 6361 7573 6564 2062 7920 7061 7274  t caused by part
-00014710: 6963 756c 6172 2065 7661 6c75 6174 696f  icular evaluatio
-00014720: 6e20 706f 696e 740a 2020 2020 2020 2020  n point.        
-00014730: 2020 2020 2020 2020 2020 2020 2e66 696c              .fil
-00014740: 7465 7228 7c66 7c20 2166 2e69 735f 636f  ter(|f| !f.is_co
-00014750: 6e73 7461 6e74 2829 290a 2020 2020 2020  nstant()).      
-00014760: 2020 2020 2020 2020 2020 2020 2020 2e63                .c
-00014770: 6f6c 6c65 6374 2829 3b0a 0a20 2020 2020  ollect();..     
-00014780: 2020 2020 2020 2020 2020 2069 6620 6269             if bi
-00014790: 7661 7269 6174 655f 6661 6374 6f72 732e  variate_factors.
-000147a0: 6c65 6e28 2920 213d 206d 6169 6e5f 6269  len() != main_bi
-000147b0: 7661 7269 6174 655f 6661 6374 6f72 732e  variate_factors.
-000147c0: 6c65 6e28 2920 7b0a 2020 2020 2020 2020  len() {.        
-000147d0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000147e0: 726e 2045 7272 2862 6976 6172 6961 7465  rn Err(bivariate
-000147f0: 5f66 6163 746f 7273 2e6c 656e 2829 2e6d  _factors.len().m
-00014800: 696e 286d 6169 6e5f 6269 7661 7269 6174  in(main_bivariat
-00014810: 655f 6661 6374 6f72 732e 6c65 6e28 2929  e_factors.len())
-00014820: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00014830: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00014840: 2020 2020 2020 5365 6c66 3a3a 6361 6e6f        Self::cano
-00014850: 6e69 6361 6c5f 736f 7274 2826 6269 7661  nical_sort(&biva
-00014860: 7269 6174 655f 6661 6374 6f72 732c 2076  riate_factors, v
-00014870: 6172 2c20 7361 6d70 6c65 5f70 6f69 6e74  ar, sample_point
-00014880: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
-00014890: 2020 2020 2020 202e 696e 746f 5f69 7465         .into_ite
-000148a0: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-000148b0: 2020 2020 2020 2020 2e6d 6170 287c 2866          .map(|(f
-000148c0: 2c20 5f2c 205f 297c 2066 290a 2020 2020  , _, _)| f).    
-000148d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000148e0: 2e63 6f6c 6c65 6374 2829 0a20 2020 2020  .collect().     
-000148f0: 2020 2020 2020 207d 3b0a 0a20 2020 2020         };..     
-00014900: 2020 2020 2020 206c 6574 2073 7175 6172         let squar
-00014910: 655f 6672 6565 5f6c 635f 6269 765f 6661  e_free_lc_biv_fa
-00014920: 6374 6f72 733a 2056 6563 3c5f 3e20 3d20  ctors: Vec<_> = 
-00014930: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00014940: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
-00014950: 2020 2e69 7465 7228 290a 2020 2020 2020    .iter().      
-00014960: 2020 2020 2020 2020 2020 2e6d 6170 287c            .map(|
-00014970: 667c 207b 0a20 2020 2020 2020 2020 2020  f| {.           
-00014980: 2020 2020 2020 2020 206c 6574 206d 7574           let mut
-00014990: 2073 6666 203d 2066 2e75 6e69 7661 7269   sff = f.univari
-000149a0: 6174 655f 6c63 6f65 6666 286f 7264 6572  ate_lcoeff(order
-000149b0: 5b30 5d29 2e73 7175 6172 655f 6672 6565  [0]).square_free
-000149c0: 5f66 6163 746f 7269 7a61 7469 6f6e 2829  _factorization()
-000149d0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-000149e0: 2020 2020 2020 2f2f 206d 616b 6520 7375        // make su
-000149f0: 7265 2065 7665 7279 2062 6976 6172 6961  re every bivaria
-00014a00: 7465 2066 6163 746f 7220 6861 7320 706f  te factor has po
-00014a10: 7369 7469 7665 206c 636f 6566 6620 7375  sitive lcoeff su
-00014a20: 6368 2074 6861 7420 7468 6520 7072 6f64  ch that the prod
-00014a30: 7563 740a 2020 2020 2020 2020 2020 2020  uct.            
-00014a40: 2020 2020 2020 2020 2f2f 206f 6620 7468          // of th
-00014a50: 6520 6261 7369 7320 656c 656d 656e 7473  e basis elements
-00014a60: 2065 7175 616c 7320 7468 6520 6576 616c   equals the eval
-00014a70: 7561 7465 6420 6c63 6f65 6666 5f73 7175  uated lcoeff_squ
-00014a80: 6172 655f 6672 6565 5f70 700a 2020 2020  are_free_pp.    
-00014a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014aa0: 666f 7220 2862 2c20 5f29 2069 6e20 266d  for (b, _) in &m
-00014ab0: 7574 2073 6666 207b 0a20 2020 2020 2020  ut sff {.       
-00014ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014ad0: 2069 6620 622e 6c63 6f65 6666 2829 2e69   if b.lcoeff().i
-00014ae0: 735f 6e65 6761 7469 7665 2829 207b 0a20  s_negative() {. 
-00014af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b00: 2020 2020 2020 2020 2020 202a 6220 3d20             *b = 
-00014b10: 2d62 2e63 6c6f 6e65 2829 3b0a 2020 2020  -b.clone();.    
-00014b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b30: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-00014b40: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00014b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b60: 7366 660a 2020 2020 2020 2020 2020 2020  sff.            
-00014b70: 2020 2020 7d29 0a20 2020 2020 2020 2020      }).         
-00014b80: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
-00014b90: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-00014ba0: 6c65 7420 6261 7369 7320 3d20 5365 6c66  let basis = Self
-00014bb0: 3a3a 6763 645f 6672 6565 5f62 6173 6973  ::gcd_free_basis
-00014bc0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00014bd0: 2020 7371 7561 7265 5f66 7265 655f 6c63    square_free_lc
-00014be0: 5f62 6976 5f66 6163 746f 7273 0a20 2020  _biv_factors.   
-00014bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c00: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
-00014c10: 2020 2020 2020 2020 2020 2020 202e 666c               .fl
-00014c20: 6174 7465 6e28 290a 2020 2020 2020 2020  atten().        
-00014c30: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
-00014c40: 287c 787c 2078 2e30 2e63 6c6f 6e65 2829  (|x| x.0.clone()
-00014c50: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00014c60: 2020 2020 2020 2e66 696c 7465 7228 7c78        .filter(|x
-00014c70: 7c20 2178 2e69 735f 636f 6e73 7461 6e74  | !x.is_constant
-00014c80: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
-00014c90: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
-00014ca0: 2829 2c0a 2020 2020 2020 2020 2020 2020  (),.            
-00014cb0: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-00014cc0: 6966 2062 6173 6973 2e69 735f 656d 7074  if basis.is_empt
-00014cd0: 7928 2920 7b0a 2020 2020 2020 2020 2020  y() {.          
-00014ce0: 2020 2020 2020 636f 6e74 696e 7565 3b0a        continue;.
-00014cf0: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
-00014d00: 2020 2020 2020 2020 2020 206c 6574 206c             let l
-00014d10: 6966 7465 6420 3d20 6966 2062 6173 6973  ifted = if basis
-00014d20: 2e6c 656e 2829 203d 3d20 3120 7b0a 2020  .len() == 1 {.  
-00014d30: 2020 2020 2020 2020 2020 2020 2020 7665                ve
-00014d40: 6321 5b6c 636f 6566 665f 7371 7561 7265  c![lcoeff_square
-00014d50: 5f66 7265 655f 7070 2e63 6c6f 6e65 2829  _free_pp.clone()
-00014d60: 5d0a 2020 2020 2020 2020 2020 2020 7d20  ].            } 
-00014d70: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
-00014d80: 2020 2020 2020 206c 6574 206d 7574 206e         let mut n
-00014d90: 6577 5f6f 7264 6572 203d 206f 7264 6572  ew_order = order
-00014da0: 2e74 6f5f 7665 6328 293b 0a20 2020 2020  .to_vec();.     
-00014db0: 2020 2020 2020 2020 2020 206e 6577 5f6f             new_o
-00014dc0: 7264 6572 2e73 7761 7028 312c 2069 202b  rder.swap(1, i +
-00014dd0: 2031 293b 0a20 2020 2020 2020 2020 2020   1);.           
-00014de0: 2020 2020 206e 6577 5f6f 7264 6572 2e72       new_order.r
-00014df0: 656d 6f76 6528 3029 3b0a 0a20 2020 2020  emove(0);..     
-00014e00: 2020 2020 2020 2020 2020 206c 636f 6566             lcoef
-00014e10: 665f 7371 7561 7265 5f66 7265 655f 7070  f_square_free_pp
-00014e20: 2e6d 756c 7469 7661 7269 6174 655f 6865  .multivariate_he
-00014e30: 6e73 656c 5f6c 6966 745f 7769 7468 5f61  nsel_lift_with_a
-00014e40: 7574 6f5f 6c63 6f65 6666 5f66 6978 696e  uto_lcoeff_fixin
-00014e50: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
-00014e60: 2020 2020 2020 2026 6261 7369 732c 0a20         &basis,. 
-00014e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e80: 2020 2073 616d 706c 655f 706f 696e 7473     sample_points
-00014e90: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00014ea0: 2020 2020 2020 266e 6577 5f6f 7264 6572        &new_order
-00014eb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00014ec0: 2020 2020 2020 626f 756e 642e 636c 6f6e        bound.clon
-00014ed0: 6528 292c 0a20 2020 2020 2020 2020 2020  e(),.           
-00014ee0: 2020 2020 2020 2020 2070 2c0a 2020 2020           p,.    
-00014ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f00: 6b2c 0a20 2020 2020 2020 2020 2020 2020  k,.             
-00014f10: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-00014f20: 207d 3b0a 0a20 2020 2020 2020 2020 2020   };..           
-00014f30: 2066 6f72 2028 6c2c 2066 6163 2920 696e   for (l, fac) in
-00014f40: 2074 7275 655f 6c63 6f65 6666 732e 6974   true_lcoeffs.it
-00014f50: 6572 5f6d 7574 2829 2e7a 6970 2826 7371  er_mut().zip(&sq
-00014f60: 7561 7265 5f66 7265 655f 6c63 5f62 6976  uare_free_lc_biv
-00014f70: 5f66 6163 746f 7273 2920 7b0a 2020 2020  _factors) {.    
-00014f80: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00014f90: 6d75 7420 636f 6e74 7269 6220 3d20 7365  mut contrib = se
-00014fa0: 6c66 2e6f 6e65 2829 3b0a 2020 2020 2020  lf.one();.      
-00014fb0: 2020 2020 2020 2020 2020 666f 7220 2866            for (f
-00014fc0: 756c 6c2c 2062 2920 696e 206c 6966 7465  ull, b) in lifte
-00014fd0: 642e 6974 6572 2829 2e7a 6970 2826 6261  d.iter().zip(&ba
-00014fe0: 7369 7329 207b 0a20 2020 2020 2020 2020  sis) {.         
-00014ff0: 2020 2020 2020 2020 2020 202f 2f20 6368             // ch
-00015000: 6563 6b20 6966 2061 2047 4344 2d66 7265  eck if a GCD-fre
-00015010: 6520 6261 7369 7320 656c 656d 656e 7420  e basis element 
-00015020: 6973 2061 2066 6163 746f 7220 6f66 2074  is a factor of t
-00015030: 6865 206c 6561 6469 6e67 2063 6f65 6666  he leading coeff
-00015040: 6963 6965 6e74 206f 6620 7468 6973 2062  icient of this b
-00015050: 6976 6172 6961 7465 2066 6163 746f 720a  ivariate factor.
-00015060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015070: 2020 2020 6966 206c 6574 2053 6f6d 6528      if let Some(
-00015080: 285f 2c20 6d29 2920 3d20 6661 632e 6974  (_, m)) = fac.it
-00015090: 6572 2829 2e66 696e 6428 7c28 662c 205f  er().find(|(f, _
-000150a0: 297c 2066 203d 3d20 6220 7c7c 2066 2e64  )| f == b || f.d
-000150b0: 6976 6964 6573 2862 292e 6973 5f73 6f6d  ivides(b).is_som
-000150c0: 6528 2929 0a20 2020 2020 2020 2020 2020  e()).           
-000150d0: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
-000150e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000150f0: 2020 2066 6f72 205f 2069 6e20 302e 2e2a     for _ in 0..*
-00015100: 6d20 7b0a 2020 2020 2020 2020 2020 2020  m {.            
-00015110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015120: 636f 6e74 7269 6220 3d20 2663 6f6e 7472  contrib = &contr
-00015130: 6962 202a 2066 756c 6c3b 0a20 2020 2020  ib * full;.     
-00015140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015150: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00015160: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00015170: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
-00015180: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00015190: 7420 6720 3d20 636f 6e74 7269 622e 6763  t g = contrib.gc
-000151a0: 6428 6c29 3b0a 2020 2020 2020 2020 2020  d(l);.          
-000151b0: 2020 2020 2020 6c65 7420 6e65 7720 3d20        let new = 
-000151c0: 2863 6f6e 7472 6962 202f 2026 6729 2e6d  (contrib / &g).m
-000151d0: 616b 655f 7072 696d 6974 6976 6528 293b  ake_primitive();
-000151e0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000151f0: 2020 2a6c 203d 2028 262a 6c20 2a20 266e    *l = (&*l * &n
-00015200: 6577 292e 6d61 6b65 5f70 7269 6d69 7469  ew).make_primiti
-00015210: 7665 2829 3b0a 0a20 2020 2020 2020 2020  ve();..         
-00015220: 2020 2020 2020 206c 6574 2028 712c 2072         let (q, r
-00015230: 2920 3d20 6c63 6f65 6666 5f6c 6566 742e  ) = lcoeff_left.
-00015240: 7175 6f74 5f72 656d 2826 6e65 772c 2074  quot_rem(&new, t
-00015250: 7275 6529 3b0a 2020 2020 2020 2020 2020  rue);.          
-00015260: 2020 2020 2020 6966 2021 722e 6973 5f7a        if !r.is_z
-00015270: 6572 6f28 2920 7b0a 2020 2020 2020 2020  ero() {.        
-00015280: 2020 2020 2020 2020 2020 2020 7061 6e69              pani
-00015290: 6321 280a 2020 2020 2020 2020 2020 2020  c!(.            
-000152a0: 2020 2020 2020 2020 2020 2020 2250 726f              "Pro
-000152b0: 626c 656d 2077 6974 6820 6269 7661 7269  blem with bivari
-000152c0: 6174 6520 6661 6374 6f72 2073 6361 6c69  ate factor scali
-000152d0: 6e67 2069 6e20 6661 6374 6f72 697a 6174  ng in factorizat
-000152e0: 696f 6e20 6f66 207b 7d3a 206f 7264 6572  ion of {}: order
-000152f0: 3d7b 3a3f 7d2c 2073 616d 706c 6573 3d7b  ={:?}, samples={
-00015300: 3a3f 7d22 2c0a 2020 2020 2020 2020 2020  :?}",.          
-00015310: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00015320: 6c66 2c0a 2020 2020 2020 2020 2020 2020  lf,.            
-00015330: 2020 2020 2020 2020 2020 2020 6f72 6465              orde
-00015340: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
-00015350: 2020 2020 2020 2020 2020 2073 616d 706c             sampl
-00015360: 655f 706f 696e 7473 0a20 2020 2020 2020  e_points.       
-00015370: 2020 2020 2020 2020 2020 2020 2029 3b0a               );.
-00015380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015390: 7d0a 0a20 2020 2020 2020 2020 2020 2020  }..             
-000153a0: 2020 206c 636f 6566 665f 6c65 6674 203d     lcoeff_left =
-000153b0: 2071 3b0a 2020 2020 2020 2020 2020 2020   q;.            
-000153c0: 7d0a 2020 2020 2020 2020 7d0a 0a20 2020  }.        }..   
-000153d0: 2020 2020 2069 6620 216c 636f 6566 665f       if !lcoeff_
-000153e0: 6c65 6674 2e69 735f 636f 6e73 7461 6e74  left.is_constant
-000153f0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00015400: 2070 616e 6963 2128 0a20 2020 2020 2020   panic!(.       
-00015410: 2020 2020 2020 2020 2022 436f 756c 6420           "Could 
-00015420: 6e6f 7420 7265 636f 6e73 7472 7563 7420  not reconstruct 
-00015430: 6c65 6164 696e 6720 636f 6566 6669 6369  leading coeffici
-00015440: 656e 7420 6f66 207b 7d3a 206f 7264 6572  ent of {}: order
-00015450: 3d7b 3a3f 7d2c 2073 616d 706c 6573 3d7b  ={:?}, samples={
-00015460: 3a3f 7d20 5265 7374 203d 207b 7d22 2c0a  :?} Rest = {}",.
-00015470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015480: 7365 6c66 2c0a 2020 2020 2020 2020 2020  self,.          
-00015490: 2020 2020 2020 6f72 6465 722c 0a20 2020        order,.   
-000154a0: 2020 2020 2020 2020 2020 2020 2073 616d               sam
-000154b0: 706c 655f 706f 696e 7473 2c0a 2020 2020  ple_points,.    
-000154c0: 2020 2020 2020 2020 2020 2020 6c63 6f65              lcoe
-000154d0: 6666 5f6c 6566 740a 2020 2020 2020 2020  ff_left.        
-000154e0: 2020 2020 293b 0a20 2020 2020 2020 207d      );.        }
-000154f0: 0a0a 2020 2020 2020 2020 2f2f 2072 6573  ..        // res
-00015500: 6361 6c65 2074 6865 206c 6561 6469 6e67  cale the leading
-00015510: 2063 6f65 6666 6963 6965 6e74 2066 6163   coefficient fac
-00015520: 746f 7273 2074 6f20 7265 636f 7665 7220  tors to recover 
-00015530: 7468 6520 6d69 7373 696e 6720 636f 6e74  the missing cont
-00015540: 656e 7420 616e 6420 7369 676e 0a20 2020  ent and sign.   
-00015550: 2020 2020 2066 6f72 2028 662c 2062 2920       for (f, b) 
-00015560: 696e 2074 7275 655f 6c63 6f65 6666 732e  in true_lcoeffs.
-00015570: 6974 6572 5f6d 7574 2829 2e7a 6970 2826  iter_mut().zip(&
-00015580: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
-00015590: 6163 746f 7273 2920 7b0a 2020 2020 2020  actors) {.      
-000155a0: 2020 2020 2020 6c65 7420 6d75 7420 625f        let mut b_
-000155b0: 6576 616c 203d 2062 2e63 6c6f 6e65 2829  eval = b.clone()
-000155c0: 3b0a 2020 2020 2020 2020 2020 2020 666f  ;.            fo
-000155d0: 7220 2876 2c20 7029 2069 6e20 7361 6d70  r (v, p) in samp
-000155e0: 6c65 5f70 6f69 6e74 7320 7b0a 2020 2020  le_points {.    
-000155f0: 2020 2020 2020 2020 2020 2020 625f 6576              b_ev
-00015600: 616c 203d 2062 5f65 7661 6c2e 7265 706c  al = b_eval.repl
-00015610: 6163 6528 2a76 2c20 7029 3b0a 2020 2020  ace(*v, p);.    
-00015620: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00015630: 2020 2020 2020 206c 6574 2062 5f6c 6320         let b_lc 
-00015640: 3d20 625f 6576 616c 2e6c 636f 6566 6628  = b_eval.lcoeff(
-00015650: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-00015660: 6c65 7420 6d75 7420 665f 6576 616c 203d  let mut f_eval =
-00015670: 2066 2e63 6c6f 6e65 2829 3b0a 2020 2020   f.clone();.    
-00015680: 2020 2020 2020 2020 666f 7220 2876 2c20          for (v, 
-00015690: 7029 2069 6e20 7361 6d70 6c65 5f70 6f69  p) in sample_poi
-000156a0: 6e74 7320 7b0a 2020 2020 2020 2020 2020  nts {.          
-000156b0: 2020 2020 2020 665f 6576 616c 203d 2066        f_eval = f
-000156c0: 5f65 7661 6c2e 7265 706c 6163 6528 2a76  _eval.replace(*v
-000156d0: 2c20 7029 3b0a 2020 2020 2020 2020 2020  , p);.          
-000156e0: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-000156f0: 6c65 7420 665f 6c63 203d 2066 5f65 7661  let f_lc = f_eva
-00015700: 6c2e 6c63 6f65 6666 2829 3b0a 0a20 2020  l.lcoeff();..   
-00015710: 2020 2020 2020 2020 206c 6574 2028 712c           let (q,
-00015720: 2072 2920 3d20 496e 7465 6765 7252 696e   r) = IntegerRin
-00015730: 673a 3a6e 6577 2829 2e71 756f 745f 7265  g::new().quot_re
-00015740: 6d28 2662 5f6c 632c 2026 665f 6c63 293b  m(&b_lc, &f_lc);
-00015750: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
-00015760: 6572 7421 280a 2020 2020 2020 2020 2020  ert!(.          
-00015770: 2020 2020 2020 722e 6973 5f7a 6572 6f28        r.is_zero(
-00015780: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00015790: 2020 2022 5072 6f62 6c65 6d20 7769 7468     "Problem with
-000157a0: 2062 6976 6172 6961 7465 2066 6163 746f   bivariate facto
-000157b0: 7220 7363 616c 696e 6720 696e 2066 6163  r scaling in fac
-000157c0: 746f 7269 7a61 7469 6f6e 206f 6620 7b7d  torization of {}
-000157d0: 3a20 6f72 6465 723d 7b3a 3f7d 2c20 7361  : order={:?}, sa
-000157e0: 6d70 6c65 733d 7b3a 3f7d 222c 0a20 2020  mples={:?}",.   
-000157f0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00015800: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
-00015810: 2020 206f 7264 6572 2c0a 2020 2020 2020     order,.      
-00015820: 2020 2020 2020 2020 2020 7361 6d70 6c65            sample
-00015830: 5f70 6f69 6e74 730a 2020 2020 2020 2020  _points.        
-00015840: 2020 2020 293b 0a0a 2020 2020 2020 2020      );..        
-00015850: 2020 2020 6c63 6f65 6666 5f6c 6566 7420      lcoeff_left 
-00015860: 3d20 6c63 6f65 6666 5f6c 6566 742e 6469  = lcoeff_left.di
-00015870: 765f 636f 6566 6628 2671 293b 0a20 2020  v_coeff(&q);.   
-00015880: 2020 2020 2020 2020 202a 6620 3d20 662e           *f = f.
-00015890: 636c 6f6e 6528 292e 6d75 6c5f 636f 6566  clone().mul_coef
-000158a0: 6628 7129 3b0a 2020 2020 2020 2020 7d0a  f(q);.        }.
-000158b0: 0a20 2020 2020 2020 2069 6620 216c 636f  .        if !lco
-000158c0: 6566 665f 6c65 6674 2e69 735f 6f6e 6528  eff_left.is_one(
-000158d0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-000158e0: 7061 6e69 6321 280a 2020 2020 2020 2020  panic!(.        
-000158f0: 2020 2020 2020 2020 2243 6f75 6c64 206e          "Could n
-00015900: 6f74 2064 6973 7472 6962 7574 6520 636f  ot distribute co
-00015910: 6e74 656e 7420 6f66 207b 7d3a 206f 7264  ntent of {}: ord
-00015920: 6572 3d7b 3a3f 7d2c 2073 616d 706c 6573  er={:?}, samples
-00015930: 3d7b 3a3f 7d20 5265 7374 203d 207b 7d22  ={:?} Rest = {}"
-00015940: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015950: 2020 7365 6c66 2c20 6f72 6465 722c 2073    self, order, s
-00015960: 616d 706c 655f 706f 696e 7473 2c20 6c63  ample_points, lc
-00015970: 6f65 6666 5f6c 6566 740a 2020 2020 2020  oeff_left.      
-00015980: 2020 2020 2020 293b 0a20 2020 2020 2020        );.       
-00015990: 207d 0a0a 2020 2020 2020 2020 4f6b 2828   }..        Ok((
-000159a0: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
-000159b0: 6163 746f 7273 2c20 7472 7565 5f6c 636f  actors, true_lco
-000159c0: 6566 6673 2929 0a20 2020 207d 0a0a 2020  effs)).    }..  
-000159d0: 2020 666e 206d 756c 7469 7661 7269 6174    fn multivariat
-000159e0: 655f 6865 6e73 656c 5f6c 6966 745f 7769  e_hensel_lift_wi
-000159f0: 7468 5f61 7574 6f5f 6c63 6f65 6666 5f66  th_auto_lcoeff_f
-00015a00: 6978 696e 6728 0a20 2020 2020 2020 2026  ixing(.        &
-00015a10: 7365 6c66 2c0a 2020 2020 2020 2020 6661  self,.        fa
-00015a20: 6374 6f72 733a 2026 5b53 656c 665d 2c0a  ctors: &[Self],.
-00015a30: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
-00015a40: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
-00015a50: 2049 6e74 6567 6572 295d 2c0a 2020 2020   Integer)],.    
-00015a60: 2020 2020 6f72 6465 723a 2026 5b75 7369      order: &[usi
-00015a70: 7a65 5d2c 0a20 2020 2020 2020 2062 6f75  ze],.        bou
-00015a80: 6e64 3a20 496e 7465 6765 722c 0a20 2020  nd: Integer,.   
-00015a90: 2020 2020 2070 3a20 7533 322c 0a20 2020       p: u32,.   
-00015aa0: 2020 2020 206b 3a20 7573 697a 652c 0a20       k: usize,. 
-00015ab0: 2020 2029 202d 3e20 5665 633c 5365 6c66     ) -> Vec<Self
-00015ac0: 3e20 7b0a 2020 2020 2020 2020 6c65 7420  > {.        let 
-00015ad0: 6d6f 6475 6c75 7320 3d20 4669 6e69 7465  modulus = Finite
-00015ae0: 4669 656c 643a 3a3c 496e 7465 6765 723e  Field::<Integer>
-00015af0: 3a3a 6e65 7728 626f 756e 6429 3b0a 2020  ::new(bound);.  
-00015b00: 2020 2020 2020 6c65 7420 6666 203d 2073        let ff = s
-00015b10: 656c 662e 6d61 705f 636f 6566 6628 7c63  elf.map_coeff(|c
-00015b20: 7c20 6d6f 6475 6c75 732e 746f 5f65 6c65  | modulus.to_ele
-00015b30: 6d65 6e74 2863 2e63 6c6f 6e65 2829 292c  ment(c.clone()),
-00015b40: 206d 6f64 756c 7573 2e63 6c6f 6e65 2829   modulus.clone()
-00015b50: 293b 0a20 2020 2020 2020 206c 6574 2066  );.        let f
-00015b60: 6163 746f 7273 5f66 663a 2056 6563 3c5f  actors_ff: Vec<_
-00015b70: 3e20 3d20 6661 6374 6f72 730a 2020 2020  > = factors.    
-00015b80: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
-00015b90: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
-00015ba0: 287c 667c 2066 2e6d 6170 5f63 6f65 6666  (|f| f.map_coeff
-00015bb0: 287c 637c 206d 6f64 756c 7573 2e74 6f5f  (|c| modulus.to_
-00015bc0: 656c 656d 656e 7428 632e 636c 6f6e 6528  element(c.clone(
-00015bd0: 2929 2c20 6d6f 6475 6c75 732e 636c 6f6e  )), modulus.clon
-00015be0: 6528 2929 290a 2020 2020 2020 2020 2020  e())).          
-00015bf0: 2020 2e63 6f6c 6c65 6374 2829 3b0a 2020    .collect();.  
-00015c00: 2020 2020 2020 6c65 7420 6c63 6f65 6666        let lcoeff
-00015c10: 203d 2066 662e 756e 6976 6172 6961 7465   = ff.univariate
-00015c20: 5f6c 636f 6566 6628 6f72 6465 725b 305d  _lcoeff(order[0]
-00015c30: 293b 0a0a 2020 2020 2020 2020 6966 206c  );..        if l
-00015c40: 636f 6566 662e 6973 5f63 6f6e 7374 616e  coeff.is_constan
-00015c50: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
-00015c60: 2020 2f2f 2074 6865 2066 6163 746f 7273    // the factors
-00015c70: 2073 686f 756c 6420 6265 2070 726f 7065   should be prope
-00015c80: 726c 7920 6e6f 726d 616c 697a 6564 0a20  rly normalized. 
-00015c90: 2020 2020 2020 2020 2020 206c 6574 2028             let (
-00015ca0: 6d75 7420 756e 692c 2064 656c 7461 2920  mut uni, delta) 
-00015cb0: 3d20 4d75 6c74 6976 6172 6961 7465 506f  = MultivariatePo
-00015cc0: 6c79 6e6f 6d69 616c 3a3a 6765 745f 756e  lynomial::get_un
-00015cd0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00015ce0: 5f61 6e64 5f64 656c 7461 7328 0a20 2020  _and_deltas(.   
-00015cf0: 2020 2020 2020 2020 2020 2020 2026 6661               &fa
-00015d00: 6374 6f72 735f 6666 2c0a 2020 2020 2020  ctors_ff,.      
-00015d10: 2020 2020 2020 2020 2020 6f72 6465 722c            order,
-00015d20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015d30: 2073 616d 706c 655f 706f 696e 7473 2c0a   sample_points,.
-00015d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d50: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-00015d60: 2020 206b 2c0a 2020 2020 2020 2020 2020     k,.          
-00015d70: 2020 293b 0a20 2020 2020 2020 2020 2020    );.           
-00015d80: 206c 6574 2068 203d 2066 662e 6d75 6c74   let h = ff.mult
-00015d90: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
-00015da0: 6c69 6674 696e 6728 0a20 2020 2020 2020  lifting(.       
-00015db0: 2020 2020 2020 2020 2026 6661 6374 6f72           &factor
-00015dc0: 735f 6666 2c0a 2020 2020 2020 2020 2020  s_ff,.          
-00015dd0: 2020 2020 2020 266d 7574 2075 6e69 2c0a        &mut uni,.
-00015de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015df0: 2664 656c 7461 2c0a 2020 2020 2020 2020  &delta,.        
-00015e00: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
-00015e10: 6f69 6e74 732c 0a20 2020 2020 2020 2020  oints,.         
-00015e20: 2020 2020 2020 204e 6f6e 652c 0a20 2020         None,.   
-00015e30: 2020 2020 2020 2020 2020 2020 206f 7264               ord
-00015e40: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
-00015e50: 2020 2020 312c 0a20 2020 2020 2020 2020      1,.         
-00015e60: 2020 2029 3b0a 0a20 2020 2020 2020 2020     );..         
-00015e70: 2020 2072 6574 7572 6e20 680a 2020 2020     return h.    
-00015e80: 2020 2020 2020 2020 2020 2020 2e69 6e74              .int
-00015e90: 6f5f 6974 6572 2829 0a20 2020 2020 2020  o_iter().       
-00015ea0: 2020 2020 2020 2020 202e 6d61 7028 7c66           .map(|f
-00015eb0: 7c20 662e 6d61 705f 636f 6566 6628 7c63  | f.map_coeff(|c
-00015ec0: 7c20 6d6f 6475 6c75 732e 746f 5f73 796d  | modulus.to_sym
-00015ed0: 6d65 7472 6963 5f69 6e74 6567 6572 2863  metric_integer(c
-00015ee0: 292c 2049 6e74 6567 6572 5269 6e67 3a3a  ), IntegerRing::
-00015ef0: 6e65 7728 2929 290a 2020 2020 2020 2020  new())).        
-00015f00: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
-00015f10: 2829 3b0a 2020 2020 2020 2020 7d0a 0a20  ();.        }.. 
-00015f20: 2020 2020 2020 202f 2f20 7265 7065 6174         // repeat
-00015f30: 2074 6865 206c 6561 6469 6e67 2063 6f65   the leading coe
-00015f40: 6666 6963 6965 6e74 2066 6f72 2065 7665  fficient for eve
-00015f50: 7279 2066 6163 746f 7220 736f 2074 6861  ry factor so tha
-00015f60: 7420 7468 6520 6c65 6164 696e 6720 636f  t the leading co
-00015f70: 6566 6669 6369 656e 7420 6973 206b 6e6f  efficient is kno
-00015f80: 776e 0a20 2020 2020 2020 206c 6574 2070  wn.        let p
-00015f90: 6164 6465 645f 6c63 6f65 6666 7320 3d20  added_lcoeffs = 
-00015fa0: 7665 6321 5b6c 636f 6566 662e 636c 6f6e  vec![lcoeff.clon
-00015fb0: 6528 293b 2066 6163 746f 7273 2e6c 656e  e(); factors.len
-00015fc0: 2829 5d3b 0a0a 2020 2020 2020 2020 6c65  ()];..        le
-00015fd0: 7420 6d75 7420 7365 6c66 5f61 646a 7573  t mut self_adjus
-00015fe0: 7465 6420 3d20 6666 3b0a 2020 2020 2020  ted = ff;.      
-00015ff0: 2020 666f 7220 5f20 696e 2031 2e2e 6661    for _ in 1..fa
-00016000: 6374 6f72 735f 6666 2e6c 656e 2829 207b  ctors_ff.len() {
-00016010: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00016020: 665f 6164 6a75 7374 6564 203d 2026 7365  f_adjusted = &se
-00016030: 6c66 5f61 646a 7573 7465 6420 2a20 266c  lf_adjusted * &l
-00016040: 636f 6566 663b 0a20 2020 2020 2020 207d  coeff;.        }
-00016050: 0a0a 2020 2020 2020 2020 2f2f 2073 6574  ..        // set
-00016060: 2074 6865 2070 726f 7065 7220 6c63 0a20   the proper lc. 
-00016070: 2020 2020 2020 206c 6574 206d 7574 206c         let mut l
-00016080: 635f 7661 725f 6576 616c 203d 206c 636f  c_var_eval = lco
-00016090: 6566 662e 636c 6f6e 6528 293b 0a20 2020  eff.clone();.   
-000160a0: 2020 2020 2066 6f72 2028 762c 2070 2920       for (v, p) 
-000160b0: 696e 2073 616d 706c 655f 706f 696e 7473  in sample_points
-000160c0: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
-000160d0: 6620 2a76 2021 3d20 6f72 6465 725b 305d  f *v != order[0]
-000160e0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-000160f0: 2020 206c 635f 7661 725f 6576 616c 203d     lc_var_eval =
-00016100: 206c 635f 7661 725f 6576 616c 2e72 6570   lc_var_eval.rep
-00016110: 6c61 6365 282a 762c 2070 293b 0a20 2020  lace(*v, p);.   
-00016120: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00016130: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
-00016140: 7420 6164 6a75 7374 6564 5f66 6163 746f  t adjusted_facto
-00016150: 7273 3a20 5665 633c 5f3e 203d 2066 6163  rs: Vec<_> = fac
-00016160: 746f 7273 5f66 660a 2020 2020 2020 2020  tors_ff.        
-00016170: 2020 2020 2e69 6e74 6f5f 6974 6572 2829      .into_iter()
-00016180: 0a20 2020 2020 2020 2020 2020 202e 6d61  .            .ma
-00016190: 7028 7c66 7c20 662e 6d61 6b65 5f6d 6f6e  p(|f| f.make_mon
-000161a0: 6963 2829 202a 2026 6c63 5f76 6172 5f65  ic() * &lc_var_e
-000161b0: 7661 6c29 0a20 2020 2020 2020 2020 2020  val).           
-000161c0: 202e 636f 6c6c 6563 7428 293b 0a0a 2020   .collect();..  
-000161d0: 2020 2020 2020 6c65 7420 286d 7574 2075        let (mut u
-000161e0: 6e69 2c20 6465 6c74 6129 203d 204d 756c  ni, delta) = Mul
-000161f0: 7469 7661 7269 6174 6550 6f6c 796e 6f6d  tivariatePolynom
-00016200: 6961 6c3a 3a67 6574 5f75 6e69 7661 7269  ial::get_univari
-00016210: 6174 655f 6661 6374 6f72 735f 616e 645f  ate_factors_and_
-00016220: 6465 6c74 6173 280a 2020 2020 2020 2020  deltas(.        
-00016230: 2020 2020 2661 646a 7573 7465 645f 6661      &adjusted_fa
-00016240: 6374 6f72 732c 0a20 2020 2020 2020 2020  ctors,.         
-00016250: 2020 206f 7264 6572 2c0a 2020 2020 2020     order,.      
-00016260: 2020 2020 2020 7361 6d70 6c65 5f70 6f69        sample_poi
-00016270: 6e74 732c 0a20 2020 2020 2020 2020 2020  nts,.           
-00016280: 2070 2c0a 2020 2020 2020 2020 2020 2020   p,.            
-00016290: 6b2c 0a20 2020 2020 2020 2029 3b0a 2020  k,.        );.  
-000162a0: 2020 2020 2020 6c65 7420 6820 3d20 7365        let h = se
-000162b0: 6c66 5f61 646a 7573 7465 642e 6d75 6c74  lf_adjusted.mult
-000162c0: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
-000162d0: 6c69 6674 696e 6728 0a20 2020 2020 2020  lifting(.       
-000162e0: 2020 2020 2026 6164 6a75 7374 6564 5f66       &adjusted_f
-000162f0: 6163 746f 7273 2c0a 2020 2020 2020 2020  actors,.        
-00016300: 2020 2020 266d 7574 2075 6e69 2c0a 2020      &mut uni,.  
-00016310: 2020 2020 2020 2020 2020 2664 656c 7461            &delta
-00016320: 2c0a 2020 2020 2020 2020 2020 2020 7361  ,.            sa
-00016330: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
-00016340: 2020 2020 2020 2020 2053 6f6d 6528 2670           Some(&p
-00016350: 6164 6465 645f 6c63 6f65 6666 7329 2c0a  added_lcoeffs),.
-00016360: 2020 2020 2020 2020 2020 2020 6f72 6465              orde
-00016370: 722c 0a20 2020 2020 2020 2020 2020 2031  r,.            1
-00016380: 2c0a 2020 2020 2020 2020 293b 0a0a 2020  ,.        );..  
-00016390: 2020 2020 2020 682e 696e 746f 5f69 7465        h.into_ite
-000163a0: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-000163b0: 2e6d 6170 287c 667c 207b 0a20 2020 2020  .map(|f| {.     
-000163c0: 2020 2020 2020 2020 2020 206c 6574 2066             let f
-000163d0: 5f69 203d 2066 2e6d 6170 5f63 6f65 6666  _i = f.map_coeff
-000163e0: 287c 637c 206d 6f64 756c 7573 2e74 6f5f  (|c| modulus.to_
-000163f0: 7379 6d6d 6574 7269 635f 696e 7465 6765  symmetric_intege
-00016400: 7228 6329 2c20 496e 7465 6765 7252 696e  r(c), IntegerRin
-00016410: 673a 3a6e 6577 2829 293b 0a20 2020 2020  g::new());.     
-00016420: 2020 2020 2020 2020 2020 206c 6574 2063             let c
-00016430: 203d 2066 5f69 2e75 6e69 7661 7269 6174   = f_i.univariat
-00016440: 655f 636f 6e74 656e 7428 6f72 6465 725b  e_content(order[
-00016450: 305d 293b 0a20 2020 2020 2020 2020 2020  0]);.           
-00016460: 2020 2020 2066 5f69 202f 2026 630a 2020       f_i / &c.  
-00016470: 2020 2020 2020 2020 2020 7d29 0a20 2020            }).   
-00016480: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-00016490: 7428 290a 2020 2020 7d0a 0a20 2020 2066  t().    }..    f
-000164a0: 6e20 6669 6e64 5f73 616d 706c 6528 0a20  n find_sample(. 
-000164b0: 2020 2020 2020 2026 7365 6c66 2c0a 2020         &self,.  
-000164c0: 2020 2020 2020 6f72 6465 723a 2026 6d75        order: &mu
-000164d0: 7420 5b75 7369 7a65 5d2c 0a20 2020 2020  t [usize],.     
-000164e0: 2020 206d 7574 2063 6f65 6666 6963 6965     mut coefficie
-000164f0: 6e74 5f75 7070 6572 5f62 6f75 6e64 3a20  nt_upper_bound: 
-00016500: 6936 342c 0a20 2020 2020 2020 206d 6178  i64,.        max
-00016510: 5f66 6163 746f 7273 5f6e 756d 3a20 4f70  _factors_num: Op
-00016520: 7469 6f6e 3c75 7369 7a65 3e2c 0a20 2020  tion<usize>,.   
-00016530: 2029 202d 3e20 2856 6563 3c53 656c 663e   ) -> (Vec<Self>
-00016540: 2c20 5665 633c 2875 7369 7a65 2c20 496e  , Vec<(usize, In
-00016550: 7465 6765 7229 3e2c 2069 3634 2c20 5365  teger)>, i64, Se
-00016560: 6c66 2920 7b0a 2020 2020 2020 2020 6465  lf) {.        de
-00016570: 6275 6721 2822 4669 6e64 2073 616d 706c  bug!("Find sampl
-00016580: 6520 666f 7220 7b7d 2077 6974 6820 6f72  e for {} with or
-00016590: 6465 7220 7b3a 3f7d 222c 2073 656c 662c  der {:?}", self,
-000165a0: 206f 7264 6572 293b 0a0a 2020 2020 2020   order);..      
-000165b0: 2020 2f2f 2073 656c 6563 7420 6120 7375    // select a su
-000165c0: 6974 6162 6c65 2065 7661 6c75 6174 696f  itable evaluatio
-000165d0: 6e20 706f 696e 742c 2061 7320 736d 616c  n point, as smal
-000165e0: 6c20 6173 2070 6f73 7369 626c 6520 6173  l as possible as
-000165f0: 2074 6f20 6e6f 7420 6368 616e 6765 2074   to not change t
-00016600: 6865 2063 6f65 6666 6963 6965 6e74 2062  he coefficient b
-00016610: 6f75 6e64 0a20 2020 2020 2020 206c 6574  ound.        let
-00016620: 206d 7574 2063 7572 5f73 616d 706c 655f   mut cur_sample_
-00016630: 706f 696e 7473 3a20 5665 633c 5f3e 203d  points: Vec<_> =
-00016640: 0a20 2020 2020 2020 2020 2020 206f 7264  .            ord
-00016650: 6572 5b31 2e2e 5d2e 6974 6572 2829 2e6d  er[1..].iter().m
-00016660: 6170 287c 697c 2028 2a69 2c20 496e 7465  ap(|i| (*i, Inte
-00016670: 6765 723a 3a7a 6572 6f28 2929 292e 636f  ger::zero())).co
-00016680: 6c6c 6563 7428 293b 0a20 2020 2020 2020  llect();.       
-00016690: 206c 6574 206d 7574 2063 7572 5f75 6e69   let mut cur_uni
-000166a0: 5f66 3b0a 2020 2020 2020 2020 6c65 7420  _f;.        let 
-000166b0: 6d75 7420 6375 725f 6269 765f 663b 0a20  mut cur_biv_f;. 
-000166c0: 2020 2020 2020 206c 6574 206d 7574 2072         let mut r
-000166d0: 6e67 203d 2074 6872 6561 645f 726e 6728  ng = thread_rng(
-000166e0: 293b 0a20 2020 2020 2020 206c 6574 2064  );.        let d
-000166f0: 6567 7265 6520 3d20 7365 6c66 2e64 6567  egree = self.deg
-00016700: 7265 6528 6f72 6465 725b 305d 293b 0a20  ree(order[0]);. 
-00016710: 2020 2020 2020 206c 6574 206d 7574 2062         let mut b
-00016720: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00016730: 3a20 5665 633c 5f3e 3b0a 0a20 2020 2020  : Vec<_>;..     
-00016740: 2020 206c 6574 2075 6e69 5f6c 636f 6566     let uni_lcoef
-00016750: 6620 3d20 7365 6c66 2e75 6e69 7661 7269  f = self.univari
-00016760: 6174 655f 6c63 6f65 6666 286f 7264 6572  ate_lcoeff(order
-00016770: 5b30 5d29 3b0a 0a20 2020 2020 2020 206c  [0]);..        l
-00016780: 6574 206d 7574 2063 6f6e 7465 6e74 5f66  et mut content_f
-00016790: 6169 6c5f 636f 756e 7420 3d20 303b 0a20  ail_count = 0;. 
-000167a0: 2020 2020 2020 2027 6e65 775f 7361 6d70         'new_samp
-000167b0: 6c65 3a20 6c6f 6f70 207b 0a20 2020 2020  le: loop {.     
-000167c0: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
-000167d0: 266d 7574 2063 7572 5f73 616d 706c 655f  &mut cur_sample_
-000167e0: 706f 696e 7473 207b 0a20 2020 2020 2020  points {.       
-000167f0: 2020 2020 2020 2020 2073 2e31 203d 2049           s.1 = I
-00016800: 6e74 6567 6572 3a3a 4e61 7475 7261 6c28  nteger::Natural(
-00016810: 726e 672e 6765 6e5f 7261 6e67 6528 302e  rng.gen_range(0.
-00016820: 2e3d 636f 6566 6669 6369 656e 745f 7570  .=coefficient_up
-00016830: 7065 725f 626f 756e 6429 293b 0a20 2020  per_bound));.   
-00016840: 2020 2020 2020 2020 2020 2020 2064 6562               deb
-00016850: 7567 2128 2253 616d 706c 6520 787b 7d20  ug!("Sample x{} 
-00016860: 7b7d 222c 2073 2e30 2c20 732e 3129 3b0a  {}", s.0, s.1);.
-00016870: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
-00016880: 2020 2020 2020 2020 2020 2063 7572 5f62             cur_b
-00016890: 6976 5f66 203d 2073 656c 662e 636c 6f6e  iv_f = self.clon
-000168a0: 6528 293b 0a20 2020 2020 2020 2020 2020  e();.           
-000168b0: 2066 6f72 2028 2876 2c20 7329 2c20 7265   for ((v, s), re
-000168c0: 6d5f 7661 7229 2069 6e20 6375 725f 7361  m_var) in cur_sa
-000168d0: 6d70 6c65 5f70 6f69 6e74 735b 312e 2e5d  mple_points[1..]
-000168e0: 2e69 7465 7228 292e 7a69 7028 266f 7264  .iter().zip(&ord
-000168f0: 6572 5b31 2e2e 5d29 2e72 6576 2829 207b  er[1..]).rev() {
-00016900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016910: 2063 7572 5f62 6976 5f66 203d 2063 7572   cur_biv_f = cur
-00016920: 5f62 6976 5f66 2e72 6570 6c61 6365 282a  _biv_f.replace(*
-00016930: 762c 2073 293b 0a20 2020 2020 2020 2020  v, s);.         
-00016940: 2020 2020 2020 2069 6620 6375 725f 6269         if cur_bi
-00016950: 765f 662e 6465 6772 6565 282a 7265 6d5f  v_f.degree(*rem_
-00016960: 7661 7229 2021 3d20 7365 6c66 2e64 6567  var) != self.deg
-00016970: 7265 6528 2a72 656d 5f76 6172 2920 7b0a  ree(*rem_var) {.
-00016980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016990: 2020 2020 636f 6566 6669 6369 656e 745f      coefficient_
-000169a0: 7570 7065 725f 626f 756e 6420 2b3d 2031  upper_bound += 1
-000169b0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-000169c0: 2020 2020 2020 636f 6e74 696e 7565 2027        continue '
-000169d0: 6e65 775f 7361 6d70 6c65 3b0a 2020 2020  new_sample;.    
-000169e0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-000169f0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
-00016a00: 2020 2020 2020 2020 202f 2f20 7265 7175           // requ
-00016a10: 6972 656d 656e 7420 666f 7220 6c65 6164  irement for lead
-00016a20: 696e 6720 636f 6566 6669 6369 656e 7420  ing coefficient 
-00016a30: 7072 6563 6f6d 7075 7461 7469 6f6e 0a20  precomputation. 
-00016a40: 2020 2020 2020 2020 2020 2069 6620 6375             if cu
-00016a50: 725f 6269 765f 662e 756e 6976 6172 6961  r_biv_f.univaria
-00016a60: 7465 5f6c 636f 6566 6628 6f72 6465 725b  te_lcoeff(order[
-00016a70: 305d 292e 6465 6772 6565 286f 7264 6572  0]).degree(order
-00016a80: 5b31 5d29 2021 3d20 756e 695f 6c63 6f65  [1]) != uni_lcoe
-00016a90: 6666 2e64 6567 7265 6528 6f72 6465 725b  ff.degree(order[
-00016aa0: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
-00016ab0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00016ac0: 2020 6465 6275 6721 280a 2020 2020 2020    debug!(.      
-00016ad0: 2020 2020 2020 2020 2020 2020 2020 2244                "D
-00016ae0: 6567 7265 6520 6f66 2078 7b7d 2069 6e20  egree of x{} in 
-00016af0: 6c65 6164 696e 6720 636f 6566 6669 6369  leading coeffici
-00016b00: 656e 7420 6f66 2062 6976 6172 6961 7465  ent of bivariate
-00016b10: 2069 6d61 6765 2069 7320 7772 6f6e 6722   image is wrong"
-00016b20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00016b30: 2020 2020 2020 6f72 6465 725b 315d 0a20        order[1]. 
-00016b40: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00016b50: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00016b60: 2020 636f 6566 6669 6369 656e 745f 7570    coefficient_up
-00016b70: 7065 725f 626f 756e 6420 2b3d 2031 3b0a  per_bound += 1;.
-00016b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b90: 636f 6e74 696e 7565 2027 6e65 775f 7361  continue 'new_sa
-00016ba0: 6d70 6c65 3b0a 2020 2020 2020 2020 2020  mple;.          
-00016bb0: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00016bc0: 206c 6574 2062 6976 5f64 6620 3d20 6375   let biv_df = cu
-00016bd0: 725f 6269 765f 662e 6465 7269 7661 7469  r_biv_f.derivati
-00016be0: 7665 286f 7264 6572 5b30 5d29 3b0a 0a20  ve(order[0]);.. 
-00016bf0: 2020 2020 2020 2020 2020 2063 7572 5f75             cur_u
-00016c00: 6e69 5f66 203d 2063 7572 5f62 6976 5f66  ni_f = cur_biv_f
-00016c10: 2e72 6570 6c61 6365 2863 7572 5f73 616d  .replace(cur_sam
-00016c20: 706c 655f 706f 696e 7473 5b30 5d2e 302c  ple_points[0].0,
-00016c30: 2026 6375 725f 7361 6d70 6c65 5f70 6f69   &cur_sample_poi
-00016c40: 6e74 735b 305d 2e31 293b 0a20 2020 2020  nts[0].1);.     
-00016c50: 2020 2020 2020 206c 6574 2075 6e69 5f64         let uni_d
-00016c60: 6620 3d20 6375 725f 756e 695f 662e 6465  f = cur_uni_f.de
-00016c70: 7269 7661 7469 7665 286f 7264 6572 5b30  rivative(order[0
-00016c80: 5d29 3b0a 0a20 2020 2020 2020 2020 2020  ]);..           
-00016c90: 2069 6620 6465 6772 6565 203d 3d20 6375   if degree == cu
-00016ca0: 725f 6269 765f 662e 6465 6772 6565 286f  r_biv_f.degree(o
-00016cb0: 7264 6572 5b30 5d29 0a20 2020 2020 2020  rder[0]).       
-00016cc0: 2020 2020 2020 2020 2026 2620 6465 6772           && degr
-00016cd0: 6565 203d 3d20 6375 725f 756e 695f 662e  ee == cur_uni_f.
-00016ce0: 6465 6772 6565 286f 7264 6572 5b30 5d29  degree(order[0])
-00016cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016d00: 2026 2620 6375 725f 6269 765f 662e 6763   && cur_biv_f.gc
-00016d10: 6428 2662 6976 5f64 6629 2e69 735f 636f  d(&biv_df).is_co
-00016d20: 6e73 7461 6e74 2829 0a20 2020 2020 2020  nstant().       
-00016d30: 2020 2020 2020 2020 2026 2620 6375 725f           && cur_
-00016d40: 756e 695f 662e 6763 6428 2675 6e69 5f64  uni_f.gcd(&uni_d
-00016d50: 6629 2e69 735f 636f 6e73 7461 6e74 2829  f).is_constant()
-00016d60: 0a20 2020 2020 2020 2020 2020 207b 0a20  .            {. 
-00016d70: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00016d80: 6620 2163 7572 5f62 6976 5f66 2e75 6e69  f !cur_biv_f.uni
-00016d90: 7661 7269 6174 655f 636f 6e74 656e 7428  variate_content(
-00016da0: 6f72 6465 725b 305d 292e 6973 5f6f 6e65  order[0]).is_one
-00016db0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00016dc0: 2020 2020 2020 2020 2063 6f6e 7465 6e74           content
-00016dd0: 5f66 6169 6c5f 636f 756e 7420 2b3d 2031  _fail_count += 1
-00016de0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00016df0: 2020 2020 2020 636f 6566 6669 6369 656e        coefficien
-00016e00: 745f 7570 7065 725f 626f 756e 6420 2b3d  t_upper_bound +=
-00016e10: 2031 3b0a 0a20 2020 2020 2020 2020 2020   1;..           
-00016e20: 2020 2020 2020 2020 2064 6562 7567 2128           debug!(
-00016e30: 2255 6e69 7661 7269 6174 6520 636f 6e74  "Univariate cont
-00016e40: 656e 7420 6973 206e 6f74 206f 6e65 2229  ent is not one")
-00016e50: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00016e60: 2020 2020 2020 6966 2063 6f6e 7465 6e74        if content
-00016e70: 5f66 6169 6c5f 636f 756e 7420 3d3d 2034  _fail_count == 4
-00016e80: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00016e90: 2020 2020 2020 2020 2020 202f 2f20 6974             // it
-00016ea0: 2069 7320 6c69 6b65 6c79 2074 6861 7420   is likely that 
-00016eb0: 7765 2077 696c 6c20 616c 7761 7973 2066  we will always f
-00016ec0: 696e 6420 636f 6e74 656e 7420 666f 7220  ind content for 
-00016ed0: 7468 6973 2076 6172 6961 626c 6520 6f72  this variable or
-00016ee0: 6465 7269 6e67 2c20 736f 2063 6861 6e67  dering, so chang
-00016ef0: 6520 7468 650a 2020 2020 2020 2020 2020  e the.          
-00016f00: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
-00016f10: 2073 6563 6f6e 6420 7661 7269 6162 6c65   second variable
-00016f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016f30: 2020 2020 2020 2020 202f 2f20 544f 444f           // TODO
-00016f40: 3a20 6973 2074 6869 7320 6775 6172 616e  : is this guaran
-00016f50: 7465 6564 2074 6f20 776f 726b 206f 7220  teed to work or 
-00016f60: 7368 6f75 6c64 2077 6520 616c 736f 2063  should we also c
-00016f70: 6861 6e67 6520 7468 6520 6669 7273 7420  hange the first 
-00016f80: 7661 7269 6162 6c65 3f0a 2020 2020 2020  variable?.      
-00016f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016fa0: 2020 6c65 7420 7365 635f 7661 7220 3d20    let sec_var = 
-00016fb0: 6f72 6465 725b 315d 3b0a 2020 2020 2020  order[1];.      
-00016fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016fd0: 2020 6f72 6465 722e 636f 7079 5f77 6974    order.copy_wit
-00016fe0: 6869 6e28 322e 2e6f 7264 6572 2e6c 656e  hin(2..order.len
-00016ff0: 2829 2c20 3129 3b0a 2020 2020 2020 2020  (), 1);.        
+000127a0: 3e3e 207b 0a20 2020 2020 2020 206c 6574  >> {.        let
+000127b0: 2066 6965 6c64 203d 205a 703a 3a6e 6577   field = Zp::new
+000127c0: 2870 293b 0a20 2020 2020 2020 206c 6574  (p);.        let
+000127d0: 2070 7269 6d65 3a20 496e 7465 6765 7220   prime: Integer 
+000127e0: 3d20 2870 2061 7320 7536 3429 2e69 6e74  = (p as u64).int
+000127f0: 6f28 293b 0a0a 2020 2020 2020 2020 6c65  o();..        le
+00012800: 7420 6d75 7420 665f 703a 2056 6563 3c5f  t mut f_p: Vec<_
+00012810: 3e20 3d20 6661 6374 6f72 730a 2020 2020  > = factors.    
+00012820: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
+00012830: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
+00012840: 287c 667c 2066 2e6d 6170 5f63 6f65 6666  (|f| f.map_coeff
+00012850: 287c 637c 2063 2e74 6f5f 6669 6e69 7465  (|c| c.to_finite
+00012860: 5f66 6965 6c64 2826 6669 656c 6429 2c20  _field(&field), 
+00012870: 6669 656c 642e 636c 6f6e 6528 2929 290a  field.clone())).
+00012880: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
+00012890: 6c65 6374 2829 3b0a 2020 2020 2020 2020  lect();.        
+000128a0: 6c65 7420 7268 735f 7020 3d20 7268 732e  let rhs_p = rhs.
+000128b0: 6d61 705f 636f 6566 6628 7c63 7c20 632e  map_coeff(|c| c.
+000128c0: 746f 5f66 696e 6974 655f 6669 656c 6428  to_finite_field(
+000128d0: 2666 6965 6c64 292c 2066 6965 6c64 2e63  &field), field.c
+000128e0: 6c6f 6e65 2829 293b 0a0a 2020 2020 2020  lone());..      
+000128f0: 2020 2f2f 2054 4f44 4f3a 2072 6563 7963    // TODO: recyc
+00012900: 6c65 2066 726f 6d20 6669 6e69 7465 2066  le from finite f
+00012910: 6965 6c64 2063 6f6d 7075 7461 7469 6f6e  ield computation
+00012920: 2074 6861 7420 6d75 7374 2068 6176 6520   that must have 
+00012930: 6861 7070 656e 6564 2065 6172 6c69 6572  happened earlier
+00012940: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00012950: 2064 656c 7461 203d 0a20 2020 2020 2020   delta =.       
+00012960: 2020 2020 204d 756c 7469 7661 7269 6174       Multivariat
+00012970: 6550 6f6c 796e 6f6d 6961 6c3a 3a3c 5a70  ePolynomial::<Zp
+00012980: 2c20 452c 204c 6578 4f72 6465 723e 3a3a  , E, LexOrder>::
+00012990: 6469 6f70 6861 6e74 696e 655f 756e 6976  diophantine_univ
+000129a0: 6172 6961 7465 2826 6d75 7420 665f 702c  ariate(&mut f_p,
+000129b0: 2026 7268 735f 7029 3b0a 0a20 2020 2020   &rhs_p);..     
+000129c0: 2020 206c 6574 206d 7574 2064 656c 7461     let mut delta
+000129d0: 733a 2056 6563 3c5f 3e20 3d20 6465 6c74  s: Vec<_> = delt
+000129e0: 610a 2020 2020 2020 2020 2020 2020 2e69  a.            .i
+000129f0: 7465 7228 290a 2020 2020 2020 2020 2020  ter().          
+00012a00: 2020 2e6d 6170 287c 737c 207b 0a20 2020    .map(|s| {.   
+00012a10: 2020 2020 2020 2020 2020 2020 2073 2e6d               s.m
+00012a20: 6170 5f63 6f65 6666 280a 2020 2020 2020  ap_coeff(.      
+00012a30: 2020 2020 2020 2020 2020 2020 2020 7c63                |c
+00012a40: 7c20 6669 656c 642e 746f 5f73 796d 6d65  | field.to_symme
+00012a50: 7472 6963 5f69 6e74 6567 6572 2863 292e  tric_integer(c).
+00012a60: 746f 5f66 696e 6974 655f 6669 656c 6428  to_finite_field(
+00012a70: 2672 6873 2e66 6965 6c64 292c 0a20 2020  &rhs.field),.   
+00012a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012a90: 2072 6873 2e66 6965 6c64 2e63 6c6f 6e65   rhs.field.clone
+00012aa0: 2829 2c0a 2020 2020 2020 2020 2020 2020  (),.            
+00012ab0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00012ac0: 2020 7d29 0a20 2020 2020 2020 2020 2020    }).           
+00012ad0: 202e 636f 6c6c 6563 7428 293b 0a0a 2020   .collect();..  
+00012ae0: 2020 2020 2020 6966 206b 203d 3d20 3120        if k == 1 
+00012af0: 7b0a 2020 2020 2020 2020 2020 2020 7265  {.            re
+00012b00: 7475 726e 2064 656c 7461 733b 0a20 2020  turn deltas;.   
+00012b10: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00012b20: 6c65 7420 6d75 7420 746f 7420 3d20 7268  let mut tot = rh
+00012b30: 732e 636f 6e73 7461 6e74 2872 6873 2e66  s.constant(rhs.f
+00012b40: 6965 6c64 2e6f 6e65 2829 293b 0a20 2020  ield.one());.   
+00012b50: 2020 2020 2066 6f72 2066 2069 6e20 6661       for f in fa
+00012b60: 6374 6f72 732e 6974 6572 2829 207b 0a20  ctors.iter() {. 
+00012b70: 2020 2020 2020 2020 2020 2074 6f74 203d             tot =
+00012b80: 2026 746f 7420 2a20 663b 0a20 2020 2020   &tot * f;.     
+00012b90: 2020 207d 0a0a 2020 2020 2020 2020 6c65     }..        le
+00012ba0: 7420 7069 203d 2066 6163 746f 7273 0a20  t pi = factors. 
+00012bb0: 2020 2020 2020 2020 2020 202e 6974 6572             .iter
+00012bc0: 5f6d 7574 2829 0a20 2020 2020 2020 2020  _mut().         
+00012bd0: 2020 202e 6d61 7028 7c66 7c20 746f 742e     .map(|f| tot.
+00012be0: 7175 6f74 5f72 656d 5f75 6e69 7661 7269  quot_rem_univari
+00012bf0: 6174 6528 6629 2e30 290a 2020 2020 2020  ate(f).0).      
+00012c00: 2020 2020 2020 2e63 6f6c 6c65 6374 3a3a        .collect::
+00012c10: 3c56 6563 3c5f 3e3e 2829 3b0a 0a20 2020  <Vec<_>>();..   
+00012c20: 2020 2020 206c 6574 206d 7574 206d 203d       let mut m =
+00012c30: 2070 7269 6d65 2e63 6c6f 6e65 2829 3b0a   prime.clone();.
+00012c40: 0a20 2020 2020 2020 2066 6f72 205f 2069  .        for _ i
+00012c50: 6e20 312e 2e6b 207b 0a20 2020 2020 2020  n 1..k {.       
+00012c60: 2020 2020 202f 2f20 544f 444f 3a20 6973       // TODO: is
+00012c70: 2062 7265 616b 696e 6720 6f6e 2065 3d30   breaking on e=0
+00012c80: 2073 6166 653f 0a20 2020 2020 2020 2020   safe?.         
+00012c90: 2020 206c 6574 206d 7574 2065 203d 2072     let mut e = r
+00012ca0: 6873 2e63 6c6f 6e65 2829 3b0a 2020 2020  hs.clone();.    
+00012cb0: 2020 2020 2020 2020 666f 7220 2864 642c          for (dd,
+00012cc0: 2070 7029 2069 6e20 6465 6c74 6173 2e69   pp) in deltas.i
+00012cd0: 7465 725f 6d75 7428 292e 7a69 7028 2670  ter_mut().zip(&p
+00012ce0: 6929 207b 0a20 2020 2020 2020 2020 2020  i) {.           
+00012cf0: 2020 2020 2065 203d 2026 6520 2d20 2628       e = &e - &(
+00012d00: 262a 6464 202a 2070 7029 3b0a 2020 2020  &*dd * pp);.    
+00012d10: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00012d20: 2020 2020 2020 206c 6574 2065 5f6d 203d         let e_m =
+00012d30: 2065 2e6d 6170 5f63 6f65 6666 287c 637c   e.map_coeff(|c|
+00012d40: 2028 6320 2f20 266d 292e 746f 5f66 696e   (c / &m).to_fin
+00012d50: 6974 655f 6669 656c 6428 2666 6965 6c64  ite_field(&field
+00012d60: 292c 2066 6965 6c64 2e63 6c6f 6e65 2829  ), field.clone()
+00012d70: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
+00012d80: 666f 7220 2828 702c 2064 5f6d 292c 2064  for ((p, d_m), d
+00012d90: 2920 696e 2066 5f70 2e69 7465 725f 6d75  ) in f_p.iter_mu
+00012da0: 7428 292e 7a69 7028 266d 7574 2064 656c  t().zip(&mut del
+00012db0: 7461 292e 7a69 7028 6465 6c74 6173 2e69  ta).zip(deltas.i
+00012dc0: 7465 725f 6d75 7428 2929 207b 0a20 2020  ter_mut()) {.   
+00012dd0: 2020 2020 2020 2020 2020 2020 206c 6574               let
+00012de0: 206e 6577 5f64 656c 7461 203d 2028 2665   new_delta = (&e
+00012df0: 5f6d 202a 2026 2a64 5f6d 292e 7175 6f74  _m * &*d_m).quot
+00012e00: 5f72 656d 5f75 6e69 7661 7269 6174 6528  _rem_univariate(
+00012e10: 7029 2e31 3b0a 0a20 2020 2020 2020 2020  p).1;..         
+00012e20: 2020 2020 2020 202a 6420 3d20 262a 640a         *d = &*d.
+00012e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e40: 2020 2020 2b20 266e 6577 5f64 656c 7461      + &new_delta
+00012e50: 2e6d 6170 5f63 6f65 6666 280a 2020 2020  .map_coeff(.    
+00012e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e70: 2020 2020 7c63 7c20 2826 6669 656c 642e      |c| (&field.
+00012e80: 746f 5f73 796d 6d65 7472 6963 5f69 6e74  to_symmetric_int
+00012e90: 6567 6572 2863 2920 2a20 266d 292e 746f  eger(c) * &m).to
+00012ea0: 5f66 696e 6974 655f 6669 656c 6428 2672  _finite_field(&r
+00012eb0: 6873 2e66 6965 6c64 292c 0a20 2020 2020  hs.field),.     
+00012ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012ed0: 2020 2072 6873 2e66 6965 6c64 2e63 6c6f     rhs.field.clo
+00012ee0: 6e65 2829 2c0a 2020 2020 2020 2020 2020  ne(),.          
+00012ef0: 2020 2020 2020 2020 2020 293b 0a20 2020            );.   
+00012f00: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+00012f10: 2020 2020 2020 2020 6d20 3d20 266d 202a          m = &m *
+00012f20: 2026 7072 696d 653b 0a20 2020 2020 2020   &prime;.       
+00012f30: 207d 0a0a 2020 2020 2020 2020 6465 6c74   }..        delt
+00012f40: 6173 0a20 2020 207d 0a0a 2020 2020 2f2f  as.    }..    //
+00012f50: 2f20 436f 6d70 7574 6520 7468 6520 4765  / Compute the Ge
+00012f60: 6c66 6f6e 6420 626f 756e 6420 666f 7220  lfond bound for 
+00012f70: 7468 6520 636f 6566 6669 6369 656e 7473  the coefficients
+00012f80: 206d 6167 6e69 7475 6465 206f 6620 6576   magnitude of ev
+00012f90: 6572 7920 6661 6374 6f72 206f 6620 7468  ery factor of th
+00012fa0: 6973 2070 6f6c 796e 6f6d 6961 6c0a 2020  is polynomial.  
+00012fb0: 2020 666e 2063 6f65 6666 6963 6965 6e74    fn coefficient
+00012fc0: 5f62 6f75 6e64 2826 7365 6c66 2920 2d3e  _bound(&self) ->
+00012fd0: 2049 6e74 6567 6572 207b 0a20 2020 2020   Integer {.     
+00012fe0: 2020 206c 6574 206d 6178 5f6e 6f72 6d20     let max_norm 
+00012ff0: 3d20 7365 6c66 2e63 6f65 6666 6963 6965  = self.coefficie
+00013000: 6e74 732e 6974 6572 2829 2e6d 6170 287c  nts.iter().map(|
+00013010: 787c 2078 2e61 6273 2829 292e 6d61 7828  x| x.abs()).max(
+00013020: 292e 756e 7772 6170 2829 3b0a 0a20 2020  ).unwrap();..   
+00013030: 2020 2020 206c 6574 206d 7574 2062 6f75       let mut bou
+00013040: 6e64 203d 2049 6e74 6567 6572 3a3a 6f6e  nd = Integer::on
+00013050: 6528 293b 0a20 2020 2020 2020 206c 6574  e();.        let
+00013060: 206d 7574 2074 6f74 616c 5f64 6567 7265   mut total_degre
+00013070: 6520 3d20 303b 0a20 2020 2020 2020 206c  e = 0;.        l
+00013080: 6574 206d 7574 206e 6f6e 5f7a 6572 6f5f  et mut non_zero_
+00013090: 7661 7273 203d 2030 3b0a 2020 2020 2020  vars = 0;.      
+000130a0: 2020 666f 7220 7620 696e 2030 2e2e 7365    for v in 0..se
+000130b0: 6c66 2e6e 7661 7273 2829 207b 0a20 2020  lf.nvars() {.   
+000130c0: 2020 2020 2020 2020 206c 6574 2064 203d           let d =
+000130d0: 2073 656c 662e 6465 6772 6565 2876 292e   self.degree(v).
+000130e0: 746f 5f75 3332 2829 2061 7320 7536 343b  to_u32() as u64;
+000130f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00013100: 6420 3e20 3020 7b0a 2020 2020 2020 2020  d > 0 {.        
+00013110: 2020 2020 2020 2020 6e6f 6e5f 7a65 726f          non_zero
+00013120: 5f76 6172 7320 2b3d 2031 3b0a 2020 2020  _vars += 1;.    
+00013130: 2020 2020 2020 2020 2020 2020 746f 7461              tota
+00013140: 6c5f 6465 6772 6565 202b 3d20 643b 0a20  l_degree += d;. 
+00013150: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00013160: 6f75 6e64 202a 3d20 2649 6e74 6567 6572  ound *= &Integer
+00013170: 3a3a 6672 6f6d 2864 202b 2031 293b 0a20  ::from(d + 1);. 
+00013180: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00013190: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+000131a0: 2f2f 206d 6f76 6520 7468 6520 325e 6e20  // move the 2^n 
+000131b0: 696e 746f 2074 6865 2073 7172 7420 746f  into the sqrt to
+000131c0: 2070 7265 7665 6e74 2070 7265 6369 7369   prevent precisi
+000131d0: 6f6e 206c 6f73 7320 7768 656e 2063 6f6e  on loss when con
+000131e0: 7665 7274 696e 6720 7468 6520 7371 7274  verting the sqrt
+000131f0: 0a20 2020 2020 2020 202f 2f20 746f 2061  .        // to a
+00013200: 6e20 696e 7465 6765 720a 2020 2020 2020  n integer.      
+00013210: 2020 626f 756e 6420 3d20 2662 6f75 6e64    bound = &bound
+00013220: 202a 2026 496e 7465 6765 723a 3a4e 6174   * &Integer::Nat
+00013230: 7572 616c 2832 292e 706f 7728 2874 6f74  ural(2).pow((tot
+00013240: 616c 5f64 6567 7265 6520 2a20 3229 2e73  al_degree * 2).s
+00013250: 6174 7572 6174 696e 675f 7375 6228 6e6f  aturating_sub(no
+00013260: 6e5f 7a65 726f 5f76 6172 7329 293b 0a0a  n_zero_vars));..
+00013270: 2020 2020 2020 2020 626f 756e 6420 3d20          bound = 
+00013280: 266d 6174 6368 2062 6f75 6e64 207b 0a20  &match bound {. 
+00013290: 2020 2020 2020 2020 2020 2049 6e74 6567             Integ
+000132a0: 6572 3a3a 4e61 7475 7261 6c28 6229 203d  er::Natural(b) =
+000132b0: 3e20 496e 7465 6765 723a 3a4e 6174 7572  > Integer::Natur
+000132c0: 616c 2828 6220 6173 2066 3634 292e 7371  al((b as f64).sq
+000132d0: 7274 2829 2061 7320 6936 3429 2c0a 2020  rt() as i64),.  
+000132e0: 2020 2020 2020 2020 2020 496e 7465 6765            Intege
+000132f0: 723a 3a44 6f75 626c 6528 6229 203d 3e20  r::Double(b) => 
+00013300: 496e 7465 6765 723a 3a66 726f 6d5f 6c61  Integer::from_la
+00013310: 7267 6528 7275 673a 3a49 6e74 6567 6572  rge(rug::Integer
+00013320: 3a3a 6672 6f6d 2862 292e 7371 7274 2829  ::from(b).sqrt()
+00013330: 292c 0a20 2020 2020 2020 2020 2020 2049  ),.            I
+00013340: 6e74 6567 6572 3a3a 4c61 7267 6528 6229  nteger::Large(b)
+00013350: 203d 3e20 496e 7465 6765 723a 3a66 726f   => Integer::fro
+00013360: 6d5f 6c61 7267 6528 622e 7371 7274 2829  m_large(b.sqrt()
+00013370: 292c 0a20 2020 2020 2020 207d 202b 2026  ),.        } + &
+00013380: 3169 3634 2e69 6e74 6f28 293b 0a0a 2020  1i64.into();..  
+00013390: 2020 2020 2020 2662 6f75 6e64 202a 2026        &bound * &
+000133a0: 2826 6d61 785f 6e6f 726d 202a 2026 7365  (&max_norm * &se
+000133b0: 6c66 2e6c 636f 6566 6628 292e 6162 7328  lf.lcoeff().abs(
+000133c0: 2929 0a20 2020 207d 0a0a 2020 2020 2f2f  )).    }..    //
+000133d0: 2f20 536f 7274 2074 6865 2062 6976 6172  / Sort the bivar
+000133e0: 6961 7465 2066 6163 746f 7273 2062 6173  iate factors bas
+000133f0: 6564 206f 6e20 7468 6569 7220 756e 6976  ed on their univ
+00013400: 6172 6961 7465 2069 6d61 6765 2073 6f20  ariate image so 
+00013410: 7468 6174 2074 6865 7920 6172 650a 2020  that they are.  
+00013420: 2020 2f2f 2f20 616c 6967 6e65 6420 6265    /// aligned be
+00013430: 7477 6565 6e20 7468 6520 6469 6666 6572  tween the differ
+00013440: 656e 7420 7661 7273 2e0a 2020 2020 2f2f  ent vars..    //
+00013450: 2054 4f44 4f3a 206d 6572 6765 2077 6974   TODO: merge wit
+00013460: 6820 7468 6520 696d 706c 656d 656e 7461  h the implementa
+00013470: 7469 6f6e 2066 6f72 2066 696e 6974 6520  tion for finite 
+00013480: 6669 656c 6473 2061 7320 7468 6520 696d  fields as the im
+00013490: 706c 656d 656e 7461 7469 6f6e 0a20 2020  plementation.   
+000134a0: 202f 2f20 6973 2061 6c6d 6f73 7420 6964   // is almost id
+000134b0: 656e 7469 6361 6c0a 2020 2020 666e 2063  entical.    fn c
+000134c0: 616e 6f6e 6963 616c 5f73 6f72 7428 0a20  anonical_sort(. 
+000134d0: 2020 2020 2020 2062 6976 5f70 6f6c 7973         biv_polys
+000134e0: 3a20 265b 5365 6c66 5d2c 0a20 2020 2020  : &[Self],.     
+000134f0: 2020 2072 6570 6c61 6365 5f76 6172 3a20     replace_var: 
+00013500: 7573 697a 652c 0a20 2020 2020 2020 2073  usize,.        s
+00013510: 616d 706c 655f 706f 696e 7473 3a20 265b  ample_points: &[
+00013520: 2875 7369 7a65 2c20 496e 7465 6765 7229  (usize, Integer)
+00013530: 5d2c 0a20 2020 2029 202d 3e20 5665 633c  ],.    ) -> Vec<
+00013540: 2853 656c 662c 2049 6e74 6567 6572 2c20  (Self, Integer, 
+00013550: 5365 6c66 293e 207b 0a20 2020 2020 2020  Self)> {.       
+00013560: 206c 6574 206d 7574 2075 6e69 7661 7269   let mut univari
+00013570: 6174 655f 6661 6374 6f72 7320 3d20 6269  ate_factors = bi
+00013580: 765f 706f 6c79 730a 2020 2020 2020 2020  v_polys.        
+00013590: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
+000135a0: 2020 2020 2020 2020 2e6d 6170 287c 667c          .map(|f|
+000135b0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+000135c0: 2020 206c 6574 206d 7574 2075 203d 2066     let mut u = f
+000135d0: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
+000135e0: 2020 2020 2020 2020 2020 666f 7220 2876            for (v
+000135f0: 2c20 7029 2069 6e20 7361 6d70 6c65 5f70  , p) in sample_p
+00013600: 6f69 6e74 7320 7b0a 2020 2020 2020 2020  oints {.        
+00013610: 2020 2020 2020 2020 2020 2020 6966 202a              if *
+00013620: 7620 3d3d 2072 6570 6c61 6365 5f76 6172  v == replace_var
+00013630: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00013640: 2020 2020 2020 2020 2020 2075 203d 2075             u = u
+00013650: 2e72 6570 6c61 6365 282a 762c 2070 293b  .replace(*v, p);
+00013660: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013670: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00013680: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+00013690: 2020 2020 2020 2020 2020 2f2f 206d 616b            // mak
+000136a0: 6520 7375 7265 2074 6865 2072 6570 7265  e sure the repre
+000136b0: 7365 6e74 6174 6976 6520 6973 2075 6e69  sentative is uni
+000136c0: 7175 650a 2020 2020 2020 2020 2020 2020  que.            
+000136d0: 2020 2020 6c65 7420 6d75 7420 756e 6920      let mut uni 
+000136e0: 3d20 752e 636c 6f6e 6528 292e 6d61 6b65  = u.clone().make
+000136f0: 5f70 7269 6d69 7469 7665 2829 3b0a 2020  _primitive();.  
+00013700: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00013710: 2075 6e69 2e6c 636f 6566 6628 292e 6973   uni.lcoeff().is
+00013720: 5f6e 6567 6174 6976 6528 2920 7b0a 2020  _negative() {.  
+00013730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013740: 2020 756e 6920 3d20 2d75 6e69 3b0a 2020    uni = -uni;.  
+00013750: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+00013760: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013770: 2028 662e 636c 6f6e 6528 292c 2075 2e6c   (f.clone(), u.l
+00013780: 636f 6566 6628 292c 2075 6e69 290a 2020  coeff(), uni).  
+00013790: 2020 2020 2020 2020 2020 7d29 0a20 2020            }).   
+000137a0: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
+000137b0: 743a 3a3c 5665 633c 5f3e 3e28 293b 0a0a  t::<Vec<_>>();..
+000137c0: 2020 2020 2020 2020 756e 6976 6172 6961          univaria
+000137d0: 7465 5f66 6163 746f 7273 2e73 6f72 745f  te_factors.sort_
+000137e0: 6279 287c 285f 2c20 5f2c 2061 292c 2028  by(|(_, _, a), (
+000137f0: 5f2c 205f 2c20 6229 7c20 7b0a 2020 2020  _, _, b)| {.    
+00013800: 2020 2020 2020 2020 612e 6578 706f 6e65          a.expone
+00013810: 6e74 730a 2020 2020 2020 2020 2020 2020  nts.            
+00013820: 2020 2020 2e63 6d70 2826 622e 6578 706f      .cmp(&b.expo
+00013830: 6e65 6e74 7329 0a20 2020 2020 2020 2020  nents).         
+00013840: 2020 2020 2020 202e 7468 656e 2861 2e63         .then(a.c
+00013850: 6f65 6666 6963 6965 6e74 732e 7061 7274  oefficients.part
+00013860: 6961 6c5f 636d 7028 2662 2e63 6f65 6666  ial_cmp(&b.coeff
+00013870: 6963 6965 6e74 7329 2e75 6e77 7261 7028  icients).unwrap(
+00013880: 2929 0a20 2020 2020 2020 207d 293b 0a0a  )).        });..
+00013890: 2020 2020 2020 2020 756e 6976 6172 6961          univaria
+000138a0: 7465 5f66 6163 746f 7273 0a20 2020 207d  te_factors.    }
+000138b0: 0a0a 2020 2020 2f2f 2f20 5072 6563 6f6d  ..    /// Precom
+000138c0: 7075 7465 2074 6865 206c 6561 6469 6e67  pute the leading
+000138d0: 2063 6f65 6666 6963 6965 6e74 7320 6f66   coefficients of
+000138e0: 2074 6865 2070 6f6c 796e 6f6d 6961 6c20   the polynomial 
+000138f0: 6661 6374 6f72 732c 2075 7369 6e67 2061  factors, using a
+00013900: 6e0a 2020 2020 2f2f 2f20 6164 6170 7465  n.    /// adapte
+00013910: 6420 7665 7273 696f 6e20 6f66 204b 616c  d version of Kal
+00013920: 746f 6665 6e27 7320 616c 676f 7269 7468  tofen's algorith
+00013930: 6d20 7468 6174 2068 6173 206d 6f64 6966  m that has modif
+00013940: 6963 6174 696f 6e73 206f 6620 4d61 7274  ications of Mart
+00013950: 696e 204c 6565 2061 6e64 2053 7461 6e69  in Lee and Stani
+00013960: 736c 6176 2050 6f73 6c61 7673 6b79 2e0a  slav Poslavsky..
+00013970: 2020 2020 2f2f 2f0a 2020 2020 2f2f 2054      ///.    // T
+00013980: 4f44 4f3a 206d 6572 6765 2077 6974 6820  ODO: merge with 
+00013990: 7468 6520 696d 706c 656d 656e 7461 7469  the implementati
+000139a0: 6f6e 2066 6f72 2066 696e 6974 6520 6669  on for finite fi
+000139b0: 656c 6473 2061 7320 7468 6520 696d 706c  elds as the impl
+000139c0: 656d 656e 7461 7469 6f6e 0a20 2020 202f  ementation.    /
+000139d0: 2f20 6973 2061 6c6d 6f73 7420 6964 656e  / is almost iden
+000139e0: 7469 6361 6c0a 2020 2020 666e 206c 636f  tical.    fn lco
+000139f0: 6566 665f 7072 6563 6f6d 7075 7461 7469  eff_precomputati
+00013a00: 6f6e 280a 2020 2020 2020 2020 2673 656c  on(.        &sel
+00013a10: 662c 0a20 2020 2020 2020 2062 6976 6172  f,.        bivar
+00013a20: 6961 7465 5f66 6163 746f 7273 3a20 265b  iate_factors: &[
+00013a30: 5365 6c66 5d2c 0a20 2020 2020 2020 2073  Self],.        s
+00013a40: 616d 706c 655f 706f 696e 7473 3a20 265b  ample_points: &[
+00013a50: 2875 7369 7a65 2c20 496e 7465 6765 7229  (usize, Integer)
+00013a60: 5d2c 0a20 2020 2020 2020 206f 7264 6572  ],.        order
+00013a70: 3a20 265b 7573 697a 655d 2c0a 2020 2020  : &[usize],.    
+00013a80: 2020 2020 626f 756e 643a 2049 6e74 6567      bound: Integ
+00013a90: 6572 2c0a 2020 2020 2020 2020 703a 2075  er,.        p: u
+00013aa0: 3332 2c0a 2020 2020 2020 2020 6b3a 2075  32,.        k: u
+00013ab0: 7369 7a65 2c0a 2020 2020 2920 2d3e 2052  size,.    ) -> R
+00013ac0: 6573 756c 743c 2856 6563 3c53 656c 663e  esult<(Vec<Self>
+00013ad0: 2c20 5665 633c 5365 6c66 3e29 2c20 7573  , Vec<Self>), us
+00013ae0: 697a 653e 207b 0a20 2020 2020 2020 206c  ize> {.        l
+00013af0: 6574 206c 636f 6566 6620 3d20 7365 6c66  et lcoeff = self
+00013b00: 2e75 6e69 7661 7269 6174 655f 6c63 6f65  .univariate_lcoe
+00013b10: 6666 286f 7264 6572 5b30 5d29 3b0a 2020  ff(order[0]);.  
+00013b20: 2020 2020 2020 6c65 7420 7371 6620 3d20        let sqf = 
+00013b30: 6c63 6f65 6666 2e73 7175 6172 655f 6672  lcoeff.square_fr
+00013b40: 6565 5f66 6163 746f 7269 7a61 7469 6f6e  ee_factorization
+00013b50: 2829 3b0a 0a20 2020 2020 2020 206c 6574  ();..        let
+00013b60: 206d 7574 206c 636f 6566 665f 7371 7561   mut lcoeff_squa
+00013b70: 7265 5f66 7265 6520 3d20 7365 6c66 2e6f  re_free = self.o
+00013b80: 6e65 2829 3b0a 2020 2020 2020 2020 666f  ne();.        fo
+00013b90: 7220 2866 2c20 5f29 2069 6e20 2673 7166  r (f, _) in &sqf
+00013ba0: 207b 0a20 2020 2020 2020 2020 2020 206c   {.            l
+00013bb0: 636f 6566 665f 7371 7561 7265 5f66 7265  coeff_square_fre
+00013bc0: 6520 3d20 266c 636f 6566 665f 7371 7561  e = &lcoeff_squa
+00013bd0: 7265 5f66 7265 6520 2a20 663b 0a20 2020  re_free * f;.   
+00013be0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00013bf0: 6c65 7420 736f 7274 6564 5f6d 6169 6e5f  let sorted_main_
+00013c00: 6661 6374 6f72 7320 3d20 5365 6c66 3a3a  factors = Self::
+00013c10: 6361 6e6f 6e69 6361 6c5f 736f 7274 2862  canonical_sort(b
+00013c20: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+00013c30: 2c20 6f72 6465 725b 315d 2c20 7361 6d70  , order[1], samp
+00013c40: 6c65 5f70 6f69 6e74 7329 3b0a 0a20 2020  le_points);..   
+00013c50: 2020 2020 206c 6574 206d 7574 2074 7275       let mut tru
+00013c60: 655f 6c63 6f65 6666 733a 2056 6563 3c5f  e_lcoeffs: Vec<_
+00013c70: 3e20 3d20 6269 7661 7269 6174 655f 6661  > = bivariate_fa
+00013c80: 6374 6f72 732e 6974 6572 2829 2e6d 6170  ctors.iter().map
+00013c90: 287c 5f7c 2073 656c 662e 6f6e 6528 2929  (|_| self.one())
+00013ca0: 2e63 6f6c 6c65 6374 2829 3b0a 0a20 2020  .collect();..   
+00013cb0: 2020 2020 206c 6574 206d 7574 206c 636f       let mut lco
+00013cc0: 6566 665f 6c65 6674 203d 206c 636f 6566  eff_left = lcoef
+00013cd0: 662e 636c 6f6e 6528 293b 0a0a 2020 2020  f.clone();..    
+00013ce0: 2020 2020 6c65 7420 6d61 696e 5f62 6976      let main_biv
+00013cf0: 6172 6961 7465 5f66 6163 746f 7273 3a20  ariate_factors: 
+00013d00: 5665 633c 5f3e 203d 0a20 2020 2020 2020  Vec<_> =.       
+00013d10: 2020 2020 2073 6f72 7465 645f 6d61 696e       sorted_main
+00013d20: 5f66 6163 746f 7273 2e69 6e74 6f5f 6974  _factors.into_it
+00013d30: 6572 2829 2e6d 6170 287c 2866 2c20 5f2c  er().map(|(f, _,
+00013d40: 205f 297c 2066 292e 636f 6c6c 6563 7428   _)| f).collect(
+00013d50: 293b 0a0a 2020 2020 2020 2020 2f2f 2054  );..        // T
+00013d60: 4f44 4f3a 2073 6d61 7274 6572 206f 7264  ODO: smarter ord
+00013d70: 6572 696e 670a 2020 2020 2020 2020 666f  ering.        fo
+00013d80: 7220 2869 2c20 2676 6172 2920 696e 206f  r (i, &var) in o
+00013d90: 7264 6572 5b31 2e2e 5d2e 6974 6572 2829  rder[1..].iter()
+00013da0: 2e65 6e75 6d65 7261 7465 2829 207b 0a20  .enumerate() {. 
+00013db0: 2020 2020 2020 2020 2020 2069 6620 6c63             if lc
+00013dc0: 6f65 6666 5f6c 6566 742e 6973 5f6f 6e65  oeff_left.is_one
+00013dd0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+00013de0: 2020 2020 2062 7265 616b 3b0a 2020 2020       break;.    
+00013df0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00013e00: 2020 2020 2020 2069 6620 6c63 6f65 6666         if lcoeff
+00013e10: 5f6c 6566 742e 6465 6772 6565 2876 6172  _left.degree(var
+00013e20: 292e 6973 5f7a 6572 6f28 2920 7b0a 2020  ).is_zero() {.  
+00013e30: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00013e40: 6e74 696e 7565 3b0a 2020 2020 2020 2020  ntinue;.        
+00013e50: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
+00013e60: 2020 202f 2f20 6f6e 6c79 2063 6f6e 7374     // only const
+00013e70: 7275 6374 2066 6163 746f 7273 2074 6861  ruct factors tha
+00013e80: 7420 6465 7065 6e64 206f 6e20 7661 7220  t depend on var 
+00013e90: 616e 6420 7265 6d6f 7665 2069 6e74 6567  and remove integ
+00013ea0: 6572 2063 6f6e 7465 6e74 2061 6e64 2075  er content and u
+00013eb0: 6e69 740a 2020 2020 2020 2020 2020 2020  nit.            
+00013ec0: 6c65 7420 6320 3d20 6c63 6f65 6666 5f73  let c = lcoeff_s
+00013ed0: 7175 6172 655f 6672 6565 2e75 6e69 7661  quare_free.univa
+00013ee0: 7269 6174 655f 636f 6e74 656e 7428 7661  riate_content(va
+00013ef0: 7229 3b0a 2020 2020 2020 2020 2020 2020  r);.            
+00013f00: 6c65 7420 6d75 7420 6c63 6f65 6666 5f73  let mut lcoeff_s
+00013f10: 7175 6172 655f 6672 6565 5f70 7020 3d20  quare_free_pp = 
+00013f20: 266c 636f 6566 665f 7371 7561 7265 5f66  &lcoeff_square_f
+00013f30: 7265 6520 2f20 2663 3b0a 2020 2020 2020  ree / &c;.      
+00013f40: 2020 2020 2020 6966 206c 636f 6566 665f        if lcoeff_
+00013f50: 7371 7561 7265 5f66 7265 655f 7070 2e6c  square_free_pp.l
+00013f60: 636f 6566 6628 292e 6973 5f6e 6567 6174  coeff().is_negat
+00013f70: 6976 6528 2920 7b0a 2020 2020 2020 2020  ive() {.        
+00013f80: 2020 2020 2020 2020 6c63 6f65 6666 5f73          lcoeff_s
+00013f90: 7175 6172 655f 6672 6565 5f70 7020 3d20  quare_free_pp = 
+00013fa0: 2d6c 636f 6566 665f 7371 7561 7265 5f66  -lcoeff_square_f
+00013fb0: 7265 655f 7070 3b0a 2020 2020 2020 2020  ree_pp;.        
+00013fc0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+00013fd0: 2020 6465 6275 6721 2822 436f 6e74 656e    debug!("Conten
+00013fe0: 742d 6672 6565 206c 6373 7166 207b 7d22  t-free lcsqf {}"
+00013ff0: 2c20 6c63 6f65 6666 5f73 7175 6172 655f  , lcoeff_square_
+00014000: 6672 6565 5f70 7029 3b0a 0a20 2020 2020  free_pp);..     
+00014010: 2020 2020 2020 202f 2f20 6368 6563 6b20         // check 
+00014020: 6966 2074 6865 2065 7661 6c75 6174 6564  if the evaluated
+00014030: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
+00014040: 6965 6e74 2072 656d 6169 6e73 2073 7175  ient remains squ
+00014050: 6172 6520 6672 6565 0a20 2020 2020 2020  are free.       
+00014060: 2020 2020 206c 6574 206d 7574 2070 6f6c       let mut pol
+00014070: 795f 6576 616c 203d 206c 636f 6566 665f  y_eval = lcoeff_
+00014080: 7371 7561 7265 5f66 7265 655f 7070 2e63  square_free_pp.c
+00014090: 6c6f 6e65 2829 3b0a 2020 2020 2020 2020  lone();.        
+000140a0: 2020 2020 666f 7220 2876 2c20 7029 2069      for (v, p) i
+000140b0: 6e20 7361 6d70 6c65 5f70 6f69 6e74 7320  n sample_points 
+000140c0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+000140d0: 2020 6966 202a 7620 213d 2076 6172 207b    if *v != var {
+000140e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000140f0: 2020 2020 2070 6f6c 795f 6576 616c 203d       poly_eval =
+00014100: 2070 6f6c 795f 6576 616c 2e72 6570 6c61   poly_eval.repla
+00014110: 6365 282a 762c 2070 293b 0a20 2020 2020  ce(*v, p);.     
+00014120: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00014130: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00014140: 2020 2020 2020 206c 6574 2073 7166 203d         let sqf =
+00014150: 2070 6f6c 795f 6576 616c 2e73 7175 6172   poly_eval.squar
+00014160: 655f 6672 6565 5f66 6163 746f 7269 7a61  e_free_factoriza
+00014170: 7469 6f6e 2829 3b0a 2020 2020 2020 2020  tion();.        
+00014180: 2020 2020 6966 2073 7166 2e6c 656e 2829      if sqf.len()
+00014190: 2021 3d20 3120 7c7c 2073 7166 5b30 5d2e   != 1 || sqf[0].
+000141a0: 3120 213d 2031 207b 0a20 2020 2020 2020  1 != 1 {.       
+000141b0: 2020 2020 2020 2020 2064 6562 7567 2128           debug!(
+000141c0: 2250 6f6c 796e 6f6d 6961 6c20 6973 206e  "Polynomial is n
+000141d0: 6f74 2073 7175 6172 6520 6672 6565 3a20  ot square free: 
+000141e0: 7b7d 222c 2070 6f6c 795f 6576 616c 293b  {}", poly_eval);
+000141f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014200: 2072 6574 7572 6e20 4572 7228 6d61 696e   return Err(main
+00014210: 5f62 6976 6172 6961 7465 5f66 6163 746f  _bivariate_facto
+00014220: 7273 2e6c 656e 2829 293b 0a20 2020 2020  rs.len());.     
+00014230: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+00014240: 2020 2020 2020 6c65 7420 6269 7661 7269        let bivari
+00014250: 6174 655f 6661 6374 6f72 7320 3d20 6966  ate_factors = if
+00014260: 2076 6172 203d 3d20 6f72 6465 725b 315d   var == order[1]
+00014270: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00014280: 2020 206d 6169 6e5f 6269 7661 7269 6174     main_bivariat
+00014290: 655f 6661 6374 6f72 732e 746f 5f76 6563  e_factors.to_vec
+000142a0: 2829 0a20 2020 2020 2020 2020 2020 207d  ().            }
+000142b0: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
+000142c0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+000142d0: 706f 6c79 5f65 7661 6c20 3d20 7365 6c66  poly_eval = self
+000142e0: 2e63 6c6f 6e65 2829 3b0a 2020 2020 2020  .clone();.      
+000142f0: 2020 2020 2020 2020 2020 666f 7220 2876            for (v
+00014300: 2c20 7029 2069 6e20 7361 6d70 6c65 5f70  , p) in sample_p
+00014310: 6f69 6e74 7320 7b0a 2020 2020 2020 2020  oints {.        
+00014320: 2020 2020 2020 2020 2020 2020 6966 202a              if *
+00014330: 7620 213d 2076 6172 207b 0a20 2020 2020  v != var {.     
+00014340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014350: 2020 2070 6f6c 795f 6576 616c 203d 2070     poly_eval = p
+00014360: 6f6c 795f 6576 616c 2e72 6570 6c61 6365  oly_eval.replace
+00014370: 282a 762c 2070 293b 0a20 2020 2020 2020  (*v, p);.       
+00014380: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00014390: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+000143a0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+000143b0: 2020 6966 2070 6f6c 795f 6576 616c 2e64    if poly_eval.d
+000143c0: 6567 7265 6528 6f72 6465 725b 305d 2920  egree(order[0]) 
+000143d0: 213d 2073 656c 662e 6465 6772 6565 286f  != self.degree(o
+000143e0: 7264 6572 5b30 5d29 0a20 2020 2020 2020  rder[0]).       
+000143f0: 2020 2020 2020 2020 2020 2020 207c 7c20               || 
+00014400: 706f 6c79 5f65 7661 6c2e 6465 6772 6565  poly_eval.degree
+00014410: 2876 6172 2920 213d 2073 656c 662e 6465  (var) != self.de
+00014420: 6772 6565 2876 6172 290a 2020 2020 2020  gree(var).      
+00014430: 2020 2020 2020 2020 2020 2020 2020 7c7c                ||
+00014440: 2070 6f6c 795f 6576 616c 2e75 6e69 7661   poly_eval.univa
+00014450: 7269 6174 655f 6c63 6f65 6666 286f 7264  riate_lcoeff(ord
+00014460: 6572 5b30 5d29 2e64 6567 7265 6528 7661  er[0]).degree(va
+00014470: 7229 2021 3d20 6c63 6f65 6666 2e64 6567  r) != lcoeff.deg
+00014480: 7265 6528 7661 7229 0a20 2020 2020 2020  ree(var).       
+00014490: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
+000144a0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+000144b0: 6562 7567 2128 2242 6164 2073 616d 706c  ebug!("Bad sampl
+000144c0: 6520 666f 7220 7265 636f 6e73 7472 7563  e for reconstruc
+000144d0: 7469 6e67 206c 636f 6566 663a 2064 6567  ting lcoeff: deg
+000144e0: 7265 6573 2064 6f20 6e6f 7420 6d61 7463  rees do not matc
+000144f0: 6822 293b 0a20 2020 2020 2020 2020 2020  h");.           
+00014500: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00014510: 4572 7228 6d61 696e 5f62 6976 6172 6961  Err(main_bivaria
+00014520: 7465 5f66 6163 746f 7273 2e6c 656e 2829  te_factors.len()
+00014530: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00014540: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+00014550: 2020 2020 2020 6c65 7420 6269 7661 7269        let bivari
+00014560: 6174 655f 6661 6374 6f72 733a 2056 6563  ate_factors: Vec
+00014570: 3c5f 3e20 3d20 706f 6c79 5f65 7661 6c0a  <_> = poly_eval.
+00014580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014590: 2020 2020 2e66 6163 746f 7228 290a 2020      .factor().  
+000145a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000145b0: 2020 2e69 6e74 6f5f 6974 6572 2829 0a20    .into_iter(). 
+000145c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000145d0: 2020 202e 6d61 7028 7c28 662c 205f 297c     .map(|(f, _)|
+000145e0: 2066 290a 2020 2020 2020 2020 2020 2020   f).            
+000145f0: 2020 2020 2020 2020 2f2f 2072 656d 6f76          // remov
+00014600: 6520 7370 7572 696f 7573 2063 6f6e 7465  e spurious conte
+00014610: 6e74 2063 6175 7365 6420 6279 2070 6172  nt caused by par
+00014620: 7469 6375 6c61 7220 6576 616c 7561 7469  ticular evaluati
+00014630: 6f6e 2070 6f69 6e74 0a20 2020 2020 2020  on point.       
+00014640: 2020 2020 2020 2020 2020 2020 202e 6669               .fi
+00014650: 6c74 6572 287c 667c 2021 662e 6973 5f63  lter(|f| !f.is_c
+00014660: 6f6e 7374 616e 7428 2929 0a20 2020 2020  onstant()).     
+00014670: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00014680: 636f 6c6c 6563 7428 293b 0a0a 2020 2020  collect();..    
+00014690: 2020 2020 2020 2020 2020 2020 6966 2062              if b
+000146a0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+000146b0: 2e6c 656e 2829 2021 3d20 6d61 696e 5f62  .len() != main_b
+000146c0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+000146d0: 2e6c 656e 2829 207b 0a20 2020 2020 2020  .len() {.       
+000146e0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+000146f0: 7572 6e20 4572 7228 6269 7661 7269 6174  urn Err(bivariat
+00014700: 655f 6661 6374 6f72 732e 6c65 6e28 292e  e_factors.len().
+00014710: 6d69 6e28 6d61 696e 5f62 6976 6172 6961  min(main_bivaria
+00014720: 7465 5f66 6163 746f 7273 2e6c 656e 2829  te_factors.len()
+00014730: 2929 3b0a 2020 2020 2020 2020 2020 2020  ));.            
+00014740: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
+00014750: 2020 2020 2020 2053 656c 663a 3a63 616e         Self::can
+00014760: 6f6e 6963 616c 5f73 6f72 7428 2662 6976  onical_sort(&biv
+00014770: 6172 6961 7465 5f66 6163 746f 7273 2c20  ariate_factors, 
+00014780: 7661 722c 2073 616d 706c 655f 706f 696e  var, sample_poin
+00014790: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
+000147a0: 2020 2020 2020 2020 2e69 6e74 6f5f 6974          .into_it
+000147b0: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
+000147c0: 2020 2020 2020 2020 202e 6d61 7028 7c28           .map(|(
+000147d0: 662c 205f 2c20 5f29 7c20 6629 0a20 2020  f, _, _)| f).   
+000147e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000147f0: 202e 636f 6c6c 6563 7428 290a 2020 2020   .collect().    
+00014800: 2020 2020 2020 2020 7d3b 0a0a 2020 2020          };..    
+00014810: 2020 2020 2020 2020 6c65 7420 7371 7561          let squa
+00014820: 7265 5f66 7265 655f 6c63 5f62 6976 5f66  re_free_lc_biv_f
+00014830: 6163 746f 7273 3a20 5665 633c 5f3e 203d  actors: Vec<_> =
+00014840: 2062 6976 6172 6961 7465 5f66 6163 746f   bivariate_facto
+00014850: 7273 0a20 2020 2020 2020 2020 2020 2020  rs.             
+00014860: 2020 202e 6974 6572 2829 0a20 2020 2020     .iter().     
+00014870: 2020 2020 2020 2020 2020 202e 6d61 7028             .map(
+00014880: 7c66 7c20 7b0a 2020 2020 2020 2020 2020  |f| {.          
+00014890: 2020 2020 2020 2020 2020 6c65 7420 6d75            let mu
+000148a0: 7420 7366 6620 3d20 662e 756e 6976 6172  t sff = f.univar
+000148b0: 6961 7465 5f6c 636f 6566 6628 6f72 6465  iate_lcoeff(orde
+000148c0: 725b 305d 292e 7371 7561 7265 5f66 7265  r[0]).square_fre
+000148d0: 655f 6661 6374 6f72 697a 6174 696f 6e28  e_factorization(
+000148e0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+000148f0: 2020 2020 2020 202f 2f20 6d61 6b65 2073         // make s
+00014900: 7572 6520 6576 6572 7920 6269 7661 7269  ure every bivari
+00014910: 6174 6520 6661 6374 6f72 2068 6173 2070  ate factor has p
+00014920: 6f73 6974 6976 6520 6c63 6f65 6666 2073  ositive lcoeff s
+00014930: 7563 6820 7468 6174 2074 6865 2070 726f  uch that the pro
+00014940: 6475 6374 0a20 2020 2020 2020 2020 2020  duct.           
+00014950: 2020 2020 2020 2020 202f 2f20 6f66 2074           // of t
+00014960: 6865 2062 6173 6973 2065 6c65 6d65 6e74  he basis element
+00014970: 7320 6571 7561 6c73 2074 6865 2065 7661  s equals the eva
+00014980: 6c75 6174 6564 206c 636f 6566 665f 7371  luated lcoeff_sq
+00014990: 7561 7265 5f66 7265 655f 7070 0a20 2020  uare_free_pp.   
+000149a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000149b0: 2066 6f72 2028 622c 205f 2920 696e 2026   for (b, _) in &
+000149c0: 6d75 7420 7366 6620 7b0a 2020 2020 2020  mut sff {.      
+000149d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000149e0: 2020 6966 2062 2e6c 636f 6566 6628 292e    if b.lcoeff().
+000149f0: 6973 5f6e 6567 6174 6976 6528 2920 7b0a  is_negative() {.
+00014a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a10: 2020 2020 2020 2020 2020 2020 2a62 203d              *b =
+00014a20: 202d 622e 636c 6f6e 6528 293b 0a20 2020   -b.clone();.   
+00014a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a40: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00014a50: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00014a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a70: 2073 6666 0a20 2020 2020 2020 2020 2020   sff.           
+00014a80: 2020 2020 207d 290a 2020 2020 2020 2020       }).        
+00014a90: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
+00014aa0: 2829 3b0a 0a20 2020 2020 2020 2020 2020  ();..           
+00014ab0: 206c 6574 2062 6173 6973 203d 2053 656c   let basis = Sel
+00014ac0: 663a 3a67 6364 5f66 7265 655f 6261 7369  f::gcd_free_basi
+00014ad0: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+00014ae0: 2020 2073 7175 6172 655f 6672 6565 5f6c     square_free_l
+00014af0: 635f 6269 765f 6661 6374 6f72 730a 2020  c_biv_factors.  
+00014b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014b10: 2020 2e69 7465 7228 290a 2020 2020 2020    .iter().      
+00014b20: 2020 2020 2020 2020 2020 2020 2020 2e66                .f
+00014b30: 6c61 7474 656e 2829 0a20 2020 2020 2020  latten().       
+00014b40: 2020 2020 2020 2020 2020 2020 202e 6d61               .ma
+00014b50: 7028 7c78 7c20 782e 302e 636c 6f6e 6528  p(|x| x.0.clone(
+00014b60: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00014b70: 2020 2020 2020 202e 6669 6c74 6572 287c         .filter(|
+00014b80: 787c 2021 782e 6973 5f63 6f6e 7374 616e  x| !x.is_constan
+00014b90: 7428 2929 0a20 2020 2020 2020 2020 2020  t()).           
+00014ba0: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
+00014bb0: 7428 292c 0a20 2020 2020 2020 2020 2020  t(),.           
+00014bc0: 2029 3b0a 0a20 2020 2020 2020 2020 2020   );..           
+00014bd0: 2069 6620 6261 7369 732e 6973 5f65 6d70   if basis.is_emp
+00014be0: 7479 2829 207b 0a20 2020 2020 2020 2020  ty() {.         
+00014bf0: 2020 2020 2020 2063 6f6e 7469 6e75 653b         continue;
+00014c00: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+00014c10: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+00014c20: 6c69 6674 6564 203d 2069 6620 6261 7369  lifted = if basi
+00014c30: 732e 6c65 6e28 2920 3d3d 2031 207b 0a20  s.len() == 1 {. 
+00014c40: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00014c50: 6563 215b 6c63 6f65 6666 5f73 7175 6172  ec![lcoeff_squar
+00014c60: 655f 6672 6565 5f70 702e 636c 6f6e 6528  e_free_pp.clone(
+00014c70: 295d 0a20 2020 2020 2020 2020 2020 207d  )].            }
+00014c80: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
+00014c90: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+00014ca0: 6e65 775f 6f72 6465 7220 3d20 6f72 6465  new_order = orde
+00014cb0: 722e 746f 5f76 6563 2829 3b0a 2020 2020  r.to_vec();.    
+00014cc0: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
+00014cd0: 6f72 6465 722e 7377 6170 2831 2c20 6920  order.swap(1, i 
+00014ce0: 2b20 3129 3b0a 2020 2020 2020 2020 2020  + 1);.          
+00014cf0: 2020 2020 2020 6e65 775f 6f72 6465 722e        new_order.
+00014d00: 7265 6d6f 7665 2830 293b 0a0a 2020 2020  remove(0);..    
+00014d10: 2020 2020 2020 2020 2020 2020 6c63 6f65              lcoe
+00014d20: 6666 5f73 7175 6172 655f 6672 6565 5f70  ff_square_free_p
+00014d30: 702e 6d75 6c74 6976 6172 6961 7465 5f68  p.multivariate_h
+00014d40: 656e 7365 6c5f 6c69 6674 5f77 6974 685f  ensel_lift_with_
+00014d50: 6175 746f 5f6c 636f 6566 665f 6669 7869  auto_lcoeff_fixi
+00014d60: 6e67 280a 2020 2020 2020 2020 2020 2020  ng(.            
+00014d70: 2020 2020 2020 2020 2662 6173 6973 2c0a          &basis,.
+00014d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d90: 2020 2020 7361 6d70 6c65 5f70 6f69 6e74      sample_point
+00014da0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00014db0: 2020 2020 2020 2026 6e65 775f 6f72 6465         &new_orde
+00014dc0: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
+00014dd0: 2020 2020 2020 2062 6f75 6e64 2e63 6c6f         bound.clo
+00014de0: 6e65 2829 2c0a 2020 2020 2020 2020 2020  ne(),.          
+00014df0: 2020 2020 2020 2020 2020 702c 0a20 2020            p,.   
+00014e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014e10: 206b 2c0a 2020 2020 2020 2020 2020 2020   k,.            
+00014e20: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00014e30: 2020 7d3b 0a0a 2020 2020 2020 2020 2020    };..          
+00014e40: 2020 666f 7220 286c 2c20 6661 6329 2069    for (l, fac) i
+00014e50: 6e20 7472 7565 5f6c 636f 6566 6673 2e69  n true_lcoeffs.i
+00014e60: 7465 725f 6d75 7428 292e 7a69 7028 2673  ter_mut().zip(&s
+00014e70: 7175 6172 655f 6672 6565 5f6c 635f 6269  quare_free_lc_bi
+00014e80: 765f 6661 6374 6f72 7329 207b 0a20 2020  v_factors) {.   
+00014e90: 2020 2020 2020 2020 2020 2020 206c 6574               let
+00014ea0: 206d 7574 2063 6f6e 7472 6962 203d 2073   mut contrib = s
+00014eb0: 656c 662e 6f6e 6528 293b 0a20 2020 2020  elf.one();.     
+00014ec0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
+00014ed0: 6675 6c6c 2c20 6229 2069 6e20 6c69 6674  full, b) in lift
+00014ee0: 6564 2e69 7465 7228 292e 7a69 7028 2662  ed.iter().zip(&b
+00014ef0: 6173 6973 2920 7b0a 2020 2020 2020 2020  asis) {.        
+00014f00: 2020 2020 2020 2020 2020 2020 2f2f 2063              // c
+00014f10: 6865 636b 2069 6620 6120 4743 442d 6672  heck if a GCD-fr
+00014f20: 6565 2062 6173 6973 2065 6c65 6d65 6e74  ee basis element
+00014f30: 2069 7320 6120 6661 6374 6f72 206f 6620   is a factor of 
+00014f40: 7468 6520 6c65 6164 696e 6720 636f 6566  the leading coef
+00014f50: 6669 6369 656e 7420 6f66 2074 6869 7320  ficient of this 
+00014f60: 6269 7661 7269 6174 6520 6661 6374 6f72  bivariate factor
+00014f70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014f80: 2020 2020 2069 6620 6c65 7420 536f 6d65       if let Some
+00014f90: 2828 5f2c 206d 2929 203d 2066 6163 2e69  ((_, m)) = fac.i
+00014fa0: 7465 7228 292e 6669 6e64 287c 2866 2c20  ter().find(|(f, 
+00014fb0: 5f29 7c20 6620 3d3d 2062 207c 7c20 662e  _)| f == b || f.
+00014fc0: 6469 7669 6465 7328 6229 2e69 735f 736f  divides(b).is_so
+00014fd0: 6d65 2829 290a 2020 2020 2020 2020 2020  me()).          
+00014fe0: 2020 2020 2020 2020 2020 7b0a 2020 2020            {.    
+00014ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015000: 2020 2020 666f 7220 5f20 696e 2030 2e2e      for _ in 0..
+00015010: 2a6d 207b 0a20 2020 2020 2020 2020 2020  *m {.           
+00015020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015030: 2063 6f6e 7472 6962 203d 2026 636f 6e74   contrib = &cont
+00015040: 7269 6220 2a20 6675 6c6c 3b0a 2020 2020  rib * full;.    
+00015050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015060: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+00015070: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00015080: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+00015090: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000150a0: 6574 2067 203d 2063 6f6e 7472 6962 2e67  et g = contrib.g
+000150b0: 6364 286c 293b 0a20 2020 2020 2020 2020  cd(l);.         
+000150c0: 2020 2020 2020 206c 6574 206e 6577 203d         let new =
+000150d0: 2028 636f 6e74 7269 6220 2f20 2667 292e   (contrib / &g).
+000150e0: 6d61 6b65 5f70 7269 6d69 7469 7665 2829  make_primitive()
+000150f0: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
+00015100: 2020 202a 6c20 3d20 2826 2a6c 202a 2026     *l = (&*l * &
+00015110: 6e65 7729 2e6d 616b 655f 7072 696d 6974  new).make_primit
+00015120: 6976 6528 293b 0a0a 2020 2020 2020 2020  ive();..        
+00015130: 2020 2020 2020 2020 6c65 7420 2871 2c20          let (q, 
+00015140: 7229 203d 206c 636f 6566 665f 6c65 6674  r) = lcoeff_left
+00015150: 2e71 756f 745f 7265 6d28 266e 6577 2c20  .quot_rem(&new, 
+00015160: 7472 7565 293b 0a20 2020 2020 2020 2020  true);.         
+00015170: 2020 2020 2020 2069 6620 2172 2e69 735f         if !r.is_
+00015180: 7a65 726f 2829 207b 0a20 2020 2020 2020  zero() {.       
+00015190: 2020 2020 2020 2020 2020 2020 2070 616e               pan
+000151a0: 6963 2128 0a20 2020 2020 2020 2020 2020  ic!(.           
+000151b0: 2020 2020 2020 2020 2020 2020 2022 5072               "Pr
+000151c0: 6f62 6c65 6d20 7769 7468 2062 6976 6172  oblem with bivar
+000151d0: 6961 7465 2066 6163 746f 7220 7363 616c  iate factor scal
+000151e0: 696e 6720 696e 2066 6163 746f 7269 7a61  ing in factoriza
+000151f0: 7469 6f6e 206f 6620 7b7d 3a20 6f72 6465  tion of {}: orde
+00015200: 723d 7b3a 3f7d 2c20 7361 6d70 6c65 733d  r={:?}, samples=
+00015210: 7b3a 3f7d 222c 0a20 2020 2020 2020 2020  {:?}",.         
+00015220: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00015230: 656c 662c 0a20 2020 2020 2020 2020 2020  elf,.           
+00015240: 2020 2020 2020 2020 2020 2020 206f 7264               ord
+00015250: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
+00015260: 2020 2020 2020 2020 2020 2020 7361 6d70              samp
+00015270: 6c65 5f70 6f69 6e74 730a 2020 2020 2020  le_points.      
+00015280: 2020 2020 2020 2020 2020 2020 2020 293b                );
+00015290: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000152a0: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
+000152b0: 2020 2020 6c63 6f65 6666 5f6c 6566 7420      lcoeff_left 
+000152c0: 3d20 713b 0a20 2020 2020 2020 2020 2020  = q;.           
+000152d0: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
+000152e0: 2020 2020 2020 6966 2021 6c63 6f65 6666        if !lcoeff
+000152f0: 5f6c 6566 742e 6973 5f63 6f6e 7374 616e  _left.is_constan
+00015300: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
+00015310: 2020 7061 6e69 6321 280a 2020 2020 2020    panic!(.      
+00015320: 2020 2020 2020 2020 2020 2243 6f75 6c64            "Could
+00015330: 206e 6f74 2072 6563 6f6e 7374 7275 6374   not reconstruct
+00015340: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
+00015350: 6965 6e74 206f 6620 7b7d 3a20 6f72 6465  ient of {}: orde
+00015360: 723d 7b3a 3f7d 2c20 7361 6d70 6c65 733d  r={:?}, samples=
+00015370: 7b3a 3f7d 2052 6573 7420 3d20 7b7d 222c  {:?} Rest = {}",
+00015380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015390: 2073 656c 662c 0a20 2020 2020 2020 2020   self,.         
+000153a0: 2020 2020 2020 206f 7264 6572 2c0a 2020         order,.  
+000153b0: 2020 2020 2020 2020 2020 2020 2020 7361                sa
+000153c0: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
+000153d0: 2020 2020 2020 2020 2020 2020 206c 636f               lco
+000153e0: 6566 665f 6c65 6674 0a20 2020 2020 2020  eff_left.       
+000153f0: 2020 2020 2029 3b0a 2020 2020 2020 2020       );.        
+00015400: 7d0a 0a20 2020 2020 2020 202f 2f20 7265  }..        // re
+00015410: 7363 616c 6520 7468 6520 6c65 6164 696e  scale the leadin
+00015420: 6720 636f 6566 6669 6369 656e 7420 6661  g coefficient fa
+00015430: 6374 6f72 7320 746f 2072 6563 6f76 6572  ctors to recover
+00015440: 2074 6865 206d 6973 7369 6e67 2063 6f6e   the missing con
+00015450: 7465 6e74 2061 6e64 2073 6967 6e0a 2020  tent and sign.  
+00015460: 2020 2020 2020 666f 7220 2866 2c20 6229        for (f, b)
+00015470: 2069 6e20 7472 7565 5f6c 636f 6566 6673   in true_lcoeffs
+00015480: 2e69 7465 725f 6d75 7428 292e 7a69 7028  .iter_mut().zip(
+00015490: 266d 6169 6e5f 6269 7661 7269 6174 655f  &main_bivariate_
+000154a0: 6661 6374 6f72 7329 207b 0a20 2020 2020  factors) {.     
+000154b0: 2020 2020 2020 206c 6574 206d 7574 2062         let mut b
+000154c0: 5f65 7661 6c20 3d20 622e 636c 6f6e 6528  _eval = b.clone(
+000154d0: 293b 0a20 2020 2020 2020 2020 2020 2066  );.            f
+000154e0: 6f72 2028 762c 2070 2920 696e 2073 616d  or (v, p) in sam
+000154f0: 706c 655f 706f 696e 7473 207b 0a20 2020  ple_points {.   
+00015500: 2020 2020 2020 2020 2020 2020 2062 5f65               b_e
+00015510: 7661 6c20 3d20 625f 6576 616c 2e72 6570  val = b_eval.rep
+00015520: 6c61 6365 282a 762c 2070 293b 0a20 2020  lace(*v, p);.   
+00015530: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+00015540: 2020 2020 2020 2020 6c65 7420 625f 6c63          let b_lc
+00015550: 203d 2062 5f65 7661 6c2e 6c63 6f65 6666   = b_eval.lcoeff
+00015560: 2829 3b0a 0a20 2020 2020 2020 2020 2020  ();..           
+00015570: 206c 6574 206d 7574 2066 5f65 7661 6c20   let mut f_eval 
+00015580: 3d20 662e 636c 6f6e 6528 293b 0a20 2020  = f.clone();.   
+00015590: 2020 2020 2020 2020 2066 6f72 2028 762c           for (v,
+000155a0: 2070 2920 696e 2073 616d 706c 655f 706f   p) in sample_po
+000155b0: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
+000155c0: 2020 2020 2020 2066 5f65 7661 6c20 3d20         f_eval = 
+000155d0: 665f 6576 616c 2e72 6570 6c61 6365 282a  f_eval.replace(*
+000155e0: 762c 2070 293b 0a20 2020 2020 2020 2020  v, p);.         
+000155f0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00015600: 206c 6574 2066 5f6c 6320 3d20 665f 6576   let f_lc = f_ev
+00015610: 616c 2e6c 636f 6566 6628 293b 0a0a 2020  al.lcoeff();..  
+00015620: 2020 2020 2020 2020 2020 6c65 7420 2871            let (q
+00015630: 2c20 7229 203d 205a 2e71 756f 745f 7265  , r) = Z.quot_re
+00015640: 6d28 2662 5f6c 632c 2026 665f 6c63 293b  m(&b_lc, &f_lc);
+00015650: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
+00015660: 6572 7421 280a 2020 2020 2020 2020 2020  ert!(.          
+00015670: 2020 2020 2020 722e 6973 5f7a 6572 6f28        r.is_zero(
+00015680: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00015690: 2020 2022 5072 6f62 6c65 6d20 7769 7468     "Problem with
+000156a0: 2062 6976 6172 6961 7465 2066 6163 746f   bivariate facto
+000156b0: 7220 7363 616c 696e 6720 696e 2066 6163  r scaling in fac
+000156c0: 746f 7269 7a61 7469 6f6e 206f 6620 7b7d  torization of {}
+000156d0: 3a20 6f72 6465 723d 7b3a 3f7d 2c20 7361  : order={:?}, sa
+000156e0: 6d70 6c65 733d 7b3a 3f7d 222c 0a20 2020  mples={:?}",.   
+000156f0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00015700: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
+00015710: 2020 206f 7264 6572 2c0a 2020 2020 2020     order,.      
+00015720: 2020 2020 2020 2020 2020 7361 6d70 6c65            sample
+00015730: 5f70 6f69 6e74 730a 2020 2020 2020 2020  _points.        
+00015740: 2020 2020 293b 0a0a 2020 2020 2020 2020      );..        
+00015750: 2020 2020 6c63 6f65 6666 5f6c 6566 7420      lcoeff_left 
+00015760: 3d20 6c63 6f65 6666 5f6c 6566 742e 6469  = lcoeff_left.di
+00015770: 765f 636f 6566 6628 2671 293b 0a20 2020  v_coeff(&q);.   
+00015780: 2020 2020 2020 2020 202a 6620 3d20 662e           *f = f.
+00015790: 636c 6f6e 6528 292e 6d75 6c5f 636f 6566  clone().mul_coef
+000157a0: 6628 7129 3b0a 2020 2020 2020 2020 7d0a  f(q);.        }.
+000157b0: 0a20 2020 2020 2020 2069 6620 216c 636f  .        if !lco
+000157c0: 6566 665f 6c65 6674 2e69 735f 6f6e 6528  eff_left.is_one(
+000157d0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+000157e0: 7061 6e69 6321 280a 2020 2020 2020 2020  panic!(.        
+000157f0: 2020 2020 2020 2020 2243 6f75 6c64 206e          "Could n
+00015800: 6f74 2064 6973 7472 6962 7574 6520 636f  ot distribute co
+00015810: 6e74 656e 7420 6f66 207b 7d3a 206f 7264  ntent of {}: ord
+00015820: 6572 3d7b 3a3f 7d2c 2073 616d 706c 6573  er={:?}, samples
+00015830: 3d7b 3a3f 7d20 5265 7374 203d 207b 7d22  ={:?} Rest = {}"
+00015840: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00015850: 2020 7365 6c66 2c20 6f72 6465 722c 2073    self, order, s
+00015860: 616d 706c 655f 706f 696e 7473 2c20 6c63  ample_points, lc
+00015870: 6f65 6666 5f6c 6566 740a 2020 2020 2020  oeff_left.      
+00015880: 2020 2020 2020 293b 0a20 2020 2020 2020        );.       
+00015890: 207d 0a0a 2020 2020 2020 2020 4f6b 2828   }..        Ok((
+000158a0: 6d61 696e 5f62 6976 6172 6961 7465 5f66  main_bivariate_f
+000158b0: 6163 746f 7273 2c20 7472 7565 5f6c 636f  actors, true_lco
+000158c0: 6566 6673 2929 0a20 2020 207d 0a0a 2020  effs)).    }..  
+000158d0: 2020 666e 206d 756c 7469 7661 7269 6174    fn multivariat
+000158e0: 655f 6865 6e73 656c 5f6c 6966 745f 7769  e_hensel_lift_wi
+000158f0: 7468 5f61 7574 6f5f 6c63 6f65 6666 5f66  th_auto_lcoeff_f
+00015900: 6978 696e 6728 0a20 2020 2020 2020 2026  ixing(.        &
+00015910: 7365 6c66 2c0a 2020 2020 2020 2020 6661  self,.        fa
+00015920: 6374 6f72 733a 2026 5b53 656c 665d 2c0a  ctors: &[Self],.
+00015930: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
+00015940: 6f69 6e74 733a 2026 5b28 7573 697a 652c  oints: &[(usize,
+00015950: 2049 6e74 6567 6572 295d 2c0a 2020 2020   Integer)],.    
+00015960: 2020 2020 6f72 6465 723a 2026 5b75 7369      order: &[usi
+00015970: 7a65 5d2c 0a20 2020 2020 2020 2062 6f75  ze],.        bou
+00015980: 6e64 3a20 496e 7465 6765 722c 0a20 2020  nd: Integer,.   
+00015990: 2020 2020 2070 3a20 7533 322c 0a20 2020       p: u32,.   
+000159a0: 2020 2020 206b 3a20 7573 697a 652c 0a20       k: usize,. 
+000159b0: 2020 2029 202d 3e20 5665 633c 5365 6c66     ) -> Vec<Self
+000159c0: 3e20 7b0a 2020 2020 2020 2020 6c65 7420  > {.        let 
+000159d0: 6d6f 6475 6c75 7320 3d20 4669 6e69 7465  modulus = Finite
+000159e0: 4669 656c 643a 3a3c 496e 7465 6765 723e  Field::<Integer>
+000159f0: 3a3a 6e65 7728 626f 756e 6429 3b0a 2020  ::new(bound);.  
+00015a00: 2020 2020 2020 6c65 7420 6666 203d 2073        let ff = s
+00015a10: 656c 662e 6d61 705f 636f 6566 6628 7c63  elf.map_coeff(|c
+00015a20: 7c20 6d6f 6475 6c75 732e 746f 5f65 6c65  | modulus.to_ele
+00015a30: 6d65 6e74 2863 2e63 6c6f 6e65 2829 292c  ment(c.clone()),
+00015a40: 206d 6f64 756c 7573 2e63 6c6f 6e65 2829   modulus.clone()
+00015a50: 293b 0a20 2020 2020 2020 206c 6574 2066  );.        let f
+00015a60: 6163 746f 7273 5f66 663a 2056 6563 3c5f  actors_ff: Vec<_
+00015a70: 3e20 3d20 6661 6374 6f72 730a 2020 2020  > = factors.    
+00015a80: 2020 2020 2020 2020 2e69 7465 7228 290a          .iter().
+00015a90: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
+00015aa0: 287c 667c 2066 2e6d 6170 5f63 6f65 6666  (|f| f.map_coeff
+00015ab0: 287c 637c 206d 6f64 756c 7573 2e74 6f5f  (|c| modulus.to_
+00015ac0: 656c 656d 656e 7428 632e 636c 6f6e 6528  element(c.clone(
+00015ad0: 2929 2c20 6d6f 6475 6c75 732e 636c 6f6e  )), modulus.clon
+00015ae0: 6528 2929 290a 2020 2020 2020 2020 2020  e())).          
+00015af0: 2020 2e63 6f6c 6c65 6374 2829 3b0a 2020    .collect();.  
+00015b00: 2020 2020 2020 6c65 7420 6c63 6f65 6666        let lcoeff
+00015b10: 203d 2066 662e 756e 6976 6172 6961 7465   = ff.univariate
+00015b20: 5f6c 636f 6566 6628 6f72 6465 725b 305d  _lcoeff(order[0]
+00015b30: 293b 0a0a 2020 2020 2020 2020 6966 206c  );..        if l
+00015b40: 636f 6566 662e 6973 5f63 6f6e 7374 616e  coeff.is_constan
+00015b50: 7428 2920 7b0a 2020 2020 2020 2020 2020  t() {.          
+00015b60: 2020 2f2f 2074 6865 2066 6163 746f 7273    // the factors
+00015b70: 2073 686f 756c 6420 6265 2070 726f 7065   should be prope
+00015b80: 726c 7920 6e6f 726d 616c 697a 6564 0a20  rly normalized. 
+00015b90: 2020 2020 2020 2020 2020 206c 6574 2028             let (
+00015ba0: 6d75 7420 756e 692c 2064 656c 7461 2920  mut uni, delta) 
+00015bb0: 3d20 4d75 6c74 6976 6172 6961 7465 506f  = MultivariatePo
+00015bc0: 6c79 6e6f 6d69 616c 3a3a 6765 745f 756e  lynomial::get_un
+00015bd0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+00015be0: 5f61 6e64 5f64 656c 7461 7328 0a20 2020  _and_deltas(.   
+00015bf0: 2020 2020 2020 2020 2020 2020 2026 6661               &fa
+00015c00: 6374 6f72 735f 6666 2c0a 2020 2020 2020  ctors_ff,.      
+00015c10: 2020 2020 2020 2020 2020 6f72 6465 722c            order,
+00015c20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015c30: 2073 616d 706c 655f 706f 696e 7473 2c0a   sample_points,.
+00015c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015c50: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
+00015c60: 2020 206b 2c0a 2020 2020 2020 2020 2020     k,.          
+00015c70: 2020 293b 0a20 2020 2020 2020 2020 2020    );.           
+00015c80: 206c 6574 2068 203d 2066 662e 6d75 6c74   let h = ff.mult
+00015c90: 6976 6172 6961 7465 5f68 656e 7365 6c5f  ivariate_hensel_
+00015ca0: 6c69 6674 696e 6728 0a20 2020 2020 2020  lifting(.       
+00015cb0: 2020 2020 2020 2020 2026 6661 6374 6f72           &factor
+00015cc0: 735f 6666 2c0a 2020 2020 2020 2020 2020  s_ff,.          
+00015cd0: 2020 2020 2020 266d 7574 2075 6e69 2c0a        &mut uni,.
+00015ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015cf0: 2664 656c 7461 2c0a 2020 2020 2020 2020  &delta,.        
+00015d00: 2020 2020 2020 2020 7361 6d70 6c65 5f70          sample_p
+00015d10: 6f69 6e74 732c 0a20 2020 2020 2020 2020  oints,.         
+00015d20: 2020 2020 2020 204e 6f6e 652c 0a20 2020         None,.   
+00015d30: 2020 2020 2020 2020 2020 2020 206f 7264               ord
+00015d40: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
+00015d50: 2020 2020 312c 0a20 2020 2020 2020 2020      1,.         
+00015d60: 2020 2029 3b0a 0a20 2020 2020 2020 2020     );..         
+00015d70: 2020 2072 6574 7572 6e20 680a 2020 2020     return h.    
+00015d80: 2020 2020 2020 2020 2020 2020 2e69 6e74              .int
+00015d90: 6f5f 6974 6572 2829 0a20 2020 2020 2020  o_iter().       
+00015da0: 2020 2020 2020 2020 202e 6d61 7028 7c66           .map(|f
+00015db0: 7c20 662e 6d61 705f 636f 6566 6628 7c63  | f.map_coeff(|c
+00015dc0: 7c20 6d6f 6475 6c75 732e 746f 5f73 796d  | modulus.to_sym
+00015dd0: 6d65 7472 6963 5f69 6e74 6567 6572 2863  metric_integer(c
+00015de0: 292c 205a 2929 0a20 2020 2020 2020 2020  ), Z)).         
+00015df0: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+00015e00: 293b 0a20 2020 2020 2020 207d 0a0a 2020  );.        }..  
+00015e10: 2020 2020 2020 2f2f 2072 6570 6561 7420        // repeat 
+00015e20: 7468 6520 6c65 6164 696e 6720 636f 6566  the leading coef
+00015e30: 6669 6369 656e 7420 666f 7220 6576 6572  ficient for ever
+00015e40: 7920 6661 6374 6f72 2073 6f20 7468 6174  y factor so that
+00015e50: 2074 6865 206c 6561 6469 6e67 2063 6f65   the leading coe
+00015e60: 6666 6963 6965 6e74 2069 7320 6b6e 6f77  fficient is know
+00015e70: 6e0a 2020 2020 2020 2020 6c65 7420 7061  n.        let pa
+00015e80: 6464 6564 5f6c 636f 6566 6673 203d 2076  dded_lcoeffs = v
+00015e90: 6563 215b 6c63 6f65 6666 2e63 6c6f 6e65  ec![lcoeff.clone
+00015ea0: 2829 3b20 6661 6374 6f72 732e 6c65 6e28  (); factors.len(
+00015eb0: 295d 3b0a 0a20 2020 2020 2020 206c 6574  )];..        let
+00015ec0: 206d 7574 2073 656c 665f 6164 6a75 7374   mut self_adjust
+00015ed0: 6564 203d 2066 663b 0a20 2020 2020 2020  ed = ff;.       
+00015ee0: 2066 6f72 205f 2069 6e20 312e 2e66 6163   for _ in 1..fac
+00015ef0: 746f 7273 5f66 662e 6c65 6e28 2920 7b0a  tors_ff.len() {.
+00015f00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00015f10: 5f61 646a 7573 7465 6420 3d20 2673 656c  _adjusted = &sel
+00015f20: 665f 6164 6a75 7374 6564 202a 2026 6c63  f_adjusted * &lc
+00015f30: 6f65 6666 3b0a 2020 2020 2020 2020 7d0a  oeff;.        }.
+00015f40: 0a20 2020 2020 2020 202f 2f20 7365 7420  .        // set 
+00015f50: 7468 6520 7072 6f70 6572 206c 630a 2020  the proper lc.  
+00015f60: 2020 2020 2020 6c65 7420 6d75 7420 6c63        let mut lc
+00015f70: 5f76 6172 5f65 7661 6c20 3d20 6c63 6f65  _var_eval = lcoe
+00015f80: 6666 2e63 6c6f 6e65 2829 3b0a 2020 2020  ff.clone();.    
+00015f90: 2020 2020 666f 7220 2876 2c20 7029 2069      for (v, p) i
+00015fa0: 6e20 7361 6d70 6c65 5f70 6f69 6e74 7320  n sample_points 
+00015fb0: 7b0a 2020 2020 2020 2020 2020 2020 6966  {.            if
+00015fc0: 202a 7620 213d 206f 7264 6572 5b30 5d20   *v != order[0] 
+00015fd0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00015fe0: 2020 6c63 5f76 6172 5f65 7661 6c20 3d20    lc_var_eval = 
+00015ff0: 6c63 5f76 6172 5f65 7661 6c2e 7265 706c  lc_var_eval.repl
+00016000: 6163 6528 2a76 2c20 7029 3b0a 2020 2020  ace(*v, p);.    
+00016010: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00016020: 2020 7d0a 0a20 2020 2020 2020 206c 6574    }..        let
+00016030: 2061 646a 7573 7465 645f 6661 6374 6f72   adjusted_factor
+00016040: 733a 2056 6563 3c5f 3e20 3d20 6661 6374  s: Vec<_> = fact
+00016050: 6f72 735f 6666 0a20 2020 2020 2020 2020  ors_ff.         
+00016060: 2020 202e 696e 746f 5f69 7465 7228 290a     .into_iter().
+00016070: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
+00016080: 287c 667c 2066 2e6d 616b 655f 6d6f 6e69  (|f| f.make_moni
+00016090: 6328 2920 2a20 266c 635f 7661 725f 6576  c() * &lc_var_ev
+000160a0: 616c 290a 2020 2020 2020 2020 2020 2020  al).            
+000160b0: 2e63 6f6c 6c65 6374 2829 3b0a 0a20 2020  .collect();..   
+000160c0: 2020 2020 206c 6574 2028 6d75 7420 756e       let (mut un
+000160d0: 692c 2064 656c 7461 2920 3d20 4d75 6c74  i, delta) = Mult
+000160e0: 6976 6172 6961 7465 506f 6c79 6e6f 6d69  ivariatePolynomi
+000160f0: 616c 3a3a 6765 745f 756e 6976 6172 6961  al::get_univaria
+00016100: 7465 5f66 6163 746f 7273 5f61 6e64 5f64  te_factors_and_d
+00016110: 656c 7461 7328 0a20 2020 2020 2020 2020  eltas(.         
+00016120: 2020 2026 6164 6a75 7374 6564 5f66 6163     &adjusted_fac
+00016130: 746f 7273 2c0a 2020 2020 2020 2020 2020  tors,.          
+00016140: 2020 6f72 6465 722c 0a20 2020 2020 2020    order,.       
+00016150: 2020 2020 2073 616d 706c 655f 706f 696e       sample_poin
+00016160: 7473 2c0a 2020 2020 2020 2020 2020 2020  ts,.            
+00016170: 702c 0a20 2020 2020 2020 2020 2020 206b  p,.            k
+00016180: 2c0a 2020 2020 2020 2020 293b 0a20 2020  ,.        );.   
+00016190: 2020 2020 206c 6574 2068 203d 2073 656c       let h = sel
+000161a0: 665f 6164 6a75 7374 6564 2e6d 756c 7469  f_adjusted.multi
+000161b0: 7661 7269 6174 655f 6865 6e73 656c 5f6c  variate_hensel_l
+000161c0: 6966 7469 6e67 280a 2020 2020 2020 2020  ifting(.        
+000161d0: 2020 2020 2661 646a 7573 7465 645f 6661      &adjusted_fa
+000161e0: 6374 6f72 732c 0a20 2020 2020 2020 2020  ctors,.         
+000161f0: 2020 2026 6d75 7420 756e 692c 0a20 2020     &mut uni,.   
+00016200: 2020 2020 2020 2020 2026 6465 6c74 612c           &delta,
+00016210: 0a20 2020 2020 2020 2020 2020 2073 616d  .            sam
+00016220: 706c 655f 706f 696e 7473 2c0a 2020 2020  ple_points,.    
+00016230: 2020 2020 2020 2020 536f 6d65 2826 7061          Some(&pa
+00016240: 6464 6564 5f6c 636f 6566 6673 292c 0a20  dded_lcoeffs),. 
+00016250: 2020 2020 2020 2020 2020 206f 7264 6572             order
+00016260: 2c0a 2020 2020 2020 2020 2020 2020 312c  ,.            1,
+00016270: 0a20 2020 2020 2020 2029 3b0a 0a20 2020  .        );..   
+00016280: 2020 2020 2068 2e69 6e74 6f5f 6974 6572       h.into_iter
+00016290: 2829 0a20 2020 2020 2020 2020 2020 202e  ().            .
+000162a0: 6d61 7028 7c66 7c20 7b0a 2020 2020 2020  map(|f| {.      
+000162b0: 2020 2020 2020 2020 2020 6c65 7420 665f            let f_
+000162c0: 6920 3d20 662e 6d61 705f 636f 6566 6628  i = f.map_coeff(
+000162d0: 7c63 7c20 6d6f 6475 6c75 732e 746f 5f73  |c| modulus.to_s
+000162e0: 796d 6d65 7472 6963 5f69 6e74 6567 6572  ymmetric_integer
+000162f0: 2863 292c 205a 293b 0a20 2020 2020 2020  (c), Z);.       
+00016300: 2020 2020 2020 2020 206c 6574 2063 203d           let c =
+00016310: 2066 5f69 2e75 6e69 7661 7269 6174 655f   f_i.univariate_
+00016320: 636f 6e74 656e 7428 6f72 6465 725b 305d  content(order[0]
+00016330: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00016340: 2020 2066 5f69 202f 2026 630a 2020 2020     f_i / &c.    
+00016350: 2020 2020 2020 2020 7d29 0a20 2020 2020          }).     
+00016360: 2020 2020 2020 202e 636f 6c6c 6563 7428         .collect(
+00016370: 290a 2020 2020 7d0a 0a20 2020 2066 6e20  ).    }..    fn 
+00016380: 6669 6e64 5f73 616d 706c 6528 0a20 2020  find_sample(.   
+00016390: 2020 2020 2026 7365 6c66 2c0a 2020 2020       &self,.    
+000163a0: 2020 2020 6f72 6465 723a 2026 6d75 7420      order: &mut 
+000163b0: 5b75 7369 7a65 5d2c 0a20 2020 2020 2020  [usize],.       
+000163c0: 206d 7574 2063 6f65 6666 6963 6965 6e74   mut coefficient
+000163d0: 5f75 7070 6572 5f62 6f75 6e64 3a20 6936  _upper_bound: i6
+000163e0: 342c 0a20 2020 2020 2020 206d 6178 5f66  4,.        max_f
+000163f0: 6163 746f 7273 5f6e 756d 3a20 4f70 7469  actors_num: Opti
+00016400: 6f6e 3c75 7369 7a65 3e2c 0a20 2020 2029  on<usize>,.    )
+00016410: 202d 3e20 2856 6563 3c53 656c 663e 2c20   -> (Vec<Self>, 
+00016420: 5665 633c 2875 7369 7a65 2c20 496e 7465  Vec<(usize, Inte
+00016430: 6765 7229 3e2c 2069 3634 2c20 5365 6c66  ger)>, i64, Self
+00016440: 2920 7b0a 2020 2020 2020 2020 6465 6275  ) {.        debu
+00016450: 6721 2822 4669 6e64 2073 616d 706c 6520  g!("Find sample 
+00016460: 666f 7220 7b7d 2077 6974 6820 6f72 6465  for {} with orde
+00016470: 7220 7b3a 3f7d 222c 2073 656c 662c 206f  r {:?}", self, o
+00016480: 7264 6572 293b 0a0a 2020 2020 2020 2020  rder);..        
+00016490: 2f2f 2073 656c 6563 7420 6120 7375 6974  // select a suit
+000164a0: 6162 6c65 2065 7661 6c75 6174 696f 6e20  able evaluation 
+000164b0: 706f 696e 742c 2061 7320 736d 616c 6c20  point, as small 
+000164c0: 6173 2070 6f73 7369 626c 6520 6173 2074  as possible as t
+000164d0: 6f20 6e6f 7420 6368 616e 6765 2074 6865  o not change the
+000164e0: 2063 6f65 6666 6963 6965 6e74 2062 6f75   coefficient bou
+000164f0: 6e64 0a20 2020 2020 2020 206c 6574 206d  nd.        let m
+00016500: 7574 2063 7572 5f73 616d 706c 655f 706f  ut cur_sample_po
+00016510: 696e 7473 3a20 5665 633c 5f3e 203d 0a20  ints: Vec<_> =. 
+00016520: 2020 2020 2020 2020 2020 206f 7264 6572             order
+00016530: 5b31 2e2e 5d2e 6974 6572 2829 2e6d 6170  [1..].iter().map
+00016540: 287c 697c 2028 2a69 2c20 496e 7465 6765  (|i| (*i, Intege
+00016550: 723a 3a7a 6572 6f28 2929 292e 636f 6c6c  r::zero())).coll
+00016560: 6563 7428 293b 0a20 2020 2020 2020 206c  ect();.        l
+00016570: 6574 206d 7574 2063 7572 5f75 6e69 5f66  et mut cur_uni_f
+00016580: 3b0a 2020 2020 2020 2020 6c65 7420 6d75  ;.        let mu
+00016590: 7420 6375 725f 6269 765f 663b 0a20 2020  t cur_biv_f;.   
+000165a0: 2020 2020 206c 6574 206d 7574 2072 6e67       let mut rng
+000165b0: 203d 2074 6872 6561 645f 726e 6728 293b   = thread_rng();
+000165c0: 0a20 2020 2020 2020 206c 6574 2064 6567  .        let deg
+000165d0: 7265 6520 3d20 7365 6c66 2e64 6567 7265  ree = self.degre
+000165e0: 6528 6f72 6465 725b 305d 293b 0a20 2020  e(order[0]);.   
+000165f0: 2020 2020 206c 6574 206d 7574 2062 6976       let mut biv
+00016600: 6172 6961 7465 5f66 6163 746f 7273 3a20  ariate_factors: 
+00016610: 5665 633c 5f3e 3b0a 0a20 2020 2020 2020  Vec<_>;..       
+00016620: 206c 6574 2075 6e69 5f6c 636f 6566 6620   let uni_lcoeff 
+00016630: 3d20 7365 6c66 2e75 6e69 7661 7269 6174  = self.univariat
+00016640: 655f 6c63 6f65 6666 286f 7264 6572 5b30  e_lcoeff(order[0
+00016650: 5d29 3b0a 0a20 2020 2020 2020 206c 6574  ]);..        let
+00016660: 206d 7574 2063 6f6e 7465 6e74 5f66 6169   mut content_fai
+00016670: 6c5f 636f 756e 7420 3d20 303b 0a20 2020  l_count = 0;.   
+00016680: 2020 2020 2027 6e65 775f 7361 6d70 6c65       'new_sample
+00016690: 3a20 6c6f 6f70 207b 0a20 2020 2020 2020  : loop {.       
+000166a0: 2020 2020 2066 6f72 2073 2069 6e20 266d       for s in &m
+000166b0: 7574 2063 7572 5f73 616d 706c 655f 706f  ut cur_sample_po
+000166c0: 696e 7473 207b 0a20 2020 2020 2020 2020  ints {.         
+000166d0: 2020 2020 2020 2073 2e31 203d 2049 6e74         s.1 = Int
+000166e0: 6567 6572 3a3a 4e61 7475 7261 6c28 726e  eger::Natural(rn
+000166f0: 672e 6765 6e5f 7261 6e67 6528 302e 2e3d  g.gen_range(0..=
+00016700: 636f 6566 6669 6369 656e 745f 7570 7065  coefficient_uppe
+00016710: 725f 626f 756e 6429 293b 0a20 2020 2020  r_bound));.     
+00016720: 2020 2020 2020 2020 2020 2064 6562 7567             debug
+00016730: 2128 2253 616d 706c 6520 787b 7d20 7b7d  !("Sample x{} {}
+00016740: 222c 2073 2e30 2c20 732e 3129 3b0a 2020  ", s.0, s.1);.  
+00016750: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+00016760: 2020 2020 2020 2020 2063 7572 5f62 6976           cur_biv
+00016770: 5f66 203d 2073 656c 662e 636c 6f6e 6528  _f = self.clone(
+00016780: 293b 0a20 2020 2020 2020 2020 2020 2066  );.            f
+00016790: 6f72 2028 2876 2c20 7329 2c20 7265 6d5f  or ((v, s), rem_
+000167a0: 7661 7229 2069 6e20 6375 725f 7361 6d70  var) in cur_samp
+000167b0: 6c65 5f70 6f69 6e74 735b 312e 2e5d 2e69  le_points[1..].i
+000167c0: 7465 7228 292e 7a69 7028 266f 7264 6572  ter().zip(&order
+000167d0: 5b31 2e2e 5d29 2e72 6576 2829 207b 0a20  [1..]).rev() {. 
+000167e0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000167f0: 7572 5f62 6976 5f66 203d 2063 7572 5f62  ur_biv_f = cur_b
+00016800: 6976 5f66 2e72 6570 6c61 6365 282a 762c  iv_f.replace(*v,
+00016810: 2073 293b 0a20 2020 2020 2020 2020 2020   s);.           
+00016820: 2020 2020 2069 6620 6375 725f 6269 765f       if cur_biv_
+00016830: 662e 6465 6772 6565 282a 7265 6d5f 7661  f.degree(*rem_va
+00016840: 7229 2021 3d20 7365 6c66 2e64 6567 7265  r) != self.degre
+00016850: 6528 2a72 656d 5f76 6172 2920 7b0a 2020  e(*rem_var) {.  
+00016860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016870: 2020 636f 6566 6669 6369 656e 745f 7570    coefficient_up
+00016880: 7065 725f 626f 756e 6420 2b3d 2031 3b0a  per_bound += 1;.
+00016890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000168a0: 2020 2020 636f 6e74 696e 7565 2027 6e65      continue 'ne
+000168b0: 775f 7361 6d70 6c65 3b0a 2020 2020 2020  w_sample;.      
+000168c0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+000168d0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+000168e0: 2020 2020 2020 202f 2f20 7265 7175 6972         // requir
+000168f0: 656d 656e 7420 666f 7220 6c65 6164 696e  ement for leadin
+00016900: 6720 636f 6566 6669 6369 656e 7420 7072  g coefficient pr
+00016910: 6563 6f6d 7075 7461 7469 6f6e 0a20 2020  ecomputation.   
+00016920: 2020 2020 2020 2020 2069 6620 6375 725f           if cur_
+00016930: 6269 765f 662e 756e 6976 6172 6961 7465  biv_f.univariate
+00016940: 5f6c 636f 6566 6628 6f72 6465 725b 305d  _lcoeff(order[0]
+00016950: 292e 6465 6772 6565 286f 7264 6572 5b31  ).degree(order[1
+00016960: 5d29 2021 3d20 756e 695f 6c63 6f65 6666  ]) != uni_lcoeff
+00016970: 2e64 6567 7265 6528 6f72 6465 725b 315d  .degree(order[1]
+00016980: 290a 2020 2020 2020 2020 2020 2020 7b0a  ).            {.
+00016990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000169a0: 6465 6275 6721 280a 2020 2020 2020 2020  debug!(.        
+000169b0: 2020 2020 2020 2020 2020 2020 2244 6567              "Deg
+000169c0: 7265 6520 6f66 2078 7b7d 2069 6e20 6c65  ree of x{} in le
+000169d0: 6164 696e 6720 636f 6566 6669 6369 656e  ading coefficien
+000169e0: 7420 6f66 2062 6976 6172 6961 7465 2069  t of bivariate i
+000169f0: 6d61 6765 2069 7320 7772 6f6e 6722 2c0a  mage is wrong",.
+00016a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016a10: 2020 2020 6f72 6465 725b 315d 0a20 2020      order[1].   
+00016a20: 2020 2020 2020 2020 2020 2020 2029 3b0a               );.
+00016a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016a40: 636f 6566 6669 6369 656e 745f 7570 7065  coefficient_uppe
+00016a50: 725f 626f 756e 6420 2b3d 2031 3b0a 2020  r_bound += 1;.  
+00016a60: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00016a70: 6e74 696e 7565 2027 6e65 775f 7361 6d70  ntinue 'new_samp
+00016a80: 6c65 3b0a 2020 2020 2020 2020 2020 2020  le;.            
+00016a90: 7d0a 0a20 2020 2020 2020 2020 2020 206c  }..            l
+00016aa0: 6574 2062 6976 5f64 6620 3d20 6375 725f  et biv_df = cur_
+00016ab0: 6269 765f 662e 6465 7269 7661 7469 7665  biv_f.derivative
+00016ac0: 286f 7264 6572 5b30 5d29 3b0a 0a20 2020  (order[0]);..   
+00016ad0: 2020 2020 2020 2020 2063 7572 5f75 6e69           cur_uni
+00016ae0: 5f66 203d 2063 7572 5f62 6976 5f66 2e72  _f = cur_biv_f.r
+00016af0: 6570 6c61 6365 2863 7572 5f73 616d 706c  eplace(cur_sampl
+00016b00: 655f 706f 696e 7473 5b30 5d2e 302c 2026  e_points[0].0, &
+00016b10: 6375 725f 7361 6d70 6c65 5f70 6f69 6e74  cur_sample_point
+00016b20: 735b 305d 2e31 293b 0a20 2020 2020 2020  s[0].1);.       
+00016b30: 2020 2020 206c 6574 2075 6e69 5f64 6620       let uni_df 
+00016b40: 3d20 6375 725f 756e 695f 662e 6465 7269  = cur_uni_f.deri
+00016b50: 7661 7469 7665 286f 7264 6572 5b30 5d29  vative(order[0])
+00016b60: 3b0a 0a20 2020 2020 2020 2020 2020 2069  ;..            i
+00016b70: 6620 6465 6772 6565 203d 3d20 6375 725f  f degree == cur_
+00016b80: 6269 765f 662e 6465 6772 6565 286f 7264  biv_f.degree(ord
+00016b90: 6572 5b30 5d29 0a20 2020 2020 2020 2020  er[0]).         
+00016ba0: 2020 2020 2020 2026 2620 6465 6772 6565         && degree
+00016bb0: 203d 3d20 6375 725f 756e 695f 662e 6465   == cur_uni_f.de
+00016bc0: 6772 6565 286f 7264 6572 5b30 5d29 0a20  gree(order[0]). 
+00016bd0: 2020 2020 2020 2020 2020 2020 2020 2026                 &
+00016be0: 2620 6375 725f 6269 765f 662e 6763 6428  & cur_biv_f.gcd(
+00016bf0: 2662 6976 5f64 6629 2e69 735f 636f 6e73  &biv_df).is_cons
+00016c00: 7461 6e74 2829 0a20 2020 2020 2020 2020  tant().         
+00016c10: 2020 2020 2020 2026 2620 6375 725f 756e         && cur_un
+00016c20: 695f 662e 6763 6428 2675 6e69 5f64 6629  i_f.gcd(&uni_df)
+00016c30: 2e69 735f 636f 6e73 7461 6e74 2829 0a20  .is_constant(). 
+00016c40: 2020 2020 2020 2020 2020 207b 0a20 2020             {.   
+00016c50: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00016c60: 2163 7572 5f62 6976 5f66 2e75 6e69 7661  !cur_biv_f.univa
+00016c70: 7269 6174 655f 636f 6e74 656e 7428 6f72  riate_content(or
+00016c80: 6465 725b 305d 292e 6973 5f6f 6e65 2829  der[0]).is_one()
+00016c90: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00016ca0: 2020 2020 2020 2063 6f6e 7465 6e74 5f66         content_f
+00016cb0: 6169 6c5f 636f 756e 7420 2b3d 2031 3b0a  ail_count += 1;.
+00016cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016cd0: 2020 2020 636f 6566 6669 6369 656e 745f      coefficient_
+00016ce0: 7570 7065 725f 626f 756e 6420 2b3d 2031  upper_bound += 1
+00016cf0: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
+00016d00: 2020 2020 2020 2064 6562 7567 2128 2255         debug!("U
+00016d10: 6e69 7661 7269 6174 6520 636f 6e74 656e  nivariate conten
+00016d20: 7420 6973 206e 6f74 206f 6e65 2229 3b0a  t is not one");.
+00016d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016d40: 2020 2020 6966 2063 6f6e 7465 6e74 5f66      if content_f
+00016d50: 6169 6c5f 636f 756e 7420 3d3d 2034 207b  ail_count == 4 {
+00016d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016d70: 2020 2020 2020 2020 202f 2f20 6974 2069           // it i
+00016d80: 7320 6c69 6b65 6c79 2074 6861 7420 7765  s likely that we
+00016d90: 2077 696c 6c20 616c 7761 7973 2066 696e   will always fin
+00016da0: 6420 636f 6e74 656e 7420 666f 7220 7468  d content for th
+00016db0: 6973 2076 6172 6961 626c 6520 6f72 6465  is variable orde
+00016dc0: 7269 6e67 2c20 736f 2063 6861 6e67 6520  ring, so change 
+00016dd0: 7468 650a 2020 2020 2020 2020 2020 2020  the.            
+00016de0: 2020 2020 2020 2020 2020 2020 2f2f 2073              // s
+00016df0: 6563 6f6e 6420 7661 7269 6162 6c65 0a20  econd variable. 
+00016e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016e10: 2020 2020 2020 202f 2f20 544f 444f 3a20         // TODO: 
+00016e20: 6973 2074 6869 7320 6775 6172 616e 7465  is this guarante
+00016e30: 6564 2074 6f20 776f 726b 206f 7220 7368  ed to work or sh
+00016e40: 6f75 6c64 2077 6520 616c 736f 2063 6861  ould we also cha
+00016e50: 6e67 6520 7468 6520 6669 7273 7420 7661  nge the first va
+00016e60: 7269 6162 6c65 3f0a 2020 2020 2020 2020  riable?.        
+00016e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016e80: 6c65 7420 7365 635f 7661 7220 3d20 6f72  let sec_var = or
+00016e90: 6465 725b 315d 3b0a 2020 2020 2020 2020  der[1];.        
+00016ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016eb0: 6f72 6465 722e 636f 7079 5f77 6974 6869  order.copy_withi
+00016ec0: 6e28 322e 2e6f 7264 6572 2e6c 656e 2829  n(2..order.len()
+00016ed0: 2c20 3129 3b0a 2020 2020 2020 2020 2020  , 1);.          
+00016ee0: 2020 2020 2020 2020 2020 2020 2020 6f72                or
+00016ef0: 6465 725b 6f72 6465 722e 6c65 6e28 2920  der[order.len() 
+00016f00: 2d20 315d 203d 2073 6563 5f76 6172 3b0a  - 1] = sec_var;.
+00016f10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016f20: 2020 2020 2020 2020 2066 6f72 2028 2876           for ((v
+00016f30: 732c 205f 292c 2076 2920 696e 2063 7572  s, _), v) in cur
+00016f40: 5f73 616d 706c 655f 706f 696e 7473 2e69  _sample_points.i
+00016f50: 7465 725f 6d75 7428 292e 7a69 7028 266f  ter_mut().zip(&o
+00016f60: 7264 6572 5b31 2e2e 5d29 207b 0a20 2020  rder[1..]) {.   
+00016f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f80: 2020 2020 2020 2020 202a 7673 203d 202a           *vs = *
+00016f90: 763b 0a20 2020 2020 2020 2020 2020 2020  v;.             
+00016fa0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+00016fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016fc0: 2020 2020 2020 6465 6275 6721 2822 4368        debug!("Ch
+00016fd0: 616e 6765 6420 7468 6520 7365 636f 6e64  anged the second
+00016fe0: 2076 6172 6961 626c 6520 746f 207b 7d22   variable to {}"
+00016ff0: 2c20 6f72 6465 725b 315d 293b 0a20 2020  , order[1]);.   
 00017000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017010: 6f72 6465 725b 6f72 6465 722e 6c65 6e28  order[order.len(
-00017020: 2920 2d20 315d 203d 2073 6563 5f76 6172  ) - 1] = sec_var
-00017030: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
-00017040: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-00017050: 2876 732c 205f 292c 2076 2920 696e 2063  (vs, _), v) in c
-00017060: 7572 5f73 616d 706c 655f 706f 696e 7473  ur_sample_points
-00017070: 2e69 7465 725f 6d75 7428 292e 7a69 7028  .iter_mut().zip(
-00017080: 266f 7264 6572 5b31 2e2e 5d29 207b 0a20  &order[1..]) {. 
-00017090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000170a0: 2020 2020 2020 2020 2020 202a 7673 203d             *vs =
-000170b0: 202a 763b 0a20 2020 2020 2020 2020 2020   *v;.           
-000170c0: 2020 2020 2020 2020 2020 2020 207d 0a0a               }..
-000170d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000170e0: 2020 2020 2020 2020 6465 6275 6721 2822          debug!("
-000170f0: 4368 616e 6765 6420 7468 6520 7365 636f  Changed the seco
-00017100: 6e64 2076 6172 6961 626c 6520 746f 207b  nd variable to {
-00017110: 7d22 2c20 6f72 6465 725b 315d 293b 0a20  }", order[1]);. 
-00017120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017130: 2020 2020 2020 2063 6f6e 7465 6e74 5f66         content_f
-00017140: 6169 6c5f 636f 756e 7420 3d20 303b 0a20  ail_count = 0;. 
-00017150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017160: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00017170: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00017180: 7565 3b0a 2020 2020 2020 2020 2020 2020  ue;.            
-00017190: 2020 2020 7d0a 0a20 2020 2020 2020 2020      }..         
-000171a0: 2020 2020 2020 2062 6976 6172 6961 7465         bivariate
-000171b0: 5f66 6163 746f 7273 203d 2063 7572 5f62  _factors = cur_b
-000171c0: 6976 5f66 2e66 6163 746f 7228 292e 696e  iv_f.factor().in
-000171d0: 746f 5f69 7465 7228 292e 6d61 7028 7c66  to_iter().map(|f
-000171e0: 7c20 662e 3029 2e63 6f6c 6c65 6374 2829  | f.0).collect()
-000171f0: 3b0a 0a20 2020 2020 2020 2020 2020 2020  ;..             
-00017200: 2020 2069 6620 6269 7661 7269 6174 655f     if bivariate_
-00017210: 6661 6374 6f72 732e 6c65 6e28 2920 3c3d  factors.len() <=
-00017220: 206d 6178 5f66 6163 746f 7273 5f6e 756d   max_factors_num
-00017230: 2e75 6e77 7261 705f 6f72 2862 6976 6172  .unwrap_or(bivar
-00017240: 6961 7465 5f66 6163 746f 7273 2e6c 656e  iate_factors.len
-00017250: 2829 2920 7b0a 2020 2020 2020 2020 2020  ()) {.          
-00017260: 2020 2020 2020 2020 2020 6272 6561 6b3b            break;
-00017270: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00017280: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
-00017290: 2020 2064 6562 7567 2128 0a20 2020 2020     debug!(.     
-000172a0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000172b0: 4e75 6d62 6572 206f 6620 6661 6374 6f72  Number of factor
-000172c0: 7320 6973 2074 6f6f 206c 6172 6765 3a20  s is too large: 
-000172d0: 7b7d 2076 7320 7b7d 222c 0a20 2020 2020  {} vs {}",.     
-000172e0: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-000172f0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00017300: 2e6c 656e 2829 2c0a 2020 2020 2020 2020  .len(),.        
-00017310: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
-00017320: 6661 6374 6f72 735f 6e75 6d2e 756e 7772  factors_num.unwr
-00017330: 6170 5f6f 7228 6269 7661 7269 6174 655f  ap_or(bivariate_
-00017340: 6661 6374 6f72 732e 6c65 6e28 2929 0a20  factors.len()). 
-00017350: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00017360: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
-00017370: 0a20 2020 2020 2020 2020 2020 2063 6f65  .            coe
-00017380: 6666 6963 6965 6e74 5f75 7070 6572 5f62  fficient_upper_b
-00017390: 6f75 6e64 202b 3d20 313b 0a20 2020 2020  ound += 1;.     
-000173a0: 2020 2020 2020 2064 6562 7567 2128 2247         debug!("G
-000173b0: 726f 7769 6e67 2062 6f75 6e64 207b 7d22  rowing bound {}"
-000173c0: 2c20 636f 6566 6669 6369 656e 745f 7570  , coefficient_up
-000173d0: 7065 725f 626f 756e 6429 3b0a 2020 2020  per_bound);.    
-000173e0: 2020 2020 7d0a 0a20 2020 2020 2020 2028      }..        (
-000173f0: 0a20 2020 2020 2020 2020 2020 2062 6976  .            biv
-00017400: 6172 6961 7465 5f66 6163 746f 7273 2c0a  ariate_factors,.
-00017410: 2020 2020 2020 2020 2020 2020 6375 725f              cur_
-00017420: 7361 6d70 6c65 5f70 6f69 6e74 732c 0a20  sample_points,. 
-00017430: 2020 2020 2020 2020 2020 2063 6f65 6666             coeff
-00017440: 6963 6965 6e74 5f75 7070 6572 5f62 6f75  icient_upper_bou
-00017450: 6e64 2c0a 2020 2020 2020 2020 2020 2020  nd,.            
-00017460: 6375 725f 756e 695f 662c 0a20 2020 2020  cur_uni_f,.     
-00017470: 2020 2029 0a20 2020 207d 0a0a 2020 2020     ).    }..    
-00017480: 2f2f 2f20 5065 7266 6f72 6d20 6d75 6c74  /// Perform mult
-00017490: 6976 6172 6961 7465 2066 6163 746f 7269  ivariate factori
-000174a0: 7a61 7469 6f6e 206f 6e20 6120 7371 7561  zation on a squa
-000174b0: 7265 2d66 7265 6520 706f 6c79 6e6f 6d69  re-free polynomi
-000174c0: 616c 2e0a 2020 2020 666e 206d 756c 7469  al..    fn multi
-000174d0: 7661 7269 6174 655f 6661 6374 6f72 697a  variate_factoriz
-000174e0: 6174 696f 6e28 0a20 2020 2020 2020 2026  ation(.        &
-000174f0: 7365 6c66 2c0a 2020 2020 2020 2020 6f72  self,.        or
-00017500: 6465 723a 2026 6d75 7420 5b75 7369 7a65  der: &mut [usize
-00017510: 5d2c 0a20 2020 2020 2020 206d 7574 2063  ],.        mut c
-00017520: 6f65 6666 6963 6965 6e74 5f75 7070 6572  oefficient_upper
-00017530: 5f62 6f75 6e64 3a20 6936 342c 0a20 2020  _bound: i64,.   
-00017540: 2020 2020 206d 7574 206d 6178 5f62 6976       mut max_biv
-00017550: 6172 6961 7465 5f66 6163 746f 7273 3a20  ariate_factors: 
-00017560: 4f70 7469 6f6e 3c75 7369 7a65 3e2c 0a20  Option<usize>,. 
-00017570: 2020 2029 202d 3e20 5665 633c 5365 6c66     ) -> Vec<Self
-00017580: 3e20 7b0a 2020 2020 2020 2020 6966 206c  > {.        if l
-00017590: 6574 2053 6f6d 6528 6d29 203d 206d 6178  et Some(m) = max
-000175a0: 5f62 6976 6172 6961 7465 5f66 6163 746f  _bivariate_facto
-000175b0: 7273 207b 0a20 2020 2020 2020 2020 2020  rs {.           
-000175c0: 2069 6620 6d20 3d3d 2031 207b 0a20 2020   if m == 1 {.   
-000175d0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-000175e0: 7572 6e20 7665 6321 5b73 656c 662e 636c  urn vec![self.cl
-000175f0: 6f6e 6528 295d 3b0a 2020 2020 2020 2020  one()];.        
-00017600: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
-00017610: 0a20 2020 2020 2020 202f 2f20 7472 7920  .        // try 
-00017620: 6d75 6c74 6970 6c65 2074 696d 6573 2074  multiple times t
-00017630: 6f20 6669 6e64 2074 6865 2063 6f72 7265  o find the corre
-00017640: 6374 206e 756d 6265 7220 6f66 2062 6976  ct number of biv
-00017650: 6172 6961 7465 2066 6163 746f 7273 0a20  ariate factors. 
-00017660: 2020 2020 2020 202f 2f20 6163 6369 6465         // accide
-00017670: 6e74 616c 6c79 2066 696e 6469 6e67 2061  ntally finding a
-00017680: 206c 6172 6765 7220 6e75 6d62 6572 206f   larger number o
-00017690: 6620 6269 7661 7269 6174 6520 6661 6374  f bivariate fact
-000176a0: 6f72 7320 7769 6c6c 2063 6175 7365 0a20  ors will cause. 
-000176b0: 2020 2020 2020 202f 2f20 6120 7665 7279         // a very
-000176c0: 2073 6c6f 7720 4865 6e73 656c 206c 6966   slow Hensel lif
-000176d0: 742c 2061 7320 7665 7279 2064 656e 7365  t, as very dense
-000176e0: 2070 6f6c 796e 6f6d 6961 6c73 2077 696c   polynomials wil
-000176f0: 6c20 6265 2063 6f6e 7374 7275 6374 6564  l be constructed
-00017700: 0a20 2020 2020 2020 2069 6620 6d61 785f  .        if max_
+00017010: 2020 2020 2063 6f6e 7465 6e74 5f66 6169       content_fai
+00017020: 6c5f 636f 756e 7420 3d20 303b 0a20 2020  l_count = 0;.   
+00017030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017040: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
+00017050: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+00017060: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00017070: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
+00017080: 2020 2020 2062 6976 6172 6961 7465 5f66       bivariate_f
+00017090: 6163 746f 7273 203d 2063 7572 5f62 6976  actors = cur_biv
+000170a0: 5f66 2e66 6163 746f 7228 292e 696e 746f  _f.factor().into
+000170b0: 5f69 7465 7228 292e 6d61 7028 7c66 7c20  _iter().map(|f| 
+000170c0: 662e 3029 2e63 6f6c 6c65 6374 2829 3b0a  f.0).collect();.
+000170d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000170e0: 2069 6620 6269 7661 7269 6174 655f 6661   if bivariate_fa
+000170f0: 6374 6f72 732e 6c65 6e28 2920 3c3d 206d  ctors.len() <= m
+00017100: 6178 5f66 6163 746f 7273 5f6e 756d 2e75  ax_factors_num.u
+00017110: 6e77 7261 705f 6f72 2862 6976 6172 6961  nwrap_or(bivaria
+00017120: 7465 5f66 6163 746f 7273 2e6c 656e 2829  te_factors.len()
+00017130: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00017140: 2020 2020 2020 2020 6272 6561 6b3b 0a20          break;. 
+00017150: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00017160: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00017170: 2064 6562 7567 2128 0a20 2020 2020 2020   debug!(.       
+00017180: 2020 2020 2020 2020 2020 2020 2022 4e75               "Nu
+00017190: 6d62 6572 206f 6620 6661 6374 6f72 7320  mber of factors 
+000171a0: 6973 2074 6f6f 206c 6172 6765 3a20 7b7d  is too large: {}
+000171b0: 2076 7320 7b7d 222c 0a20 2020 2020 2020   vs {}",.       
+000171c0: 2020 2020 2020 2020 2020 2020 2062 6976               biv
+000171d0: 6172 6961 7465 5f66 6163 746f 7273 2e6c  ariate_factors.l
+000171e0: 656e 2829 2c0a 2020 2020 2020 2020 2020  en(),.          
+000171f0: 2020 2020 2020 2020 2020 6d61 785f 6661            max_fa
+00017200: 6374 6f72 735f 6e75 6d2e 756e 7772 6170  ctors_num.unwrap
+00017210: 5f6f 7228 6269 7661 7269 6174 655f 6661  _or(bivariate_fa
+00017220: 6374 6f72 732e 6c65 6e28 2929 0a20 2020  ctors.len()).   
+00017230: 2020 2020 2020 2020 2020 2020 2029 3b0a               );.
+00017240: 2020 2020 2020 2020 2020 2020 7d0a 0a20              }.. 
+00017250: 2020 2020 2020 2020 2020 2063 6f65 6666             coeff
+00017260: 6963 6965 6e74 5f75 7070 6572 5f62 6f75  icient_upper_bou
+00017270: 6e64 202b 3d20 313b 0a20 2020 2020 2020  nd += 1;.       
+00017280: 2020 2020 2064 6562 7567 2128 2247 726f       debug!("Gro
+00017290: 7769 6e67 2062 6f75 6e64 207b 7d22 2c20  wing bound {}", 
+000172a0: 636f 6566 6669 6369 656e 745f 7570 7065  coefficient_uppe
+000172b0: 725f 626f 756e 6429 3b0a 2020 2020 2020  r_bound);.      
+000172c0: 2020 7d0a 0a20 2020 2020 2020 2028 0a20    }..        (. 
+000172d0: 2020 2020 2020 2020 2020 2062 6976 6172             bivar
+000172e0: 6961 7465 5f66 6163 746f 7273 2c0a 2020  iate_factors,.  
+000172f0: 2020 2020 2020 2020 2020 6375 725f 7361            cur_sa
+00017300: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
+00017310: 2020 2020 2020 2020 2063 6f65 6666 6963           coeffic
+00017320: 6965 6e74 5f75 7070 6572 5f62 6f75 6e64  ient_upper_bound
+00017330: 2c0a 2020 2020 2020 2020 2020 2020 6375  ,.            cu
+00017340: 725f 756e 695f 662c 0a20 2020 2020 2020  r_uni_f,.       
+00017350: 2029 0a20 2020 207d 0a0a 2020 2020 2f2f   ).    }..    //
+00017360: 2f20 5065 7266 6f72 6d20 6d75 6c74 6976  / Perform multiv
+00017370: 6172 6961 7465 2066 6163 746f 7269 7a61  ariate factoriza
+00017380: 7469 6f6e 206f 6e20 6120 7371 7561 7265  tion on a square
+00017390: 2d66 7265 6520 706f 6c79 6e6f 6d69 616c  -free polynomial
+000173a0: 2e0a 2020 2020 666e 206d 756c 7469 7661  ..    fn multiva
+000173b0: 7269 6174 655f 6661 6374 6f72 697a 6174  riate_factorizat
+000173c0: 696f 6e28 0a20 2020 2020 2020 2026 7365  ion(.        &se
+000173d0: 6c66 2c0a 2020 2020 2020 2020 6f72 6465  lf,.        orde
+000173e0: 723a 2026 6d75 7420 5b75 7369 7a65 5d2c  r: &mut [usize],
+000173f0: 0a20 2020 2020 2020 206d 7574 2063 6f65  .        mut coe
+00017400: 6666 6963 6965 6e74 5f75 7070 6572 5f62  fficient_upper_b
+00017410: 6f75 6e64 3a20 6936 342c 0a20 2020 2020  ound: i64,.     
+00017420: 2020 206d 7574 206d 6178 5f62 6976 6172     mut max_bivar
+00017430: 6961 7465 5f66 6163 746f 7273 3a20 4f70  iate_factors: Op
+00017440: 7469 6f6e 3c75 7369 7a65 3e2c 0a20 2020  tion<usize>,.   
+00017450: 2029 202d 3e20 5665 633c 5365 6c66 3e20   ) -> Vec<Self> 
+00017460: 7b0a 2020 2020 2020 2020 6966 206c 6574  {.        if let
+00017470: 2053 6f6d 6528 6d29 203d 206d 6178 5f62   Some(m) = max_b
+00017480: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+00017490: 207b 0a20 2020 2020 2020 2020 2020 2069   {.            i
+000174a0: 6620 6d20 3d3d 2031 207b 0a20 2020 2020  f m == 1 {.     
+000174b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000174c0: 6e20 7665 6321 5b73 656c 662e 636c 6f6e  n vec![self.clon
+000174d0: 6528 295d 3b0a 2020 2020 2020 2020 2020  e()];.          
+000174e0: 2020 7d0a 2020 2020 2020 2020 7d0a 0a20    }.        }.. 
+000174f0: 2020 2020 2020 202f 2f20 7472 7920 6d75         // try mu
+00017500: 6c74 6970 6c65 2074 696d 6573 2074 6f20  ltiple times to 
+00017510: 6669 6e64 2074 6865 2063 6f72 7265 6374  find the correct
+00017520: 206e 756d 6265 7220 6f66 2062 6976 6172   number of bivar
+00017530: 6961 7465 2066 6163 746f 7273 0a20 2020  iate factors.   
+00017540: 2020 2020 202f 2f20 6163 6369 6465 6e74       // accident
+00017550: 616c 6c79 2066 696e 6469 6e67 2061 206c  ally finding a l
+00017560: 6172 6765 7220 6e75 6d62 6572 206f 6620  arger number of 
+00017570: 6269 7661 7269 6174 6520 6661 6374 6f72  bivariate factor
+00017580: 7320 7769 6c6c 2063 6175 7365 0a20 2020  s will cause.   
+00017590: 2020 2020 202f 2f20 6120 7665 7279 2073       // a very s
+000175a0: 6c6f 7720 4865 6e73 656c 206c 6966 742c  low Hensel lift,
+000175b0: 2061 7320 7665 7279 2064 656e 7365 2070   as very dense p
+000175c0: 6f6c 796e 6f6d 6961 6c73 2077 696c 6c20  olynomials will 
+000175d0: 6265 2063 6f6e 7374 7275 6374 6564 0a20  be constructed. 
+000175e0: 2020 2020 2020 2069 6620 6d61 785f 6269         if max_bi
+000175f0: 7661 7269 6174 655f 6661 6374 6f72 732e  variate_factors.
+00017600: 6973 5f6e 6f6e 6528 2920 7b0a 2020 2020  is_none() {.    
+00017610: 2020 2020 2020 2020 666f 7220 5f20 696e          for _ in
+00017620: 2030 2e2e 3320 7b0a 2020 2020 2020 2020   0..3 {.        
+00017630: 2020 2020 2020 2020 2f2f 2074 7279 206c          // try l
+00017640: 6172 6765 2073 616d 706c 6520 706f 696e  arge sample poin
+00017650: 7473 2074 6f20 6465 6372 6561 7365 2074  ts to decrease t
+00017660: 6865 206f 6464 7320 6f66 2073 7570 6572  he odds of super
+00017670: 666c 756f 7573 2073 616d 706c 6573 0a20  fluous samples. 
+00017680: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00017690: 6574 2028 6269 7661 7269 6174 655f 6661  et (bivariate_fa
+000176a0: 6374 6f72 732c 205f 2c20 5f2c 205f 2920  ctors, _, _, _) 
+000176b0: 3d0a 2020 2020 2020 2020 2020 2020 2020  =.              
+000176c0: 2020 2020 2020 7365 6c66 2e66 696e 645f        self.find_
+000176d0: 7361 6d70 6c65 286f 7264 6572 2c20 3130  sample(order, 10
+000176e0: 3030 2c20 6d61 785f 6269 7661 7269 6174  00, max_bivariat
+000176f0: 655f 6661 6374 6f72 7329 3b0a 0a20 2020  e_factors);..   
+00017700: 2020 2020 2020 2020 2020 2020 2069 6620               if 
 00017710: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00017720: 732e 6973 5f6e 6f6e 6528 2920 7b0a 2020  s.is_none() {.  
-00017730: 2020 2020 2020 2020 2020 666f 7220 5f20            for _ 
-00017740: 696e 2030 2e2e 3320 7b0a 2020 2020 2020  in 0..3 {.      
-00017750: 2020 2020 2020 2020 2020 2f2f 2074 7279            // try
-00017760: 206c 6172 6765 2073 616d 706c 6520 706f   large sample po
-00017770: 696e 7473 2074 6f20 6465 6372 6561 7365  ints to decrease
-00017780: 2074 6865 206f 6464 7320 6f66 2073 7570   the odds of sup
-00017790: 6572 666c 756f 7573 2073 616d 706c 6573  erfluous samples
-000177a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000177b0: 206c 6574 2028 6269 7661 7269 6174 655f   let (bivariate_
-000177c0: 6661 6374 6f72 732c 205f 2c20 5f2c 205f  factors, _, _, _
-000177d0: 2920 3d0a 2020 2020 2020 2020 2020 2020  ) =.            
-000177e0: 2020 2020 2020 2020 7365 6c66 2e66 696e          self.fin
-000177f0: 645f 7361 6d70 6c65 286f 7264 6572 2c20  d_sample(order, 
-00017800: 3130 3030 2c20 6d61 785f 6269 7661 7269  1000, max_bivari
-00017810: 6174 655f 6661 6374 6f72 7329 3b0a 0a20  ate_factors);.. 
-00017820: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00017830: 6620 6269 7661 7269 6174 655f 6661 6374  f bivariate_fact
-00017840: 6f72 732e 6c65 6e28 2920 3d3d 2031 207b  ors.len() == 1 {
-00017850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00017860: 2020 2020 202f 2f20 7468 6520 706f 6c79       // the poly
-00017870: 6e6f 6d69 616c 2069 7320 6972 7265 6475  nomial is irredu
-00017880: 6369 626c 650a 2020 2020 2020 2020 2020  cible.          
-00017890: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000178a0: 2076 6563 215b 7365 6c66 2e63 6c6f 6e65   vec![self.clone
-000178b0: 2829 5d3b 0a20 2020 2020 2020 2020 2020  ()];.           
-000178c0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-000178d0: 2020 2020 2020 2020 6966 206c 6574 2053          if let S
-000178e0: 6f6d 6528 6d61 7829 203d 206d 6178 5f62  ome(max) = max_b
-000178f0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00017900: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00017910: 2020 2020 2020 2069 6620 6269 7661 7269         if bivari
-00017920: 6174 655f 6661 6374 6f72 732e 6c65 6e28  ate_factors.len(
-00017930: 2920 3c20 6d61 7820 7b0a 2020 2020 2020  ) < max {.      
-00017940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017950: 2020 6465 6275 6721 2822 5570 6461 7469    debug!("Updati
-00017960: 6e67 2062 6976 6172 6961 7465 2062 6f75  ng bivariate bou
-00017970: 6e64 2074 6f20 7b7d 222c 2062 6976 6172  nd to {}", bivar
-00017980: 6961 7465 5f66 6163 746f 7273 2e6c 656e  iate_factors.len
-00017990: 2829 293b 0a20 2020 2020 2020 2020 2020  ());.           
-000179a0: 2020 2020 2020 2020 2020 2020 206d 6178               max
-000179b0: 5f62 6976 6172 6961 7465 5f66 6163 746f  _bivariate_facto
-000179c0: 7273 203d 2053 6f6d 6528 6269 7661 7269  rs = Some(bivari
-000179d0: 6174 655f 6661 6374 6f72 732e 6c65 6e28  ate_factors.len(
-000179e0: 2929 3b0a 2020 2020 2020 2020 2020 2020  ));.            
-000179f0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00017a00: 2020 2020 2020 2020 2020 7d20 656c 7365            } else
-00017a10: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00017a20: 2020 2020 2020 2064 6562 7567 2128 2255         debug!("U
-00017a30: 7064 6174 696e 6720 6269 7661 7269 6174  pdating bivariat
-00017a40: 6520 626f 756e 6420 746f 207b 7d22 2c20  e bound to {}", 
-00017a50: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
-00017a60: 732e 6c65 6e28 2929 3b0a 2020 2020 2020  s.len());.      
-00017a70: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
-00017a80: 785f 6269 7661 7269 6174 655f 6661 6374  x_bivariate_fact
-00017a90: 6f72 7320 3d20 536f 6d65 2862 6976 6172  ors = Some(bivar
-00017aa0: 6961 7465 5f66 6163 746f 7273 2e6c 656e  iate_factors.len
-00017ab0: 2829 293b 0a20 2020 2020 2020 2020 2020  ());.           
-00017ac0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-00017ad0: 2020 207d 0a20 2020 2020 2020 207d 0a0a     }.        }..
-00017ae0: 2020 2020 2020 2020 2f2f 2066 696e 6420          // find 
-00017af0: 6120 7361 6d70 6c65 2070 6f69 6e74 2077  a sample point w
-00017b00: 6974 6820 6120 736d 616c 6c20 7368 6966  ith a small shif
-00017b10: 740a 2020 2020 2020 2020 6c65 7420 2862  t.        let (b
-00017b20: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00017b30: 2c20 7361 6d70 6c65 5f70 6f69 6e74 732c  , sample_points,
-00017b40: 2063 6f65 6666 5f62 2c20 756e 695f 6629   coeff_b, uni_f)
-00017b50: 203d 0a20 2020 2020 2020 2020 2020 2073   =.            s
-00017b60: 656c 662e 6669 6e64 5f73 616d 706c 6528  elf.find_sample(
-00017b70: 6f72 6465 722c 2063 6f65 6666 6963 6965  order, coefficie
-00017b80: 6e74 5f75 7070 6572 5f62 6f75 6e64 2c20  nt_upper_bound, 
-00017b90: 6d61 785f 6269 7661 7269 6174 655f 6661  max_bivariate_fa
-00017ba0: 6374 6f72 7329 3b0a 2020 2020 2020 2020  ctors);.        
-00017bb0: 636f 6566 6669 6369 656e 745f 7570 7065  coefficient_uppe
-00017bc0: 725f 626f 756e 6420 3d20 636f 6566 665f  r_bound = coeff_
-00017bd0: 623b 0a0a 2020 2020 2020 2020 6966 2062  b;..        if b
-00017be0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00017bf0: 2e6c 656e 2829 203d 3d20 3120 7b0a 2020  .len() == 1 {.  
-00017c00: 2020 2020 2020 2020 2020 2f2f 2074 6865            // the
-00017c10: 2070 6f6c 796e 6f6d 6961 6c20 6973 2069   polynomial is i
-00017c20: 7272 6564 7563 6962 6c65 0a20 2020 2020  rreducible.     
-00017c30: 2020 2020 2020 2072 6574 7572 6e20 7665         return ve
-00017c40: 6321 5b73 656c 662e 636c 6f6e 6528 295d  c![self.clone()]
-00017c50: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
-00017c60: 2020 2020 2069 6620 6c65 7420 536f 6d65       if let Some
-00017c70: 286d 6178 2920 3d20 6d61 785f 6269 7661  (max) = max_biva
-00017c80: 7269 6174 655f 6661 6374 6f72 7320 7b0a  riate_factors {.
-00017c90: 2020 2020 2020 2020 2020 2020 6966 2062              if b
-00017ca0: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00017cb0: 2e6c 656e 2829 203e 206d 6178 207b 0a20  .len() > max {. 
-00017cc0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00017cd0: 6574 7572 6e20 7365 6c66 2e6d 756c 7469  eturn self.multi
-00017ce0: 7661 7269 6174 655f 6661 6374 6f72 697a  variate_factoriz
-00017cf0: 6174 696f 6e28 0a20 2020 2020 2020 2020  ation(.         
-00017d00: 2020 2020 2020 2020 2020 206f 7264 6572             order
-00017d10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00017d20: 2020 2020 2020 636f 6566 6669 6369 656e        coefficien
-00017d30: 745f 7570 7065 725f 626f 756e 642c 0a20  t_upper_bound,. 
-00017d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017d50: 2020 206d 6178 5f62 6976 6172 6961 7465     max_bivariate
-00017d60: 5f66 6163 746f 7273 2c0a 2020 2020 2020  _factors,.      
-00017d70: 2020 2020 2020 2020 2020 293b 0a20 2020            );.   
-00017d80: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00017d90: 2020 207d 0a0a 2020 2020 2020 2020 666f     }..        fo
-00017da0: 7220 2876 2c20 7329 2069 6e20 2673 616d  r (v, s) in &sam
-00017db0: 706c 655f 706f 696e 7473 207b 0a20 2020  ple_points {.   
-00017dc0: 2020 2020 2020 2020 2064 6562 7567 2128           debug!(
-00017dd0: 2253 616d 706c 6520 706f 696e 7420 787b  "Sample point x{
-00017de0: 7d20 3d20 7b7d 222c 2076 2c20 7329 3b0a  } = {}", v, s);.
-00017df0: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
-00017e00: 2020 202f 2f20 7365 6c65 6374 2061 2073     // select a s
-00017e10: 7569 7461 626c 6520 7072 696d 650a 2020  uitable prime.  
-00017e20: 2020 2020 2020 6c65 7420 6d75 7420 6669        let mut fi
-00017e30: 656c 643b 0a20 2020 2020 2020 206c 6574  eld;.        let
-00017e40: 206d 7574 2069 203d 2030 3b0a 2020 2020   mut i = 0;.    
-00017e50: 2020 2020 276e 6577 5f70 7269 6d65 3a20      'new_prime: 
-00017e60: 6c6f 6f70 207b 0a20 2020 2020 2020 2020  loop {.         
-00017e70: 2020 2069 202b 3d20 313b 0a20 2020 2020     i += 1;.     
-00017e80: 2020 2020 2020 2069 6620 6920 3d3d 204c         if i == L
-00017e90: 4152 4745 5f55 3332 5f50 5249 4d45 532e  ARGE_U32_PRIMES.
-00017ea0: 6c65 6e28 2920 7b0a 2020 2020 2020 2020  len() {.        
-00017eb0: 2020 2020 2020 2020 7061 6e69 6321 2822          panic!("
-00017ec0: 5261 6e20 6f75 7420 6f66 2070 7269 6d65  Ran out of prime
-00017ed0: 7320 6475 7269 6e67 2066 6163 746f 7269  s during factori
-00017ee0: 7a61 7469 6f6e 206f 6620 7b7d 222c 2073  zation of {}", s
-00017ef0: 656c 6629 3b0a 2020 2020 2020 2020 2020  elf);.          
-00017f00: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00017f10: 206c 6574 2070 203d 204c 4152 4745 5f55   let p = LARGE_U
-00017f20: 3332 5f50 5249 4d45 535b 695d 3b0a 0a20  32_PRIMES[i];.. 
-00017f30: 2020 2020 2020 2020 2020 2069 6620 2826             if (&
-00017f40: 756e 695f 662e 6c63 6f65 6666 2829 2025  uni_f.lcoeff() %
-00017f50: 2026 496e 7465 6765 723a 3a4e 6174 7572   &Integer::Natur
-00017f60: 616c 2870 2061 7320 6936 3429 292e 6973  al(p as i64)).is
-00017f70: 5f7a 6572 6f28 2920 7b0a 2020 2020 2020  _zero() {.      
-00017f80: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00017f90: 7565 3b0a 2020 2020 2020 2020 2020 2020  ue;.            
-00017fa0: 7d0a 0a20 2020 2020 2020 2020 2020 2066  }..            f
-00017fb0: 6965 6c64 203d 2046 696e 6974 6546 6965  ield = FiniteFie
-00017fc0: 6c64 3a3a 3c75 3332 3e3a 3a6e 6577 2870  ld::<u32>::new(p
-00017fd0: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-00017fe0: 2f2f 206d 616b 6520 7375 7265 2074 6865  // make sure the
-00017ff0: 2062 6976 6172 6961 7465 2066 6163 746f   bivariate facto
-00018000: 7273 2073 7461 7920 636f 7072 696d 650a  rs stay coprime.
-00018010: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00018020: 6673 5f70 3a20 5665 633c 5f3e 203d 2062  fs_p: Vec<_> = b
-00018030: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
-00018040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018050: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
-00018060: 2020 2020 2020 2020 202e 6d61 7028 7c66           .map(|f
-00018070: 7c20 662e 6d61 705f 636f 6566 6628 7c63  | f.map_coeff(|c
-00018080: 7c20 632e 746f 5f66 696e 6974 655f 6669  | c.to_finite_fi
-00018090: 656c 6428 2666 6965 6c64 292c 2066 6965  eld(&field), fie
-000180a0: 6c64 2e63 6c6f 6e65 2829 2929 0a20 2020  ld.clone())).   
-000180b0: 2020 2020 2020 2020 2020 2020 202e 636f               .co
-000180c0: 6c6c 6563 7428 293b 0a0a 2020 2020 2020  llect();..      
-000180d0: 2020 2020 2020 666f 7220 286a 2c20 6629        for (j, f)
-000180e0: 2069 6e20 6673 5f70 2e69 7465 7228 292e   in fs_p.iter().
-000180f0: 656e 756d 6572 6174 6528 2920 7b0a 2020  enumerate() {.  
-00018100: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00018110: 7220 6720 696e 2026 6673 5f70 5b6a 202b  r g in &fs_p[j +
-00018120: 2031 2e2e 5d20 7b0a 2020 2020 2020 2020   1..] {.        
-00018130: 2020 2020 2020 2020 2020 2020 6966 2021              if !
-00018140: 662e 6763 6428 6729 2e69 735f 6f6e 6528  f.gcd(g).is_one(
-00018150: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00018160: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-00018170: 696e 7565 2027 6e65 775f 7072 696d 653b  inue 'new_prime;
-00018180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018190: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-000181a0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-000181b0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
-000181c0: 2020 2020 6272 6561 6b3b 0a20 2020 2020      break;.     
-000181d0: 2020 207d 0a0a 2020 2020 2020 2020 2f2f     }..        //
-000181e0: 2054 4f44 4f3a 206d 6f64 6966 7920 626f   TODO: modify bo
-000181f0: 756e 6420 6279 2074 616b 696e 6720 7468  und by taking th
-00018200: 6520 7368 6966 7473 2069 6e74 6f20 6163  e shifts into ac
-00018210: 636f 756e 743f 0a20 2020 2020 2020 206c  count?.        l
-00018220: 6574 2062 6f75 6e64 203d 2073 656c 662e  et bound = self.
-00018230: 636f 6566 6669 6369 656e 745f 626f 756e  coefficient_boun
-00018240: 6428 293b 0a0a 2020 2020 2020 2020 6c65  d();..        le
-00018250: 7420 7020 3d20 6669 656c 642e 6765 745f  t p = field.get_
-00018260: 7072 696d 6528 292e 746f 5f75 3634 2829  prime().to_u64()
-00018270: 2061 7320 7533 323b 0a20 2020 2020 2020   as u32;.       
-00018280: 206c 6574 2070 5f69 6e74 203d 2049 6e74   let p_int = Int
-00018290: 6567 6572 3a3a 6672 6f6d 2866 6965 6c64  eger::from(field
-000182a0: 2e67 6574 5f70 7269 6d65 2829 2e74 6f5f  .get_prime().to_
-000182b0: 7536 3428 2929 3b0a 2020 2020 2020 2020  u64());.        
-000182c0: 6c65 7420 6d75 7420 6d61 785f 7020 3d20  let mut max_p = 
-000182d0: 705f 696e 742e 636c 6f6e 6528 293b 0a20  p_int.clone();. 
-000182e0: 2020 2020 2020 206c 6574 206d 7574 206b         let mut k
-000182f0: 203d 2031 3b0a 2020 2020 2020 2020 7768   = 1;.        wh
-00018300: 696c 6520 266d 6178 5f70 202a 2032 203c  ile &max_p * 2 <
-00018310: 2062 6f75 6e64 207b 0a20 2020 2020 2020   bound {.       
-00018320: 2020 2020 206d 6178 5f70 203d 2026 6d61       max_p = &ma
-00018330: 785f 7020 2a20 2670 5f69 6e74 3b0a 2020  x_p * &p_int;.  
-00018340: 2020 2020 2020 2020 2020 6b20 2b3d 2031            k += 1
-00018350: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
-00018360: 2020 2020 206c 6574 2028 736f 7274 6564       let (sorted
-00018370: 5f62 6976 5f66 6163 746f 7273 2c20 7472  _biv_factors, tr
-00018380: 7565 5f6c 636f 6566 6673 2920 3d20 6d61  ue_lcoeffs) = ma
-00018390: 7463 6820 7365 6c66 2e6c 636f 6566 665f  tch self.lcoeff_
-000183a0: 7072 6563 6f6d 7075 7461 7469 6f6e 280a  precomputation(.
-000183b0: 2020 2020 2020 2020 2020 2020 2662 6976              &biv
-000183c0: 6172 6961 7465 5f66 6163 746f 7273 2c0a  ariate_factors,.
-000183d0: 2020 2020 2020 2020 2020 2020 2673 616d              &sam
-000183e0: 706c 655f 706f 696e 7473 2c0a 2020 2020  ple_points,.    
-000183f0: 2020 2020 2020 2020 6f72 6465 722c 0a20          order,. 
-00018400: 2020 2020 2020 2020 2020 206d 6178 5f70             max_p
-00018410: 2e63 6c6f 6e65 2829 2c0a 2020 2020 2020  .clone(),.      
-00018420: 2020 2020 2020 702c 0a20 2020 2020 2020        p,.       
-00018430: 2020 2020 206b 2c0a 2020 2020 2020 2020       k,.        
-00018440: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00018450: 4f6b 2828 736f 7274 6564 5f62 6976 5f66  Ok((sorted_biv_f
-00018460: 6163 746f 7273 2c20 7472 7565 5f6c 636f  actors, true_lco
-00018470: 6566 6673 2929 203d 3e20 2873 6f72 7465  effs)) => (sorte
-00018480: 645f 6269 765f 6661 6374 6f72 732c 2074  d_biv_factors, t
-00018490: 7275 655f 6c63 6f65 6666 7329 2c0a 2020  rue_lcoeffs),.  
-000184a0: 2020 2020 2020 2020 2020 4572 7228 6d61            Err(ma
-000184b0: 785f 6269 7629 203d 3e20 7b0a 2020 2020  x_biv) => {.    
-000184c0: 2020 2020 2020 2020 2020 2020 2f2f 2074              // t
-000184d0: 6865 206c 6561 6469 6e67 2063 6f65 6666  he leading coeff
-000184e0: 6963 6965 6e74 2063 6f6d 7075 7461 7469  icient computati
-000184f0: 6f6e 2066 6169 6c65 6420 6265 6361 7573  on failed becaus
-00018500: 6520 7468 6520 6269 7661 7269 6174 6520  e the bivariate 
-00018510: 6661 6374 6f72 697a 6174 696f 6e20 7761  factorization wa
-00018520: 7320 7772 6f6e 670a 2020 2020 2020 2020  s wrong.        
-00018530: 2020 2020 2020 2020 2f2f 2074 7279 2061          // try a
-00018540: 6761 696e 2077 6974 6820 6f74 6865 7220  gain with other 
-00018550: 7361 6d70 6c65 2070 6f69 6e74 7320 616e  sample points an
-00018560: 6420 6120 6265 7474 6572 2062 6f75 6e64  d a better bound
-00018570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018580: 2072 6574 7572 6e20 7365 6c66 2e6d 756c   return self.mul
-00018590: 7469 7661 7269 6174 655f 6661 6374 6f72  tivariate_factor
-000185a0: 697a 6174 696f 6e28 0a20 2020 2020 2020  ization(.       
-000185b0: 2020 2020 2020 2020 2020 2020 206f 7264               ord
-000185c0: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
-000185d0: 2020 2020 2020 2020 636f 6566 6669 6369          coeffici
-000185e0: 656e 745f 7570 7065 725f 626f 756e 6420  ent_upper_bound 
-000185f0: 2b20 312c 0a20 2020 2020 2020 2020 2020  + 1,.           
-00018600: 2020 2020 2020 2020 2053 6f6d 6528 6d61           Some(ma
-00018610: 785f 6269 7629 2c0a 2020 2020 2020 2020  x_biv),.        
-00018620: 2020 2020 2020 2020 293b 0a20 2020 2020          );.     
-00018630: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-00018640: 207d 3b0a 0a20 2020 2020 2020 2066 6f72   };..        for
-00018650: 2028 622c 206c 2920 696e 2073 6f72 7465   (b, l) in sorte
-00018660: 645f 6269 765f 6661 6374 6f72 732e 6974  d_biv_factors.it
-00018670: 6572 2829 2e7a 6970 2826 7472 7565 5f6c  er().zip(&true_l
-00018680: 636f 6566 6673 2920 7b0a 2020 2020 2020  coeffs) {.      
-00018690: 2020 2020 2020 6465 6275 6721 2822 4269        debug!("Bi
-000186a0: 7661 7269 6174 6520 6661 6374 6f72 207b  variate factor {
-000186b0: 7d20 7769 7468 2074 7275 6520 6c63 6f65  } with true lcoe
-000186c0: 6666 207b 7d22 2c20 622c 206c 293b 0a20  ff {}", b, l);. 
-000186d0: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
-000186e0: 2020 6c65 7420 6669 656c 645f 6d6f 6420    let field_mod 
-000186f0: 3d20 4669 6e69 7465 4669 656c 643a 3a3c  = FiniteField::<
-00018700: 496e 7465 6765 723e 3a3a 6e65 7728 6d61  Integer>::new(ma
-00018710: 785f 702e 636c 6f6e 6528 2929 3b0a 2020  x_p.clone());.  
-00018720: 2020 2020 2020 6c65 7420 736f 7274 6564        let sorted
-00018730: 5f62 6976 5f66 6163 746f 7273 5f66 663a  _biv_factors_ff:
-00018740: 2056 6563 3c5f 3e20 3d20 736f 7274 6564   Vec<_> = sorted
-00018750: 5f62 6976 5f66 6163 746f 7273 0a20 2020  _biv_factors.   
-00018760: 2020 2020 2020 2020 202e 6974 6572 2829           .iter()
-00018770: 0a20 2020 2020 2020 2020 2020 202e 6d61  .            .ma
-00018780: 7028 7c66 7c20 662e 6d61 705f 636f 6566  p(|f| f.map_coef
-00018790: 6628 7c63 7c20 632e 746f 5f66 696e 6974  f(|c| c.to_finit
-000187a0: 655f 6669 656c 6428 2666 6965 6c64 5f6d  e_field(&field_m
-000187b0: 6f64 292c 2066 6965 6c64 5f6d 6f64 2e63  od), field_mod.c
-000187c0: 6c6f 6e65 2829 2929 0a20 2020 2020 2020  lone())).       
-000187d0: 2020 2020 202e 636f 6c6c 6563 7428 293b       .collect();
-000187e0: 0a0a 2020 2020 2020 2020 6c65 7420 286d  ..        let (m
-000187f0: 7574 2075 6e69 2c20 6465 6c74 6129 203d  ut uni, delta) =
-00018800: 204d 756c 7469 7661 7269 6174 6550 6f6c   MultivariatePol
-00018810: 796e 6f6d 6961 6c3a 3a67 6574 5f75 6e69  ynomial::get_uni
-00018820: 7661 7269 6174 655f 6661 6374 6f72 735f  variate_factors_
-00018830: 616e 645f 6465 6c74 6173 280a 2020 2020  and_deltas(.    
-00018840: 2020 2020 2020 2020 2673 6f72 7465 645f          &sorted_
-00018850: 6269 765f 6661 6374 6f72 735f 6666 2c0a  biv_factors_ff,.
-00018860: 2020 2020 2020 2020 2020 2020 6f72 6465              orde
-00018870: 722c 0a20 2020 2020 2020 2020 2020 2026  r,.            &
-00018880: 7361 6d70 6c65 5f70 6f69 6e74 732c 0a20  sample_points,. 
-00018890: 2020 2020 2020 2020 2020 2070 2c0a 2020             p,.  
-000188a0: 2020 2020 2020 2020 2020 6b2c 0a20 2020            k,.   
-000188b0: 2020 2020 2029 3b0a 0a20 2020 2020 2020       );..       
-000188c0: 202f 2f20 7065 7266 6f72 6d20 7468 6520   // perform the 
-000188d0: 4865 6e73 656c 206c 6966 7469 6e67 2069  Hensel lifting i
-000188e0: 6e20 6120 7065 7266 6f72 6d61 6e63 652d  n a performance-
-000188f0: 6f70 7469 6d69 7a65 6420 6669 6e69 7465  optimized finite
-00018900: 2066 6965 6c64 2069 6620 706f 7373 6962   field if possib
-00018910: 6c65 0a20 2020 2020 2020 206c 6574 2066  le.        let f
-00018920: 6163 746f 7269 7a61 7469 6f6e 203d 2069  actorization = i
-00018930: 6620 6d61 785f 7020 3c20 7536 343a 3a4d  f max_p < u64::M
-00018940: 4158 2e69 6e74 6f28 2920 7b0a 2020 2020  AX.into() {.    
-00018950: 2020 2020 2020 2020 6c65 7420 7072 696d          let prim
-00018960: 6520 3d20 6d61 7463 6820 6d61 785f 7020  e = match max_p 
-00018970: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00018980: 2020 496e 7465 6765 723a 3a4e 6174 7572    Integer::Natur
-00018990: 616c 2862 2920 3d3e 2062 2061 7320 7536  al(b) => b as u6
-000189a0: 342c 0a20 2020 2020 2020 2020 2020 2020  4,.             
-000189b0: 2020 2049 6e74 6567 6572 3a3a 446f 7562     Integer::Doub
-000189c0: 6c65 2862 2920 3d3e 2062 2061 7320 7536  le(b) => b as u6
-000189d0: 342c 0a20 2020 2020 2020 2020 2020 2020  4,.             
-000189e0: 2020 2049 6e74 6567 6572 3a3a 4c61 7267     Integer::Larg
-000189f0: 6528 6229 203d 3e20 622e 746f 5f75 3634  e(b) => b.to_u64
-00018a00: 2829 2e75 6e77 7261 7028 292c 0a20 2020  ().unwrap(),.   
-00018a10: 2020 2020 2020 2020 207d 3b0a 2020 2020           };.    
-00018a20: 2020 2020 2020 2020 6c65 7420 736d 616c          let smal
-00018a30: 6c5f 6669 656c 645f 6d6f 6420 3d20 4669  l_field_mod = Fi
-00018a40: 6e69 7465 4669 656c 643a 3a3c 7536 343e  niteField::<u64>
-00018a50: 3a3a 6e65 7728 7072 696d 6529 3b0a 0a20  ::new(prime);.. 
-00018a60: 2020 2020 2020 2020 2020 206c 6574 2070             let p
-00018a70: 6f6c 795f 6666 203d 2073 656c 662e 6d61  oly_ff = self.ma
-00018a80: 705f 636f 6566 6628 0a20 2020 2020 2020  p_coeff(.       
-00018a90: 2020 2020 2020 2020 207c 637c 2063 2e74           |c| c.t
-00018aa0: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
-00018ab0: 736d 616c 6c5f 6669 656c 645f 6d6f 6429  small_field_mod)
-00018ac0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00018ad0: 2020 736d 616c 6c5f 6669 656c 645f 6d6f    small_field_mo
-00018ae0: 642e 636c 6f6e 6528 292c 0a20 2020 2020  d.clone(),.     
-00018af0: 2020 2020 2020 2029 3b0a 0a20 2020 2020         );..     
-00018b00: 2020 2020 2020 206c 6574 2074 7275 655f         let true_
-00018b10: 6c63 6f65 6666 735f 6666 3a20 5665 633c  lcoeffs_ff: Vec<
-00018b20: 5f3e 203d 2074 7275 655f 6c63 6f65 6666  _> = true_lcoeff
-00018b30: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
-00018b40: 2020 2e69 6e74 6f5f 6974 6572 2829 0a20    .into_iter(). 
-00018b50: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00018b60: 6d61 7028 7c66 7c20 7b0a 2020 2020 2020  map(|f| {.      
-00018b70: 2020 2020 2020 2020 2020 2020 2020 662e                f.
-00018b80: 6d61 705f 636f 6566 6628 0a20 2020 2020  map_coeff(.     
-00018b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018ba0: 2020 207c 637c 2063 2e74 6f5f 6669 6e69     |c| c.to_fini
-00018bb0: 7465 5f66 6965 6c64 2826 736d 616c 6c5f  te_field(&small_
-00018bc0: 6669 656c 645f 6d6f 6429 2c0a 2020 2020  field_mod),.    
-00018bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018be0: 2020 2020 736d 616c 6c5f 6669 656c 645f      small_field_
-00018bf0: 6d6f 642e 636c 6f6e 6528 292c 0a20 2020  mod.clone(),.   
-00018c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018c10: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
-00018c20: 2020 207d 290a 2020 2020 2020 2020 2020     }).          
-00018c30: 2020 2020 2020 2e63 6f6c 6c65 6374 2829        .collect()
-00018c40: 3b0a 0a20 2020 2020 2020 2020 2020 206c  ;..            l
-00018c50: 6574 2073 6f72 7465 645f 6269 765f 6661  et sorted_biv_fa
-00018c60: 6374 6f72 735f 6666 3a20 5665 633c 5f3e  ctors_ff: Vec<_>
-00018c70: 203d 2073 6f72 7465 645f 6269 765f 6661   = sorted_biv_fa
-00018c80: 6374 6f72 730a 2020 2020 2020 2020 2020  ctors.          
-00018c90: 2020 2020 2020 2e69 6e74 6f5f 6974 6572        .into_iter
-00018ca0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
-00018cb0: 2020 202e 6d61 7028 7c66 7c20 7b0a 2020     .map(|f| {.  
-00018cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018cd0: 2020 662e 6d61 705f 636f 6566 6628 0a20    f.map_coeff(. 
+00017720: 732e 6c65 6e28 2920 3d3d 2031 207b 0a20  s.len() == 1 {. 
+00017730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017740: 2020 202f 2f20 7468 6520 706f 6c79 6e6f     // the polyno
+00017750: 6d69 616c 2069 7320 6972 7265 6475 6369  mial is irreduci
+00017760: 626c 650a 2020 2020 2020 2020 2020 2020  ble.            
+00017770: 2020 2020 2020 2020 7265 7475 726e 2076          return v
+00017780: 6563 215b 7365 6c66 2e63 6c6f 6e65 2829  ec![self.clone()
+00017790: 5d3b 0a20 2020 2020 2020 2020 2020 2020  ];.             
+000177a0: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+000177b0: 2020 2020 2020 6966 206c 6574 2053 6f6d        if let Som
+000177c0: 6528 6d61 7829 203d 206d 6178 5f62 6976  e(max) = max_biv
+000177d0: 6172 6961 7465 5f66 6163 746f 7273 207b  ariate_factors {
+000177e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000177f0: 2020 2020 2069 6620 6269 7661 7269 6174       if bivariat
+00017800: 655f 6661 6374 6f72 732e 6c65 6e28 2920  e_factors.len() 
+00017810: 3c20 6d61 7820 7b0a 2020 2020 2020 2020  < max {.        
+00017820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017830: 6465 6275 6721 2822 5570 6461 7469 6e67  debug!("Updating
+00017840: 2062 6976 6172 6961 7465 2062 6f75 6e64   bivariate bound
+00017850: 2074 6f20 7b7d 222c 2062 6976 6172 6961   to {}", bivaria
+00017860: 7465 5f66 6163 746f 7273 2e6c 656e 2829  te_factors.len()
+00017870: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00017880: 2020 2020 2020 2020 2020 206d 6178 5f62             max_b
+00017890: 6976 6172 6961 7465 5f66 6163 746f 7273  ivariate_factors
+000178a0: 203d 2053 6f6d 6528 6269 7661 7269 6174   = Some(bivariat
+000178b0: 655f 6661 6374 6f72 732e 6c65 6e28 2929  e_factors.len())
+000178c0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+000178d0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+000178e0: 2020 2020 2020 2020 7d20 656c 7365 207b          } else {
+000178f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00017900: 2020 2020 2064 6562 7567 2128 2255 7064       debug!("Upd
+00017910: 6174 696e 6720 6269 7661 7269 6174 6520  ating bivariate 
+00017920: 626f 756e 6420 746f 207b 7d22 2c20 6269  bound to {}", bi
+00017930: 7661 7269 6174 655f 6661 6374 6f72 732e  variate_factors.
+00017940: 6c65 6e28 2929 3b0a 2020 2020 2020 2020  len());.        
+00017950: 2020 2020 2020 2020 2020 2020 6d61 785f              max_
+00017960: 6269 7661 7269 6174 655f 6661 6374 6f72  bivariate_factor
+00017970: 7320 3d20 536f 6d65 2862 6976 6172 6961  s = Some(bivaria
+00017980: 7465 5f66 6163 746f 7273 2e6c 656e 2829  te_factors.len()
+00017990: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+000179a0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+000179b0: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
+000179c0: 2020 2020 2020 2f2f 2066 696e 6420 6120        // find a 
+000179d0: 7361 6d70 6c65 2070 6f69 6e74 2077 6974  sample point wit
+000179e0: 6820 6120 736d 616c 6c20 7368 6966 740a  h a small shift.
+000179f0: 2020 2020 2020 2020 6c65 7420 2862 6976          let (biv
+00017a00: 6172 6961 7465 5f66 6163 746f 7273 2c20  ariate_factors, 
+00017a10: 7361 6d70 6c65 5f70 6f69 6e74 732c 2063  sample_points, c
+00017a20: 6f65 6666 5f62 2c20 756e 695f 6629 203d  oeff_b, uni_f) =
+00017a30: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00017a40: 662e 6669 6e64 5f73 616d 706c 6528 6f72  f.find_sample(or
+00017a50: 6465 722c 2063 6f65 6666 6963 6965 6e74  der, coefficient
+00017a60: 5f75 7070 6572 5f62 6f75 6e64 2c20 6d61  _upper_bound, ma
+00017a70: 785f 6269 7661 7269 6174 655f 6661 6374  x_bivariate_fact
+00017a80: 6f72 7329 3b0a 2020 2020 2020 2020 636f  ors);.        co
+00017a90: 6566 6669 6369 656e 745f 7570 7065 725f  efficient_upper_
+00017aa0: 626f 756e 6420 3d20 636f 6566 665f 623b  bound = coeff_b;
+00017ab0: 0a0a 2020 2020 2020 2020 6966 2062 6976  ..        if biv
+00017ac0: 6172 6961 7465 5f66 6163 746f 7273 2e6c  ariate_factors.l
+00017ad0: 656e 2829 203d 3d20 3120 7b0a 2020 2020  en() == 1 {.    
+00017ae0: 2020 2020 2020 2020 2f2f 2074 6865 2070          // the p
+00017af0: 6f6c 796e 6f6d 6961 6c20 6973 2069 7272  olynomial is irr
+00017b00: 6564 7563 6962 6c65 0a20 2020 2020 2020  educible.       
+00017b10: 2020 2020 2072 6574 7572 6e20 7665 6321       return vec!
+00017b20: 5b73 656c 662e 636c 6f6e 6528 295d 3b0a  [self.clone()];.
+00017b30: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00017b40: 2020 2069 6620 6c65 7420 536f 6d65 286d     if let Some(m
+00017b50: 6178 2920 3d20 6d61 785f 6269 7661 7269  ax) = max_bivari
+00017b60: 6174 655f 6661 6374 6f72 7320 7b0a 2020  ate_factors {.  
+00017b70: 2020 2020 2020 2020 2020 6966 2062 6976            if biv
+00017b80: 6172 6961 7465 5f66 6163 746f 7273 2e6c  ariate_factors.l
+00017b90: 656e 2829 203e 206d 6178 207b 0a20 2020  en() > max {.   
+00017ba0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00017bb0: 7572 6e20 7365 6c66 2e6d 756c 7469 7661  urn self.multiva
+00017bc0: 7269 6174 655f 6661 6374 6f72 697a 6174  riate_factorizat
+00017bd0: 696f 6e28 0a20 2020 2020 2020 2020 2020  ion(.           
+00017be0: 2020 2020 2020 2020 206f 7264 6572 2c0a           order,.
+00017bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017c00: 2020 2020 636f 6566 6669 6369 656e 745f      coefficient_
+00017c10: 7570 7065 725f 626f 756e 642c 0a20 2020  upper_bound,.   
+00017c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017c30: 206d 6178 5f62 6976 6172 6961 7465 5f66   max_bivariate_f
+00017c40: 6163 746f 7273 2c0a 2020 2020 2020 2020  actors,.        
+00017c50: 2020 2020 2020 2020 293b 0a20 2020 2020          );.     
+00017c60: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00017c70: 207d 0a0a 2020 2020 2020 2020 666f 7220   }..        for 
+00017c80: 2876 2c20 7329 2069 6e20 2673 616d 706c  (v, s) in &sampl
+00017c90: 655f 706f 696e 7473 207b 0a20 2020 2020  e_points {.     
+00017ca0: 2020 2020 2020 2064 6562 7567 2128 2253         debug!("S
+00017cb0: 616d 706c 6520 706f 696e 7420 787b 7d20  ample point x{} 
+00017cc0: 3d20 7b7d 222c 2076 2c20 7329 3b0a 2020  = {}", v, s);.  
+00017cd0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00017ce0: 202f 2f20 7365 6c65 6374 2061 2073 7569   // select a sui
+00017cf0: 7461 626c 6520 7072 696d 650a 2020 2020  table prime.    
+00017d00: 2020 2020 6c65 7420 6d75 7420 6669 656c      let mut fiel
+00017d10: 643b 0a20 2020 2020 2020 206c 6574 206d  d;.        let m
+00017d20: 7574 2069 203d 2030 3b0a 2020 2020 2020  ut i = 0;.      
+00017d30: 2020 276e 6577 5f70 7269 6d65 3a20 6c6f    'new_prime: lo
+00017d40: 6f70 207b 0a20 2020 2020 2020 2020 2020  op {.           
+00017d50: 2069 202b 3d20 313b 0a20 2020 2020 2020   i += 1;.       
+00017d60: 2020 2020 2069 6620 6920 3d3d 204c 4152       if i == LAR
+00017d70: 4745 5f55 3332 5f50 5249 4d45 532e 6c65  GE_U32_PRIMES.le
+00017d80: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
+00017d90: 2020 2020 2020 7061 6e69 6321 2822 5261        panic!("Ra
+00017da0: 6e20 6f75 7420 6f66 2070 7269 6d65 7320  n out of primes 
+00017db0: 6475 7269 6e67 2066 6163 746f 7269 7a61  during factoriza
+00017dc0: 7469 6f6e 206f 6620 7b7d 222c 2073 656c  tion of {}", sel
+00017dd0: 6629 3b0a 2020 2020 2020 2020 2020 2020  f);.            
+00017de0: 7d0a 0a20 2020 2020 2020 2020 2020 206c  }..            l
+00017df0: 6574 2070 203d 204c 4152 4745 5f55 3332  et p = LARGE_U32
+00017e00: 5f50 5249 4d45 535b 695d 3b0a 0a20 2020  _PRIMES[i];..   
+00017e10: 2020 2020 2020 2020 2069 6620 2826 756e           if (&un
+00017e20: 695f 662e 6c63 6f65 6666 2829 2025 2026  i_f.lcoeff() % &
+00017e30: 496e 7465 6765 723a 3a4e 6174 7572 616c  Integer::Natural
+00017e40: 2870 2061 7320 6936 3429 292e 6973 5f7a  (p as i64)).is_z
+00017e50: 6572 6f28 2920 7b0a 2020 2020 2020 2020  ero() {.        
+00017e60: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+00017e70: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
+00017e80: 0a20 2020 2020 2020 2020 2020 2066 6965  .            fie
+00017e90: 6c64 203d 205a 703a 3a6e 6577 2870 293b  ld = Zp::new(p);
+00017ea0: 0a0a 2020 2020 2020 2020 2020 2020 2f2f  ..            //
+00017eb0: 206d 616b 6520 7375 7265 2074 6865 2062   make sure the b
+00017ec0: 6976 6172 6961 7465 2066 6163 746f 7273  ivariate factors
+00017ed0: 2073 7461 7920 636f 7072 696d 650a 2020   stay coprime.  
+00017ee0: 2020 2020 2020 2020 2020 6c65 7420 6673            let fs
+00017ef0: 5f70 3a20 5665 633c 5f3e 203d 2062 6976  _p: Vec<_> = biv
+00017f00: 6172 6961 7465 5f66 6163 746f 7273 0a20  ariate_factors. 
+00017f10: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00017f20: 6974 6572 2829 0a20 2020 2020 2020 2020  iter().         
+00017f30: 2020 2020 2020 202e 6d61 7028 7c66 7c20         .map(|f| 
+00017f40: 662e 6d61 705f 636f 6566 6628 7c63 7c20  f.map_coeff(|c| 
+00017f50: 632e 746f 5f66 696e 6974 655f 6669 656c  c.to_finite_fiel
+00017f60: 6428 2666 6965 6c64 292c 2066 6965 6c64  d(&field), field
+00017f70: 2e63 6c6f 6e65 2829 2929 0a20 2020 2020  .clone())).     
+00017f80: 2020 2020 2020 2020 2020 202e 636f 6c6c             .coll
+00017f90: 6563 7428 293b 0a0a 2020 2020 2020 2020  ect();..        
+00017fa0: 2020 2020 666f 7220 286a 2c20 6629 2069      for (j, f) i
+00017fb0: 6e20 6673 5f70 2e69 7465 7228 292e 656e  n fs_p.iter().en
+00017fc0: 756d 6572 6174 6528 2920 7b0a 2020 2020  umerate() {.    
+00017fd0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00017fe0: 6720 696e 2026 6673 5f70 5b6a 202b 2031  g in &fs_p[j + 1
+00017ff0: 2e2e 5d20 7b0a 2020 2020 2020 2020 2020  ..] {.          
+00018000: 2020 2020 2020 2020 2020 6966 2021 662e            if !f.
+00018010: 6763 6428 6729 2e69 735f 6f6e 6528 2920  gcd(g).is_one() 
+00018020: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00018030: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+00018040: 7565 2027 6e65 775f 7072 696d 653b 0a20  ue 'new_prime;. 
+00018050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018060: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00018070: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00018080: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
+00018090: 2020 6272 6561 6b3b 0a20 2020 2020 2020    break;.       
+000180a0: 207d 0a0a 2020 2020 2020 2020 2f2f 2054   }..        // T
+000180b0: 4f44 4f3a 206d 6f64 6966 7920 626f 756e  ODO: modify boun
+000180c0: 6420 6279 2074 616b 696e 6720 7468 6520  d by taking the 
+000180d0: 7368 6966 7473 2069 6e74 6f20 6163 636f  shifts into acco
+000180e0: 756e 743f 0a20 2020 2020 2020 206c 6574  unt?.        let
+000180f0: 2062 6f75 6e64 203d 2073 656c 662e 636f   bound = self.co
+00018100: 6566 6669 6369 656e 745f 626f 756e 6428  efficient_bound(
+00018110: 293b 0a0a 2020 2020 2020 2020 6c65 7420  );..        let 
+00018120: 7020 3d20 6669 656c 642e 6765 745f 7072  p = field.get_pr
+00018130: 696d 6528 292e 746f 5f75 3634 2829 2061  ime().to_u64() a
+00018140: 7320 7533 323b 0a20 2020 2020 2020 206c  s u32;.        l
+00018150: 6574 2070 5f69 6e74 203d 2049 6e74 6567  et p_int = Integ
+00018160: 6572 3a3a 6672 6f6d 2866 6965 6c64 2e67  er::from(field.g
+00018170: 6574 5f70 7269 6d65 2829 2e74 6f5f 7536  et_prime().to_u6
+00018180: 3428 2929 3b0a 2020 2020 2020 2020 6c65  4());.        le
+00018190: 7420 6d75 7420 6d61 785f 7020 3d20 705f  t mut max_p = p_
+000181a0: 696e 742e 636c 6f6e 6528 293b 0a20 2020  int.clone();.   
+000181b0: 2020 2020 206c 6574 206d 7574 206b 203d       let mut k =
+000181c0: 2031 3b0a 2020 2020 2020 2020 7768 696c   1;.        whil
+000181d0: 6520 266d 6178 5f70 202a 2032 203c 2062  e &max_p * 2 < b
+000181e0: 6f75 6e64 207b 0a20 2020 2020 2020 2020  ound {.         
+000181f0: 2020 206d 6178 5f70 203d 2026 6d61 785f     max_p = &max_
+00018200: 7020 2a20 2670 5f69 6e74 3b0a 2020 2020  p * &p_int;.    
+00018210: 2020 2020 2020 2020 6b20 2b3d 2031 3b0a          k += 1;.
+00018220: 2020 2020 2020 2020 7d0a 0a20 2020 2020          }..     
+00018230: 2020 206c 6574 2028 736f 7274 6564 5f62     let (sorted_b
+00018240: 6976 5f66 6163 746f 7273 2c20 7472 7565  iv_factors, true
+00018250: 5f6c 636f 6566 6673 2920 3d20 6d61 7463  _lcoeffs) = matc
+00018260: 6820 7365 6c66 2e6c 636f 6566 665f 7072  h self.lcoeff_pr
+00018270: 6563 6f6d 7075 7461 7469 6f6e 280a 2020  ecomputation(.  
+00018280: 2020 2020 2020 2020 2020 2662 6976 6172            &bivar
+00018290: 6961 7465 5f66 6163 746f 7273 2c0a 2020  iate_factors,.  
+000182a0: 2020 2020 2020 2020 2020 2673 616d 706c            &sampl
+000182b0: 655f 706f 696e 7473 2c0a 2020 2020 2020  e_points,.      
+000182c0: 2020 2020 2020 6f72 6465 722c 0a20 2020        order,.   
+000182d0: 2020 2020 2020 2020 206d 6178 5f70 2e63           max_p.c
+000182e0: 6c6f 6e65 2829 2c0a 2020 2020 2020 2020  lone(),.        
+000182f0: 2020 2020 702c 0a20 2020 2020 2020 2020      p,.         
+00018300: 2020 206b 2c0a 2020 2020 2020 2020 2920     k,.        ) 
+00018310: 7b0a 2020 2020 2020 2020 2020 2020 4f6b  {.            Ok
+00018320: 2828 736f 7274 6564 5f62 6976 5f66 6163  ((sorted_biv_fac
+00018330: 746f 7273 2c20 7472 7565 5f6c 636f 6566  tors, true_lcoef
+00018340: 6673 2929 203d 3e20 2873 6f72 7465 645f  fs)) => (sorted_
+00018350: 6269 765f 6661 6374 6f72 732c 2074 7275  biv_factors, tru
+00018360: 655f 6c63 6f65 6666 7329 2c0a 2020 2020  e_lcoeffs),.    
+00018370: 2020 2020 2020 2020 4572 7228 6d61 785f          Err(max_
+00018380: 6269 7629 203d 3e20 7b0a 2020 2020 2020  biv) => {.      
+00018390: 2020 2020 2020 2020 2020 2f2f 2074 6865            // the
+000183a0: 206c 6561 6469 6e67 2063 6f65 6666 6963   leading coeffic
+000183b0: 6965 6e74 2063 6f6d 7075 7461 7469 6f6e  ient computation
+000183c0: 2066 6169 6c65 6420 6265 6361 7573 6520   failed because 
+000183d0: 7468 6520 6269 7661 7269 6174 6520 6661  the bivariate fa
+000183e0: 6374 6f72 697a 6174 696f 6e20 7761 7320  ctorization was 
+000183f0: 7772 6f6e 670a 2020 2020 2020 2020 2020  wrong.          
+00018400: 2020 2020 2020 2f2f 2074 7279 2061 6761        // try aga
+00018410: 696e 2077 6974 6820 6f74 6865 7220 7361  in with other sa
+00018420: 6d70 6c65 2070 6f69 6e74 7320 616e 6420  mple points and 
+00018430: 6120 6265 7474 6572 2062 6f75 6e64 0a20  a better bound. 
+00018440: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00018450: 6574 7572 6e20 7365 6c66 2e6d 756c 7469  eturn self.multi
+00018460: 7661 7269 6174 655f 6661 6374 6f72 697a  variate_factoriz
+00018470: 6174 696f 6e28 0a20 2020 2020 2020 2020  ation(.         
+00018480: 2020 2020 2020 2020 2020 206f 7264 6572             order
+00018490: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000184a0: 2020 2020 2020 636f 6566 6669 6369 656e        coefficien
+000184b0: 745f 7570 7065 725f 626f 756e 6420 2b20  t_upper_bound + 
+000184c0: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
+000184d0: 2020 2020 2020 2053 6f6d 6528 6d61 785f         Some(max_
+000184e0: 6269 7629 2c0a 2020 2020 2020 2020 2020  biv),.          
+000184f0: 2020 2020 2020 293b 0a20 2020 2020 2020        );.       
+00018500: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
+00018510: 3b0a 0a20 2020 2020 2020 2066 6f72 2028  ;..        for (
+00018520: 622c 206c 2920 696e 2073 6f72 7465 645f  b, l) in sorted_
+00018530: 6269 765f 6661 6374 6f72 732e 6974 6572  biv_factors.iter
+00018540: 2829 2e7a 6970 2826 7472 7565 5f6c 636f  ().zip(&true_lco
+00018550: 6566 6673 2920 7b0a 2020 2020 2020 2020  effs) {.        
+00018560: 2020 2020 6465 6275 6721 2822 4269 7661      debug!("Biva
+00018570: 7269 6174 6520 6661 6374 6f72 207b 7d20  riate factor {} 
+00018580: 7769 7468 2074 7275 6520 6c63 6f65 6666  with true lcoeff
+00018590: 207b 7d22 2c20 622c 206c 293b 0a20 2020   {}", b, l);.   
+000185a0: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+000185b0: 6c65 7420 6669 656c 645f 6d6f 6420 3d20  let field_mod = 
+000185c0: 4669 6e69 7465 4669 656c 643a 3a3c 496e  FiniteField::<In
+000185d0: 7465 6765 723e 3a3a 6e65 7728 6d61 785f  teger>::new(max_
+000185e0: 702e 636c 6f6e 6528 2929 3b0a 2020 2020  p.clone());.    
+000185f0: 2020 2020 6c65 7420 736f 7274 6564 5f62      let sorted_b
+00018600: 6976 5f66 6163 746f 7273 5f66 663a 2056  iv_factors_ff: V
+00018610: 6563 3c5f 3e20 3d20 736f 7274 6564 5f62  ec<_> = sorted_b
+00018620: 6976 5f66 6163 746f 7273 0a20 2020 2020  iv_factors.     
+00018630: 2020 2020 2020 202e 6974 6572 2829 0a20         .iter(). 
+00018640: 2020 2020 2020 2020 2020 202e 6d61 7028             .map(
+00018650: 7c66 7c20 662e 6d61 705f 636f 6566 6628  |f| f.map_coeff(
+00018660: 7c63 7c20 632e 746f 5f66 696e 6974 655f  |c| c.to_finite_
+00018670: 6669 656c 6428 2666 6965 6c64 5f6d 6f64  field(&field_mod
+00018680: 292c 2066 6965 6c64 5f6d 6f64 2e63 6c6f  ), field_mod.clo
+00018690: 6e65 2829 2929 0a20 2020 2020 2020 2020  ne())).         
+000186a0: 2020 202e 636f 6c6c 6563 7428 293b 0a0a     .collect();..
+000186b0: 2020 2020 2020 2020 6c65 7420 286d 7574          let (mut
+000186c0: 2075 6e69 2c20 6465 6c74 6129 203d 204d   uni, delta) = M
+000186d0: 756c 7469 7661 7269 6174 6550 6f6c 796e  ultivariatePolyn
+000186e0: 6f6d 6961 6c3a 3a67 6574 5f75 6e69 7661  omial::get_univa
+000186f0: 7269 6174 655f 6661 6374 6f72 735f 616e  riate_factors_an
+00018700: 645f 6465 6c74 6173 280a 2020 2020 2020  d_deltas(.      
+00018710: 2020 2020 2020 2673 6f72 7465 645f 6269        &sorted_bi
+00018720: 765f 6661 6374 6f72 735f 6666 2c0a 2020  v_factors_ff,.  
+00018730: 2020 2020 2020 2020 2020 6f72 6465 722c            order,
+00018740: 0a20 2020 2020 2020 2020 2020 2026 7361  .            &sa
+00018750: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
+00018760: 2020 2020 2020 2020 2070 2c0a 2020 2020           p,.    
+00018770: 2020 2020 2020 2020 6b2c 0a20 2020 2020          k,.     
+00018780: 2020 2029 3b0a 0a20 2020 2020 2020 202f     );..        /
+00018790: 2f20 7065 7266 6f72 6d20 7468 6520 4865  / perform the He
+000187a0: 6e73 656c 206c 6966 7469 6e67 2069 6e20  nsel lifting in 
+000187b0: 6120 7065 7266 6f72 6d61 6e63 652d 6f70  a performance-op
+000187c0: 7469 6d69 7a65 6420 6669 6e69 7465 2066  timized finite f
+000187d0: 6965 6c64 2069 6620 706f 7373 6962 6c65  ield if possible
+000187e0: 0a20 2020 2020 2020 206c 6574 2066 6163  .        let fac
+000187f0: 746f 7269 7a61 7469 6f6e 203d 2069 6620  torization = if 
+00018800: 6d61 785f 7020 3c20 7536 343a 3a4d 4158  max_p < u64::MAX
+00018810: 2e69 6e74 6f28 2920 7b0a 2020 2020 2020  .into() {.      
+00018820: 2020 2020 2020 6c65 7420 7072 696d 6520        let prime 
+00018830: 3d20 6d61 7463 6820 6d61 785f 7020 7b0a  = match max_p {.
+00018840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018850: 496e 7465 6765 723a 3a4e 6174 7572 616c  Integer::Natural
+00018860: 2862 2920 3d3e 2062 2061 7320 7536 342c  (b) => b as u64,
+00018870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018880: 2049 6e74 6567 6572 3a3a 446f 7562 6c65   Integer::Double
+00018890: 2862 2920 3d3e 2062 2061 7320 7536 342c  (b) => b as u64,
+000188a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000188b0: 2049 6e74 6567 6572 3a3a 4c61 7267 6528   Integer::Large(
+000188c0: 6229 203d 3e20 622e 746f 5f75 3634 2829  b) => b.to_u64()
+000188d0: 2e75 6e77 7261 7028 292c 0a20 2020 2020  .unwrap(),.     
+000188e0: 2020 2020 2020 207d 3b0a 2020 2020 2020         };.      
+000188f0: 2020 2020 2020 6c65 7420 736d 616c 6c5f        let small_
+00018900: 6669 656c 645f 6d6f 6420 3d20 5a70 3634  field_mod = Zp64
+00018910: 3a3a 6e65 7728 7072 696d 6529 3b0a 0a20  ::new(prime);.. 
+00018920: 2020 2020 2020 2020 2020 206c 6574 2070             let p
+00018930: 6f6c 795f 6666 203d 2073 656c 662e 6d61  oly_ff = self.ma
+00018940: 705f 636f 6566 6628 0a20 2020 2020 2020  p_coeff(.       
+00018950: 2020 2020 2020 2020 207c 637c 2063 2e74           |c| c.t
+00018960: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
+00018970: 736d 616c 6c5f 6669 656c 645f 6d6f 6429  small_field_mod)
+00018980: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00018990: 2020 736d 616c 6c5f 6669 656c 645f 6d6f    small_field_mo
+000189a0: 642e 636c 6f6e 6528 292c 0a20 2020 2020  d.clone(),.     
+000189b0: 2020 2020 2020 2029 3b0a 0a20 2020 2020         );..     
+000189c0: 2020 2020 2020 206c 6574 2074 7275 655f         let true_
+000189d0: 6c63 6f65 6666 735f 6666 3a20 5665 633c  lcoeffs_ff: Vec<
+000189e0: 5f3e 203d 2074 7275 655f 6c63 6f65 6666  _> = true_lcoeff
+000189f0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00018a00: 2020 2e69 6e74 6f5f 6974 6572 2829 0a20    .into_iter(). 
+00018a10: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00018a20: 6d61 7028 7c66 7c20 7b0a 2020 2020 2020  map(|f| {.      
+00018a30: 2020 2020 2020 2020 2020 2020 2020 662e                f.
+00018a40: 6d61 705f 636f 6566 6628 0a20 2020 2020  map_coeff(.     
+00018a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018a60: 2020 207c 637c 2063 2e74 6f5f 6669 6e69     |c| c.to_fini
+00018a70: 7465 5f66 6965 6c64 2826 736d 616c 6c5f  te_field(&small_
+00018a80: 6669 656c 645f 6d6f 6429 2c0a 2020 2020  field_mod),.    
+00018a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018aa0: 2020 2020 736d 616c 6c5f 6669 656c 645f      small_field_
+00018ab0: 6d6f 642e 636c 6f6e 6528 292c 0a20 2020  mod.clone(),.   
+00018ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018ad0: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00018ae0: 2020 207d 290a 2020 2020 2020 2020 2020     }).          
+00018af0: 2020 2020 2020 2e63 6f6c 6c65 6374 2829        .collect()
+00018b00: 3b0a 0a20 2020 2020 2020 2020 2020 206c  ;..            l
+00018b10: 6574 2073 6f72 7465 645f 6269 765f 6661  et sorted_biv_fa
+00018b20: 6374 6f72 735f 6666 3a20 5665 633c 5f3e  ctors_ff: Vec<_>
+00018b30: 203d 2073 6f72 7465 645f 6269 765f 6661   = sorted_biv_fa
+00018b40: 6374 6f72 730a 2020 2020 2020 2020 2020  ctors.          
+00018b50: 2020 2020 2020 2e69 6e74 6f5f 6974 6572        .into_iter
+00018b60: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00018b70: 2020 202e 6d61 7028 7c66 7c20 7b0a 2020     .map(|f| {.  
+00018b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b90: 2020 662e 6d61 705f 636f 6566 6628 0a20    f.map_coeff(. 
+00018ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018bb0: 2020 2020 2020 207c 637c 2063 2e74 6f5f         |c| c.to_
+00018bc0: 6669 6e69 7465 5f66 6965 6c64 2826 736d  finite_field(&sm
+00018bd0: 616c 6c5f 6669 656c 645f 6d6f 6429 2c0a  all_field_mod),.
+00018be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018bf0: 2020 2020 2020 2020 736d 616c 6c5f 6669          small_fi
+00018c00: 656c 645f 6d6f 642e 636c 6f6e 6528 292c  eld_mod.clone(),
+00018c10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018c20: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00018c30: 2020 2020 2020 207d 290a 2020 2020 2020         }).      
+00018c40: 2020 2020 2020 2020 2020 2e63 6f6c 6c65            .colle
+00018c50: 6374 2829 3b0a 0a20 2020 2020 2020 2020  ct();..         
+00018c60: 2020 206c 6574 206d 7574 2075 6e69 5f66     let mut uni_f
+00018c70: 3a20 5665 633c 5f3e 203d 2075 6e69 0a20  : Vec<_> = uni. 
+00018c80: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00018c90: 696e 746f 5f69 7465 7228 290a 2020 2020  into_iter().    
+00018ca0: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
+00018cb0: 287c 667c 207b 0a20 2020 2020 2020 2020  (|f| {.         
+00018cc0: 2020 2020 2020 2020 2020 2066 2e6d 6170             f.map
+00018cd0: 5f63 6f65 6666 280a 2020 2020 2020 2020  _coeff(.        
 00018ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018cf0: 2020 2020 2020 207c 637c 2063 2e74 6f5f         |c| c.to_
-00018d00: 6669 6e69 7465 5f66 6965 6c64 2826 736d  finite_field(&sm
-00018d10: 616c 6c5f 6669 656c 645f 6d6f 6429 2c0a  all_field_mod),.
-00018d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d30: 2020 2020 2020 2020 736d 616c 6c5f 6669          small_fi
-00018d40: 656c 645f 6d6f 642e 636c 6f6e 6528 292c  eld_mod.clone(),
-00018d50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018d60: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00018d70: 2020 2020 2020 207d 290a 2020 2020 2020         }).      
-00018d80: 2020 2020 2020 2020 2020 2e63 6f6c 6c65            .colle
-00018d90: 6374 2829 3b0a 0a20 2020 2020 2020 2020  ct();..         
-00018da0: 2020 206c 6574 206d 7574 2075 6e69 5f66     let mut uni_f
-00018db0: 3a20 5665 633c 5f3e 203d 2075 6e69 0a20  : Vec<_> = uni. 
-00018dc0: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00018dd0: 696e 746f 5f69 7465 7228 290a 2020 2020  into_iter().    
-00018de0: 2020 2020 2020 2020 2020 2020 2e6d 6170              .map
-00018df0: 287c 667c 207b 0a20 2020 2020 2020 2020  (|f| {.         
-00018e00: 2020 2020 2020 2020 2020 2066 2e6d 6170             f.map
-00018e10: 5f63 6f65 6666 280a 2020 2020 2020 2020  _coeff(.        
-00018e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018e30: 7c63 7c20 6669 656c 645f 6d6f 642e 6672  |c| field_mod.fr
-00018e40: 6f6d 5f65 6c65 6d65 6e74 2863 292e 746f  om_element(c).to
-00018e50: 5f66 696e 6974 655f 6669 656c 6428 2673  _finite_field(&s
-00018e60: 6d61 6c6c 5f66 6965 6c64 5f6d 6f64 292c  mall_field_mod),
-00018e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018e80: 2020 2020 2020 2020 2073 6d61 6c6c 5f66           small_f
-00018e90: 6965 6c64 5f6d 6f64 2e63 6c6f 6e65 2829  ield_mod.clone()
-00018ea0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00018eb0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00018ec0: 2020 2020 2020 2020 7d29 0a20 2020 2020          }).     
-00018ed0: 2020 2020 2020 2020 2020 202e 636f 6c6c             .coll
-00018ee0: 6563 7428 293b 0a0a 2020 2020 2020 2020  ect();..        
-00018ef0: 2020 2020 6c65 7420 6465 6c74 615f 663a      let delta_f:
-00018f00: 2056 6563 3c5f 3e20 3d20 6465 6c74 610a   Vec<_> = delta.
-00018f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018f20: 2e69 6e74 6f5f 6974 6572 2829 0a20 2020  .into_iter().   
-00018f30: 2020 2020 2020 2020 2020 2020 202e 6d61               .ma
-00018f40: 7028 7c66 7c20 7b0a 2020 2020 2020 2020  p(|f| {.        
-00018f50: 2020 2020 2020 2020 2020 2020 662e 6d61              f.ma
-00018f60: 705f 636f 6566 6628 0a20 2020 2020 2020  p_coeff(.       
-00018f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018f80: 207c 637c 2066 6965 6c64 5f6d 6f64 2e66   |c| field_mod.f
-00018f90: 726f 6d5f 656c 656d 656e 7428 6329 2e74  rom_element(c).t
-00018fa0: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
-00018fb0: 736d 616c 6c5f 6669 656c 645f 6d6f 6429  small_field_mod)
-00018fc0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00018fd0: 2020 2020 2020 2020 2020 736d 616c 6c5f            small_
-00018fe0: 6669 656c 645f 6d6f 642e 636c 6f6e 6528  field_mod.clone(
-00018ff0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00019000: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00019010: 2020 2020 2020 2020 207d 290a 2020 2020           }).    
-00019020: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
-00019030: 6c65 6374 2829 3b0a 0a20 2020 2020 2020  lect();..       
-00019040: 2020 2020 206c 6574 2073 616d 706c 655f       let sample_
-00019050: 706f 696e 7473 3a20 5665 633c 5f3e 203d  points: Vec<_> =
-00019060: 2073 616d 706c 655f 706f 696e 7473 0a20   sample_points. 
-00019070: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00019080: 6974 6572 2829 0a20 2020 2020 2020 2020  iter().         
-00019090: 2020 2020 2020 202e 6d61 7028 7c28 762c         .map(|(v,
-000190a0: 2070 297c 2028 2a76 2c20 702e 746f 5f66   p)| (*v, p.to_f
-000190b0: 696e 6974 655f 6669 656c 6428 2673 6d61  inite_field(&sma
-000190c0: 6c6c 5f66 6965 6c64 5f6d 6f64 2929 290a  ll_field_mod))).
-000190d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000190e0: 2e63 6f6c 6c65 6374 2829 3b0a 0a20 2020  .collect();..   
-000190f0: 2020 2020 2020 2020 206c 6574 2066 6163           let fac
-00019100: 746f 7269 7a61 7469 6f6e 5f66 6620 3d20  torization_ff = 
-00019110: 706f 6c79 5f66 662e 6d75 6c74 6976 6172  poly_ff.multivar
-00019120: 6961 7465 5f68 656e 7365 6c5f 6c69 6674  iate_hensel_lift
-00019130: 696e 6728 0a20 2020 2020 2020 2020 2020  ing(.           
-00019140: 2020 2020 2026 736f 7274 6564 5f62 6976       &sorted_biv
-00019150: 5f66 6163 746f 7273 5f66 662c 0a20 2020  _factors_ff,.   
-00019160: 2020 2020 2020 2020 2020 2020 2026 6d75               &mu
-00019170: 7420 756e 695f 662c 0a20 2020 2020 2020  t uni_f,.       
-00019180: 2020 2020 2020 2020 2026 6465 6c74 615f           &delta_
-00019190: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
-000191a0: 2020 2026 7361 6d70 6c65 5f70 6f69 6e74     &sample_point
-000191b0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
-000191c0: 2020 2053 6f6d 6528 2674 7275 655f 6c63     Some(&true_lc
-000191d0: 6f65 6666 735f 6666 292c 0a20 2020 2020  oeffs_ff),.     
-000191e0: 2020 2020 2020 2020 2020 206f 7264 6572             order
-000191f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00019200: 2020 322c 0a20 2020 2020 2020 2020 2020    2,.           
-00019210: 2029 3b0a 2020 2020 2020 2020 2020 2020   );.            
-00019220: 6661 6374 6f72 697a 6174 696f 6e5f 6666  factorization_ff
-00019230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00019240: 202e 696e 746f 5f69 7465 7228 290a 2020   .into_iter().  
-00019250: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
-00019260: 6170 287c 667c 207b 0a20 2020 2020 2020  ap(|f| {.       
-00019270: 2020 2020 2020 2020 2020 2020 2066 2e6d               f.m
-00019280: 6170 5f63 6f65 6666 280a 2020 2020 2020  ap_coeff(.      
+00018cf0: 7c63 7c20 6669 656c 645f 6d6f 642e 6672  |c| field_mod.fr
+00018d00: 6f6d 5f65 6c65 6d65 6e74 2863 292e 746f  om_element(c).to
+00018d10: 5f66 696e 6974 655f 6669 656c 6428 2673  _finite_field(&s
+00018d20: 6d61 6c6c 5f66 6965 6c64 5f6d 6f64 292c  mall_field_mod),
+00018d30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018d40: 2020 2020 2020 2020 2073 6d61 6c6c 5f66           small_f
+00018d50: 6965 6c64 5f6d 6f64 2e63 6c6f 6e65 2829  ield_mod.clone()
+00018d60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00018d70: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00018d80: 2020 2020 2020 2020 7d29 0a20 2020 2020          }).     
+00018d90: 2020 2020 2020 2020 2020 202e 636f 6c6c             .coll
+00018da0: 6563 7428 293b 0a0a 2020 2020 2020 2020  ect();..        
+00018db0: 2020 2020 6c65 7420 6465 6c74 615f 663a      let delta_f:
+00018dc0: 2056 6563 3c5f 3e20 3d20 6465 6c74 610a   Vec<_> = delta.
+00018dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018de0: 2e69 6e74 6f5f 6974 6572 2829 0a20 2020  .into_iter().   
+00018df0: 2020 2020 2020 2020 2020 2020 202e 6d61               .ma
+00018e00: 7028 7c66 7c20 7b0a 2020 2020 2020 2020  p(|f| {.        
+00018e10: 2020 2020 2020 2020 2020 2020 662e 6d61              f.ma
+00018e20: 705f 636f 6566 6628 0a20 2020 2020 2020  p_coeff(.       
+00018e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018e40: 207c 637c 2066 6965 6c64 5f6d 6f64 2e66   |c| field_mod.f
+00018e50: 726f 6d5f 656c 656d 656e 7428 6329 2e74  rom_element(c).t
+00018e60: 6f5f 6669 6e69 7465 5f66 6965 6c64 2826  o_finite_field(&
+00018e70: 736d 616c 6c5f 6669 656c 645f 6d6f 6429  small_field_mod)
+00018e80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00018e90: 2020 2020 2020 2020 2020 736d 616c 6c5f            small_
+00018ea0: 6669 656c 645f 6d6f 642e 636c 6f6e 6528  field_mod.clone(
+00018eb0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00018ec0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00018ed0: 2020 2020 2020 2020 207d 290a 2020 2020           }).    
+00018ee0: 2020 2020 2020 2020 2020 2020 2e63 6f6c              .col
+00018ef0: 6c65 6374 2829 3b0a 0a20 2020 2020 2020  lect();..       
+00018f00: 2020 2020 206c 6574 2073 616d 706c 655f       let sample_
+00018f10: 706f 696e 7473 3a20 5665 633c 5f3e 203d  points: Vec<_> =
+00018f20: 2073 616d 706c 655f 706f 696e 7473 0a20   sample_points. 
+00018f30: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+00018f40: 6974 6572 2829 0a20 2020 2020 2020 2020  iter().         
+00018f50: 2020 2020 2020 202e 6d61 7028 7c28 762c         .map(|(v,
+00018f60: 2070 297c 2028 2a76 2c20 702e 746f 5f66   p)| (*v, p.to_f
+00018f70: 696e 6974 655f 6669 656c 6428 2673 6d61  inite_field(&sma
+00018f80: 6c6c 5f66 6965 6c64 5f6d 6f64 2929 290a  ll_field_mod))).
+00018f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018fa0: 2e63 6f6c 6c65 6374 2829 3b0a 0a20 2020  .collect();..   
+00018fb0: 2020 2020 2020 2020 206c 6574 2066 6163           let fac
+00018fc0: 746f 7269 7a61 7469 6f6e 5f66 6620 3d20  torization_ff = 
+00018fd0: 706f 6c79 5f66 662e 6d75 6c74 6976 6172  poly_ff.multivar
+00018fe0: 6961 7465 5f68 656e 7365 6c5f 6c69 6674  iate_hensel_lift
+00018ff0: 696e 6728 0a20 2020 2020 2020 2020 2020  ing(.           
+00019000: 2020 2020 2026 736f 7274 6564 5f62 6976       &sorted_biv
+00019010: 5f66 6163 746f 7273 5f66 662c 0a20 2020  _factors_ff,.   
+00019020: 2020 2020 2020 2020 2020 2020 2026 6d75               &mu
+00019030: 7420 756e 695f 662c 0a20 2020 2020 2020  t uni_f,.       
+00019040: 2020 2020 2020 2020 2026 6465 6c74 615f           &delta_
+00019050: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
+00019060: 2020 2026 7361 6d70 6c65 5f70 6f69 6e74     &sample_point
+00019070: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00019080: 2020 2053 6f6d 6528 2674 7275 655f 6c63     Some(&true_lc
+00019090: 6f65 6666 735f 6666 292c 0a20 2020 2020  oeffs_ff),.     
+000190a0: 2020 2020 2020 2020 2020 206f 7264 6572             order
+000190b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000190c0: 2020 322c 0a20 2020 2020 2020 2020 2020    2,.           
+000190d0: 2029 3b0a 2020 2020 2020 2020 2020 2020   );.            
+000190e0: 6661 6374 6f72 697a 6174 696f 6e5f 6666  factorization_ff
+000190f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019100: 202e 696e 746f 5f69 7465 7228 290a 2020   .into_iter().  
+00019110: 2020 2020 2020 2020 2020 2020 2020 2e6d                .m
+00019120: 6170 287c 667c 2066 2e6d 6170 5f63 6f65  ap(|f| f.map_coe
+00019130: 6666 287c 637c 2073 6d61 6c6c 5f66 6965  ff(|c| small_fie
+00019140: 6c64 5f6d 6f64 2e74 6f5f 7379 6d6d 6574  ld_mod.to_symmet
+00019150: 7269 635f 696e 7465 6765 7228 6329 2c20  ric_integer(c), 
+00019160: 5a29 290a 2020 2020 2020 2020 2020 2020  Z)).            
+00019170: 2020 2020 2e63 6f6c 6c65 6374 2829 0a20      .collect(). 
+00019180: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
+00019190: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
+000191a0: 6669 656c 645f 6d6f 6420 3d20 4669 6e69  field_mod = Fini
+000191b0: 7465 4669 656c 643a 3a3c 496e 7465 6765  teField::<Intege
+000191c0: 723e 3a3a 6e65 7728 6d61 785f 702e 636c  r>::new(max_p.cl
+000191d0: 6f6e 6528 2929 3b0a 0a20 2020 2020 2020  one());..       
+000191e0: 2020 2020 206c 6574 2070 6f6c 795f 6666       let poly_ff
+000191f0: 203d 2073 656c 662e 6d61 705f 636f 6566   = self.map_coef
+00019200: 6628 7c63 7c20 6669 656c 645f 6d6f 642e  f(|c| field_mod.
+00019210: 746f 5f65 6c65 6d65 6e74 2863 2e63 6c6f  to_element(c.clo
+00019220: 6e65 2829 292c 2066 6965 6c64 5f6d 6f64  ne()), field_mod
+00019230: 2e63 6c6f 6e65 2829 293b 0a0a 2020 2020  .clone());..    
+00019240: 2020 2020 2020 2020 6c65 7420 7472 7565          let true
+00019250: 5f6c 636f 6566 6673 5f66 663a 2056 6563  _lcoeffs_ff: Vec
+00019260: 3c5f 3e20 3d20 7472 7565 5f6c 636f 6566  <_> = true_lcoef
+00019270: 6673 0a20 2020 2020 2020 2020 2020 2020  fs.             
+00019280: 2020 202e 696e 746f 5f69 7465 7228 290a     .into_iter().
 00019290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000192a0: 2020 7c63 7c20 736d 616c 6c5f 6669 656c    |c| small_fiel
-000192b0: 645f 6d6f 642e 746f 5f73 796d 6d65 7472  d_mod.to_symmetr
-000192c0: 6963 5f69 6e74 6567 6572 2863 292c 0a20  ic_integer(c),. 
-000192d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000192e0: 2020 2020 2020 2049 6e74 6567 6572 5269         IntegerRi
-000192f0: 6e67 3a3a 6e65 7728 292c 0a20 2020 2020  ng::new(),.     
-00019300: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00019310: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00019320: 207d 290a 2020 2020 2020 2020 2020 2020   }).            
-00019330: 2020 2020 2e63 6f6c 6c65 6374 2829 0a20      .collect(). 
-00019340: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
-00019350: 2020 2020 2020 2020 2020 2020 6c65 7420              let 
-00019360: 6669 656c 645f 6d6f 6420 3d20 4669 6e69  field_mod = Fini
-00019370: 7465 4669 656c 643a 3a3c 496e 7465 6765  teField::<Intege
-00019380: 723e 3a3a 6e65 7728 6d61 785f 702e 636c  r>::new(max_p.cl
-00019390: 6f6e 6528 2929 3b0a 0a20 2020 2020 2020  one());..       
-000193a0: 2020 2020 206c 6574 2070 6f6c 795f 6666       let poly_ff
-000193b0: 203d 2073 656c 662e 6d61 705f 636f 6566   = self.map_coef
-000193c0: 6628 7c63 7c20 6669 656c 645f 6d6f 642e  f(|c| field_mod.
-000193d0: 746f 5f65 6c65 6d65 6e74 2863 2e63 6c6f  to_element(c.clo
-000193e0: 6e65 2829 292c 2066 6965 6c64 5f6d 6f64  ne()), field_mod
-000193f0: 2e63 6c6f 6e65 2829 293b 0a0a 2020 2020  .clone());..    
-00019400: 2020 2020 2020 2020 6c65 7420 7472 7565          let true
-00019410: 5f6c 636f 6566 6673 5f66 663a 2056 6563  _lcoeffs_ff: Vec
-00019420: 3c5f 3e20 3d20 7472 7565 5f6c 636f 6566  <_> = true_lcoef
-00019430: 6673 0a20 2020 2020 2020 2020 2020 2020  fs.             
-00019440: 2020 202e 696e 746f 5f69 7465 7228 290a     .into_iter().
-00019450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019460: 2e6d 6170 287c 667c 2066 2e6d 6170 5f63  .map(|f| f.map_c
-00019470: 6f65 6666 287c 637c 2066 6965 6c64 5f6d  oeff(|c| field_m
-00019480: 6f64 2e74 6f5f 656c 656d 656e 7428 632e  od.to_element(c.
-00019490: 636c 6f6e 6528 2929 2c20 6669 656c 645f  clone()), field_
-000194a0: 6d6f 642e 636c 6f6e 6528 2929 290a 2020  mod.clone())).  
-000194b0: 2020 2020 2020 2020 2020 2020 2020 2e63                .c
-000194c0: 6f6c 6c65 6374 2829 3b0a 0a20 2020 2020  ollect();..     
-000194d0: 2020 2020 2020 206c 6574 2066 6163 746f         let facto
-000194e0: 7269 7a61 7469 6f6e 5f66 6620 3d20 706f  rization_ff = po
-000194f0: 6c79 5f66 662e 6d75 6c74 6976 6172 6961  ly_ff.multivaria
-00019500: 7465 5f68 656e 7365 6c5f 6c69 6674 696e  te_hensel_liftin
-00019510: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
-00019520: 2020 2026 736f 7274 6564 5f62 6976 5f66     &sorted_biv_f
-00019530: 6163 746f 7273 5f66 662c 0a20 2020 2020  actors_ff,.     
-00019540: 2020 2020 2020 2020 2020 2026 6d75 7420             &mut 
-00019550: 756e 692c 0a20 2020 2020 2020 2020 2020  uni,.           
-00019560: 2020 2020 2026 6465 6c74 612c 0a20 2020       &delta,.   
-00019570: 2020 2020 2020 2020 2020 2020 2026 7361               &sa
-00019580: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
-00019590: 2020 2020 2020 2020 2020 2020 2053 6f6d               Som
-000195a0: 6528 2674 7275 655f 6c63 6f65 6666 735f  e(&true_lcoeffs_
-000195b0: 6666 292c 0a20 2020 2020 2020 2020 2020  ff),.           
-000195c0: 2020 2020 206f 7264 6572 2c0a 2020 2020       order,.    
-000195d0: 2020 2020 2020 2020 2020 2020 322c 0a20              2,. 
-000195e0: 2020 2020 2020 2020 2020 2029 3b0a 2020             );.  
-000195f0: 2020 2020 2020 2020 2020 6661 6374 6f72            factor
-00019600: 697a 6174 696f 6e5f 6666 0a20 2020 2020  ization_ff.     
-00019610: 2020 2020 2020 2020 2020 202e 696e 746f             .into
-00019620: 5f69 7465 7228 290a 2020 2020 2020 2020  _iter().        
-00019630: 2020 2020 2020 2020 2e6d 6170 287c 667c          .map(|f|
-00019640: 2066 2e6d 6170 5f63 6f65 6666 287c 637c   f.map_coeff(|c|
-00019650: 2066 6965 6c64 5f6d 6f64 2e74 6f5f 7379   field_mod.to_sy
-00019660: 6d6d 6574 7269 635f 696e 7465 6765 7228  mmetric_integer(
-00019670: 6329 2c20 496e 7465 6765 7252 696e 673a  c), IntegerRing:
-00019680: 3a6e 6577 2829 2929 0a20 2020 2020 2020  :new())).       
-00019690: 2020 2020 2020 2020 202e 636f 6c6c 6563           .collec
-000196a0: 7428 290a 2020 2020 2020 2020 7d3b 0a0a  t().        };..
-000196b0: 2020 2020 2020 2020 2f2f 2074 6573 7420          // test 
-000196c0: 7468 6520 6661 6374 6f72 697a 6174 696f  the factorizatio
-000196d0: 6e0a 2020 2020 2020 2020 6c65 7420 6d75  n.        let mu
-000196e0: 7420 7465 7374 203d 2073 656c 662e 6f6e  t test = self.on
-000196f0: 6528 293b 0a20 2020 2020 2020 2066 6f72  e();.        for
-00019700: 2066 2069 6e20 2666 6163 746f 7269 7a61   f in &factoriza
-00019710: 7469 6f6e 207b 0a20 2020 2020 2020 2020  tion {.         
-00019720: 2020 2064 6562 7567 2128 2246 6163 746f     debug!("Facto
-00019730: 7220 3d20 7b7d 222c 2066 293b 0a20 2020  r = {}", f);.   
-00019740: 2020 2020 2020 2020 2074 6573 7420 3d20           test = 
-00019750: 2674 6573 7420 2a20 663b 0a20 2020 2020  &test * f;.     
-00019760: 2020 207d 0a0a 2020 2020 2020 2020 6966     }..        if
-00019770: 2026 7465 7374 203d 3d20 7365 6c66 207b   &test == self {
-00019780: 0a20 2020 2020 2020 2020 2020 2066 6163  .            fac
-00019790: 746f 7269 7a61 7469 6f6e 0a20 2020 2020  torization.     
-000197a0: 2020 207d 2065 6c73 6520 7b0a 2020 2020     } else {.    
-000197b0: 2020 2020 2020 2020 6c65 7420 6e65 775f          let new_
-000197c0: 626f 756e 6420 3d20 6d61 785f 6269 7661  bound = max_biva
-000197d0: 7269 6174 655f 6661 6374 6f72 732e 756e  riate_factors.un
-000197e0: 7772 6170 5f6f 7228 6269 7661 7269 6174  wrap_or(bivariat
-000197f0: 655f 6661 6374 6f72 732e 6c65 6e28 2929  e_factors.len())
-00019800: 202d 2031 3b0a 2020 2020 2020 2020 2020   - 1;.          
-00019810: 2020 6465 6275 6721 280a 2020 2020 2020    debug!(.      
-00019820: 2020 2020 2020 2020 2020 224e 6f20 696d            "No im
-00019830: 6d65 6469 6174 6520 6661 6374 6f72 697a  mediate factoriz
-00019840: 6174 696f 6e20 6f66 207b 7d20 666f 7220  ation of {} for 
-00019850: 7361 6d70 6c65 2070 6f69 6e74 7320 7b3a  sample points {:
-00019860: 3f7d 2c20 6e65 7720 626f 756e 6420 6f66  ?}, new bound of
-00019870: 2062 6976 6172 6961 7465 2066 6163 746f   bivariate facto
-00019880: 7273 3a20 7b7d 222c 0a20 2020 2020 2020  rs: {}",.       
-00019890: 2020 2020 2020 2020 2073 656c 662c 2073           self, s
-000198a0: 616d 706c 655f 706f 696e 7473 2c20 6e65  ample_points, ne
-000198b0: 775f 626f 756e 640a 2020 2020 2020 2020  w_bound.        
-000198c0: 2020 2020 293b 0a0a 2020 2020 2020 2020      );..        
-000198d0: 2020 2020 2f2f 2074 6865 2062 6976 6172      // the bivar
-000198e0: 6961 7465 2066 6163 746f 7269 7a61 7469  iate factorizati
-000198f0: 6f6e 2068 6173 2074 6f6f 206d 616e 7920  on has too many 
-00019900: 6661 6374 6f72 732c 2074 7279 2061 6761  factors, try aga
-00019910: 696e 2077 6974 6820 6f74 6865 7220 7361  in with other sa
-00019920: 6d70 6c65 2070 6f69 6e74 730a 2020 2020  mple points.    
-00019930: 2020 2020 2020 2020 7365 6c66 2e6d 756c          self.mul
-00019940: 7469 7661 7269 6174 655f 6661 6374 6f72  tivariate_factor
-00019950: 697a 6174 696f 6e28 6f72 6465 722c 2063  ization(order, c
-00019960: 6f65 6666 6963 6965 6e74 5f75 7070 6572  oefficient_upper
-00019970: 5f62 6f75 6e64 202b 2031 2c20 536f 6d65  _bound + 1, Some
-00019980: 286e 6577 5f62 6f75 6e64 2929 0a20 2020  (new_bound)).   
-00019990: 2020 2020 207d 0a20 2020 207d 0a7d 0a0a       }.    }.}..
-000199a0: 696d 706c 3c45 3a20 4578 706f 6e65 6e74  impl<E: Exponent
-000199b0: 3e20 4d75 6c74 6976 6172 6961 7465 506f  > MultivariatePo
-000199c0: 6c79 6e6f 6d69 616c 3c46 696e 6974 6546  lynomial<FiniteF
-000199d0: 6965 6c64 3c49 6e74 6567 6572 3e2c 2045  ield<Integer>, E
-000199e0: 2c20 4c65 784f 7264 6572 3e20 7b0a 2020  , LexOrder> {.  
-000199f0: 2020 2f2f 2f20 436f 6d70 7574 6520 6120    /// Compute a 
-00019a00: 756e 6976 6172 6961 7465 2064 696f 7068  univariate dioph
-00019a10: 616e 7469 6e65 2065 7175 6174 696f 6e20  antine equation 
-00019a20: 696e 2060 5a5f 705e 6b60 2062 7920 4e65  in `Z_p^k` by Ne
-00019a30: 7774 6f6e 2069 7465 7261 7469 6f6e 2e0a  wton iteration..
-00019a40: 2020 2020 666e 2067 6574 5f75 6e69 7661      fn get_univa
-00019a50: 7269 6174 655f 6661 6374 6f72 735f 616e  riate_factors_an
-00019a60: 645f 6465 6c74 6173 280a 2020 2020 2020  d_deltas(.      
-00019a70: 2020 6661 6374 6f72 733a 2026 5b53 656c    factors: &[Sel
-00019a80: 665d 2c0a 2020 2020 2020 2020 6f72 6465  f],.        orde
-00019a90: 723a 2026 5b75 7369 7a65 5d2c 0a20 2020  r: &[usize],.   
-00019aa0: 2020 2020 2073 616d 706c 655f 706f 696e       sample_poin
-00019ab0: 7473 3a20 265b 2875 7369 7a65 2c20 496e  ts: &[(usize, In
-00019ac0: 7465 6765 7229 5d2c 0a20 2020 2020 2020  teger)],.       
-00019ad0: 2070 3a20 7533 322c 0a20 2020 2020 2020   p: u32,.       
-00019ae0: 206b 3a20 7573 697a 652c 0a20 2020 2029   k: usize,.    )
-00019af0: 202d 3e20 2856 6563 3c53 656c 663e 2c20   -> (Vec<Self>, 
-00019b00: 5665 633c 5365 6c66 3e29 207b 0a20 2020  Vec<Self>) {.   
-00019b10: 2020 2020 202f 2f20 7072 6f64 7563 6520       // produce 
-00019b20: 756e 6976 6172 6961 7465 2066 6163 746f  univariate facto
-00019b30: 7273 2061 6e64 2075 6e69 7661 7269 6174  rs and univariat
-00019b40: 6520 6465 6c74 610a 2020 2020 2020 2020  e delta.        
-00019b50: 6c65 7420 6d75 7420 756e 6976 6172 6961  let mut univaria
-00019b60: 7465 5f66 6163 746f 7273 203d 2066 6163  te_factors = fac
-00019b70: 746f 7273 2e74 6f5f 7665 6328 293b 0a20  tors.to_vec();. 
-00019b80: 2020 2020 2020 2066 6f72 2066 2069 6e20         for f in 
-00019b90: 266d 7574 2075 6e69 7661 7269 6174 655f  &mut univariate_
-00019ba0: 6661 6374 6f72 7320 7b0a 2020 2020 2020  factors {.      
-00019bb0: 2020 2020 2020 666f 7220 2876 2c20 7329        for (v, s)
-00019bc0: 2069 6e20 7361 6d70 6c65 5f70 6f69 6e74   in sample_point
-00019bd0: 7320 7b0a 2020 2020 2020 2020 2020 2020  s {.            
-00019be0: 2020 2020 6966 206f 7264 6572 5b30 5d20      if order[0] 
-00019bf0: 213d 202a 7620 7b0a 2020 2020 2020 2020  != *v {.        
-00019c00: 2020 2020 2020 2020 2020 2020 2a66 203d              *f =
-00019c10: 2066 2e72 6570 6c61 6365 282a 762c 2073   f.replace(*v, s
-00019c20: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00019c30: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00019c40: 207d 0a20 2020 2020 2020 207d 0a0a 2020   }.        }..  
-00019c50: 2020 2020 2020 6c65 7420 756e 6976 6172        let univar
-00019c60: 6961 7465 5f64 656c 7461 7320 3d20 4d75  iate_deltas = Mu
-00019c70: 6c74 6976 6172 6961 7465 506f 6c79 6e6f  ltivariatePolyno
-00019c80: 6d69 616c 3a3a 6c69 6674 5f64 696f 7068  mial::lift_dioph
-00019c90: 616e 7469 6e65 5f75 6e69 7661 7269 6174  antine_univariat
-00019ca0: 6528 0a20 2020 2020 2020 2020 2020 2026  e(.            &
-00019cb0: 6d75 7420 756e 6976 6172 6961 7465 5f66  mut univariate_f
-00019cc0: 6163 746f 7273 2c0a 2020 2020 2020 2020  actors,.        
-00019cd0: 2020 2020 2666 6163 746f 7273 5b30 5d2e      &factors[0].
-00019ce0: 636f 6e73 7461 6e74 2866 6163 746f 7273  constant(factors
-00019cf0: 5b30 5d2e 6669 656c 642e 6f6e 6528 2929  [0].field.one())
-00019d00: 2c0a 2020 2020 2020 2020 2020 2020 702c  ,.            p,
-00019d10: 0a20 2020 2020 2020 2020 2020 206b 2c0a  .            k,.
-00019d20: 2020 2020 2020 2020 293b 0a0a 2020 2020          );..    
-00019d30: 2020 2020 2875 6e69 7661 7269 6174 655f      (univariate_
-00019d40: 6661 6374 6f72 732c 2075 6e69 7661 7269  factors, univari
-00019d50: 6174 655f 6465 6c74 6173 290a 2020 2020  ate_deltas).    
-00019d60: 7d0a 7d0a                                }.}.
+000192a0: 2e6d 6170 287c 667c 2066 2e6d 6170 5f63  .map(|f| f.map_c
+000192b0: 6f65 6666 287c 637c 2066 6965 6c64 5f6d  oeff(|c| field_m
+000192c0: 6f64 2e74 6f5f 656c 656d 656e 7428 632e  od.to_element(c.
+000192d0: 636c 6f6e 6528 2929 2c20 6669 656c 645f  clone()), field_
+000192e0: 6d6f 642e 636c 6f6e 6528 2929 290a 2020  mod.clone())).  
+000192f0: 2020 2020 2020 2020 2020 2020 2020 2e63                .c
+00019300: 6f6c 6c65 6374 2829 3b0a 0a20 2020 2020  ollect();..     
+00019310: 2020 2020 2020 206c 6574 2066 6163 746f         let facto
+00019320: 7269 7a61 7469 6f6e 5f66 6620 3d20 706f  rization_ff = po
+00019330: 6c79 5f66 662e 6d75 6c74 6976 6172 6961  ly_ff.multivaria
+00019340: 7465 5f68 656e 7365 6c5f 6c69 6674 696e  te_hensel_liftin
+00019350: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
+00019360: 2020 2026 736f 7274 6564 5f62 6976 5f66     &sorted_biv_f
+00019370: 6163 746f 7273 5f66 662c 0a20 2020 2020  actors_ff,.     
+00019380: 2020 2020 2020 2020 2020 2026 6d75 7420             &mut 
+00019390: 756e 692c 0a20 2020 2020 2020 2020 2020  uni,.           
+000193a0: 2020 2020 2026 6465 6c74 612c 0a20 2020       &delta,.   
+000193b0: 2020 2020 2020 2020 2020 2020 2026 7361               &sa
+000193c0: 6d70 6c65 5f70 6f69 6e74 732c 0a20 2020  mple_points,.   
+000193d0: 2020 2020 2020 2020 2020 2020 2053 6f6d               Som
+000193e0: 6528 2674 7275 655f 6c63 6f65 6666 735f  e(&true_lcoeffs_
+000193f0: 6666 292c 0a20 2020 2020 2020 2020 2020  ff),.           
+00019400: 2020 2020 206f 7264 6572 2c0a 2020 2020       order,.    
+00019410: 2020 2020 2020 2020 2020 2020 322c 0a20              2,. 
+00019420: 2020 2020 2020 2020 2020 2029 3b0a 2020             );.  
+00019430: 2020 2020 2020 2020 2020 6661 6374 6f72            factor
+00019440: 697a 6174 696f 6e5f 6666 0a20 2020 2020  ization_ff.     
+00019450: 2020 2020 2020 2020 2020 202e 696e 746f             .into
+00019460: 5f69 7465 7228 290a 2020 2020 2020 2020  _iter().        
+00019470: 2020 2020 2020 2020 2e6d 6170 287c 667c          .map(|f|
+00019480: 2066 2e6d 6170 5f63 6f65 6666 287c 637c   f.map_coeff(|c|
+00019490: 2066 6965 6c64 5f6d 6f64 2e74 6f5f 7379   field_mod.to_sy
+000194a0: 6d6d 6574 7269 635f 696e 7465 6765 7228  mmetric_integer(
+000194b0: 6329 2c20 5a29 290a 2020 2020 2020 2020  c), Z)).        
+000194c0: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
+000194d0: 2829 0a20 2020 2020 2020 207d 3b0a 0a20  ().        };.. 
+000194e0: 2020 2020 2020 202f 2f20 7465 7374 2074         // test t
+000194f0: 6865 2066 6163 746f 7269 7a61 7469 6f6e  he factorization
+00019500: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00019510: 2074 6573 7420 3d20 7365 6c66 2e6f 6e65   test = self.one
+00019520: 2829 3b0a 2020 2020 2020 2020 666f 7220  ();.        for 
+00019530: 6620 696e 2026 6661 6374 6f72 697a 6174  f in &factorizat
+00019540: 696f 6e20 7b0a 2020 2020 2020 2020 2020  ion {.          
+00019550: 2020 6465 6275 6721 2822 4661 6374 6f72    debug!("Factor
+00019560: 203d 207b 7d22 2c20 6629 3b0a 2020 2020   = {}", f);.    
+00019570: 2020 2020 2020 2020 7465 7374 203d 2026          test = &
+00019580: 7465 7374 202a 2066 3b0a 2020 2020 2020  test * f;.      
+00019590: 2020 7d0a 0a20 2020 2020 2020 2069 6620    }..        if 
+000195a0: 2674 6573 7420 3d3d 2073 656c 6620 7b0a  &test == self {.
+000195b0: 2020 2020 2020 2020 2020 2020 6661 6374              fact
+000195c0: 6f72 697a 6174 696f 6e0a 2020 2020 2020  orization.      
+000195d0: 2020 7d20 656c 7365 207b 0a20 2020 2020    } else {.     
+000195e0: 2020 2020 2020 206c 6574 206e 6577 5f62         let new_b
+000195f0: 6f75 6e64 203d 206d 6178 5f62 6976 6172  ound = max_bivar
+00019600: 6961 7465 5f66 6163 746f 7273 2e75 6e77  iate_factors.unw
+00019610: 7261 705f 6f72 2862 6976 6172 6961 7465  rap_or(bivariate
+00019620: 5f66 6163 746f 7273 2e6c 656e 2829 2920  _factors.len()) 
+00019630: 2d20 313b 0a20 2020 2020 2020 2020 2020  - 1;.           
+00019640: 2064 6562 7567 2128 0a20 2020 2020 2020   debug!(.       
+00019650: 2020 2020 2020 2020 2022 4e6f 2069 6d6d           "No imm
+00019660: 6564 6961 7465 2066 6163 746f 7269 7a61  ediate factoriza
+00019670: 7469 6f6e 206f 6620 7b7d 2066 6f72 2073  tion of {} for s
+00019680: 616d 706c 6520 706f 696e 7473 207b 3a3f  ample points {:?
+00019690: 7d2c 206e 6577 2062 6f75 6e64 206f 6620  }, new bound of 
+000196a0: 6269 7661 7269 6174 6520 6661 6374 6f72  bivariate factor
+000196b0: 733a 207b 7d22 2c0a 2020 2020 2020 2020  s: {}",.        
+000196c0: 2020 2020 2020 2020 7365 6c66 2c20 7361          self, sa
+000196d0: 6d70 6c65 5f70 6f69 6e74 732c 206e 6577  mple_points, new
+000196e0: 5f62 6f75 6e64 0a20 2020 2020 2020 2020  _bound.         
+000196f0: 2020 2029 3b0a 0a20 2020 2020 2020 2020     );..         
+00019700: 2020 202f 2f20 7468 6520 6269 7661 7269     // the bivari
+00019710: 6174 6520 6661 6374 6f72 697a 6174 696f  ate factorizatio
+00019720: 6e20 6861 7320 746f 6f20 6d61 6e79 2066  n has too many f
+00019730: 6163 746f 7273 2c20 7472 7920 6167 6169  actors, try agai
+00019740: 6e20 7769 7468 206f 7468 6572 2073 616d  n with other sam
+00019750: 706c 6520 706f 696e 7473 0a20 2020 2020  ple points.     
+00019760: 2020 2020 2020 2073 656c 662e 6d75 6c74         self.mult
+00019770: 6976 6172 6961 7465 5f66 6163 746f 7269  ivariate_factori
+00019780: 7a61 7469 6f6e 286f 7264 6572 2c20 636f  zation(order, co
+00019790: 6566 6669 6369 656e 745f 7570 7065 725f  efficient_upper_
+000197a0: 626f 756e 6420 2b20 312c 2053 6f6d 6528  bound + 1, Some(
+000197b0: 6e65 775f 626f 756e 6429 290a 2020 2020  new_bound)).    
+000197c0: 2020 2020 7d0a 2020 2020 7d0a 7d0a 0a69      }.    }.}..i
+000197d0: 6d70 6c3c 453a 2045 7870 6f6e 656e 743e  mpl<E: Exponent>
+000197e0: 204d 756c 7469 7661 7269 6174 6550 6f6c   MultivariatePol
+000197f0: 796e 6f6d 6961 6c3c 4669 6e69 7465 4669  ynomial<FiniteFi
+00019800: 656c 643c 496e 7465 6765 723e 2c20 452c  eld<Integer>, E,
+00019810: 204c 6578 4f72 6465 723e 207b 0a20 2020   LexOrder> {.   
+00019820: 202f 2f2f 2043 6f6d 7075 7465 2061 2075   /// Compute a u
+00019830: 6e69 7661 7269 6174 6520 6469 6f70 6861  nivariate diopha
+00019840: 6e74 696e 6520 6571 7561 7469 6f6e 2069  ntine equation i
+00019850: 6e20 605a 5f70 5e6b 6020 6279 204e 6577  n `Z_p^k` by New
+00019860: 746f 6e20 6974 6572 6174 696f 6e2e 0a20  ton iteration.. 
+00019870: 2020 2066 6e20 6765 745f 756e 6976 6172     fn get_univar
+00019880: 6961 7465 5f66 6163 746f 7273 5f61 6e64  iate_factors_and
+00019890: 5f64 656c 7461 7328 0a20 2020 2020 2020  _deltas(.       
+000198a0: 2066 6163 746f 7273 3a20 265b 5365 6c66   factors: &[Self
+000198b0: 5d2c 0a20 2020 2020 2020 206f 7264 6572  ],.        order
+000198c0: 3a20 265b 7573 697a 655d 2c0a 2020 2020  : &[usize],.    
+000198d0: 2020 2020 7361 6d70 6c65 5f70 6f69 6e74      sample_point
+000198e0: 733a 2026 5b28 7573 697a 652c 2049 6e74  s: &[(usize, Int
+000198f0: 6567 6572 295d 2c0a 2020 2020 2020 2020  eger)],.        
+00019900: 703a 2075 3332 2c0a 2020 2020 2020 2020  p: u32,.        
+00019910: 6b3a 2075 7369 7a65 2c0a 2020 2020 2920  k: usize,.    ) 
+00019920: 2d3e 2028 5665 633c 5365 6c66 3e2c 2056  -> (Vec<Self>, V
+00019930: 6563 3c53 656c 663e 2920 7b0a 2020 2020  ec<Self>) {.    
+00019940: 2020 2020 2f2f 2070 726f 6475 6365 2075      // produce u
+00019950: 6e69 7661 7269 6174 6520 6661 6374 6f72  nivariate factor
+00019960: 7320 616e 6420 756e 6976 6172 6961 7465  s and univariate
+00019970: 2064 656c 7461 0a20 2020 2020 2020 206c   delta.        l
+00019980: 6574 206d 7574 2075 6e69 7661 7269 6174  et mut univariat
+00019990: 655f 6661 6374 6f72 7320 3d20 6661 6374  e_factors = fact
+000199a0: 6f72 732e 746f 5f76 6563 2829 3b0a 2020  ors.to_vec();.  
+000199b0: 2020 2020 2020 666f 7220 6620 696e 2026        for f in &
+000199c0: 6d75 7420 756e 6976 6172 6961 7465 5f66  mut univariate_f
+000199d0: 6163 746f 7273 207b 0a20 2020 2020 2020  actors {.       
+000199e0: 2020 2020 2066 6f72 2028 762c 2073 2920       for (v, s) 
+000199f0: 696e 2073 616d 706c 655f 706f 696e 7473  in sample_points
+00019a00: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00019a10: 2020 2069 6620 6f72 6465 725b 305d 2021     if order[0] !
+00019a20: 3d20 2a76 207b 0a20 2020 2020 2020 2020  = *v {.         
+00019a30: 2020 2020 2020 2020 2020 202a 6620 3d20             *f = 
+00019a40: 662e 7265 706c 6163 6528 2a76 2c20 7329  f.replace(*v, s)
+00019a50: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00019a60: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
+00019a70: 7d0a 2020 2020 2020 2020 7d0a 0a20 2020  }.        }..   
+00019a80: 2020 2020 206c 6574 2075 6e69 7661 7269       let univari
+00019a90: 6174 655f 6465 6c74 6173 203d 204d 756c  ate_deltas = Mul
+00019aa0: 7469 7661 7269 6174 6550 6f6c 796e 6f6d  tivariatePolynom
+00019ab0: 6961 6c3a 3a6c 6966 745f 6469 6f70 6861  ial::lift_diopha
+00019ac0: 6e74 696e 655f 756e 6976 6172 6961 7465  ntine_univariate
+00019ad0: 280a 2020 2020 2020 2020 2020 2020 266d  (.            &m
+00019ae0: 7574 2075 6e69 7661 7269 6174 655f 6661  ut univariate_fa
+00019af0: 6374 6f72 732c 0a20 2020 2020 2020 2020  ctors,.         
+00019b00: 2020 2026 6661 6374 6f72 735b 305d 2e63     &factors[0].c
+00019b10: 6f6e 7374 616e 7428 6661 6374 6f72 735b  onstant(factors[
+00019b20: 305d 2e66 6965 6c64 2e6f 6e65 2829 292c  0].field.one()),
+00019b30: 0a20 2020 2020 2020 2020 2020 2070 2c0a  .            p,.
+00019b40: 2020 2020 2020 2020 2020 2020 6b2c 0a20              k,. 
+00019b50: 2020 2020 2020 2029 3b0a 0a20 2020 2020         );..     
+00019b60: 2020 2028 756e 6976 6172 6961 7465 5f66     (univariate_f
+00019b70: 6163 746f 7273 2c20 756e 6976 6172 6961  actors, univaria
+00019b80: 7465 5f64 656c 7461 7329 0a20 2020 207d  te_deltas).    }
+00019b90: 0a7d 0a0a 235b 6366 6728 7465 7374 295d  .}..#[cfg(test)]
+00019ba0: 0a6d 6f64 2074 6573 7420 7b0a 2020 2020  .mod test {.    
+00019bb0: 7573 6520 6372 6174 653a 3a7b 0a20 2020  use crate::{.   
+00019bc0: 2020 2020 2061 746f 6d3a 3a41 746f 6d2c       atom::Atom,
+00019bd0: 0a20 2020 2020 2020 2064 6f6d 6169 6e73  .        domains
+00019be0: 3a3a 7b66 696e 6974 655f 6669 656c 643a  ::{finite_field:
+00019bf0: 3a5a 702c 2069 6e74 6567 6572 3a3a 5a7d  :Zp, integer::Z}
+00019c00: 2c0a 2020 2020 2020 2020 706f 6c79 3a3a  ,.        poly::
+00019c10: 6661 6374 6f72 3a3a 4661 6374 6f72 697a  factor::Factoriz
+00019c20: 652c 0a20 2020 207d 3b0a 0a20 2020 2023  e,.    };..    #
+00019c30: 5b74 6573 745d 0a20 2020 2066 6e20 6661  [test].    fn fa
+00019c40: 6374 6f72 5f66 665f 7371 7561 7265 5f66  ctor_ff_square_f
+00019c50: 7265 6528 2920 7b0a 2020 2020 2020 2020  ree() {.        
+00019c60: 6c65 7420 6669 656c 6420 3d20 5a70 3a3a  let field = Zp::
+00019c70: 6e65 7728 3329 3b0a 2020 2020 2020 2020  new(3);.        
+00019c80: 6c65 7420 706f 6c79 203d 2041 746f 6d3a  let poly = Atom:
+00019c90: 3a70 6172 7365 2822 2831 2b76 3129 2a28  :parse("(1+v1)*(
+00019ca0: 312b 7631 5e32 295e 322a 2876 315e 342b  1+v1^2)^2*(v1^4+
+00019cb0: 3129 5e33 2229 0a20 2020 2020 2020 2020  1)^3").         
+00019cc0: 2020 202e 756e 7772 6170 2829 0a20 2020     .unwrap().   
+00019cd0: 2020 2020 2020 2020 202e 746f 5f70 6f6c           .to_pol
+00019ce0: 796e 6f6d 6961 6c3a 3a3c 5f2c 2075 383e  ynomial::<_, u8>
+00019cf0: 2826 6669 656c 642c 204e 6f6e 6529 3b0a  (&field, None);.
+00019d00: 0a20 2020 2020 2020 206c 6574 2072 6573  .        let res
+00019d10: 203d 205b 2822 312b 7631 5e34 222c 2033   = [("1+v1^4", 3
+00019d20: 292c 2028 2231 2b76 315e 3222 2c20 3229  ), ("1+v1^2", 2)
+00019d30: 2c20 2822 312b 7631 222c 2031 295d 3b0a  , ("1+v1", 1)];.
+00019d40: 0a20 2020 2020 2020 206c 6574 206d 7574  .        let mut
+00019d50: 2072 6573 203d 2072 6573 0a20 2020 2020   res = res.     
+00019d60: 2020 2020 2020 202e 6974 6572 2829 0a20         .iter(). 
+00019d70: 2020 2020 2020 2020 2020 202e 6d61 7028             .map(
+00019d80: 7c28 662c 2070 297c 207b 0a20 2020 2020  |(f, p)| {.     
+00019d90: 2020 2020 2020 2020 2020 2028 0a20 2020             (.   
+00019da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019db0: 2041 746f 6d3a 3a70 6172 7365 2866 290a   Atom::parse(f).
+00019dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019dd0: 2020 2020 2020 2020 2e75 6e77 7261 7028          .unwrap(
+00019de0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00019df0: 2020 2020 2020 2020 2020 2e65 7870 616e            .expan
+00019e00: 6428 290a 2020 2020 2020 2020 2020 2020  d().            
+00019e10: 2020 2020 2020 2020 2020 2020 2e74 6f5f              .to_
+00019e20: 706f 6c79 6e6f 6d69 616c 2826 6669 656c  polynomial(&fiel
+00019e30: 642c 2070 6f6c 792e 7661 7269 6162 6c65  d, poly.variable
+00019e40: 732e 636c 6f6e 6528 292e 696e 746f 2829  s.clone().into()
+00019e50: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00019e60: 2020 2020 2020 202a 702c 0a20 2020 2020         *p,.     
+00019e70: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00019e80: 2020 2020 2020 2020 207d 290a 2020 2020           }).    
+00019e90: 2020 2020 2020 2020 2e63 6f6c 6c65 6374          .collect
+00019ea0: 3a3a 3c56 6563 3c5f 3e3e 2829 3b0a 2020  ::<Vec<_>>();.  
+00019eb0: 2020 2020 2020 7265 732e 736f 7274 5f62        res.sort_b
+00019ec0: 7928 7c61 2c20 627c 2061 2e70 6172 7469  y(|a, b| a.parti
+00019ed0: 616c 5f63 6d70 2826 6229 2e75 6e77 7261  al_cmp(&b).unwra
+00019ee0: 7028 2929 3b0a 2020 2020 2020 2020 6c65  p());.        le
+00019ef0: 7420 6d75 7420 7220 3d20 706f 6c79 2e73  t mut r = poly.s
+00019f00: 7175 6172 655f 6672 6565 5f66 6163 746f  quare_free_facto
+00019f10: 7269 7a61 7469 6f6e 2829 3b0a 2020 2020  rization();.    
+00019f20: 2020 2020 722e 736f 7274 5f62 7928 7c61      r.sort_by(|a
+00019f30: 2c20 627c 2061 2e70 6172 7469 616c 5f63  , b| a.partial_c
+00019f40: 6d70 2826 6229 2e75 6e77 7261 7028 2929  mp(&b).unwrap())
+00019f50: 3b0a 0a20 2020 2020 2020 2061 7373 6572  ;..        asser
+00019f60: 745f 6571 2128 722c 2072 6573 293b 0a20  t_eq!(r, res);. 
+00019f70: 2020 207d 0a0a 2020 2020 235b 7465 7374     }..    #[test
+00019f80: 5d0a 2020 2020 666e 2066 6163 746f 725f  ].    fn factor_
+00019f90: 6666 5f62 6976 6172 6961 7465 2829 207b  ff_bivariate() {
+00019fa0: 0a20 2020 2020 2020 206c 6574 2066 6965  .        let fie
+00019fb0: 6c64 203d 205a 703a 3a6e 6577 2839 3937  ld = Zp::new(997
+00019fc0: 293b 0a20 2020 2020 2020 206c 6574 2070  );.        let p
+00019fd0: 6f6c 7920 3d20 4174 6f6d 3a3a 7061 7273  oly = Atom::pars
+00019fe0: 6528 2228 2876 322b 3129 2a76 315e 322b  e("((v2+1)*v1^2+
+00019ff0: 7631 2a76 322b 3129 2a28 2876 325e 322b  v1*v2+1)*((v2^2+
+0001a000: 3229 2a76 315e 322b 7632 2b31 2922 290a  2)*v1^2+v2+1)").
+0001a010: 2020 2020 2020 2020 2020 2020 2e75 6e77              .unw
+0001a020: 7261 7028 290a 2020 2020 2020 2020 2020  rap().          
+0001a030: 2020 2e74 6f5f 706f 6c79 6e6f 6d69 616c    .to_polynomial
+0001a040: 3a3a 3c5f 2c20 7538 3e28 2666 6965 6c64  ::<_, u8>(&field
+0001a050: 2c20 4e6f 6e65 293b 0a0a 2020 2020 2020  , None);..      
+0001a060: 2020 6c65 7420 7265 7320 3d20 5b28 2231    let res = [("1
+0001a070: 2b32 2a76 315e 322b 7632 2b76 325e 322a  +2*v1^2+v2+v2^2*
+0001a080: 7631 5e32 222c 2031 292c 2028 2231 2b76  v1^2", 1), ("1+v
+0001a090: 315e 322b 7632 2a76 312b 7632 2a76 315e  1^2+v2*v1+v2*v1^
+0001a0a0: 3222 2c20 3129 5d3b 0a0a 2020 2020 2020  2", 1)];..      
+0001a0b0: 2020 6c65 7420 6d75 7420 7265 7320 3d20    let mut res = 
+0001a0c0: 7265 730a 2020 2020 2020 2020 2020 2020  res.            
+0001a0d0: 2e69 7465 7228 290a 2020 2020 2020 2020  .iter().        
+0001a0e0: 2020 2020 2e6d 6170 287c 2866 2c20 7029      .map(|(f, p)
+0001a0f0: 7c20 7b0a 2020 2020 2020 2020 2020 2020  | {.            
+0001a100: 2020 2020 280a 2020 2020 2020 2020 2020      (.          
+0001a110: 2020 2020 2020 2020 2020 4174 6f6d 3a3a            Atom::
+0001a120: 7061 7273 6528 6629 0a20 2020 2020 2020  parse(f).       
+0001a130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a140: 202e 756e 7772 6170 2829 0a20 2020 2020   .unwrap().     
+0001a150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a160: 2020 202e 6578 7061 6e64 2829 0a20 2020     .expand().   
+0001a170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a180: 2020 2020 202e 746f 5f70 6f6c 796e 6f6d       .to_polynom
+0001a190: 6961 6c28 2666 6965 6c64 2c20 706f 6c79  ial(&field, poly
+0001a1a0: 2e76 6172 6961 626c 6573 2e63 6c6f 6e65  .variables.clone
+0001a1b0: 2829 2e69 6e74 6f28 2929 2c0a 2020 2020  ().into()),.    
+0001a1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a1d0: 2a70 2c0a 2020 2020 2020 2020 2020 2020  *p,.            
+0001a1e0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0001a1f0: 2020 7d29 0a20 2020 2020 2020 2020 2020    }).           
+0001a200: 202e 636f 6c6c 6563 743a 3a3c 5665 633c   .collect::<Vec<
+0001a210: 5f3e 3e28 293b 0a0a 2020 2020 2020 2020  _>>();..        
+0001a220: 7265 732e 736f 7274 5f62 7928 7c61 2c20  res.sort_by(|a, 
+0001a230: 627c 2061 2e70 6172 7469 616c 5f63 6d70  b| a.partial_cmp
+0001a240: 2826 6229 2e75 6e77 7261 7028 2929 3b0a  (&b).unwrap());.
+0001a250: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0001a260: 7220 3d20 706f 6c79 2e66 6163 746f 7228  r = poly.factor(
+0001a270: 293b 0a20 2020 2020 2020 2072 2e73 6f72  );.        r.sor
+0001a280: 745f 6279 287c 612c 2062 7c20 612e 7061  t_by(|a, b| a.pa
+0001a290: 7274 6961 6c5f 636d 7028 2662 292e 756e  rtial_cmp(&b).un
+0001a2a0: 7772 6170 2829 293b 0a20 2020 2020 2020  wrap());.       
+0001a2b0: 2061 7373 6572 745f 6571 2128 722c 2072   assert_eq!(r, r
+0001a2c0: 6573 293b 0a20 2020 207d 0a0a 2020 2020  es);.    }..    
+0001a2d0: 235b 7465 7374 5d0a 2020 2020 666e 2066  #[test].    fn f
+0001a2e0: 6163 746f 725f 7371 7561 7265 5f66 7265  actor_square_fre
+0001a2f0: 6528 2920 7b0a 2020 2020 2020 2020 6c65  e() {.        le
+0001a300: 7420 706f 6c79 203d 2041 746f 6d3a 3a70  t poly = Atom::p
+0001a310: 6172 7365 2822 332a 2832 2a76 315e 322b  arse("3*(2*v1^2+
+0001a320: 7632 2928 7631 5e33 2b76 3229 5e32 2831  v2)(v1^3+v2)^2(1
+0001a330: 2b34 2a76 3229 5e32 2831 2b76 3129 2229  +4*v2)^2(1+v1)")
+0001a340: 0a20 2020 2020 2020 2020 2020 202e 756e  .            .un
+0001a350: 7772 6170 2829 0a20 2020 2020 2020 2020  wrap().         
+0001a360: 2020 202e 746f 5f70 6f6c 796e 6f6d 6961     .to_polynomia
+0001a370: 6c3a 3a3c 5f2c 2075 383e 2826 5a2c 204e  l::<_, u8>(&Z, N
+0001a380: 6f6e 6529 3b0a 0a20 2020 2020 2020 206c  one);..        l
+0001a390: 6574 2072 6573 203d 205b 0a20 2020 2020  et res = [.     
+0001a3a0: 2020 2020 2020 2028 2233 222c 2031 292c         ("3", 1),
+0001a3b0: 0a20 2020 2020 2020 2020 2020 2028 2231  .            ("1
+0001a3c0: 2b34 2a76 3222 2c20 3229 2c0a 2020 2020  +4*v2", 2),.    
+0001a3d0: 2020 2020 2020 2020 2822 312b 7631 222c          ("1+v1",
+0001a3e0: 2031 292c 0a20 2020 2020 2020 2020 2020   1),.           
+0001a3f0: 2028 2276 322b 322a 7631 5e32 222c 2031   ("v2+2*v1^2", 1
+0001a400: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+0001a410: 2276 322b 7631 5e33 222c 2032 292c 0a20  "v2+v1^3", 2),. 
+0001a420: 2020 2020 2020 205d 3b0a 0a20 2020 2020         ];..     
+0001a430: 2020 206c 6574 206d 7574 2072 6573 203d     let mut res =
+0001a440: 2072 6573 0a20 2020 2020 2020 2020 2020   res.           
+0001a450: 202e 6974 6572 2829 0a20 2020 2020 2020   .iter().       
+0001a460: 2020 2020 202e 6d61 7028 7c28 662c 2070       .map(|(f, p
+0001a470: 297c 207b 0a20 2020 2020 2020 2020 2020  )| {.           
+0001a480: 2020 2020 2028 0a20 2020 2020 2020 2020       (.         
+0001a490: 2020 2020 2020 2020 2020 2041 746f 6d3a             Atom:
+0001a4a0: 3a70 6172 7365 2866 290a 2020 2020 2020  :parse(f).      
+0001a4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a4c0: 2020 2e75 6e77 7261 7028 290a 2020 2020    .unwrap().    
+0001a4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a4e0: 2020 2020 2e65 7870 616e 6428 290a 2020      .expand().  
+0001a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a500: 2020 2020 2020 2e74 6f5f 706f 6c79 6e6f        .to_polyno
+0001a510: 6d69 616c 2826 5a2c 2070 6f6c 792e 7661  mial(&Z, poly.va
+0001a520: 7269 6162 6c65 732e 636c 6f6e 6528 292e  riables.clone().
+0001a530: 696e 746f 2829 292c 0a20 2020 2020 2020  into()),.       
+0001a540: 2020 2020 2020 2020 2020 2020 202a 702c               *p,
+0001a550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a560: 2029 0a20 2020 2020 2020 2020 2020 207d   ).            }
+0001a570: 290a 2020 2020 2020 2020 2020 2020 2e63  ).            .c
+0001a580: 6f6c 6c65 6374 3a3a 3c56 6563 3c5f 3e3e  ollect::<Vec<_>>
+0001a590: 2829 3b0a 0a20 2020 2020 2020 2072 6573  ();..        res
+0001a5a0: 2e73 6f72 745f 6279 287c 612c 2062 7c20  .sort_by(|a, b| 
+0001a5b0: 612e 7061 7274 6961 6c5f 636d 7028 2662  a.partial_cmp(&b
+0001a5c0: 292e 756e 7772 6170 2829 293b 0a20 2020  ).unwrap());.   
+0001a5d0: 2020 2020 206c 6574 206d 7574 2072 203d       let mut r =
+0001a5e0: 2070 6f6c 792e 7371 7561 7265 5f66 7265   poly.square_fre
+0001a5f0: 655f 6661 6374 6f72 697a 6174 696f 6e28  e_factorization(
+0001a600: 293b 0a20 2020 2020 2020 2072 2e73 6f72  );.        r.sor
+0001a610: 745f 6279 287c 612c 2062 7c20 612e 7061  t_by(|a, b| a.pa
+0001a620: 7274 6961 6c5f 636d 7028 2662 292e 756e  rtial_cmp(&b).un
+0001a630: 7772 6170 2829 293b 0a20 2020 2020 2020  wrap());.       
+0001a640: 2061 7373 6572 745f 6571 2128 722c 2072   assert_eq!(r, r
+0001a650: 6573 293b 0a20 2020 207d 0a0a 2020 2020  es);.    }..    
+0001a660: 235b 7465 7374 5d0a 2020 2020 666e 2066  #[test].    fn f
+0001a670: 6163 746f 725f 756e 6976 6172 6961 7465  actor_univariate
+0001a680: 5f31 2829 207b 0a20 2020 2020 2020 206c  _1() {.        l
+0001a690: 6574 2070 6f6c 7920 3d20 4174 6f6d 3a3a  et poly = Atom::
+0001a6a0: 7061 7273 6528 2232 2a28 3420 2b20 332a  parse("2*(4 + 3*
+0001a6b0: 7631 292a 2833 202b 2032 2a76 3120 2b20  v1)*(3 + 2*v1 + 
+0001a6c0: 332a 7631 5e32 292a 2833 202b 2038 2a76  3*v1^2)*(3 + 8*v
+0001a6d0: 315e 3229 2a28 3420 2b20 7631 202b 2076  1^2)*(4 + v1 + v
+0001a6e0: 315e 3136 2922 290a 2020 2020 2020 2020  1^16)").        
+0001a6f0: 2020 2020 2e75 6e77 7261 7028 290a 2020      .unwrap().  
+0001a700: 2020 2020 2020 2020 2020 2e74 6f5f 706f            .to_po
+0001a710: 6c79 6e6f 6d69 616c 3a3a 3c5f 2c20 7538  lynomial::<_, u8
+0001a720: 3e28 265a 2c20 4e6f 6e65 293b 0a0a 2020  >(&Z, None);..  
+0001a730: 2020 2020 2020 6c65 7420 7265 7320 3d20        let res = 
+0001a740: 5b0a 2020 2020 2020 2020 2020 2020 2822  [.            ("
+0001a750: 3222 2c20 3129 2c0a 2020 2020 2020 2020  2", 1),.        
+0001a760: 2020 2020 2822 342b 332a 7631 222c 2031      ("4+3*v1", 1
+0001a770: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+0001a780: 2233 2b32 2a76 312b 332a 7631 5e32 222c  "3+2*v1+3*v1^2",
+0001a790: 2031 292c 0a20 2020 2020 2020 2020 2020   1),.           
+0001a7a0: 2028 2233 2b38 2a76 315e 3222 2c20 3129   ("3+8*v1^2", 1)
+0001a7b0: 2c0a 2020 2020 2020 2020 2020 2020 2822  ,.            ("
+0001a7c0: 342b 7631 2b76 315e 3136 222c 2031 292c  4+v1+v1^16", 1),
+0001a7d0: 0a20 2020 2020 2020 205d 3b0a 0a20 2020  .        ];..   
+0001a7e0: 2020 2020 206c 6574 206d 7574 2072 6573       let mut res
+0001a7f0: 203d 2072 6573 0a20 2020 2020 2020 2020   = res.         
+0001a800: 2020 202e 6974 6572 2829 0a20 2020 2020     .iter().     
+0001a810: 2020 2020 2020 202e 6d61 7028 7c28 662c         .map(|(f,
+0001a820: 2070 297c 207b 0a20 2020 2020 2020 2020   p)| {.         
+0001a830: 2020 2020 2020 2028 0a20 2020 2020 2020         (.       
+0001a840: 2020 2020 2020 2020 2020 2020 2041 746f               Ato
+0001a850: 6d3a 3a70 6172 7365 2866 290a 2020 2020  m::parse(f).    
+0001a860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a870: 2020 2020 2e75 6e77 7261 7028 290a 2020      .unwrap().  
+0001a880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a890: 2020 2020 2020 2e65 7870 616e 6428 290a        .expand().
+0001a8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a8b0: 2020 2020 2020 2020 2e74 6f5f 706f 6c79          .to_poly
+0001a8c0: 6e6f 6d69 616c 2826 5a2c 2070 6f6c 792e  nomial(&Z, poly.
+0001a8d0: 7661 7269 6162 6c65 732e 636c 6f6e 6528  variables.clone(
+0001a8e0: 292e 696e 746f 2829 292c 0a20 2020 2020  ).into()),.     
+0001a8f0: 2020 2020 2020 2020 2020 2020 2020 202a                 *
+0001a900: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
+0001a910: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+0001a920: 207d 290a 2020 2020 2020 2020 2020 2020   }).            
+0001a930: 2e63 6f6c 6c65 6374 3a3a 3c56 6563 3c5f  .collect::<Vec<_
+0001a940: 3e3e 2829 3b0a 0a20 2020 2020 2020 2072  >>();..        r
+0001a950: 6573 2e73 6f72 745f 6279 287c 612c 2062  es.sort_by(|a, b
+0001a960: 7c20 612e 7061 7274 6961 6c5f 636d 7028  | a.partial_cmp(
+0001a970: 2662 292e 756e 7772 6170 2829 293b 0a20  &b).unwrap());. 
+0001a980: 2020 2020 2020 206c 6574 206d 7574 2072         let mut r
+0001a990: 203d 2070 6f6c 792e 6661 6374 6f72 2829   = poly.factor()
+0001a9a0: 3b0a 2020 2020 2020 2020 722e 736f 7274  ;.        r.sort
+0001a9b0: 5f62 7928 7c61 2c20 627c 2061 2e70 6172  _by(|a, b| a.par
+0001a9c0: 7469 616c 5f63 6d70 2826 6229 2e75 6e77  tial_cmp(&b).unw
+0001a9d0: 7261 7028 2929 3b0a 2020 2020 2020 2020  rap());.        
+0001a9e0: 6173 7365 7274 5f65 7121 2872 2c20 7265  assert_eq!(r, re
+0001a9f0: 7329 3b0a 2020 2020 7d0a 0a20 2020 2023  s);.    }..    #
+0001aa00: 5b74 6573 745d 0a20 2020 2066 6e20 6661  [test].    fn fa
+0001aa10: 6374 6f72 5f75 6e69 7661 7269 6174 655f  ctor_univariate_
+0001aa20: 3228 2920 7b0a 2020 2020 2020 2020 6c65  2() {.        le
+0001aa30: 7420 706f 6c79 203d 2041 746f 6d3a 3a70  t poly = Atom::p
+0001aa40: 6172 7365 280a 2020 2020 2020 2020 2020  arse(.          
+0001aa50: 2020 2228 7631 2b31 2928 7631 2b32 2928    "(v1+1)(v1+2)(
+0001aa60: 7631 2b33 295e 3328 7631 2b34 2928 7631  v1+3)^3(v1+4)(v1
+0001aa70: 2b35 2928 7631 5e32 2b36 2928 7631 5e33  +5)(v1^2+6)(v1^3
+0001aa80: 2b37 2928 7631 2b38 295e 3228 7631 5e34  +7)(v1+8)^2(v1^4
+0001aa90: 2b39 2928 7631 5e35 2b76 312b 3130 2922  +9)(v1^5+v1+10)"
+0001aaa0: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
+0001aab0: 2020 2020 2e75 6e77 7261 7028 290a 2020      .unwrap().  
+0001aac0: 2020 2020 2020 2e74 6f5f 706f 6c79 6e6f        .to_polyno
+0001aad0: 6d69 616c 3a3a 3c5f 2c20 7538 3e28 265a  mial::<_, u8>(&Z
+0001aae0: 2c20 4e6f 6e65 293b 0a0a 2020 2020 2020  , None);..      
+0001aaf0: 2020 6c65 7420 7265 7320 3d20 5b0a 2020    let res = [.  
+0001ab00: 2020 2020 2020 2020 2020 2822 352b 7631            ("5+v1
+0001ab10: 222c 2031 292c 0a20 2020 2020 2020 2020  ", 1),.         
+0001ab20: 2020 2028 2231 2b76 3122 2c20 3129 2c0a     ("1+v1", 1),.
+0001ab30: 2020 2020 2020 2020 2020 2020 2822 342b              ("4+
+0001ab40: 7631 222c 2031 292c 0a20 2020 2020 2020  v1", 1),.       
+0001ab50: 2020 2020 2028 2232 2b76 3122 2c20 3129       ("2+v1", 1)
+0001ab60: 2c0a 2020 2020 2020 2020 2020 2020 2822  ,.            ("
+0001ab70: 372b 7631 5e33 222c 2031 292c 0a20 2020  7+v1^3", 1),.   
+0001ab80: 2020 2020 2020 2020 2028 2231 302b 7631           ("10+v1
+0001ab90: 2b76 315e 3522 2c20 3129 2c0a 2020 2020  +v1^5", 1),.    
+0001aba0: 2020 2020 2020 2020 2822 362b 7631 5e32          ("6+v1^2
+0001abb0: 222c 2031 292c 0a20 2020 2020 2020 2020  ", 1),.         
+0001abc0: 2020 2028 2239 2b76 315e 3422 2c20 3129     ("9+v1^4", 1)
+0001abd0: 2c0a 2020 2020 2020 2020 2020 2020 2822  ,.            ("
+0001abe0: 382b 7631 222c 2032 292c 0a20 2020 2020  8+v1", 2),.     
+0001abf0: 2020 2020 2020 2028 2233 2b76 3122 2c20         ("3+v1", 
+0001ac00: 3329 2c0a 2020 2020 2020 2020 5d3b 0a0a  3),.        ];..
+0001ac10: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0001ac20: 7265 7320 3d20 7265 730a 2020 2020 2020  res = res.      
+0001ac30: 2020 2020 2020 2e69 7465 7228 290a 2020        .iter().  
+0001ac40: 2020 2020 2020 2020 2020 2e6d 6170 287c            .map(|
+0001ac50: 2866 2c20 7029 7c20 7b0a 2020 2020 2020  (f, p)| {.      
+0001ac60: 2020 2020 2020 2020 2020 280a 2020 2020            (.    
+0001ac70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ac80: 4174 6f6d 3a3a 7061 7273 6528 6629 0a20  Atom::parse(f). 
+0001ac90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001aca0: 2020 2020 2020 202e 756e 7772 6170 2829         .unwrap()
+0001acb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001acc0: 2020 2020 2020 2020 202e 6578 7061 6e64           .expand
+0001acd0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+0001ace0: 2020 2020 2020 2020 2020 202e 746f 5f70             .to_p
+0001acf0: 6f6c 796e 6f6d 6961 6c28 265a 2c20 706f  olynomial(&Z, po
+0001ad00: 6c79 2e76 6172 6961 626c 6573 2e63 6c6f  ly.variables.clo
+0001ad10: 6e65 2829 2e69 6e74 6f28 2929 2c0a 2020  ne().into()),.  
+0001ad20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ad30: 2020 2a70 2c0a 2020 2020 2020 2020 2020    *p,.          
+0001ad40: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001ad50: 2020 2020 7d29 0a20 2020 2020 2020 2020      }).         
+0001ad60: 2020 202e 636f 6c6c 6563 743a 3a3c 5665     .collect::<Ve
+0001ad70: 633c 5f3e 3e28 293b 0a0a 2020 2020 2020  c<_>>();..      
+0001ad80: 2020 7265 732e 736f 7274 5f62 7928 7c61    res.sort_by(|a
+0001ad90: 2c20 627c 2061 2e70 6172 7469 616c 5f63  , b| a.partial_c
+0001ada0: 6d70 2826 6229 2e75 6e77 7261 7028 2929  mp(&b).unwrap())
+0001adb0: 3b0a 2020 2020 2020 2020 6c65 7420 6d75  ;.        let mu
+0001adc0: 7420 7220 3d20 706f 6c79 2e66 6163 746f  t r = poly.facto
+0001add0: 7228 293b 0a20 2020 2020 2020 2072 2e73  r();.        r.s
+0001ade0: 6f72 745f 6279 287c 612c 2062 7c20 612e  ort_by(|a, b| a.
+0001adf0: 7061 7274 6961 6c5f 636d 7028 2662 292e  partial_cmp(&b).
+0001ae00: 756e 7772 6170 2829 293b 0a20 2020 2020  unwrap());.     
+0001ae10: 2020 2061 7373 6572 745f 6571 2128 722c     assert_eq!(r,
+0001ae20: 2072 6573 293b 0a20 2020 207d 0a0a 2020   res);.    }..  
+0001ae30: 2020 235b 7465 7374 5d0a 2020 2020 666e    #[test].    fn
+0001ae40: 2066 6163 746f 725f 6269 7661 7269 6174   factor_bivariat
+0001ae50: 6528 2920 7b0a 2020 2020 2020 2020 6c65  e() {.        le
+0001ae60: 7420 696e 7075 7420 3d20 2228 7631 5e32  t input = "(v1^2
+0001ae70: 2b76 322b 7631 2b31 2928 332a 7631 2b76  +v2+v1+1)(3*v1+v
+0001ae80: 325e 322b 3429 2a28 362a 7631 2a28 7632  2^2+4)*(6*v1*(v2
+0001ae90: 2b31 292b 7632 2b35 292a 2837 2a76 312a  +1)+v2+5)*(7*v1*
+0001aea0: 7632 2b34 2922 3b0a 2020 2020 2020 2020  v2+4)";.        
+0001aeb0: 6c65 7420 706f 6c79 203d 2041 746f 6d3a  let poly = Atom:
+0001aec0: 3a70 6172 7365 2869 6e70 7574 292e 756e  :parse(input).un
+0001aed0: 7772 6170 2829 2e74 6f5f 706f 6c79 6e6f  wrap().to_polyno
+0001aee0: 6d69 616c 3a3a 3c5f 2c20 7538 3e28 265a  mial::<_, u8>(&Z
+0001aef0: 2c20 4e6f 6e65 293b 0a0a 2020 2020 2020  , None);..      
+0001af00: 2020 6c65 7420 7265 7320 3d20 5b0a 2020    let res = [.  
+0001af10: 2020 2020 2020 2020 2020 2822 2831 2b76            ("(1+v
+0001af20: 322b 7631 2b76 315e 3229 222c 2031 292c  2+v1+v1^2)", 1),
+0001af30: 0a20 2020 2020 2020 2020 2020 2028 2228  .            ("(
+0001af40: 352b 7632 2b36 2a76 312b 362a 7631 2a76  5+v2+6*v1+6*v1*v
+0001af50: 3229 222c 2031 292c 0a20 2020 2020 2020  2)", 1),.       
+0001af60: 2020 2020 2028 2228 342b 7632 5e32 2b33       ("(4+v2^2+3
+0001af70: 2a76 3129 222c 2031 292c 0a20 2020 2020  *v1)", 1),.     
+0001af80: 2020 2020 2020 2028 2228 342b 372a 7631         ("(4+7*v1
+0001af90: 2a76 3229 222c 2031 292c 0a20 2020 2020  *v2)", 1),.     
+0001afa0: 2020 205d 3b0a 0a20 2020 2020 2020 206c     ];..        l
+0001afb0: 6574 206d 7574 2072 6573 203d 2072 6573  et mut res = res
+0001afc0: 0a20 2020 2020 2020 2020 2020 202e 6974  .            .it
+0001afd0: 6572 2829 0a20 2020 2020 2020 2020 2020  er().           
+0001afe0: 202e 6d61 7028 7c28 662c 2070 297c 207b   .map(|(f, p)| {
+0001aff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b000: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+0001b010: 2020 2020 2020 2041 746f 6d3a 3a70 6172         Atom::par
+0001b020: 7365 2866 290a 2020 2020 2020 2020 2020  se(f).          
+0001b030: 2020 2020 2020 2020 2020 2020 2020 2e75                .u
+0001b040: 6e77 7261 7028 290a 2020 2020 2020 2020  nwrap().        
+0001b050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b060: 2e65 7870 616e 6428 290a 2020 2020 2020  .expand().      
+0001b070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b080: 2020 2e74 6f5f 706f 6c79 6e6f 6d69 616c    .to_polynomial
+0001b090: 2826 5a2c 2070 6f6c 792e 7661 7269 6162  (&Z, poly.variab
+0001b0a0: 6c65 732e 636c 6f6e 6528 292e 696e 746f  les.clone().into
+0001b0b0: 2829 292c 0a20 2020 2020 2020 2020 2020  ()),.           
+0001b0c0: 2020 2020 2020 2020 202a 702c 0a20 2020           *p,.   
+0001b0d0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0001b0e0: 2020 2020 2020 2020 2020 207d 290a 2020             }).  
+0001b0f0: 2020 2020 2020 2020 2020 2e63 6f6c 6c65            .colle
+0001b100: 6374 3a3a 3c56 6563 3c5f 3e3e 2829 3b0a  ct::<Vec<_>>();.
+0001b110: 0a20 2020 2020 2020 2072 6573 2e73 6f72  .        res.sor
+0001b120: 745f 6279 287c 612c 2062 7c20 612e 7061  t_by(|a, b| a.pa
+0001b130: 7274 6961 6c5f 636d 7028 2662 292e 756e  rtial_cmp(&b).un
+0001b140: 7772 6170 2829 293b 0a20 2020 2020 2020  wrap());.       
+0001b150: 206c 6574 206d 7574 2072 203d 2070 6f6c   let mut r = pol
+0001b160: 792e 6661 6374 6f72 2829 3b0a 2020 2020  y.factor();.    
+0001b170: 2020 2020 722e 736f 7274 5f62 7928 7c61      r.sort_by(|a
+0001b180: 2c20 627c 2061 2e70 6172 7469 616c 5f63  , b| a.partial_c
+0001b190: 6d70 2826 6229 2e75 6e77 7261 7028 2929  mp(&b).unwrap())
+0001b1a0: 3b0a 2020 2020 2020 2020 6173 7365 7274  ;.        assert
+0001b1b0: 5f65 7121 2872 2c20 7265 7329 3b0a 2020  _eq!(r, res);.  
+0001b1c0: 2020 7d0a 0a20 2020 2023 5b74 6573 745d    }..    #[test]
+0001b1d0: 0a20 2020 2066 6e20 6661 6374 6f72 5f6d  .    fn factor_m
+0001b1e0: 756c 7469 7661 7269 6174 6528 2920 7b0a  ultivariate() {.
+0001b1f0: 2020 2020 2020 2020 6c65 7420 696e 7075          let inpu
+0001b200: 7420 3d20 2228 7631 2a28 322b 322a 7632  t = "(v1*(2+2*v2
+0001b210: 2b32 2a76 3329 2b31 292a 2876 312a 2834  +2*v3)+1)*(v1*(4
+0001b220: 2b76 335e 3229 2b76 322b 3329 2a28 7631  +v3^2)+v2+3)*(v1
+0001b230: 2a28 7634 2b76 345e 322b 342b 7632 292b  *(v4+v4^2+4+v2)+
+0001b240: 7634 2b35 2922 3b0a 2020 2020 2020 2020  v4+5)";.        
+0001b250: 6c65 7420 706f 6c79 203d 2041 746f 6d3a  let poly = Atom:
+0001b260: 3a70 6172 7365 2869 6e70 7574 292e 756e  :parse(input).un
+0001b270: 7772 6170 2829 2e74 6f5f 706f 6c79 6e6f  wrap().to_polyno
+0001b280: 6d69 616c 3a3a 3c5f 2c20 7538 3e28 265a  mial::<_, u8>(&Z
+0001b290: 2c20 4e6f 6e65 293b 0a0a 2020 2020 2020  , None);..      
+0001b2a0: 2020 6c65 7420 7265 7320 3d20 5b0a 2020    let res = [.  
+0001b2b0: 2020 2020 2020 2020 2020 2822 352b 7634            ("5+v4
+0001b2c0: 2b34 2a76 312b 7631 2a76 342b 7631 2a76  +4*v1+v1*v4+v1*v
+0001b2d0: 345e 322b 7631 2a76 3222 2c20 3129 2c0a  4^2+v1*v2", 1),.
+0001b2e0: 2020 2020 2020 2020 2020 2020 2822 312b              ("1+
+0001b2f0: 322a 7631 2b32 2a76 312a 7633 2b32 2a76  2*v1+2*v1*v3+2*v
+0001b300: 312a 7632 2022 2c20 3129 2c0a 2020 2020  1*v2 ", 1),.    
+0001b310: 2020 2020 2020 2020 2822 332b 7632 2b34          ("3+v2+4
+0001b320: 2a76 312b 7631 2a76 335e 3222 2c20 3129  *v1+v1*v3^2", 1)
+0001b330: 2c0a 2020 2020 2020 2020 5d3b 0a0a 2020  ,.        ];..  
+0001b340: 2020 2020 2020 6c65 7420 6d75 7420 7265        let mut re
+0001b350: 7320 3d20 7265 730a 2020 2020 2020 2020  s = res.        
+0001b360: 2020 2020 2e69 7465 7228 290a 2020 2020      .iter().    
+0001b370: 2020 2020 2020 2020 2e6d 6170 287c 2866          .map(|(f
+0001b380: 2c20 7029 7c20 7b0a 2020 2020 2020 2020  , p)| {.        
+0001b390: 2020 2020 2020 2020 280a 2020 2020 2020          (.      
+0001b3a0: 2020 2020 2020 2020 2020 2020 2020 4174                At
+0001b3b0: 6f6d 3a3a 7061 7273 6528 6629 0a20 2020  om::parse(f).   
+0001b3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b3d0: 2020 2020 202e 756e 7772 6170 2829 0a20       .unwrap(). 
+0001b3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b3f0: 2020 2020 2020 202e 6578 7061 6e64 2829         .expand()
+0001b400: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b410: 2020 2020 2020 2020 202e 746f 5f70 6f6c           .to_pol
+0001b420: 796e 6f6d 6961 6c28 265a 2c20 706f 6c79  ynomial(&Z, poly
+0001b430: 2e76 6172 6961 626c 6573 2e63 6c6f 6e65  .variables.clone
+0001b440: 2829 2e69 6e74 6f28 2929 2c0a 2020 2020  ().into()),.    
+0001b450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b460: 2a70 2c0a 2020 2020 2020 2020 2020 2020  *p,.            
+0001b470: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0001b480: 2020 7d29 0a20 2020 2020 2020 2020 2020    }).           
+0001b490: 202e 636f 6c6c 6563 743a 3a3c 5665 633c   .collect::<Vec<
+0001b4a0: 5f3e 3e28 293b 0a0a 2020 2020 2020 2020  _>>();..        
+0001b4b0: 7265 732e 736f 7274 5f62 7928 7c61 2c20  res.sort_by(|a, 
+0001b4c0: 627c 2061 2e70 6172 7469 616c 5f63 6d70  b| a.partial_cmp
+0001b4d0: 2826 6229 2e75 6e77 7261 7028 2929 3b0a  (&b).unwrap());.
+0001b4e0: 2020 2020 2020 2020 6c65 7420 6d75 7420          let mut 
+0001b4f0: 7220 3d20 706f 6c79 2e66 6163 746f 7228  r = poly.factor(
+0001b500: 293b 0a20 2020 2020 2020 2072 2e73 6f72  );.        r.sor
+0001b510: 745f 6279 287c 612c 2062 7c20 612e 7061  t_by(|a, b| a.pa
+0001b520: 7274 6961 6c5f 636d 7028 2662 292e 756e  rtial_cmp(&b).un
+0001b530: 7772 6170 2829 293b 0a20 2020 2020 2020  wrap());.       
+0001b540: 2061 7373 6572 745f 6571 2128 722c 2072   assert_eq!(r, r
+0001b550: 6573 293b 0a20 2020 207d 0a7d 0a         es);.    }.}.
```

### Comparing `symbolica-0.3.0/src/poly/gcd.rs` & `symbolica-0.4.0/src/poly/gcd.rs`

 * *Files 4% similar despite different names*

```diff
@@ -3,22 +3,23 @@
 use smallvec::{smallvec, SmallVec};
 use std::borrow::Cow;
 use std::cmp::{max, min, Ordering};
 use std::mem;
 use std::ops::Add;
 use tracing::{debug, instrument};
 
+use crate::domains::algebraic_number::AlgebraicNumberRing;
 use crate::domains::finite_field::{
-    FiniteField, FiniteFieldCore, FiniteFieldWorkspace, ToFiniteField,
+    FiniteField, FiniteFieldCore, FiniteFieldWorkspace, ToFiniteField, Zp,
 };
-use crate::domains::integer::{FromFiniteField, Integer, IntegerRing, SMALL_PRIMES};
-use crate::domains::linear_system::{LinearSolverError, Matrix};
-use crate::domains::rational::RationalField;
+use crate::domains::integer::{FromFiniteField, Integer, IntegerRing, SMALL_PRIMES, Z};
+use crate::domains::rational::{Rational, RationalField, Q};
 use crate::domains::{EuclideanDomain, Field, Ring};
 use crate::poly::INLINED_EXPONENTS;
+use crate::tensors::matrix::{Matrix, MatrixError};
 
 use super::polynomial::MultivariatePolynomial;
 use super::Exponent;
 
 // 100 large u32 primes starting from the 203213901st prime number
 pub const LARGE_U32_PRIMES: [u32; 100] = [
     4293490987, 4293491603, 4293492277, 4293492857, 4293491017, 4293491621, 4293492283, 4293492881,
@@ -117,1071 +118,962 @@
 
 #[derive(Debug, PartialEq, Eq, Copy, Clone)]
 enum GCDError {
     BadOriginalImage,
     BadCurrentImage,
 }
 
-fn newton_interpolation<UField: FiniteFieldWorkspace, E: Exponent>(
-    a: &[<FiniteField<UField> as Ring>::Element],
-    u: &[MultivariatePolynomial<FiniteField<UField>, E>],
-    x: usize, // the variable index to extend the polynomial by
-) -> MultivariatePolynomial<FiniteField<UField>, E>
-where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-{
-    let field = &u[0].field;
-
-    // compute inverses
-    let mut gammas = Vec::with_capacity(a.len());
-    for k in 1..a.len() {
-        let mut pr = field.sub(&a[k], &a[0]);
-        for i in 1..k {
-            u[0].field.mul_assign(&mut pr, &field.sub(&a[k], &a[i]));
-        }
-        gammas.push(u[0].field.inv(&pr));
-    }
-
-    // compute Newton coefficients
-    let mut v = vec![u[0].clone()];
-    for k in 1..a.len() {
-        let mut tmp = v[k - 1].clone();
-        for j in (0..k - 1).rev() {
-            tmp = tmp.mul_coeff(field.sub(&a[k], &a[j])).add(v[j].clone());
-        }
-
-        let mut r = u[k].clone() - tmp;
-        r = r.mul_coeff(gammas[k - 1].clone());
-        v.push(r);
-    }
-
-    // convert to standard form
-    let mut e = vec![E::zero(); u[0].nvars];
-    e[x] = E::one();
-    let xp = u[0].monomial(field.one(), e);
-    let mut u = v[v.len() - 1].clone();
-    for k in (0..v.len() - 1).rev() {
-        // TODO: prevent cloning
-        u = u * &(xp.clone() - v[0].constant(a[k].clone())) + v[k].clone();
-    }
-    u
-}
+impl<R: Ring, E: Exponent> MultivariatePolynomial<R, E> {
+    /// Evaluation of the exponents by filling in the variables
+    #[inline(always)]
+    fn evaluate_exponents(
+        &self,
+        r: &[(usize, R::Element)],
+        cache: &mut [Vec<R::Element>],
+    ) -> Vec<R::Element> {
+        let mut eval = vec![self.field.one(); self.nterms()];
+        for (c, t) in eval.iter_mut().zip(self) {
+            // evaluate each exponent
+            for (n, v) in r {
+                let exp = t.exponents[*n].to_u32() as usize;
+                if exp > 0 {
+                    if exp < cache[*n].len() {
+                        if R::is_zero(&cache[*n][exp]) {
+                            cache[*n][exp] = self.field.pow(v, exp as u64);
+                        }
 
-/// Evaluation of the exponents by filling in the variables
-#[inline(always)]
-fn evaluate_exponents<UField: FiniteFieldWorkspace, E: Exponent>(
-    poly: &MultivariatePolynomial<FiniteField<UField>, E>,
-    r: &[(usize, <FiniteField<UField> as Ring>::Element)],
-    cache: &mut [Vec<<FiniteField<UField> as Ring>::Element>],
-) -> Vec<<FiniteField<UField> as Ring>::Element>
-where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-    <FiniteField<UField> as Ring>::Element: Copy,
-{
-    let mut eval = vec![poly.field.one(); poly.nterms()];
-    for (c, t) in eval.iter_mut().zip(poly) {
-        // evaluate each exponent
-        for &(n, v) in r {
-            let exp = t.exponents[n].to_u32() as usize;
-            if exp > 0 {
-                if exp < cache[n].len() {
-                    if FiniteField::<UField>::is_zero(&cache[n][exp]) {
-                        cache[n][exp] = poly.field.pow(&v, exp as u64);
+                        self.field.mul_assign(c, &cache[*n][exp]);
+                    } else {
+                        self.field.mul_assign(c, &self.field.pow(v, exp as u64));
                     }
-
-                    poly.field.mul_assign(c, &cache[n][exp]);
-                } else {
-                    poly.field.mul_assign(c, &poly.field.pow(&v, exp as u64));
                 }
             }
         }
+        eval
     }
-    eval
-}
 
-/// Evaluate a polynomial using the evaluation of the exponent of every monomial.
-#[inline(always)]
-fn evaluate_using_exponents<UField: FiniteFieldWorkspace, E: Exponent>(
-    poly: &MultivariatePolynomial<FiniteField<UField>, E>,
-    exp_evals: &[<FiniteField<UField> as Ring>::Element],
-    main_var: usize,
-    out: &mut MultivariatePolynomial<FiniteField<UField>, E>,
-) where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-    <FiniteField<UField> as Ring>::Element: Copy,
-{
-    out.clear();
-    let mut c = poly.field.zero();
-    let mut new_exp = vec![E::zero(); poly.nvars];
-    for (aa, e) in poly.into_iter().zip(exp_evals) {
-        if aa.exponents[main_var] != new_exp[main_var] {
-            if !FiniteField::is_zero(&c) {
-                out.coefficients.push(c);
-                out.exponents.extend_from_slice(&new_exp);
+    /// Evaluate a polynomial using the evaluation of the exponent of every monomial.
+    #[inline(always)]
+    fn evaluate_using_exponents(
+        &self,
+        exp_evals: &[R::Element],
+        main_var: usize,
+        out: &mut MultivariatePolynomial<R, E>,
+    ) {
+        out.clear();
+        let mut c = self.field.zero();
+        let mut new_exp = vec![E::zero(); self.nvars()];
+        for (aa, e) in self.into_iter().zip(exp_evals) {
+            if aa.exponents[main_var] != new_exp[main_var] {
+                if !R::is_zero(&c) {
+                    out.coefficients.push(c);
+                    out.exponents.extend_from_slice(&new_exp);
+
+                    c = self.field.zero();
+                }
 
-                c = poly.field.zero();
+                new_exp[main_var] = aa.exponents[main_var];
             }
 
-            new_exp[main_var] = aa.exponents[main_var];
+            self.field.add_mul_assign(&mut c, aa.coefficient, e);
         }
 
-        poly.field.add_mul_assign(&mut c, aa.coefficient, e);
-    }
-
-    if !FiniteField::is_zero(&c) {
-        out.coefficients.push(c);
-        out.exponents.extend_from_slice(&new_exp);
+        if !R::is_zero(&c) {
+            out.coefficients.push(c);
+            out.exponents.extend_from_slice(&new_exp);
+        }
     }
 }
 
-fn solve_vandermonde<UField: FiniteFieldWorkspace, E: Exponent>(
-    a: &MultivariatePolynomial<FiniteField<UField>, E>,
-    main_var: usize,
-    shape: &[(MultivariatePolynomial<FiniteField<UField>, E>, E)],
-    row_sample_values: Vec<Vec<<FiniteField<UField> as Ring>::Element>>,
-    samples: Vec<Vec<<FiniteField<UField> as Ring>::Element>>,
-) -> MultivariatePolynomial<FiniteField<UField>, E>
-where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-    <FiniteField<UField> as Ring>::Element: Copy,
-{
-    let mut gp = a.zero();
+impl<F: Field, E: Exponent> MultivariatePolynomial<F, E> {
+    /// Compute the univariate GCD using Euclid's algorithm. The result is normalized to 1.
+    pub fn univariate_gcd(&self, b: &Self) -> Self {
+        if self.is_zero() {
+            return b.clone();
+        }
+        if b.is_zero() {
+            return self.clone();
+        }
 
-    // solve the transposed Vandermonde system
-    for (((c, ex), sample), rhs) in shape.iter().zip(&row_sample_values).zip(&samples) {
-        if c.nterms() == 1 {
-            let coeff = a.field.div(&rhs[0], &sample[0]);
-            let mut ee: SmallVec<[E; INLINED_EXPONENTS]> = c.exponents(0).into();
-            ee[main_var] = *ex;
-            gp.append_monomial(coeff, &ee);
-            continue;
+        let mut c = self.clone();
+        let mut d = b.clone();
+        if self.ldegree_max() < b.ldegree_max() {
+            mem::swap(&mut c, &mut d);
         }
 
-        // construct the master polynomial (1-s1)*(1-s2)*... efficiently
-        let mut master = vec![a.field.zero(); sample.len() + 1];
-        master[0] = a.field.one();
+        // TODO: there exists an efficient algorithm for univariate poly
+        // division in a finite field using FFT
+        let mut r = c.quot_rem_univariate(&mut d).1;
+        while !r.is_zero() {
+            c = d;
+            d = r;
+            r = c.quot_rem_univariate(&mut d).1;
+        }
 
-        for (i, x) in sample.iter().take(c.nterms()).enumerate() {
-            let first = &mut master[0];
-            let mut old_last = *first;
-            a.field.mul_assign(first, &a.field.neg(x));
-            for m in &mut master[1..=i] {
-                let ov = *m;
-                a.field.mul_assign(m, &a.field.neg(x));
-                a.field.add_assign(m, &old_last);
-                old_last = ov;
-            }
-            master[i + 1] = a.field.one();
+        // normalize the gcd
+        let l = d.coefficients.last().unwrap().clone();
+        for x in &mut d.coefficients {
+            self.field.div_assign(x, &l);
         }
 
-        for (i, s) in sample.iter().take(c.nterms()).enumerate() {
-            let mut norm = a.field.one();
+        d
+    }
 
-            // sample master/(1-s_i) by using the factorized form
-            for (j, l) in sample.iter().enumerate() {
-                if j != i {
-                    a.field.mul_assign(&mut norm, &a.field.sub(s, l))
-                }
-            }
+    /// Replace all variables except `v` in the polynomial by elements from
+    /// a finite field of size `p`.
+    pub fn sample_polynomial(
+        &self,
+        v: usize,
+        r: &[(usize, F::Element)],
+        cache: &mut [Vec<F::Element>],
+        tm: &mut HashMap<E, F::Element>,
+    ) -> Self {
+        for mv in self.into_iter() {
+            let mut c = mv.coefficient.clone();
+            for (n, vv) in r {
+                let exp = mv.exponents[*n].to_u32() as usize;
+                if exp > 0 {
+                    if exp < cache[*n].len() {
+                        if F::is_zero(&cache[*n][exp]) {
+                            cache[*n][exp] = self.field.pow(vv, exp as u64);
+                        }
 
-            // divide out 1-s_i
-            let mut coeff = a.field.zero();
-            let mut last_q = a.field.zero();
-            for (m, rhs) in master.iter().skip(1).zip(rhs).rev() {
-                last_q = a.field.add(m, &a.field.mul(s, &last_q));
-                a.field.add_mul_assign(&mut coeff, &last_q, rhs);
+                        self.field.mul_assign(&mut c, &cache[*n][exp]);
+                    } else {
+                        self.field
+                            .mul_assign(&mut c, &self.field.pow(vv, exp as u64));
+                    }
+                }
             }
-            a.field.div_assign(&mut coeff, &norm);
-
-            // divide by the Vandermonde row since the Vandermonde matrices should start with a 1
-            a.field.div_assign(&mut coeff, s);
 
-            let mut ee: SmallVec<[E; INLINED_EXPONENTS]> = c.exponents(i).into();
-            ee[main_var] = *ex;
+            tm.entry(mv.exponents[v])
+                .and_modify(|e| self.field.add_assign(e, &c))
+                .or_insert(c);
+        }
 
-            gp.append_monomial(coeff, &ee);
+        let mut res = self.zero();
+        let mut e = vec![E::zero(); self.nvars()];
+        for (k, c) in tm.drain() {
+            if !F::is_zero(&c) {
+                e[v] = k;
+                res.append_monomial(c, &e);
+                e[v] = E::zero();
+            }
         }
+
+        res
     }
 
-    gp
-}
+    /// Find the upper bound of a variable `var` in the gcd.
+    /// This is done by computing the univariate gcd by
+    /// substituting all variables except `var`. This
+    /// upper bound could be too tight due to an unfortunate
+    /// sample point, but this is rare.
+    fn get_gcd_var_bound(ap: &Self, bp: &Self, vars: &[usize], var: usize) -> E {
+        let mut rng = rand::thread_rng();
 
-#[instrument(level = "trace", fields(%a, %b))]
-fn construct_new_image_single_scale<UField: FiniteFieldWorkspace, E: Exponent>(
-    a: &MultivariatePolynomial<FiniteField<UField>, E>,
-    b: &MultivariatePolynomial<FiniteField<UField>, E>,
-    a_ldegree: E,
-    b_ldegree: E,
-    bounds: &mut [E],
-    single_scale: usize,
-    vars: &[usize],
-    main_var: usize,
-    shape: &[(MultivariatePolynomial<FiniteField<UField>, E>, E)],
-) -> Result<MultivariatePolynomial<FiniteField<UField>, E>, GCDError>
-where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-    <FiniteField<UField> as Ring>::Element: Copy,
-{
-    if vars.is_empty() {
-        // return gcd divided by the single scale factor
-        let g = MultivariatePolynomial::univariate_gcd(a, b);
-
-        if g.ldegree(main_var) < bounds[main_var] {
-            // original image and form and degree bounds are unlucky
-            // change the bound and try a new prime
-            debug!("Unlucky degree bound: {} vs {}", g, bounds[main_var]);
-            bounds[main_var] = g.ldegree(main_var);
-            return Err(GCDError::BadOriginalImage);
-        }
+        // store a table for variables raised to a certain power
+        let mut cache = (0..ap.nvars())
+            .map(|i| {
+                vec![
+                    ap.field.zero();
+                    min(
+                        max(ap.degree(i), bp.degree(i)).to_u32() as usize + 1,
+                        POW_CACHE_SIZE
+                    )
+                ]
+            })
+            .collect::<Vec<_>>();
 
-        if g.ldegree(main_var) > bounds[main_var] {
-            return Err(GCDError::BadCurrentImage);
-        }
+        // store a power map for the univariate polynomials that will be sampled
+        // the sampling_polynomial routine will set the power to 0 after use
+        let mut tm = HashMap::with_capacity_and_hasher(INITIAL_POW_MAP_SIZE, Default::default());
 
-        // check if all the monomials of the image appear in the shape
-        // if not, the original shape is bad
-        for m in g.into_iter() {
-            if shape.iter().all(|(_, pow)| *pow != m.exponents[main_var]) {
-                debug!("Bad shape: terms missing");
-                return Err(GCDError::BadOriginalImage);
+        // generate random numbers for all non-leading variables
+        // TODO: apply a Horner scheme to speed up the substitution?
+        let (_, a1, b1) = loop {
+            for v in &mut cache {
+                for vi in v {
+                    *vi = ap.field.zero();
+                }
             }
-        }
 
-        // construct the scaling coefficient
-        let (_, d) = &shape[single_scale];
-        for t in &g {
-            if t.exponents[main_var] == *d {
-                let scale_factor = a.field.neg(&a.field.inv(t.coefficient)); // TODO: why -1?
-                return Ok(g.mul_coeff(scale_factor));
-            }
-        }
+            let r: Vec<_> = vars
+                .iter()
+                .map(|i| (*i, ap.field.sample(&mut rng, (1, MAX_RNG_PREFACTOR as i64))))
+                .collect();
 
-        // the scaling term is missing, so the assumed form is wrong
-        debug!("Bad original image");
-        return Err(GCDError::BadOriginalImage);
-    }
+            let a1 = ap.sample_polynomial(var, &r, &mut cache, &mut tm);
+            let b1 = bp.sample_polynomial(var, &r, &mut cache, &mut tm);
 
-    let mut rng = rand::thread_rng();
+            if a1.ldegree(var) == ap.degree(var) && b1.ldegree(var) == bp.degree(var) {
+                break (r, a1, b1);
+            }
 
-    let mut failure_count = 0;
+            debug!(
+                "Degree error during sampling: trying again: a={}, a1=={}, bp={}, b1={}",
+                ap, a1, bp, b1
+            );
+        };
 
-    // store a table for variables raised to a certain power
-    let mut cache = (0..a.nvars)
-        .map(|i| {
-            vec![
-                a.field.zero();
-                min(
-                    max(a.degree(i), b.degree(i)).to_u32() as usize + 1,
-                    POW_CACHE_SIZE
-                )
-            ]
-        })
-        .collect::<Vec<_>>();
+        let g1 = a1.univariate_gcd(&b1);
+        g1.ldegree_max()
+    }
 
-    // find a set of sample points that yield unique coefficients for every coefficient of a term in the shape
-    let (row_sample_values, samples) = 'find_root_sample: loop {
-        for v in &mut cache {
-            for vi in v {
-                *vi = a.field.zero();
+    fn solve_vandermonde(
+        &self,
+        main_var: usize,
+        shape: &[(MultivariatePolynomial<F, E>, E)],
+        row_sample_values: Vec<Vec<F::Element>>,
+        samples: Vec<Vec<F::Element>>,
+    ) -> MultivariatePolynomial<F, E> {
+        let mut gp = self.zero();
+
+        // solve the transposed Vandermonde system
+        for (((c, ex), sample), rhs) in shape.iter().zip(&row_sample_values).zip(&samples) {
+            if c.nterms() == 1 {
+                let coeff = self.field.div(&rhs[0], &sample[0]);
+                let mut ee: SmallVec<[E; INLINED_EXPONENTS]> = c.exponents(0).into();
+                ee[main_var] = *ex;
+                gp.append_monomial(coeff, &ee);
+                continue;
             }
-        }
 
-        let r_orig: SmallVec<[_; INLINED_EXPONENTS]> = vars
-            .iter()
-            .map(|i| {
-                (
-                    *i,
-                    a.field.sample(
-                        &mut rng,
-                        (
-                            1,
-                            a.field.get_prime().to_u64().min(MAX_RNG_PREFACTOR as u64) as i64,
-                        ),
-                    ),
-                )
-            })
-            .collect();
+            // construct the master polynomial (1-s1)*(1-s2)*... efficiently
+            let mut master = vec![self.field.zero(); sample.len() + 1];
+            master[0] = self.field.one();
 
-        let mut row_sample_values = Vec::with_capacity(shape.len()); // coefficients for the linear system
-        let mut samples_needed = 0;
-        for (c, _) in shape.iter() {
-            samples_needed = samples_needed.max(c.nterms());
-            let mut row = Vec::with_capacity(c.nterms());
-            let mut seen = HashSet::new();
-
-            for t in c {
-                // evaluate each exponent
-                let mut c = a.field.one();
-                for &(n, v) in &r_orig {
-                    let exp = t.exponents[n].to_u32() as usize;
-                    if exp > 0 {
-                        if exp < cache[n].len() {
-                            if FiniteField::<UField>::is_zero(&cache[n][exp]) {
-                                cache[n][exp] = a.field.pow(&v, exp as u64);
-                            }
+            for (i, x) in sample.iter().take(c.nterms()).enumerate() {
+                let first = &mut master[0];
+                let mut old_last = first.clone();
+                self.field.mul_assign(first, &self.field.neg(x));
+                for m in &mut master[1..=i] {
+                    let ov = m.clone();
+                    self.field.mul_assign(m, &self.field.neg(x));
+                    self.field.add_assign(m, &old_last);
+                    old_last = ov;
+                }
+                master[i + 1] = self.field.one();
+            }
 
-                            a.field.mul_assign(&mut c, &cache[n][exp]);
-                        } else {
-                            a.field.mul_assign(&mut c, &a.field.pow(&v, exp as u64));
-                        }
+            for (i, s) in sample.iter().take(c.nterms()).enumerate() {
+                let mut norm = self.field.one();
+
+                // sample master/(1-s_i) by using the factorized form
+                for (j, l) in sample.iter().enumerate() {
+                    if j != i {
+                        self.field.mul_assign(&mut norm, &self.field.sub(s, l))
                     }
                 }
-                row.push(c);
 
-                // check if each element is unique
-                if !seen.insert(a.field.from_element(&c)) {
-                    debug!("Duplicate element: restarting");
-                    continue 'find_root_sample;
+                // divide out 1-s_i
+                let mut coeff = self.field.zero();
+                let mut last_q = self.field.zero();
+                for (m, rhs) in master.iter().skip(1).zip(rhs).rev() {
+                    last_q = self.field.add(m, &self.field.mul(s, &last_q));
+                    self.field.add_mul_assign(&mut coeff, &last_q, rhs);
                 }
-            }
+                self.field.div_assign(&mut coeff, &norm);
 
-            row_sample_values.push(row);
-        }
+                // divide by the Vandermonde row since the Vandermonde matrices should start with a 1
+                self.field.div_assign(&mut coeff, s);
 
-        let mut samples = vec![Vec::with_capacity(samples_needed); shape.len()];
-        let mut r = r_orig.clone();
+                let mut ee: SmallVec<[E; INLINED_EXPONENTS]> = c.exponents(i).into();
+                ee[main_var] = *ex;
 
-        let a_eval = evaluate_exponents(a, &r_orig, &mut cache);
-        let b_eval = evaluate_exponents(b, &r_orig, &mut cache);
+                gp.append_monomial(coeff, &ee);
+            }
+        }
 
-        let mut a_current = Cow::Borrowed(&a_eval);
-        let mut b_current = Cow::Borrowed(&b_eval);
+        gp
+    }
 
-        let mut a_poly = a.zero_with_capacity(a.degree(main_var).to_u32() as usize + 1);
-        let mut b_poly = b.zero_with_capacity(b.degree(main_var).to_u32() as usize + 1);
+    /// Perform Newton interpolation in the variable `x`, by providing
+    /// a list of sample points `a` and their evaluations `u`.
+    pub fn newton_interpolation(
+        a: &[F::Element],
+        u: &[MultivariatePolynomial<F, E>],
+        x: usize, // the variable index to extend the polynomial by
+    ) -> MultivariatePolynomial<F, E> {
+        let field = &u[0].field;
 
-        for sample_index in 0..samples_needed {
-            // sample at r^i
-            if sample_index > 0 {
-                for (c, rr) in r.iter_mut().zip(&r_orig) {
-                    *c = (c.0, a.field.mul(&c.1, &rr.1));
-                }
+        // compute inverses
+        let mut gammas = Vec::with_capacity(a.len());
+        for k in 1..a.len() {
+            let mut pr = field.sub(&a[k], &a[0]);
+            for i in 1..k {
+                u[0].field.mul_assign(&mut pr, &field.sub(&a[k], &a[i]));
+            }
+            gammas.push(u[0].field.inv(&pr));
+        }
 
-                for (c, e) in a_current.to_mut().iter_mut().zip(&a_eval) {
-                    a.field.mul_assign(c, e);
-                }
-                for (c, e) in b_current.to_mut().iter_mut().zip(&b_eval) {
-                    b.field.mul_assign(c, e);
-                }
+        // compute Newton coefficients
+        let mut v = vec![u[0].clone()];
+        for k in 1..a.len() {
+            let mut tmp = v[k - 1].clone();
+            for j in (0..k - 1).rev() {
+                tmp = tmp.mul_coeff(field.sub(&a[k], &a[j])).add(v[j].clone());
             }
 
-            // now construct the univariate polynomials from the current evaluated monomials
-            evaluate_using_exponents(a, &a_current, main_var, &mut a_poly);
-            evaluate_using_exponents(b, &b_current, main_var, &mut b_poly);
+            let mut r = u[k].clone() - tmp;
+            r = r.mul_coeff(gammas[k - 1].clone());
+            v.push(r);
+        }
 
-            if a_poly.ldegree(main_var) != a_ldegree || b_poly.ldegree(main_var) != b_ldegree {
-                continue 'find_root_sample;
-            }
+        // convert to standard form
+        let mut e = vec![E::zero(); u[0].nvars()];
+        e[x] = E::one();
+        let xp = u[0].monomial(field.one(), e);
+        let mut u = v[v.len() - 1].clone();
+        for k in (0..v.len() - 1).rev() {
+            // TODO: prevent cloning
+            u = u * &(xp.clone() - v[0].constant(a[k].clone())) + v[k].clone();
+        }
+        u
+    }
 
-            let g = MultivariatePolynomial::univariate_gcd(&a_poly, &b_poly);
-            debug!(
-                "GCD of sample at point {:?} in main var {}: {}",
-                r, main_var, g
-            );
+    #[instrument(level = "trace", fields(%a, %b))]
+    fn construct_new_image_single_scale(
+        a: &MultivariatePolynomial<F, E>,
+        b: &MultivariatePolynomial<F, E>,
+        a_ldegree: E,
+        b_ldegree: E,
+        bounds: &mut [E],
+        single_scale: usize,
+        vars: &[usize],
+        main_var: usize,
+        shape: &[(MultivariatePolynomial<F, E>, E)],
+    ) -> Result<MultivariatePolynomial<F, E>, GCDError> {
+        if vars.is_empty() {
+            // return gcd divided by the single scale factor
+            let g = a.univariate_gcd(b);
 
             if g.ldegree(main_var) < bounds[main_var] {
                 // original image and form and degree bounds are unlucky
                 // change the bound and try a new prime
-
                 debug!("Unlucky degree bound: {} vs {}", g, bounds[main_var]);
                 bounds[main_var] = g.ldegree(main_var);
                 return Err(GCDError::BadOriginalImage);
             }
 
             if g.ldegree(main_var) > bounds[main_var] {
-                failure_count += 1;
-                if failure_count > 2 {
-                    // p is likely unlucky
-                    debug!(
-                        "Bad current image: gcd({},{}) mod {} under {:?} = {}",
-                        a,
-                        b,
-                        a.field.get_prime(),
-                        r,
-                        g
-                    );
-                    return Err(GCDError::BadCurrentImage);
-                }
-                debug!("Degree too high");
-                continue 'find_root_sample;
-            }
-
-            // construct the scaling coefficient
-            let mut scale_factor = a.field.one();
-            let mut coeff = a.field.one();
-            let (c, d) = &shape[single_scale];
-            for (n, v) in r.iter() {
-                // TODO: can be taken from row?
-                a.field.mul_assign(
-                    &mut coeff,
-                    &a.field.pow(v, c.exponents(0)[*n].to_u32() as u64),
-                );
-            }
-
-            let mut found = false;
-            for t in &g {
-                if t.exponents[main_var] == *d {
-                    scale_factor = g.field.div(&coeff, t.coefficient);
-                    found = true;
-                    break;
-                }
-            }
-
-            if !found {
-                // the scaling term is missing, so the assumed form is wrong
-                debug!("Bad original image");
-                return Err(GCDError::BadOriginalImage);
+                return Err(GCDError::BadCurrentImage);
             }
 
             // check if all the monomials of the image appear in the shape
             // if not, the original shape is bad
             for m in g.into_iter() {
                 if shape.iter().all(|(_, pow)| *pow != m.exponents[main_var]) {
                     debug!("Bad shape: terms missing");
                     return Err(GCDError::BadOriginalImage);
                 }
             }
 
-            // construct the right-hand side
-            'rhs: for (i, (rhs, (shape_part, exp))) in samples.iter_mut().zip(shape).enumerate() {
-                // we may not need all terms
-                if rhs.len() == shape_part.nterms() {
-                    continue;
-                }
-
-                // find the associated term in the sample, trying the usual place first
-                if i < g.nterms() && g.exponents(i)[main_var] == *exp {
-                    rhs.push(a.field.neg(&a.field.mul(&g.coefficients[i], &scale_factor)));
-                } else {
-                    // find the matching term if it exists
-                    for m in g.into_iter() {
-                        if m.exponents[main_var] == *exp {
-                            rhs.push(a.field.neg(&a.field.mul(m.coefficient, &scale_factor)));
-                            continue 'rhs;
-                        }
-                    }
-
-                    rhs.push(a.field.zero());
+            // construct the scaling coefficient
+            let (_, d) = &shape[single_scale];
+            for t in &g {
+                if t.exponents[main_var] == *d {
+                    let scale_factor = a.field.neg(&a.field.inv(t.coefficient)); // TODO: why -1?
+                    return Ok(g.mul_coeff(scale_factor));
                 }
             }
-        }
-
-        break (row_sample_values, samples);
-    };
-
-    Ok(solve_vandermonde(
-        a,
-        main_var,
-        shape,
-        row_sample_values,
-        samples,
-    ))
-}
 
-/// Construct an image in the case where no monomial in the main variable is a single term.
-/// Using Javadi's method to solve the normalization problem, we first determine the coefficients of a single monomial using
-/// Gaussian elimination. Then, we are back in the single term case and we use a Vandermonde
-/// matrix to solve for every coefficient.
-#[instrument(level = "trace", fields(%a, %b))]
-fn construct_new_image_multiple_scales<UField: FiniteFieldWorkspace, E: Exponent>(
-    a: &MultivariatePolynomial<FiniteField<UField>, E>,
-    b: &MultivariatePolynomial<FiniteField<UField>, E>,
-    a_ldegree: E,
-    b_ldegree: E,
-    bounds: &mut [E],
-    vars: &[usize],
-    main_var: usize,
-    shape: &[(MultivariatePolynomial<FiniteField<UField>, E>, E)],
-) -> Result<MultivariatePolynomial<FiniteField<UField>, E>, GCDError>
-where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-    <FiniteField<UField> as Ring>::Element: Copy,
-{
-    let mut rng = rand::thread_rng();
-
-    let mut failure_count = 0;
-
-    // store a table for variables raised to a certain power
-    let mut cache = (0..a.nvars)
-        .map(|i| {
-            vec![
-                a.field.zero();
-                min(
-                    max(a.degree(i), b.degree(i)).to_u32() as usize + 1,
-                    POW_CACHE_SIZE
-                )
-            ]
-        })
-        .collect::<Vec<_>>();
-
-    // sort the shape based on the number of terms in the coefficient
-    let mut shape_map: Vec<_> = (0..shape.len()).collect();
-    shape_map.sort_unstable_by_key(|i| shape[*i].0.nterms());
-
-    let mut scaling_var_relations: Vec<Vec<<FiniteField<UField> as Ring>::Element>> = vec![];
+            // the scaling term is missing, so the assumed form is wrong
+            debug!("Bad original image");
+            return Err(GCDError::BadOriginalImage);
+        }
 
-    let max_terms = shape[*shape_map.last().unwrap()].0.nterms();
+        let mut rng = rand::thread_rng();
 
-    // find a set of sample points that yield unique coefficients for every coefficient of a term in the shape
-    let (row_sample_values, samples) = 'find_root_sample: loop {
-        for v in &mut cache {
-            for vi in v {
-                *vi = a.field.zero();
-            }
-        }
+        let mut failure_count = 0;
 
-        let r_orig: SmallVec<[_; INLINED_EXPONENTS]> = vars
-            .iter()
+        // store a table for variables raised to a certain power
+        let mut cache = (0..a.nvars())
             .map(|i| {
-                (
-                    *i,
-                    a.field.sample(
-                        &mut rng,
-                        (
-                            1,
-                            a.field.get_prime().to_u64().min(MAX_RNG_PREFACTOR as u64) as i64,
-                        ),
-                    ),
-                )
+                vec![
+                    a.field.zero();
+                    min(
+                        max(a.degree(i), b.degree(i)).to_u32() as usize + 1,
+                        POW_CACHE_SIZE
+                    )
+                ]
             })
-            .collect();
+            .collect::<Vec<_>>();
 
-        let mut row_sample_values = Vec::with_capacity(shape.len()); // coefficients for the linear system
+        // find a set of sample points that yield unique coefficients for every coefficient of a term in the shape
+        let (row_sample_values, samples) = 'find_root_sample: loop {
+            for v in &mut cache {
+                for vi in v {
+                    *vi = a.field.zero();
+                }
+            }
 
-        let max_samples_needed = 2 * max_terms - 1;
-        for (c, _) in shape.iter() {
-            let mut row = Vec::with_capacity(c.nterms());
-            let mut seen = HashSet::new();
-
-            for t in c {
-                // evaluate each exponent
-                let mut c = a.field.one();
-                for &(n, v) in &r_orig {
-                    let exp = t.exponents[n].to_u32() as usize;
-                    if exp > 0 {
-                        if exp < cache[n].len() {
-                            if FiniteField::<UField>::is_zero(&cache[n][exp]) {
-                                cache[n][exp] = a.field.pow(&v, exp as u64);
-                            }
+            let r_orig: SmallVec<[_; INLINED_EXPONENTS]> = vars
+                .iter()
+                .map(|i| (*i, a.field.sample(&mut rng, (1, MAX_RNG_PREFACTOR as i64))))
+                .collect();
 
-                            a.field.mul_assign(&mut c, &cache[n][exp]);
-                        } else {
-                            a.field.mul_assign(&mut c, &a.field.pow(&v, exp as u64));
+            let mut row_sample_values = Vec::with_capacity(shape.len()); // coefficients for the linear system
+            let mut samples_needed = 0;
+            for (c, _) in shape.iter() {
+                samples_needed = samples_needed.max(c.nterms());
+                let mut row = Vec::with_capacity(c.nterms());
+                let mut seen = HashSet::new();
+
+                for t in c {
+                    // evaluate each exponent
+                    let mut c = a.field.one();
+                    for (n, v) in &r_orig {
+                        let exp = t.exponents[*n].to_u32() as usize;
+                        if exp > 0 {
+                            if exp < cache[*n].len() {
+                                if F::is_zero(&cache[*n][exp]) {
+                                    cache[*n][exp] = a.field.pow(v, exp as u64);
+                                }
+
+                                a.field.mul_assign(&mut c, &cache[*n][exp]);
+                            } else {
+                                a.field.mul_assign(&mut c, &a.field.pow(v, exp as u64));
+                            }
                         }
                     }
-                }
-                row.push(c);
+                    row.push(c.clone());
 
-                // check if each element is unique
-                if !seen.insert(a.field.from_element(&c)) {
-                    debug!("Duplicate element: restarting");
-                    continue 'find_root_sample;
+                    // check if each element is unique
+                    if !seen.insert(c.clone()) {
+                        debug!("Duplicate element: restarting");
+                        continue 'find_root_sample;
+                    }
                 }
-            }
 
-            row_sample_values.push(row);
-        }
+                row_sample_values.push(row);
+            }
 
-        let mut samples = vec![Vec::with_capacity(max_samples_needed); shape.len()];
-        let mut r = r_orig.clone();
+            let mut samples = vec![Vec::with_capacity(samples_needed); shape.len()];
+            let mut r = r_orig.clone();
 
-        let a_eval = evaluate_exponents(a, &r_orig, &mut cache);
-        let b_eval = evaluate_exponents(b, &r_orig, &mut cache);
+            let a_eval = a.evaluate_exponents(&r_orig, &mut cache);
+            let b_eval = b.evaluate_exponents(&r_orig, &mut cache);
 
-        let mut a_current = Cow::Borrowed(&a_eval);
-        let mut b_current = Cow::Borrowed(&b_eval);
+            let mut a_current = Cow::Borrowed(&a_eval);
+            let mut b_current = Cow::Borrowed(&b_eval);
 
-        let mut a_poly = a.zero_with_capacity(a.degree(main_var).to_u32() as usize + 1);
-        let mut b_poly = b.zero_with_capacity(b.degree(main_var).to_u32() as usize + 1);
+            let mut a_poly = a.zero_with_capacity(a.degree(main_var).to_u32() as usize + 1);
+            let mut b_poly = b.zero_with_capacity(b.degree(main_var).to_u32() as usize + 1);
 
-        let mut second_index = 1;
-        let mut solved_coeff = None;
-        for sample_index in 0..max_samples_needed {
-            if solved_coeff.is_some() && sample_index >= max_terms {
-                // we have enough samples
-                break;
-            }
+            for sample_index in 0..samples_needed {
+                // sample at r^i
+                if sample_index > 0 {
+                    for (c, rr) in r.iter_mut().zip(&r_orig) {
+                        *c = (c.0, a.field.mul(&c.1, &rr.1));
+                    }
 
-            // sample at r^i
-            if sample_index > 0 {
-                for (c, rr) in r.iter_mut().zip(&r_orig) {
-                    *c = (c.0, a.field.mul(&c.1, &rr.1));
+                    for (c, e) in a_current.to_mut().iter_mut().zip(&a_eval) {
+                        a.field.mul_assign(c, e);
+                    }
+                    for (c, e) in b_current.to_mut().iter_mut().zip(&b_eval) {
+                        b.field.mul_assign(c, e);
+                    }
                 }
 
-                for (c, e) in a_current.to_mut().iter_mut().zip(&a_eval) {
-                    a.field.mul_assign(c, e);
-                }
-                for (c, e) in b_current.to_mut().iter_mut().zip(&b_eval) {
-                    b.field.mul_assign(c, e);
-                }
-            }
+                // now construct the univariate polynomials from the current evaluated monomials
+                a.evaluate_using_exponents(&a_current, main_var, &mut a_poly);
+                b.evaluate_using_exponents(&b_current, main_var, &mut b_poly);
 
-            // now construct the univariate polynomials from the current evaluated monomials
-            evaluate_using_exponents(a, &a_current, main_var, &mut a_poly);
-            evaluate_using_exponents(b, &b_current, main_var, &mut b_poly);
+                if a_poly.ldegree(main_var) != a_ldegree || b_poly.ldegree(main_var) != b_ldegree {
+                    continue 'find_root_sample;
+                }
 
-            if a_poly.ldegree(main_var) != a_ldegree || b_poly.ldegree(main_var) != b_ldegree {
-                continue 'find_root_sample;
-            }
+                let g = a_poly.univariate_gcd(&b_poly);
+                debug!(
+                    "GCD of sample at point {:?} in main var {}: {}",
+                    r, main_var, g
+                );
 
-            let mut g = MultivariatePolynomial::univariate_gcd(&a_poly, &b_poly);
-            debug!(
-                "GCD of sample at point {:?} in main var {}: {}",
-                r, main_var, g
-            );
+                if g.ldegree(main_var) < bounds[main_var] {
+                    // original image and form and degree bounds are unlucky
+                    // change the bound and try a new prime
 
-            if g.ldegree(main_var) < bounds[main_var] {
-                // original image and form and degree bounds are unlucky
-                // change the bound and try a new prime
+                    debug!("Unlucky degree bound: {} vs {}", g, bounds[main_var]);
+                    bounds[main_var] = g.ldegree(main_var);
+                    return Err(GCDError::BadOriginalImage);
+                }
 
-                debug!("Unlucky degree bound: {} vs {}", g, bounds[main_var]);
-                bounds[main_var] = g.ldegree(main_var);
-                return Err(GCDError::BadOriginalImage);
-            }
+                if g.ldegree(main_var) > bounds[main_var] {
+                    failure_count += 1;
+                    if failure_count > 2 {
+                        // p is likely unlucky
+                        debug!(
+                            "Bad current image: gcd({},{}) mod {} under {:?} = {}",
+                            a, b, a.field, r, g
+                        );
+                        return Err(GCDError::BadCurrentImage);
+                    }
+                    debug!("Degree too high");
+                    continue 'find_root_sample;
+                }
 
-            if g.ldegree(main_var) > bounds[main_var] {
-                failure_count += 1;
-                if failure_count > 2 {
-                    // p is likely unlucky
-                    debug!(
-                        "Bad current image: gcd({},{}) mod {} under {:?} = {}",
-                        a,
-                        b,
-                        a.field.get_prime(),
-                        r,
-                        g
+                // construct the scaling coefficient
+                let mut scale_factor = a.field.one();
+                let mut coeff = a.field.one();
+                let (c, d) = &shape[single_scale];
+                for (n, v) in r.iter() {
+                    // TODO: can be taken from row?
+                    a.field.mul_assign(
+                        &mut coeff,
+                        &a.field.pow(v, c.exponents(0)[*n].to_u32() as u64),
                     );
-                    return Err(GCDError::BadCurrentImage);
                 }
-                debug!("Degree too high");
-                continue 'find_root_sample;
-            }
 
-            // check if all the monomials of the image appear in the shape
-            // if not, the original shape is bad
-            for m in g.into_iter() {
-                if shape.iter().all(|(_, pow)| *pow != m.exponents[main_var]) {
-                    debug!("Bad shape: terms missing");
-                    return Err(GCDError::BadOriginalImage);
+                let mut found = false;
+                for t in &g {
+                    if t.exponents[main_var] == *d {
+                        scale_factor = g.field.div(&coeff, t.coefficient);
+                        found = true;
+                        break;
+                    }
                 }
-            }
 
-            // set the coefficient of the scaling term in the gcd to 1
-            let (_, d) = &shape[shape_map[0]];
-            let mut found = false;
-            for t in &g {
-                if t.exponents[main_var] == *d {
-                    let scale_factor = g.field.inv(t.coefficient);
-                    g = g.mul_coeff(scale_factor);
-                    found = true;
-                    break;
+                if !found {
+                    // the scaling term is missing, so the assumed form is wrong
+                    debug!("Bad original image");
+                    return Err(GCDError::BadOriginalImage);
                 }
-            }
 
-            if !found {
-                // the scaling term is missing, so the sample point is bad
-                debug!("Bad sample point: scaling term missing");
-                // TODO: check if this happen a number of times in a row
-                // as the prime may be too small to generate n samples that
-                // all contain the scaling term
-                continue 'find_root_sample;
-            }
-
-            // construct the right-hand side
-            'rhs: for (i, (rhs, (shape_part, exp))) in samples.iter_mut().zip(shape).enumerate() {
-                // we may not need all terms
-                if solved_coeff.is_some() && rhs.len() == shape_part.nterms() {
-                    continue;
+                // check if all the monomials of the image appear in the shape
+                // if not, the original shape is bad
+                for m in g.into_iter() {
+                    if shape.iter().all(|(_, pow)| *pow != m.exponents[main_var]) {
+                        debug!("Bad shape: terms missing");
+                        return Err(GCDError::BadOriginalImage);
+                    }
                 }
 
-                // find the associated term in the sample, trying the usual place first
-                if i < g.nterms() && g.exponents(i)[main_var] == *exp {
-                    rhs.push(g.coefficients[i]);
-                } else {
-                    // find the matching term if it exists
-                    for m in g.into_iter() {
-                        if m.exponents[main_var] == *exp {
-                            rhs.push(*m.coefficient);
-                            continue 'rhs;
-                        }
+                // construct the right-hand side
+                'rhs: for (i, (rhs, (shape_part, exp))) in samples.iter_mut().zip(shape).enumerate()
+                {
+                    // we may not need all terms
+                    if rhs.len() == shape_part.nterms() {
+                        continue;
                     }
 
-                    rhs.push(a.field.zero());
+                    // find the associated term in the sample, trying the usual place first
+                    if i < g.nterms() && g.exponents(i)[main_var] == *exp {
+                        rhs.push(a.field.neg(&a.field.mul(&g.coefficients[i], &scale_factor)));
+                    } else {
+                        // find the matching term if it exists
+                        for m in g.into_iter() {
+                            if m.exponents[main_var] == *exp {
+                                rhs.push(a.field.neg(&a.field.mul(m.coefficient, &scale_factor)));
+                                continue 'rhs;
+                            }
+                        }
+
+                        rhs.push(a.field.zero());
+                    }
                 }
             }
 
-            // see if we have collected enough samples to solve for the scaling factor
-            while solved_coeff.is_none() {
-                // try to solve the system!
-                let vars_scale = shape[shape_map[0]].0.nterms() - 1;
-                let vars_second = shape[shape_map[second_index]].0.nterms();
-                let samples_needed = vars_scale + vars_second;
-                let rows = samples_needed + scaling_var_relations.len();
+            break (row_sample_values, samples);
+        };
 
-                if sample_index + 1 < samples_needed {
-                    break; // obtain more samples
-                }
+        Ok(a.solve_vandermonde(main_var, shape, row_sample_values, samples))
+    }
 
-                let mut gfm = SmallVec::with_capacity(rows * samples_needed);
-                let mut new_rhs = SmallVec::with_capacity(rows);
+    /// Construct an image in the case where no monomial in the main variable is a single term.
+    /// Using Javadi's method to solve the normalization problem, we first determine the coefficients of a single monomial using
+    /// Gaussian elimination. Then, we are back in the single term case and we use a Vandermonde
+    /// matrix to solve for every coefficient.
+    #[instrument(level = "trace", fields(%a, %b))]
+    fn construct_new_image_multiple_scales(
+        a: &MultivariatePolynomial<F, E>,
+        b: &MultivariatePolynomial<F, E>,
+        a_ldegree: E,
+        b_ldegree: E,
+        bounds: &mut [E],
+        vars: &[usize],
+        main_var: usize,
+        shape: &[(MultivariatePolynomial<F, E>, E)],
+    ) -> Result<MultivariatePolynomial<F, E>, GCDError> {
+        let mut rng = rand::thread_rng();
 
-                for sample_index in 0..samples_needed {
-                    let rhs_sec = &samples[shape_map[second_index]][sample_index];
-                    let row_eval_sec = &row_sample_values[shape_map[second_index]];
-                    let row_eval_first = &row_sample_values[shape_map[0]];
+        let mut failure_count = 0;
 
-                    // assume first constant is 1, which will form the rhs of our equation
-                    let actual_rhs = a.field.mul(
-                        rhs_sec,
-                        &a.field.pow(&row_eval_first[0], sample_index as u64 + 1),
-                    );
+        // store a table for variables raised to a certain power
+        let mut cache = (0..a.nvars())
+            .map(|i| {
+                vec![
+                    a.field.zero();
+                    min(
+                        max(a.degree(i), b.degree(i)).to_u32() as usize + 1,
+                        POW_CACHE_SIZE
+                    )
+                ]
+            })
+            .collect::<Vec<_>>();
 
-                    for aa in row_eval_sec {
-                        gfm.push(a.field.pow(aa, sample_index as u64 + 1));
-                    }
+        // sort the shape based on the number of terms in the coefficient
+        let mut shape_map: Vec<_> = (0..shape.len()).collect();
+        shape_map.sort_unstable_by_key(|i| shape[*i].0.nterms());
 
-                    // place the scaling term variables at the end
-                    for aa in &row_eval_first[1..] {
-                        gfm.push(
-                            a.field.neg(
-                                &a.field
-                                    .mul(rhs_sec, &a.field.pow(aa, sample_index as u64 + 1)),
-                            ),
-                        );
-                    }
+        let mut scaling_var_relations: Vec<Vec<F::Element>> = vec![];
 
-                    new_rhs.push(actual_rhs);
+        let max_terms = shape[*shape_map.last().unwrap()].0.nterms();
+
+        // find a set of sample points that yield unique coefficients for every coefficient of a term in the shape
+        let (row_sample_values, samples) = 'find_root_sample: loop {
+            for v in &mut cache {
+                for vi in v {
+                    *vi = a.field.zero();
                 }
+            }
+
+            let r_orig: SmallVec<[_; INLINED_EXPONENTS]> = vars
+                .iter()
+                .map(|i| (*i, a.field.sample(&mut rng, (1, MAX_RNG_PREFACTOR as i64))))
+                .collect();
 
-                // add extra relations between the scaling term variables coming from previous tries
-                // that yielded underdetermined systems
-                for extra_relations in &scaling_var_relations {
-                    for _ in 0..vars_second {
-                        gfm.push(a.field.zero());
+            let mut row_sample_values = Vec::with_capacity(shape.len()); // coefficients for the linear system
+
+            let max_samples_needed = 2 * max_terms - 1;
+            for (c, _) in shape.iter() {
+                let mut row = Vec::with_capacity(c.nterms());
+                let mut seen = HashSet::new();
+
+                for t in c {
+                    // evaluate each exponent
+                    let mut c = a.field.one();
+                    for (n, v) in &r_orig {
+                        let exp = t.exponents[*n].to_u32() as usize;
+                        if exp > 0 {
+                            if exp < cache[*n].len() {
+                                if F::is_zero(&cache[*n][exp]) {
+                                    cache[*n][exp] = a.field.pow(v, exp as u64);
+                                }
+
+                                a.field.mul_assign(&mut c, &cache[*n][exp]);
+                            } else {
+                                a.field.mul_assign(&mut c, &a.field.pow(v, exp as u64));
+                            }
+                        }
                     }
+                    row.push(c.clone());
 
-                    for v in &extra_relations[..vars_scale] {
-                        gfm.push(*v);
+                    // check if each element is unique
+                    if !seen.insert(c) {
+                        debug!("Duplicate element: restarting");
+                        continue 'find_root_sample;
                     }
-                    new_rhs.push(*extra_relations.last().unwrap());
                 }
 
-                let m = Matrix {
-                    shape: (rows as u32, samples_needed as u32),
-                    data: gfm,
-                    field: a.field.clone(),
-                };
-                let rhs = Matrix {
-                    shape: (rows as u32, 1),
-                    data: new_rhs,
-                    field: a.field.clone(),
-                };
+                row_sample_values.push(row);
+            }
 
-                match m.solve(&rhs) {
-                    Ok(r) => {
-                        debug!(
-                            "Solved with {} and {} term",
-                            shape[shape_map[0]].0, shape[shape_map[second_index]].0
-                        );
+            let mut samples = vec![Vec::with_capacity(max_samples_needed); shape.len()];
+            let mut r = r_orig.clone();
 
-                        let mut r = r.data;
-                        r.drain(0..vars_second);
-                        solved_coeff = Some(r);
-                    }
-                    Err(LinearSolverError::Underdetermined {
-                        row_reduced_matrix, ..
-                    }) => {
-                        // extract relations between the variables in the scaling term from the row reduced augmented matrix
-                        let mat = row_reduced_matrix.expect("Row reduced matrix missing");
+            let a_eval = a.evaluate_exponents(&r_orig, &mut cache);
+            let b_eval = b.evaluate_exponents(&r_orig, &mut cache);
 
-                        debug!(
-                            "Underdetermined system {} and {} term; row reduction={}, rhs={}",
-                            shape[shape_map[0]].0, shape[shape_map[second_index]].0, mat, rhs
-                        );
+            let mut a_current = Cow::Borrowed(&a_eval);
+            let mut b_current = Cow::Borrowed(&b_eval);
 
-                        for x in mat.row_iter() {
-                            if x[..vars_second].iter().all(FiniteField::<UField>::is_zero)
-                                && x.iter().any(|y| !FiniteField::<UField>::is_zero(y))
-                            {
-                                scaling_var_relations.push(x[vars_second..].to_vec());
-                            }
-                        }
+            let mut a_poly = a.zero_with_capacity(a.degree(main_var).to_u32() as usize + 1);
+            let mut b_poly = b.zero_with_capacity(b.degree(main_var).to_u32() as usize + 1);
 
-                        second_index += 1;
-                        if second_index == shape.len() {
-                            // the system remains underdetermined, that means the shape is bad
-                            debug!("Could not determine monomial scaling due to a bad shape\na={}\nb={}\na_ldegree={}, b_ldegree={}\nbounds={:?}, vars={:?}, main_var={},\nmat={}\nrhs={},\nshape=",
-                            a,
-                            b,
-                            a_ldegree,
-                            b_ldegree,
-                            bounds,
-                            vars,
-                            main_var,
-                            mat,
-                            rhs);
-                            for s in shape {
-                                debug!("\t({}, {})", s.0, s.1);
-                            }
+            let mut second_index = 1;
+            let mut solved_coeff = None;
+            for sample_index in 0..max_samples_needed {
+                if solved_coeff.is_some() && sample_index >= max_terms {
+                    // we have enough samples
+                    break;
+                }
 
-                            return Err(GCDError::BadOriginalImage);
-                        }
+                // sample at r^i
+                if sample_index > 0 {
+                    for (c, rr) in r.iter_mut().zip(&r_orig) {
+                        *c = (c.0, a.field.mul(&c.1, &rr.1));
                     }
-                    Err(LinearSolverError::Inconsistent) => {
-                        debug!("Inconsistent system: bad shape");
-                        return Err(GCDError::BadOriginalImage);
+
+                    for (c, e) in a_current.to_mut().iter_mut().zip(&a_eval) {
+                        a.field.mul_assign(c, e);
                     }
-                    Err(LinearSolverError::NotSquare) => {
-                        unreachable!()
+                    for (c, e) in b_current.to_mut().iter_mut().zip(&b_eval) {
+                        b.field.mul_assign(c, e);
                     }
                 }
-            }
-        }
 
-        if let Some(r) = solved_coeff {
-            // evaluate the scaling term for every sample
-            let mut lcoeff_cache = Vec::with_capacity(max_terms);
-            for sample_index in 0..max_terms {
-                let row_eval_first = &row_sample_values[shape_map[0]];
-                let mut scaling_factor = a.field.pow(&row_eval_first[0], sample_index as u64 + 1); // coeff eval is 1
-                for (exp_eval, coeff_eval) in row_sample_values[shape_map[0]][1..].iter().zip(&r) {
-                    a.field.add_mul_assign(
-                        &mut scaling_factor,
-                        coeff_eval,
-                        &a.field.pow(exp_eval, sample_index as u64 + 1),
-                    );
+                // now construct the univariate polynomials from the current evaluated monomials
+                a.evaluate_using_exponents(&a_current, main_var, &mut a_poly);
+                b.evaluate_using_exponents(&b_current, main_var, &mut b_poly);
+
+                if a_poly.ldegree(main_var) != a_ldegree || b_poly.ldegree(main_var) != b_ldegree {
+                    continue 'find_root_sample;
                 }
-                lcoeff_cache.push(scaling_factor);
+
+                let mut g = a_poly.univariate_gcd(&b_poly);
                 debug!(
-                    "Scaling fac {}: {}",
-                    sample_index,
-                    a.field.from_element(&scaling_factor)
+                    "GCD of sample at point {:?} in main var {}: {}",
+                    r, main_var, g
                 );
-            }
-
-            for ((c, _), rhs) in shape.iter().zip(&mut samples) {
-                rhs.truncate(c.nterms()); // drop unneeded samples
-                for (r, scale) in rhs.iter_mut().zip(&lcoeff_cache) {
-                    a.field.mul_assign(r, scale);
-                }
-            }
-        } else {
-            debug!(
-                "Could not solve the system with just 2 terms: a={}, b={}",
-                a, b
-            );
-        }
 
-        break (row_sample_values, samples);
-    };
+                if g.ldegree(main_var) < bounds[main_var] {
+                    // original image and form and degree bounds are unlucky
+                    // change the bound and try a new prime
 
-    Ok(solve_vandermonde(
-        a,
-        main_var,
-        shape,
-        row_sample_values,
-        samples,
-    ))
-}
+                    debug!("Unlucky degree bound: {} vs {}", g, bounds[main_var]);
+                    bounds[main_var] = g.ldegree(main_var);
+                    return Err(GCDError::BadOriginalImage);
+                }
 
-impl<UField: FiniteFieldWorkspace, E: Exponent> MultivariatePolynomial<FiniteField<UField>, E>
-where
-    FiniteField<UField>: FiniteFieldCore<UField>,
-    <FiniteField<UField> as Ring>::Element: Copy,
-{
-    /// Compute the univariate GCD using Euclid's algorithm. The result is normalized to 1.
-    fn univariate_gcd(&self, b: &Self) -> Self {
-        if self.is_zero() {
-            return b.clone();
-        }
-        if b.is_zero() {
-            return self.clone();
-        }
+                if g.ldegree(main_var) > bounds[main_var] {
+                    failure_count += 1;
+                    if failure_count > 2 {
+                        // p is likely unlucky
+                        debug!(
+                            "Bad current image: gcd({},{}) mod {} under {:?} = {}",
+                            a, b, a.field, r, g
+                        );
+                        return Err(GCDError::BadCurrentImage);
+                    }
+                    debug!("Degree too high");
+                    continue 'find_root_sample;
+                }
 
-        let mut c = self.clone();
-        let mut d = b.clone();
-        if self.ldegree_max() < b.ldegree_max() {
-            mem::swap(&mut c, &mut d);
-        }
+                // check if all the monomials of the image appear in the shape
+                // if not, the original shape is bad
+                for m in g.into_iter() {
+                    if shape.iter().all(|(_, pow)| *pow != m.exponents[main_var]) {
+                        debug!("Bad shape: terms missing");
+                        return Err(GCDError::BadOriginalImage);
+                    }
+                }
 
-        // TODO: there exists an efficient algorithm for univariate poly
-        // division in a finite field using FFT
-        let mut r = c.quot_rem_univariate(&mut d).1;
-        while !r.is_zero() {
-            c = d;
-            d = r;
-            r = c.quot_rem_univariate(&mut d).1;
-        }
+                // set the coefficient of the scaling term in the gcd to 1
+                let (_, d) = &shape[shape_map[0]];
+                let mut found = false;
+                for t in &g {
+                    if t.exponents[main_var] == *d {
+                        let scale_factor = g.field.inv(t.coefficient);
+                        g = g.mul_coeff(scale_factor);
+                        found = true;
+                        break;
+                    }
+                }
 
-        // normalize the gcd
-        let l = *d.coefficients.last().unwrap();
-        for x in &mut d.coefficients {
-            self.field.div_assign(x, &l);
-        }
+                if !found {
+                    // the scaling term is missing, so the sample point is bad
+                    debug!("Bad sample point: scaling term missing");
+                    // TODO: check if this happen a number of times in a row
+                    // as the prime may be too small to generate n samples that
+                    // all contain the scaling term
+                    continue 'find_root_sample;
+                }
 
-        d
-    }
+                // construct the right-hand side
+                'rhs: for (i, (rhs, (shape_part, exp))) in samples.iter_mut().zip(shape).enumerate()
+                {
+                    // we may not need all terms
+                    if solved_coeff.is_some() && rhs.len() == shape_part.nterms() {
+                        continue;
+                    }
 
-    /// Replace all variables except `v` in the polynomial by elements from
-    /// a finite field of size `p`.
-    pub fn sample_polynomial(
-        &self,
-        v: usize,
-        r: &[(usize, <FiniteField<UField> as Ring>::Element)],
-        cache: &mut [Vec<<FiniteField<UField> as Ring>::Element>],
-        tm: &mut HashMap<E, <FiniteField<UField> as Ring>::Element>,
-    ) -> Self {
-        for mv in self.into_iter() {
-            let mut c = *mv.coefficient;
-            for &(n, vv) in r {
-                let exp = mv.exponents[n].to_u32() as usize;
-                if exp > 0 {
-                    if exp < cache[n].len() {
-                        if FiniteField::<UField>::is_zero(&cache[n][exp]) {
-                            cache[n][exp] = self.field.pow(&vv, exp as u64);
+                    // find the associated term in the sample, trying the usual place first
+                    if i < g.nterms() && g.exponents(i)[main_var] == *exp {
+                        rhs.push(g.coefficients[i].clone());
+                    } else {
+                        // find the matching term if it exists
+                        for m in g.into_iter() {
+                            if m.exponents[main_var] == *exp {
+                                rhs.push(m.coefficient.clone());
+                                continue 'rhs;
+                            }
                         }
 
-                        self.field.mul_assign(&mut c, &cache[n][exp]);
-                    } else {
-                        self.field
-                            .mul_assign(&mut c, &self.field.pow(&vv, exp as u64));
+                        rhs.push(a.field.zero());
                     }
                 }
-            }
 
-            tm.entry(mv.exponents[v])
-                .and_modify(|e| self.field.add_assign(e, &c))
-                .or_insert(c);
-        }
+                // see if we have collected enough samples to solve for the scaling factor
+                while solved_coeff.is_none() {
+                    // try to solve the system!
+                    let vars_scale = shape[shape_map[0]].0.nterms() - 1;
+                    let vars_second = shape[shape_map[second_index]].0.nterms();
+                    let samples_needed = vars_scale + vars_second;
+                    let rows = samples_needed + scaling_var_relations.len();
 
-        let mut res = self.zero();
-        let mut e = vec![E::zero(); self.nvars];
-        for (k, c) in tm.drain() {
-            if !FiniteField::<UField>::is_zero(&c) {
-                e[v] = k;
-                res.append_monomial(c, &e);
-                e[v] = E::zero();
-            }
-        }
+                    if sample_index + 1 < samples_needed {
+                        break; // obtain more samples
+                    }
 
-        res
-    }
+                    let mut gfm = Vec::with_capacity(rows * samples_needed);
+                    let mut new_rhs = Vec::with_capacity(rows);
 
-    /// Replace all variables except `v` in the polynomial by elements from
-    /// a finite field of size `p`. The exponent of `v` should be small.
-    pub fn sample_polynomial_small_exponent(
-        &self,
-        v: usize,
-        r: &[(usize, <FiniteField<UField> as Ring>::Element)],
-        cache: &mut [Vec<<FiniteField<UField> as Ring>::Element>],
-        tm: &mut [<FiniteField<UField> as Ring>::Element],
-    ) -> MultivariatePolynomial<FiniteField<UField>, E> {
-        for mv in self.into_iter() {
-            let mut c = *mv.coefficient;
-            for &(n, vv) in r {
-                let exp = mv.exponents[n].to_u32() as usize;
-                if exp > 0 {
-                    if exp < cache[n].len() {
-                        if FiniteField::<UField>::is_zero(&cache[n][exp]) {
-                            cache[n][exp] = self.field.pow(&vv, exp as u64);
-                        }
+                    for sample_index in 0..samples_needed {
+                        let rhs_sec = &samples[shape_map[second_index]][sample_index];
+                        let row_eval_sec = &row_sample_values[shape_map[second_index]];
+                        let row_eval_first = &row_sample_values[shape_map[0]];
 
-                        self.field.mul_assign(&mut c, &cache[n][exp]);
-                    } else {
-                        self.field
-                            .mul_assign(&mut c, &self.field.pow(&vv, exp as u64));
-                    }
-                }
-            }
+                        // assume first constant is 1, which will form the rhs of our equation
+                        let actual_rhs = a.field.mul(
+                            rhs_sec,
+                            &a.field.pow(&row_eval_first[0], sample_index as u64 + 1),
+                        );
 
-            let expv = mv.exponents[v].to_u32() as usize;
-            self.field.add_assign(&mut tm[expv], &c);
-        }
+                        for aa in row_eval_sec {
+                            gfm.push(a.field.pow(aa, sample_index as u64 + 1));
+                        }
 
-        // TODO: add bounds estimate
-        let mut res = self.zero();
-        let mut e = vec![E::zero(); self.nvars];
-        for (k, c) in tm.iter_mut().enumerate() {
-            if !FiniteField::<UField>::is_zero(c) {
-                e[v] = E::from_u32(k as u32);
-                res.append_monomial_back(mem::replace(c, self.field.zero()), &e);
-                e[v] = E::zero();
-            }
-        }
+                        // place the scaling term variables at the end
+                        for aa in &row_eval_first[1..] {
+                            gfm.push(
+                                a.field.neg(
+                                    &a.field
+                                        .mul(rhs_sec, &a.field.pow(aa, sample_index as u64 + 1)),
+                                ),
+                            );
+                        }
 
-        res
-    }
+                        new_rhs.push(actual_rhs);
+                    }
 
-    /// Find the upper bound of a variable `var` in the gcd.
-    /// This is done by computing the univariate gcd by
-    /// substituting all variables except `var`. This
-    /// upper bound could be too tight due to an unfortunate
-    /// sample point, but this is rare.
-    fn get_gcd_var_bound(ap: &Self, bp: &Self, vars: &[usize], var: usize) -> E {
-        let mut rng = rand::thread_rng();
+                    // add extra relations between the scaling term variables coming from previous tries
+                    // that yielded underdetermined systems
+                    for extra_relations in &scaling_var_relations {
+                        for _ in 0..vars_second {
+                            gfm.push(a.field.zero());
+                        }
 
-        // store a table for variables raised to a certain power
-        let mut cache = (0..ap.nvars)
-            .map(|i| {
-                vec![
-                    ap.field.zero();
-                    min(
-                        max(ap.degree(i), bp.degree(i)).to_u32() as usize + 1,
-                        POW_CACHE_SIZE
+                        for v in &extra_relations[..vars_scale] {
+                            gfm.push(v.clone());
+                        }
+                        new_rhs.push(extra_relations.last().unwrap().clone());
+                    }
+
+                    let m = Matrix::from_linear(
+                        gfm,
+                        rows as u32,
+                        samples_needed as u32,
+                        a.field.clone(),
                     )
-                ]
-            })
-            .collect::<Vec<_>>();
+                    .unwrap();
+                    let rhs = Matrix::new_vec(new_rhs, a.field.clone());
 
-        // store a power map for the univariate polynomials that will be sampled
-        // the sampling_polynomial routine will set the power to 0 after use
-        let mut tm = HashMap::with_capacity_and_hasher(INITIAL_POW_MAP_SIZE, Default::default());
+                    match m.solve(&rhs) {
+                        Ok(r) => {
+                            debug!(
+                                "Solved with {} and {} term",
+                                shape[shape_map[0]].0, shape[shape_map[second_index]].0
+                            );
+
+                            let mut r = r.data;
+                            r.drain(0..vars_second);
+                            solved_coeff = Some(r);
+                        }
+                        Err(MatrixError::Underdetermined {
+                            row_reduced_matrix, ..
+                        }) => {
+                            // extract relations between the variables in the scaling term from the row reduced augmented matrix
+                            let mat = row_reduced_matrix.expect("Row reduced matrix missing");
+
+                            debug!(
+                                "Underdetermined system {} and {} term; row reduction={}, rhs={}",
+                                shape[shape_map[0]].0, shape[shape_map[second_index]].0, mat, rhs
+                            );
+
+                            for x in mat.row_iter() {
+                                if x[..vars_second].iter().all(F::is_zero)
+                                    && x.iter().any(|y| !F::is_zero(y))
+                                {
+                                    scaling_var_relations.push(x[vars_second..].to_vec());
+                                }
+                            }
 
-        // generate random numbers for all non-leading variables
-        // TODO: apply a Horner scheme to speed up the substitution?
-        let (_, a1, b1) = loop {
-            for v in &mut cache {
-                for vi in v {
-                    *vi = ap.field.zero();
+                            second_index += 1;
+                            if second_index == shape.len() {
+                                // the system remains underdetermined, that means the shape is bad
+                                debug!("Could not determine monomial scaling due to a bad shape\na={}\nb={}\na_ldegree={}, b_ldegree={}\nbounds={:?}, vars={:?}, main_var={},\nmat={}\nrhs={},\nshape=",
+                            a,
+                            b,
+                            a_ldegree,
+                            b_ldegree,
+                            bounds,
+                            vars,
+                            main_var,
+                            mat,
+                            rhs);
+                                for s in shape {
+                                    debug!("\t({}, {})", s.0, s.1);
+                                }
+
+                                return Err(GCDError::BadOriginalImage);
+                            }
+                        }
+                        Err(MatrixError::Inconsistent) => {
+                            debug!("Inconsistent system: bad shape");
+                            return Err(GCDError::BadOriginalImage);
+                        }
+                        Err(
+                            MatrixError::NotSquare
+                            | MatrixError::ShapeMismatch
+                            | MatrixError::RightHandSideIsNotVector
+                            | MatrixError::Singular,
+                        ) => {
+                            unreachable!()
+                        }
+                    }
                 }
             }
 
-            let r: Vec<_> = vars
-                .iter()
-                .map(|i| {
-                    (
-                        *i,
-                        ap.field.sample(
-                            &mut rng,
-                            (
-                                1,
-                                ap.field.get_prime().to_u64().min(MAX_RNG_PREFACTOR as u64) as i64,
-                            ),
-                        ),
-                    )
-                })
-                .collect();
+            if let Some(r) = solved_coeff {
+                // evaluate the scaling term for every sample
+                let mut lcoeff_cache = Vec::with_capacity(max_terms);
+                for sample_index in 0..max_terms {
+                    let row_eval_first = &row_sample_values[shape_map[0]];
+                    let mut scaling_factor =
+                        a.field.pow(&row_eval_first[0], sample_index as u64 + 1); // coeff eval is 1
+                    for (exp_eval, coeff_eval) in
+                        row_sample_values[shape_map[0]][1..].iter().zip(&r)
+                    {
+                        a.field.add_mul_assign(
+                            &mut scaling_factor,
+                            coeff_eval,
+                            &a.field.pow(exp_eval, sample_index as u64 + 1),
+                        );
+                    }
 
-            let a1 = ap.sample_polynomial(var, &r, &mut cache, &mut tm);
-            let b1 = bp.sample_polynomial(var, &r, &mut cache, &mut tm);
+                    debug!(
+                        "Scaling fac {}: {}",
+                        sample_index,
+                        a.field.printer(&scaling_factor)
+                    );
+                    lcoeff_cache.push(scaling_factor);
+                }
 
-            if a1.ldegree(var) == ap.degree(var) && b1.ldegree(var) == bp.degree(var) {
-                break (r, a1, b1);
+                for ((c, _), rhs) in shape.iter().zip(&mut samples) {
+                    rhs.truncate(c.nterms()); // drop unneeded samples
+                    for (r, scale) in rhs.iter_mut().zip(&lcoeff_cache) {
+                        a.field.mul_assign(r, scale);
+                    }
+                }
+            } else {
+                debug!(
+                    "Could not solve the system with just 2 terms: a={}, b={}",
+                    a, b
+                );
             }
 
-            debug!(
-                "Degree error during sampling: trying again: a={}, a1=={}, bp={}, b1={}",
-                ap, a1, bp, b1
-            );
+            break (row_sample_values, samples);
         };
 
-        let g1 = MultivariatePolynomial::univariate_gcd(&a1, &b1);
-        g1.ldegree_max()
+        Ok(a.solve_vandermonde(main_var, shape, row_sample_values, samples))
     }
+}
 
+impl<F: Field + PolynomialGCD<E>, E: Exponent> MultivariatePolynomial<F, E> {
     /// Compute the gcd shape of two polynomials in a finite field by filling in random
     /// numbers.
     #[instrument(level = "debug", skip_all)]
     fn gcd_shape_modular(
         a: &Self,
         b: &Self,
         vars: &[usize],         // variables
@@ -1189,37 +1081,36 @@
         tight_bounds: &mut [E], // tighter degree bounds
     ) -> Option<Self> {
         let lastvar = *vars.last().unwrap();
 
         // if we are in the univariate case, return the univariate gcd
         // TODO: this is a modification of the algorithm!
         if vars.len() == 1 {
-            let gg = MultivariatePolynomial::univariate_gcd(a, b);
+            let gg = a.univariate_gcd(b);
             if gg.degree(vars[0]) > bounds[vars[0]] {
                 return None;
             }
             bounds[vars[0]] = gg.degree(vars[0]); // update degree bound
             return Some(gg);
         }
 
         // the gcd of the content in the last variable should be 1
-        let c = MultivariatePolynomial::multivariate_content_gcd(a, b, lastvar);
+        let c = a.multivariate_content_gcd(b, lastvar);
         if !c.is_one() {
             debug!("Content in last variable is not 1, but {}", c);
             // TODO: we assume that a content of -1 is also allowed
             // like in the special case gcd_(-x0*x1,-x0-x0*x1)
             if c.nterms() != 1 || c.coefficients[0] != a.field.neg(&a.field.one()) {
                 return None;
             }
         }
 
-        let gamma = MultivariatePolynomial::univariate_gcd(
-            &a.lcoeff_last_varorder(vars),
-            &b.lcoeff_last_varorder(vars),
-        );
+        let gamma = a
+            .lcoeff_last_varorder(vars)
+            .univariate_gcd(&b.lcoeff_last_varorder(vars));
 
         let mut rng = rand::thread_rng();
 
         let mut failure_count = 0;
 
         'newfirstnum: loop {
             // if we had two failures, it may be that the tight degree bound
@@ -1230,27 +1121,21 @@
                     lastvar, tight_bounds[lastvar], bounds[lastvar]
                 );
                 tight_bounds[lastvar] = bounds[lastvar];
             }
             failure_count += 1;
 
             let v = loop {
-                let a = a.field.sample(
-                    &mut rng,
-                    (
-                        1,
-                        a.field.get_prime().to_u64().min(MAX_RNG_PREFACTOR as u64) as i64,
-                    ),
-                );
+                let a = a.field.sample(&mut rng, (1, MAX_RNG_PREFACTOR as i64));
                 if !gamma.replace(lastvar, &a).is_zero() {
                     break a;
                 }
             };
 
-            debug!("Chosen variable: {}", a.field.from_element(&v));
+            debug!("Chosen variable: {}", a.field.printer(&v));
             let av = a.replace(lastvar, &v);
             let bv = b.replace(lastvar, &v);
 
             // performance dense reconstruction
             let mut gv = if vars.len() > 2 {
                 match MultivariatePolynomial::gcd_shape_modular(
                     &av,
@@ -1259,25 +1144,25 @@
                     bounds,
                     tight_bounds,
                 ) {
                     Some(x) => x,
                     None => return None,
                 }
             } else {
-                let gg = MultivariatePolynomial::univariate_gcd(&av, &bv);
+                let gg = av.univariate_gcd(&bv);
                 if gg.degree(vars[0]) > bounds[vars[0]] {
                     return None;
                 }
                 bounds[vars[0]] = gg.degree(vars[0]); // update degree bound
                 gg
             };
 
             debug!(
                 "GCD shape suggestion for sample point {} and gamma {}: {}",
-                a.field.from_element(&v),
+                a.field.printer(&v),
                 gamma,
                 gv
             );
 
             // construct a new assumed form
             let gfu = gv.to_univariate_polynomial_list(vars[0]);
 
@@ -1320,46 +1205,40 @@
                 if gseq.len()
                     == (tight_bounds[lastvar].to_u32() + gamma.ldegree_max().to_u32() + 1) as usize
                 {
                     break;
                 }
 
                 let v = loop {
-                    let v = a.field.sample(
-                        &mut rng,
-                        (
-                            1,
-                            a.field.get_prime().to_u64().min(MAX_RNG_PREFACTOR as u64) as i64,
-                        ),
-                    );
+                    let v = a.field.sample(&mut rng, (1, MAX_RNG_PREFACTOR as i64));
                     if !gamma.replace(lastvar, &v).is_zero() {
                         // we need unique sampling points
                         if !vseq.contains(&v) {
                             break v;
                         }
                     }
                 };
 
                 let av = a.replace(lastvar, &v);
                 let bv = b.replace(lastvar, &v);
 
                 let rec = if let Some(single_scale) = single_scale {
-                    construct_new_image_single_scale(
+                    Self::construct_new_image_single_scale(
                         &av,
                         &bv,
                         av.degree(vars[0]),
                         bv.degree(vars[0]),
                         bounds,
                         single_scale,
                         &vars[1..vars.len() - 1],
                         vars[0],
                         &gfu,
                     )
                 } else {
-                    construct_new_image_multiple_scales(
+                    Self::construct_new_image_multiple_scales(
                         &av,
                         &bv,
                         // NOTE: different from paper where they use a.degree(..)
                         // it could be that the degree in av is lower than that of a
                         // which means the sampling will never terminate
                         av.degree(vars[0]),
                         bv.degree(vars[0]),
@@ -1393,55 +1272,43 @@
                             .div(&gamma.replace(lastvar, &v).coefficients[0], &lc),
                     ),
                 );
                 vseq.push(v);
             }
 
             // use interpolation to construct x_n dependence
-            let mut gc = newton_interpolation(&vseq, &gseq, lastvar);
+            let mut gc = Self::newton_interpolation(&vseq, &gseq, lastvar);
             debug!("Interpolated: {}", gc);
 
             // remove content in x_n (wrt all other variables)
             let cont = gc.multivariate_content(lastvar);
             if !cont.is_one() {
                 debug!("Removing content in x{}: {}", lastvar, cont);
                 gc = gc.divides(&cont).unwrap();
             }
 
             // do a probabilistic division test
             let (g1, a1, b1) = loop {
                 // store a table for variables raised to a certain power
-                let mut cache = (0..a.nvars)
+                let mut cache = (0..a.nvars())
                     .map(|i| {
                         vec![
                             a.field.zero();
                             min(
                                 max(a.degree(i), b.degree(i)).to_u32() as usize + 1,
                                 POW_CACHE_SIZE
                             )
                         ]
                     })
                     .collect::<Vec<_>>();
 
                 let r: Vec<_> = vars
                     .iter()
                     .skip(1)
-                    .map(|i| {
-                        (
-                            *i,
-                            a.field.sample(
-                                &mut rng,
-                                (
-                                    1,
-                                    a.field.get_prime().to_u64().min(MAX_RNG_PREFACTOR as u64)
-                                        as i64,
-                                ),
-                            ),
-                        )
-                    })
+                    .map(|i| (*i, a.field.sample(&mut rng, (1, MAX_RNG_PREFACTOR as i64))))
                     .collect();
 
                 let g1 = gc.replace_all_except(vars[0], &r, &mut cache);
 
                 if g1.ldegree(vars[0]) == gc.degree(vars[0]) {
                     let a1 = a.replace_all_except(vars[0], &r, &mut cache);
                     let b1 = b.replace_all_except(vars[0], &r, &mut cache);
@@ -1618,54 +1485,54 @@
 
         None
     }
 
     /// Compute the gcd of two multivariate polynomials.
     #[instrument(skip_all)]
     pub fn gcd(&self, b: &MultivariatePolynomial<R, E>) -> MultivariatePolynomial<R, E> {
-        debug_assert_eq!(self.nvars, b.nvars);
+        debug_assert_eq!(self.nvars(), b.nvars());
         debug!("gcd of {} and {}", self, b);
 
         if let Some(g) = self.simple_gcd(b) {
             debug!("Simple {} ", g);
             return g;
         }
 
         // a and b are only copied when needed
         let mut a = Cow::Borrowed(self);
         let mut b = Cow::Borrowed(b);
 
         // determine the maximum shared power of every variable
         let mut shared_degree: SmallVec<[E; INLINED_EXPONENTS]> = a.exponents(0).into();
         for p in [&a, &b] {
-            for e in p.exponents.chunks(p.nvars) {
+            for e in p.exponents_iter() {
                 for (md, v) in shared_degree.iter_mut().zip(e) {
                     *md = (*md).min(*v);
                 }
             }
         }
 
         // divide out the common factors
         if shared_degree.iter().any(|d| *d != E::zero()) {
             let aa = a.to_mut();
-            for e in aa.exponents.chunks_mut(aa.nvars) {
+            for e in aa.exponents_iter_mut() {
                 for (v, d) in e.iter_mut().zip(&shared_degree) {
                     *v = *v - *d;
                 }
             }
 
             let bb = b.to_mut();
-            for e in bb.exponents.chunks_mut(bb.nvars) {
+            for e in bb.exponents_iter_mut() {
                 for (v, d) in e.iter_mut().zip(&shared_degree) {
                     *v = *v - *d;
                 }
             }
         };
 
-        let mut base_degree: SmallVec<[Option<E>; INLINED_EXPONENTS]> = smallvec![None; a.nvars];
+        let mut base_degree: SmallVec<[Option<E>; INLINED_EXPONENTS]> = smallvec![None; a.nvars()];
 
         if let Some(g) = MultivariatePolynomial::simple_gcd(&a, &b) {
             return rescale_gcd(g, &shared_degree, &base_degree, &a.constant(a.field.one()));
         }
 
         // check if the polynomial are functions of x^n, n > 1
         for p in [&a, &b] {
@@ -1686,24 +1553,24 @@
 
         // rename x^base_deg to x
         if base_degree
             .iter()
             .any(|d| d.is_some() && d.unwrap() > E::one())
         {
             let aa = a.to_mut();
-            for e in aa.exponents.chunks_mut(aa.nvars) {
+            for e in aa.exponents_iter_mut() {
                 for (v, d) in e.iter_mut().zip(&base_degree) {
                     if let Some(d) = d {
                         *v = *v / *d;
                     }
                 }
             }
 
             let bb = b.to_mut();
-            for e in bb.exponents.chunks_mut(bb.nvars) {
+            for e in bb.exponents_iter_mut() {
                 for (v, d) in e.iter_mut().zip(&base_degree) {
                     if let Some(d) = d {
                         *v = *v / *d;
                     }
                 }
             }
         }
@@ -1721,15 +1588,15 @@
             }
 
             if shared_degree.iter().any(|d| *d > E::from_u32(0))
                 || base_degree
                     .iter()
                     .any(|d| d.map(|bd| bd > E::one()).unwrap_or(false))
             {
-                for e in g.exponents.chunks_mut(g.nvars) {
+                for e in g.exponents_iter_mut() {
                     for ((v, d), s) in e.iter_mut().zip(base_degree).zip(shared_degree) {
                         if let Some(d) = d {
                             *v = *v * *d;
                         }
 
                         *v += *s;
                     }
@@ -1746,15 +1613,15 @@
                 &shared_degree,
                 &base_degree,
                 &a.constant(a.field.one()),
             );
         }
 
         // store which variables appear in which expression
-        let mut scratch: SmallVec<[i32; INLINED_EXPONENTS]> = smallvec![0i32; a.nvars];
+        let mut scratch: SmallVec<[i32; INLINED_EXPONENTS]> = smallvec![0i32; a.nvars()];
         for (p, inc) in [(&a, 1), (&b, 2)] {
             for t in p.into_iter() {
                 for (e, ee) in scratch.iter_mut().zip(t.exponents) {
                     if !ee.is_zero() {
                         *e |= inc;
                     }
                 }
@@ -1801,15 +1668,15 @@
         }
         if a.nterms() <= b.nterms() && b.divides(&a).is_some() {
             return rescale_gcd(a.into_owned(), &shared_degree, &base_degree, &b.one());
         }
 
         // check if the polynomial is linear in a variable and compute the gcd using the univariate content
         for (p1, p2) in [(&a, &b), (&b, &a)] {
-            if let Some(var) = (0..p1.nvars).find(|v| p1.degree(*v) == E::one()) {
+            if let Some(var) = (0..p1.nvars()).find(|v| p1.degree(*v) == E::one()) {
                 let mut cont = p1.univariate_content(var);
 
                 let p1_prim = p1.as_ref() / &cont;
 
                 if !cont.is_one() || !R::one_is_gcd_unit() {
                     let cont_p2 = p2.univariate_content(var);
                     cont = cont.gcd(&cont_p2);
@@ -1831,15 +1698,15 @@
         let mut vars: SmallVec<[_; INLINED_EXPONENTS]> = scratch
             .iter()
             .enumerate()
             .filter_map(|(i, v)| if *v == 3 { Some(i) } else { None })
             .collect();
 
         // determine safe bounds for variables in the gcd
-        let mut bounds: SmallVec<[_; INLINED_EXPONENTS]> = (0..a.nvars)
+        let mut bounds: SmallVec<[_; INLINED_EXPONENTS]> = (0..a.nvars())
             .map(|i| {
                 let da = a.degree(i);
                 let db = b.degree(i);
                 if da < db {
                     da
                 } else {
                     db
@@ -1880,22 +1747,22 @@
             if !a.field.is_one(&uca) {
                 a = Cow::Owned(a.into_owned().div_coeff(&uca));
             }
             if !a.field.is_one(&ucb) {
                 b = Cow::Owned(b.into_owned().div_coeff(&ucb));
             }
 
-            p.add_monomial(content)
+            p.add_constant(content)
         };
 
         let rearrange = vars.len() > 1 && vars.windows(2).any(|s| s[0] > s[1]);
         if rearrange {
             debug!("Rearranging variables with map: {:?}", vars);
-            a = Cow::Owned(a.rearrange(&vars, false));
-            b = Cow::Owned(b.rearrange(&vars, false));
+            a = Cow::Owned(a.rearrange_impl(&vars, false, false));
+            b = Cow::Owned(b.rearrange_impl(&vars, false, false));
 
             let mut newbounds: SmallVec<[_; INLINED_EXPONENTS]> =
                 smallvec![E::zero(); bounds.len()];
             for x in 0..vars.len() {
                 newbounds[x] = bounds[vars[x]];
             }
             bounds = newbounds;
@@ -1917,15 +1784,15 @@
                 Cow::Borrowed(&vars)
             },
             &mut bounds,
             &mut tight_bounds,
         );
 
         if rearrange {
-            g = g.rearrange(&vars, true);
+            g = g.rearrange_impl(&vars, true, false);
         }
 
         rescale_gcd(g, &shared_degree, &base_degree, &content)
     }
 }
 
 #[derive(Debug)]
@@ -1946,36 +1813,37 @@
             let mut g = gamma.zero();
             let mut i = 0;
             let xi_half = xi / &Integer::Natural(2);
             while !gamma.is_zero() {
                 // create xi-adic representation using the symmetric modulus
                 let mut g_i = gamma.zero_with_capacity(gamma.nterms());
                 for m in &gamma {
-                    let mut c = IntegerRing::new().quot_rem(m.coefficient, xi).1;
+                    let mut c = Z.quot_rem(m.coefficient, xi).1;
 
                     if c > xi_half {
                         c -= xi;
                     }
 
                     if !IntegerRing::is_zero(&c) {
                         g_i.append_monomial(c, m.exponents);
                     }
                 }
 
                 for c in &mut g_i.coefficients {
-                    *c = IntegerRing::new().quot_rem(c, xi).1;
+                    *c = Z.quot_rem(c, xi).1;
 
                     if *c > xi_half {
                         *c -= xi;
                     }
                 }
 
                 // multiply with var^i
                 let mut g_i_2 = g_i.clone();
-                for x in g_i_2.exponents.chunks_mut(g_i_2.nvars) {
+                let nvars = g_i_2.nvars();
+                for x in g_i_2.exponents.chunks_mut(nvars) {
                     x[var] = E::from_u32(i);
                 }
 
                 g = g.add(g_i_2);
 
                 gamma = (gamma - g_i).div_coeff(xi);
                 i += 1;
@@ -1997,15 +1865,15 @@
             a = Cow::Owned(a.into_owned().div_coeff(&content_gcd));
             b = Cow::Owned(b.into_owned().div_coeff(&content_gcd));
         }
 
         debug!("a_red={}; b_red={}", a, b);
 
         if let Some(var) =
-            (0..a.nvars).find(|x| a.degree(*x) > E::zero() && b.degree(*x) > E::zero())
+            (0..a.nvars()).find(|x| a.degree(*x) > E::zero() && b.degree(*x) > E::zero())
         {
             let max_a = a
                 .coefficients
                 .iter()
                 .max_by(|x1, x2| x1.abs_cmp(x2))
                 .unwrap_or(&Integer::Natural(0));
 
@@ -2041,15 +1909,15 @@
 
                 let (gamma, co_fac_p, co_fac_q) = match aa.heuristic_gcd(&bb) {
                     Ok(x) => x,
                     Err(HeuristicGCDError::MaxSizeExceeded) => {
                         return Err(HeuristicGCDError::MaxSizeExceeded);
                     }
                     Err(HeuristicGCDError::BadReconstruction) => {
-                        xi = IntegerRing::new()
+                        xi = Z
                             .quot_rem(&(&xi * &Integer::Natural(73794)), &Integer::Natural(27011))
                             .0;
                         continue;
                     }
                 };
 
                 debug!("gamma={}", gamma);
@@ -2085,15 +1953,15 @@
                     if let Some(q) = b.divides(&b_co_fac) {
                         if let Some(q1) = a.divides(&q) {
                             return Ok((q.mul_coeff(content_gcd), q1, b_co_fac));
                         }
                     }
                 }
 
-                xi = IntegerRing::new()
+                xi = Z
                     .quot_rem(&(&xi * &Integer::Natural(73794)), &Integer::Natural(27011))
                     .0;
             }
 
             Err(HeuristicGCDError::BadReconstruction)
         } else {
             Ok((self.constant(content_gcd), a.into_owned(), b.into_owned()))
@@ -2313,15 +2181,18 @@
 
             // construct the gcd suggestion in Z
             let mut gm = self.zero_with_capacity(gp.nterms());
             gm.exponents = gp.exponents.clone();
             gm.coefficients = gp
                 .coefficients
                 .iter()
-                .map(|x| Integer::from_finite_field(&gp.field, gp.field.mul(x, &lcoeff_factor)))
+                .map(|x| {
+                    gp.field
+                        .to_symmetric_integer(&gp.field.mul(x, &lcoeff_factor))
+                })
                 .collect();
 
             let mut m = Integer::from_prime(&finite_field); // size of finite field
 
             debug!("GCD suggestion with gamma: {} mod {} ", gm, p);
 
             let mut old_gm = self.zero();
@@ -2368,15 +2239,15 @@
 
                 let ap = self.map_coeff(|c| c.to_finite_field(&finite_field), finite_field.clone());
                 let bp = b.map_coeff(|c| c.to_finite_field(&finite_field), finite_field.clone());
                 debug!("New image: gcd({},{})", ap, bp);
 
                 // for the univariate case, we don't need to construct an image
                 if vars.len() == 1 {
-                    gp = MultivariatePolynomial::univariate_gcd(&ap, &bp);
+                    gp = ap.univariate_gcd(&bp);
                     if gp.degree(vars[0]) < bounds[vars[0]] {
                         // original image and variable bound unlucky: restart
                         debug!("Unlucky original image: restart");
                         continue 'newfirstprime;
                     }
 
                     if gp.degree(vars[0]) > bounds[vars[0]] {
@@ -2389,27 +2260,27 @@
                         if gfu.iter().all(|(_, pow)| *pow != m.exponents[vars[0]]) {
                             debug!("Bad shape: terms missing");
                             continue 'newfirstprime;
                         }
                     }
                 } else {
                     let rec = if let Some(single_scale) = single_scale {
-                        construct_new_image_single_scale(
+                        MultivariatePolynomial::construct_new_image_single_scale(
                             &ap,
                             &bp,
                             ap.degree(vars[0]),
                             bp.degree(vars[0]),
                             bounds,
                             single_scale,
                             &vars[1..],
                             vars[0],
                             &gfu,
                         )
                     } else {
-                        construct_new_image_multiple_scales(
+                        MultivariatePolynomial::construct_new_image_multiple_scales(
                             &ap,
                             &bp,
                             // NOTE: different from paper where they use a.degree(..)
                             // it could be that the degree in ap is lower than that of a
                             // which means the sampling will never terminate
                             ap.degree(vars[0]),
                             bp.degree(vars[0]),
@@ -2503,15 +2374,15 @@
     ) -> Option<(
         MultivariatePolynomial<Self, E>,
         MultivariatePolynomial<Self, E>,
         MultivariatePolynomial<Self, E>,
     )> {
         // estimate if the heuristic gcd will overflow
         let mut max_deg_a = 0;
-        let mut contains_a: SmallVec<[bool; INLINED_EXPONENTS]> = smallvec![false; a.nvars];
+        let mut contains_a: SmallVec<[bool; INLINED_EXPONENTS]> = smallvec![false; a.nvars()];
         for t in a {
             let mut deg = 1;
             for (var, e) in t.exponents.iter().enumerate() {
                 let v = e.to_u32() as usize;
                 if v > 0 {
                     contains_a[var] = true;
                     deg *= v + 1;
@@ -2520,15 +2391,15 @@
 
             if deg > max_deg_a {
                 max_deg_a = deg;
             }
         }
 
         let mut max_deg_b = 0;
-        let mut contains_b: SmallVec<[bool; INLINED_EXPONENTS]> = smallvec![false; b.nvars];
+        let mut contains_b: SmallVec<[bool; INLINED_EXPONENTS]> = smallvec![false; b.nvars()];
         for t in b {
             let mut deg = 1;
             for (var, e) in t.exponents.iter().enumerate() {
                 let v = e.to_u32() as usize;
                 if v > 0 {
                     contains_b[var] = true;
                     deg *= v + 1;
@@ -2555,33 +2426,33 @@
     }
 
     fn gcd_multiple(f: Vec<MultivariatePolynomial<Self, E>>) -> MultivariatePolynomial<Self, E> {
         MultivariatePolynomial::gcd_multiple(f)
     }
 
     fn gcd(
-        a: &MultivariatePolynomial<IntegerRing, E>,
-        b: &MultivariatePolynomial<IntegerRing, E>,
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
         vars: &[usize],
         bounds: &mut [E],
         tight_bounds: &mut [E],
-    ) -> MultivariatePolynomial<IntegerRing, E> {
+    ) -> MultivariatePolynomial<Self, E> {
         MultivariatePolynomial::gcd_zippel::<u32>(a, b, vars, bounds, tight_bounds)
     }
 
     fn get_gcd_var_bounds(
-        a: &MultivariatePolynomial<IntegerRing, E>,
-        b: &MultivariatePolynomial<IntegerRing, E>,
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
         vars: &[usize],
         loose_bounds: &[E],
     ) -> SmallVec<[E; INLINED_EXPONENTS]> {
         let mut tight_bounds: SmallVec<[_; INLINED_EXPONENTS]> = loose_bounds.into();
         let mut i = 0;
         loop {
-            let f = FiniteField::<u32>::new(LARGE_U32_PRIMES[i]);
+            let f = Zp::new(LARGE_U32_PRIMES[i]);
             let ap = a.map_coeff(|c| c.to_finite_field(&f), f.clone());
             let bp = b.map_coeff(|c| c.to_finite_field(&f), f.clone());
             if ap.nterms() > 0
                 && bp.nterms() > 0
                 && ap.last_exponents() == a.last_exponents()
                 && bp.last_exponents() == b.last_exponents()
             {
@@ -2632,31 +2503,31 @@
         vars: &[usize],
         bounds: &mut [E],
         tight_bounds: &mut [E],
     ) -> MultivariatePolynomial<Self, E> {
         // remove the content so that the polynomials have integer coefficients
         let content = a.field.gcd(&a.content(), &b.content());
 
-        let a_int = a.map_coeff(|c| a.field.div(c, &content).numerator(), IntegerRing::new());
-        let b_int = b.map_coeff(|c| b.field.div(c, &content).numerator(), IntegerRing::new());
+        let a_int = a.map_coeff(|c| a.field.div(c, &content).numerator(), Z);
+        let b_int = b.map_coeff(|c| b.field.div(c, &content).numerator(), Z);
 
         MultivariatePolynomial::gcd_zippel::<u32>(&a_int, &b_int, vars, bounds, tight_bounds)
-            .map_coeff(|c| c.to_rational(), RationalField::new())
+            .map_coeff(|c| c.to_rational(), Q)
     }
 
     fn get_gcd_var_bounds(
-        a: &MultivariatePolynomial<RationalField, E>,
-        b: &MultivariatePolynomial<RationalField, E>,
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
         vars: &[usize],
         loose_bounds: &[E],
     ) -> SmallVec<[E; INLINED_EXPONENTS]> {
         let mut tight_bounds: SmallVec<[_; INLINED_EXPONENTS]> = loose_bounds.into();
         let mut i = 0;
         loop {
-            let f = FiniteField::<u32>::new(LARGE_U32_PRIMES[i]);
+            let f = Zp::new(LARGE_U32_PRIMES[i]);
             let ap = a.map_coeff(|c| c.to_finite_field(&f), f.clone());
             let bp = b.map_coeff(|c| c.to_finite_field(&f), f.clone());
             if ap.nterms() > 0
                 && bp.nterms() > 0
                 && ap.last_exponents() == a.last_exponents()
                 && bp.last_exponents() == b.last_exponents()
             {
@@ -2697,27 +2568,470 @@
         MultivariatePolynomial<Self, E>,
         MultivariatePolynomial<Self, E>,
     )> {
         None
     }
 
     fn gcd(
-        a: &MultivariatePolynomial<FiniteField<UField>, E>,
-        b: &MultivariatePolynomial<FiniteField<UField>, E>,
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
         vars: &[usize],
         bounds: &mut [E],
         tight_bounds: &mut [E],
-    ) -> MultivariatePolynomial<FiniteField<UField>, E> {
+    ) -> MultivariatePolynomial<Self, E> {
         assert!(!a.is_zero() || !b.is_zero());
         MultivariatePolynomial::gcd_shape_modular(a, b, vars, bounds, tight_bounds).unwrap()
     }
 
     fn get_gcd_var_bounds(
-        a: &MultivariatePolynomial<FiniteField<UField>, E>,
-        b: &MultivariatePolynomial<FiniteField<UField>, E>,
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
+        vars: &[usize],
+        loose_bounds: &[E],
+    ) -> SmallVec<[E; INLINED_EXPONENTS]> {
+        let mut tight_bounds: SmallVec<[_; INLINED_EXPONENTS]> = loose_bounds.into();
+        for var in vars {
+            let vvars: SmallVec<[usize; INLINED_EXPONENTS]> =
+                vars.iter().filter(|i| *i != var).cloned().collect();
+            tight_bounds[*var] = MultivariatePolynomial::get_gcd_var_bound(a, b, &vvars, *var);
+        }
+        tight_bounds
+    }
+
+    fn gcd_multiple(f: Vec<MultivariatePolynomial<Self, E>>) -> MultivariatePolynomial<Self, E> {
+        MultivariatePolynomial::repeated_gcd(f)
+    }
+
+    fn normalize(a: MultivariatePolynomial<Self, E>) -> MultivariatePolynomial<Self, E> {
+        a.make_monic()
+    }
+}
+
+impl<E: Exponent> PolynomialGCD<E> for AlgebraicNumberRing<RationalField> {
+    fn heuristic_gcd(
+        _a: &MultivariatePolynomial<Self, E>,
+        _b: &MultivariatePolynomial<Self, E>,
+    ) -> Option<(
+        MultivariatePolynomial<Self, E>,
+        MultivariatePolynomial<Self, E>,
+        MultivariatePolynomial<Self, E>,
+    )> {
+        None
+    }
+
+    fn gcd_multiple(f: Vec<MultivariatePolynomial<Self, E>>) -> MultivariatePolynomial<Self, E> {
+        MultivariatePolynomial::repeated_gcd(f)
+    }
+
+    fn gcd(
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
+        vars: &[usize],
+        bounds: &mut [E],
+        tight_bounds: &mut [E],
+    ) -> MultivariatePolynomial<Self, E> {
+        let content = a.field.poly().content().inv();
+        let a_integer =
+            AlgebraicNumberRing::new(a.field.poly().map_coeff(|c| (c * &content).numerator(), Z));
+        let a_lcoeff = a_integer.poly().lcoeff();
+
+        debug!("Zippel gcd of {} and {} % {}", a, b, a_integer);
+        #[cfg(debug_assertions)]
+        {
+            a.check_consistency();
+            b.check_consistency();
+        }
+
+        let mut pi = 0;
+        let primes = u32::get_primes();
+
+        'newfirstprime: loop {
+            pi += 1;
+
+            if pi == primes.len() {
+                a.check_consistency();
+                b.check_consistency();
+                panic!(
+                    "Ran out of primes for gcd reconstruction.\ngcd({},{})",
+                    a, b
+                );
+            }
+
+            let mut p = &primes[pi];
+
+            let mut finite_field = Zp::new(p.clone());
+            let mut algebraic_field_ff = a.field.to_finite_field(&finite_field);
+
+            let a_lcoeff_p = a_lcoeff.to_finite_field(&finite_field);
+
+            if Zp::is_zero(&a_lcoeff_p) {
+                continue 'newfirstprime;
+            }
+
+            let ap = a.map_coeff(
+                |c| c.to_finite_field(&finite_field),
+                algebraic_field_ff.clone(),
+            );
+            let bp = b.map_coeff(
+                |c| c.to_finite_field(&finite_field),
+                algebraic_field_ff.clone(),
+            );
+
+            debug!("New first image: gcd({},{}) mod {}", ap, bp, p);
+
+            // calculate modular gcd image
+            let mut gp = match MultivariatePolynomial::gcd_shape_modular(
+                &ap,
+                &bp,
+                vars,
+                bounds,
+                tight_bounds,
+            ) {
+                Some(x) => x,
+                None => {
+                    debug!("Modular GCD failed: getting new prime");
+                    continue 'newfirstprime;
+                }
+            };
+
+            debug!("GCD suggestion: {}", gp);
+
+            bounds[vars[0]] = gp.degree(vars[0]);
+
+            // construct a new assumed form
+            // we have to find the proper normalization
+            let gfu = gp.to_univariate_polynomial_list(vars[0]);
+
+            // find a coefficient of x1 in gf that is a monomial (single scaling)
+            let mut single_scale = None;
+            let mut nx = 0; // count the minimal number of samples needed
+            for (i, (c, _e)) in gfu.iter().enumerate() {
+                if c.nterms() > nx {
+                    nx = c.nterms();
+                }
+                if c.nterms() == 1 {
+                    single_scale = Some(i);
+                }
+            }
+
+            // In the case of multiple scaling, each sample adds an
+            // additional unknown, except for the first
+            if single_scale.is_none() {
+                let mut nx1 = (gp.nterms() - 1) / (gfu.len() - 1);
+                if (gp.nterms() - 1) % (gfu.len() - 1) != 0 {
+                    nx1 += 1;
+                }
+                if nx < nx1 {
+                    nx = nx1;
+                }
+                debug!("Multiple scaling case: sample {} times", nx);
+            }
+
+            let gpc = gp.lcoeff_varorder(vars);
+            let lcoeff_factor = gp.field.inv(&gpc);
+
+            // construct the gcd suggestion in Z
+            // contrary to the integer case, we do not know the leading coefficient in Z
+            // as it cannot easily be predicted from the two input polynomials
+            // we use rational reconstruction to recover it
+            let mut gm: MultivariatePolynomial<AlgebraicNumberRing<IntegerRing>, E> =
+                MultivariatePolynomial::new(
+                    &a_integer,
+                    gp.nterms().into(),
+                    a.variables.clone().into(),
+                );
+            gm.exponents = gp.exponents.clone();
+            gm.coefficients = gp
+                .coefficients
+                .iter()
+                .map(|x| {
+                    a_integer.to_element(
+                        gp.field
+                            .mul(x, &lcoeff_factor)
+                            .poly
+                            .map_coeff(|c| finite_field.to_symmetric_integer(c), Z),
+                    )
+                })
+                .collect();
+
+            let mut m = Integer::from_prime(&finite_field); // size of finite field
+
+            debug!("GCD suggestion with gamma: {} mod {} ", gm, p);
+
+            // add new primes until we can reconstruct the full gcd
+            'newprime: loop {
+                loop {
+                    pi += 1;
+
+                    if pi == LARGE_U32_PRIMES.len() {
+                        a.check_consistency();
+                        b.check_consistency();
+                        panic!(
+                            "Ran out of primes for gcd images.\ngcd({},{})\nAttempt: {}\n vars: {:?}, bounds: {:?}; {:?}",
+                            a, b, gm, vars, bounds, tight_bounds
+                        );
+                    }
+
+                    p = &primes[pi];
+                    finite_field = Zp::new(p.clone());
+                    algebraic_field_ff = a.field.to_finite_field(&finite_field);
+
+                    let a_lcoeff_p = a_lcoeff.to_finite_field(&finite_field);
+
+                    if !Zp::is_zero(&a_lcoeff_p) {
+                        break;
+                    }
+                }
+
+                let ap = a.map_coeff(
+                    |c| c.to_finite_field(&finite_field),
+                    algebraic_field_ff.clone(),
+                );
+                let bp = b.map_coeff(
+                    |c| c.to_finite_field(&finite_field),
+                    algebraic_field_ff.clone(),
+                );
+                debug!("New image: gcd({},{})", ap, bp);
+
+                // for the univariate case, we don't need to construct an image
+                if vars.len() == 1 {
+                    gp = ap.univariate_gcd(&bp);
+                    if gp.degree(vars[0]) < bounds[vars[0]] {
+                        // original image and variable bound unlucky: restart
+                        debug!("Unlucky original image: restart");
+                        continue 'newfirstprime;
+                    }
+
+                    if gp.degree(vars[0]) > bounds[vars[0]] {
+                        // prime is probably unlucky
+                        debug!("Unlucky current image: try new one");
+                        continue 'newprime;
+                    }
+
+                    for m in gp.into_iter() {
+                        if gfu.iter().all(|(_, pow)| *pow != m.exponents[vars[0]]) {
+                            debug!("Bad shape: terms missing");
+                            continue 'newfirstprime;
+                        }
+                    }
+                } else {
+                    let rec = if let Some(single_scale) = single_scale {
+                        MultivariatePolynomial::construct_new_image_single_scale(
+                            &ap,
+                            &bp,
+                            ap.degree(vars[0]),
+                            bp.degree(vars[0]),
+                            bounds,
+                            single_scale,
+                            &vars[1..],
+                            vars[0],
+                            &gfu,
+                        )
+                    } else {
+                        MultivariatePolynomial::construct_new_image_multiple_scales(
+                            &ap,
+                            &bp,
+                            // NOTE: different from paper where they use a.degree(..)
+                            // it could be that the degree in ap is lower than that of a
+                            // which means the sampling will never terminate
+                            ap.degree(vars[0]),
+                            bp.degree(vars[0]),
+                            bounds,
+                            &vars[1..],
+                            vars[0],
+                            &gfu,
+                        )
+                    };
+
+                    match rec {
+                        Ok(r) => {
+                            gp = r;
+                        }
+                        Err(GCDError::BadOriginalImage) => continue 'newfirstprime,
+                        Err(GCDError::BadCurrentImage) => continue 'newprime,
+                    }
+                }
+
+                // scale the new image
+                let gpc = gp.lcoeff_varorder(vars);
+                gp = gp.mul_coeff(ap.field.inv(&gpc));
+                debug!("gp: {} mod {}", gp, gp.field);
+
+                // use chinese remainder theorem to merge coefficients and map back to Z
+                // terms could be missing in gp, but not in gm (TODO: check this?)
+                let mut gpi = 0;
+                for t in 0..gm.nterms() {
+                    let gpc = if gm.exponents(t) == gp.exponents(gpi) {
+                        gpi += 1;
+                        gp.coefficients[gpi - 1].clone()
+                    } else {
+                        ap.field.zero()
+                    };
+
+                    let gmc_a = &mut gm.coefficients[t];
+
+                    // apply CRT to each integer coefficient in the algebraic number ring
+                    let mut gpc_pos = 0;
+                    let mut gmc_pos = 0;
+                    for i in 0..a.field.poly().degree(0) {
+                        let gpc = if i == gpc.poly.exponents(gpc_pos)[0] {
+                            gpc_pos += 1;
+                            Integer::from_finite_field(
+                                &finite_field,
+                                gpc.poly.coefficients[gpc_pos - 1],
+                            )
+                        } else {
+                            Integer::zero()
+                        };
+
+                        let gpm = if i == gmc_a.poly.exponents(gmc_pos)[0] {
+                            gmc_pos += 1;
+                            let r = &gmc_a.poly.coefficients[gmc_pos - 1];
+                            if r.is_negative() {
+                                r + &m
+                            } else {
+                                r.clone()
+                            }
+                        } else {
+                            Integer::zero()
+                        };
+
+                        let absent = gpm.is_zero();
+
+                        let res = Integer::chinese_remainder(
+                            gpm,
+                            gpc,
+                            m.clone(),
+                            Integer::from_prime(&finite_field),
+                        );
+
+                        if absent {
+                            if !res.is_zero() {
+                                gmc_a.poly.append_monomial(res, &[i]);
+                                gmc_pos += 1;
+                            }
+                        } else {
+                            assert!(!res.is_zero());
+                            gmc_a.poly.coefficients[gmc_pos - 1] = res;
+                        }
+                    }
+                }
+
+                m *= &Integer::from_prime(&finite_field);
+
+                debug!("gm: {} from ring {}", gm, m);
+
+                // do rational reconstruction
+                // TODO: don't try every iteration?
+                let mut gc = a.zero();
+
+                for c in &gm.coefficients {
+                    let mut nc = a.field.poly().zero();
+
+                    for aa in &c.poly.coefficients {
+                        match Rational::maximal_quotient_reconstruction(aa, &m, None) {
+                            Ok(x) => nc.coefficients.push(x),
+                            Err(e) => {
+                                debug!("Bad rational reconstruction: {}", e);
+                                // more samples!
+                                continue 'newprime;
+                            }
+                        }
+                    }
+
+                    nc.exponents = c.poly.exponents.clone();
+                    gc.coefficients.push(a.field.to_element(nc));
+                }
+
+                gc.exponents = gm.exponents.clone();
+
+                debug!("Final suggested gcd: {}", gc);
+                if gc.is_one() || (a.divides(&gc).is_some() && b.divides(&gc).is_some()) {
+                    return gc;
+                }
+
+                // if it does not divide, we need more primes
+                debug!("Does not divide: more primes needed");
+            }
+        }
+    }
+
+    fn get_gcd_var_bounds(
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
+        vars: &[usize],
+        loose_bounds: &[E],
+    ) -> SmallVec<[E; INLINED_EXPONENTS]> {
+        let mut tight_bounds: SmallVec<[_; INLINED_EXPONENTS]> = loose_bounds.into();
+        let mut i = 0;
+        loop {
+            let f = Zp::new(LARGE_U32_PRIMES[i]);
+            let algebraic_field_ff = a.field.to_finite_field(&f);
+            let ap = a.map_coeff(|c| c.to_finite_field(&f), algebraic_field_ff.clone());
+            let bp = b.map_coeff(|c| c.to_finite_field(&f), algebraic_field_ff.clone());
+            if ap.nterms() > 0
+                && bp.nterms() > 0
+                && ap.last_exponents() == a.last_exponents()
+                && bp.last_exponents() == b.last_exponents()
+            {
+                for var in vars.iter() {
+                    let vvars: SmallVec<[usize; INLINED_EXPONENTS]> =
+                        vars.iter().filter(|i| *i != var).cloned().collect();
+                    tight_bounds[*var] =
+                        MultivariatePolynomial::get_gcd_var_bound(&ap, &bp, &vvars, *var);
+                }
+                break;
+            } else {
+                debug!("Variable bounds failed due to unlucky prime");
+                i += 1;
+            }
+        }
+        tight_bounds
+    }
+
+    fn normalize(a: MultivariatePolynomial<Self, E>) -> MultivariatePolynomial<Self, E> {
+        if a.lcoeff().poly.lcoeff().is_negative() {
+            -a
+        } else {
+            a
+        }
+    }
+}
+
+impl<UField: FiniteFieldWorkspace, E: Exponent> PolynomialGCD<E>
+    for AlgebraicNumberRing<FiniteField<UField>>
+where
+    FiniteField<UField>: FiniteFieldCore<UField>,
+    <FiniteField<UField> as Ring>::Element: Copy,
+{
+    fn heuristic_gcd(
+        _a: &MultivariatePolynomial<Self, E>,
+        _b: &MultivariatePolynomial<Self, E>,
+    ) -> Option<(
+        MultivariatePolynomial<Self, E>,
+        MultivariatePolynomial<Self, E>,
+        MultivariatePolynomial<Self, E>,
+    )> {
+        None
+    }
+
+    fn gcd(
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
+        vars: &[usize],
+        bounds: &mut [E],
+        tight_bounds: &mut [E],
+    ) -> MultivariatePolynomial<Self, E> {
+        assert!(!a.is_zero() || !b.is_zero());
+        MultivariatePolynomial::gcd_shape_modular(a, b, vars, bounds, tight_bounds).unwrap()
+    }
+
+    fn get_gcd_var_bounds(
+        a: &MultivariatePolynomial<Self, E>,
+        b: &MultivariatePolynomial<Self, E>,
         vars: &[usize],
         loose_bounds: &[E],
     ) -> SmallVec<[E; INLINED_EXPONENTS]> {
         let mut tight_bounds: SmallVec<[_; INLINED_EXPONENTS]> = loose_bounds.into();
         for var in vars {
             let vvars: SmallVec<[usize; INLINED_EXPONENTS]> =
                 vars.iter().filter(|i| *i != var).cloned().collect();
```

### Comparing `symbolica-0.3.0/src/poly/groebner.rs` & `symbolica-0.4.0/src/poly/groebner.rs`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 use std::{cmp::Ordering, rc::Rc};
 
 use ahash::HashMap;
 
 use crate::domains::{
-    finite_field::{FiniteField, FiniteFieldCore, Mersenne64},
+    finite_field::{FiniteField, FiniteFieldCore, Mersenne64, Zp, Zp64},
     rational::RationalField,
     Field, Ring,
 };
 
 use super::{polynomial::MultivariatePolynomial, Exponent, MonomialOrder};
 
 #[derive(Debug)]
@@ -79,20 +79,15 @@
     ///
     /// Progress can be monitored with `print_stats`.
     pub fn new(
         ideal: &[MultivariatePolynomial<R, E, O>],
         print_stats: bool,
     ) -> GroebnerBasis<R, E, O> {
         let mut ideal = ideal.to_vec();
-        for _ in 0..2 {
-            let (first, rest) = ideal.split_first_mut().unwrap();
-            for x in rest {
-                first.unify_var_map(x);
-            }
-        }
+        MultivariatePolynomial::unify_variables_list(&mut ideal);
 
         let mut b = GroebnerBasis {
             system: ideal,
             print_stats,
         };
 
         b.f4();
@@ -120,15 +115,15 @@
     }
 
     /// The F4 algorithm for computing a Groebner basis.
     ///
     /// Adapted from [A new efficient algorithm for computing Grbner bases (F4)](https://doi.org/10.1016/S0022-4049(99)00005-5) by Jean-Charles Faugre.
     ///
     fn f4(&mut self) {
-        let nvars = self.system[0].nvars;
+        let nvars = self.system[0].nvars();
         let field = self.system[0].field.clone();
 
         let mut simplifications = vec![];
         let mut basis = vec![];
         let mut critical_pairs = vec![];
 
         for (i, f) in self.system.drain(..).enumerate() {
@@ -214,15 +209,15 @@
                     );
                 }
             }
 
             new_polys.clear();
             let mut i = 0;
             while i < selected_polys.len() {
-                for monom in selected_polys[i].exponents.chunks(nvars) {
+                for monom in selected_polys[i].exponents_iter() {
                     if let Some(m) = all_monomials.get_mut(monom) {
                         if m.present {
                             continue;
                         }
                         m.present = true;
                     } else {
                         all_monomials.insert(
@@ -299,15 +294,14 @@
                     .unwrap()
                     .column = column;
             }
 
             R::echelonize(
                 &mut matrix,
                 &mut selected_polys,
-                nvars,
                 &all_monomials,
                 &sorted_monomial_indices,
                 &field,
                 &mut buffer,
                 &mut pivots,
                 self.print_stats,
             );
@@ -437,15 +431,15 @@
     ) -> MultivariatePolynomial<R, E, O> {
         let mut q = p.zero_with_capacity(p.nterms());
         let mut r = p.clone();
 
         let mut rest_coeff = vec![];
         let mut rest_exponents = vec![];
 
-        let mut monom = vec![E::zero(); p.nvars];
+        let mut monom = vec![E::zero(); p.nvars()];
 
         'term: while !r.is_zero() {
             // find a divisor that has the least amount of terms
             while let Some(g) = gs
                 .iter()
                 .filter(|g| {
                     r.max_exp()
@@ -471,15 +465,15 @@
             rest_exponents.extend_from_slice(r.exponents(r.nterms() - 1));
             rest_coeff.push(r.coefficients.pop().unwrap());
         }
 
         // append in sorted order
         while let Some(c) = rest_coeff.pop() {
             let l = rest_coeff.len();
-            q.append_monomial(c, &rest_exponents[l * p.nvars..(l + 1) * p.nvars]);
+            q.append_monomial(c, &rest_exponents[l * p.nvars()..(l + 1) * p.nvars()]);
         }
 
         q
     }
 
     pub fn reduce_basis(mut self) -> Self {
         // filter lead-reducible polynomials
@@ -571,36 +565,34 @@
 pub trait Echelonize: Field {
     type LargerField;
 
     fn from_larger(&self, element: &Self::LargerField) -> <Self as Ring>::Element;
     fn echelonize<E: Exponent, O: MonomialOrder>(
         matrix: &mut Vec<Vec<(Self::LargerField, usize)>>,
         selected_polys: &mut Vec<Rc<MultivariatePolynomial<Self, E, O>>>,
-        nvars: usize,
         all_monomials: &HashMap<Vec<E>, MonomialData>,
         sorted_monomial_indices: &[usize],
         field: &Self,
         buffer: &mut Vec<Self::LargerField>,
         pivots: &mut Vec<Option<usize>>,
         print_stats: bool,
     );
 }
 
-impl Echelonize for FiniteField<u32> {
+impl Echelonize for Zp {
     type LargerField = i64;
 
     /// Specialized 32-bit finite field echelonization based on
     /// "A Compact Parallel Implementation of F4" by Monagan and Pearce.
     fn echelonize<E: Exponent, O: MonomialOrder>(
         matrix: &mut Vec<Vec<(i64, usize)>>,
-        selected_polys: &mut Vec<Rc<MultivariatePolynomial<FiniteField<u32>, E, O>>>,
-        nvars: usize,
+        selected_polys: &mut Vec<Rc<MultivariatePolynomial<Zp, E, O>>>,
         all_monomials: &HashMap<Vec<E>, MonomialData>,
         sorted_monomial_indices: &[usize],
-        field: &FiniteField<u32>,
+        field: &Zp,
         buffer: &mut Vec<i64>,
         pivots: &mut Vec<Option<usize>>,
         print_stats: bool,
     ) {
         fn u32_inv(coeff: u32, prime: u32) -> u32 {
             // extended Euclidean algorithm: a x + b p = gcd(x, p) = 1 or a x = 1 (mod p)
             let mut u1: u32 = 1;
@@ -627,15 +619,15 @@
             }
         }
 
         matrix.resize(selected_polys.len(), vec![]);
         for (row, p) in matrix.iter_mut().zip(selected_polys) {
             row.clear();
 
-            for (coeff, exp) in p.coefficients.iter().zip(p.exponents.chunks(nvars)).rev() {
+            for (coeff, exp) in p.coefficients.iter().zip(p.exponents_iter()).rev() {
                 row.push((
                     field.from_element(coeff) as i64,
                     all_monomials.get(exp).unwrap().column,
                 ));
             }
         }
 
@@ -797,27 +789,26 @@
         impl Echelonize for $f {
             type LargerField = Self::Element;
 
             #[inline(never)]
             fn echelonize<E: Exponent, O: MonomialOrder>(
                 matrix: &mut Vec<Vec<(Self::Element, usize)>>,
                 selected_polys: &mut Vec<Rc<MultivariatePolynomial<Self, E, O>>>,
-                nvars: usize,
                 all_monomials: &HashMap<Vec<E>, MonomialData>,
                 sorted_monomial_indices: &[usize],
                 field: &Self,
                 buffer: &mut Vec<Self::Element>,
                 pivots: &mut Vec<Option<usize>>,
                 print_stats: bool,
             ) {
                 matrix.resize(selected_polys.len(), vec![]);
                 for (row, p) in matrix.iter_mut().zip(selected_polys) {
                     row.clear();
 
-                    for (coeff, exp) in p.coefficients.iter().zip(p.exponents.chunks(nvars)).rev() {
+                    for (coeff, exp) in p.coefficients.iter().zip(p.exponents_iter()).rev() {
                         row.push((coeff.clone(), all_monomials.get(exp).unwrap().column));
                     }
                 }
 
                 // sort the matrix rows to sort the shortest and most reduced pivots on top
                 matrix.sort_unstable_by(|r1, r2| {
                     r1[0]
@@ -927,10 +918,84 @@
             fn from_larger(&self, element: &Self::LargerField) -> <Self as Ring>::Element {
                 element.clone()
             }
         }
     };
 }
 
-echelonize_impl!(FiniteField<u64>);
+echelonize_impl!(Zp64);
 echelonize_impl!(FiniteField<Mersenne64>);
 echelonize_impl!(RationalField);
+
+#[cfg(test)]
+mod test {
+    use crate::{
+        atom::Atom,
+        domains::finite_field::Zp,
+        poly::{groebner::GroebnerBasis, polynomial::MultivariatePolynomial, GrevLexOrder},
+    };
+
+    #[test]
+    fn cyclic4() {
+        let polys = [
+            "v1 v2 v3 v4 - 1",
+            "v1 v2 v3 + v1 v2 v4 + v1 v3 v4 + v2 v3 v4",
+            "v1 v2 + v2 v3 + v1 v4 + v3 v4",
+            "v1 + v2 + v3 + v4",
+        ];
+
+        let ideal: Vec<MultivariatePolynomial<_, u16>> = polys
+            .iter()
+            .map(|x| {
+                let a = Atom::parse(x).unwrap().expand();
+                a.to_polynomial(&Zp::new(13), None)
+            })
+            .collect();
+
+        // compute the Groebner basis with lex ordering
+        let gb = GroebnerBasis::new(&ideal, false);
+
+        let res = [
+            "v4+v3+v2+v1",
+            "v4^2+2*v2*v4+v2^2",
+            "11*v4^2+v3*v4+v3^2*v4^4-v2*v4+v2*v3",
+            "-v4+v4^5-v2+v2*v4^4",
+            "-v4-v3+v3^2*v4^3+v3^3*v4^2",
+            "1-v4^4-v3^2*v4^2+v3^2*v4^6",
+        ];
+
+        let res: Vec<MultivariatePolynomial<_, u16>> = res
+            .iter()
+            .map(|x| {
+                let a = Atom::parse(x).unwrap().expand();
+                a.to_polynomial(&Zp::new(13), ideal[0].variables.clone().into())
+            })
+            .collect();
+
+        assert_eq!(gb.system, res);
+
+        // compute the Groebner basis with grevlex ordering by converting the polynomials
+        let grevlex_ideal: Vec<_> = ideal.iter().map(|p| p.reorder::<GrevLexOrder>()).collect();
+        let gb = GroebnerBasis::new(&grevlex_ideal, false);
+
+        let res = [
+            "v4+v3+v2+v1",
+            "v4^2+2*v2*v4+v2^2",
+            "-v4^3-v2*v4^2+v3^2*v4+v2*v3^2",
+            "-1-v4^4+v3*v4^3-v2*v4^3+v3^2*v4^2+v2*v3*v4^2",
+            "-v4-v2+v4^5+v2*v4^4",
+            "-v4-v3+v3^2*v4^3+v3^3*v4^2",
+            "11*v4^2+v3*v4-v2*v4+v2*v3+v3^2*v4^4",
+        ];
+
+        let res: Vec<MultivariatePolynomial<_, u16, _>> = res
+            .iter()
+            .map(|x| {
+                let a = Atom::parse(x).unwrap().expand();
+                a.to_polynomial(&Zp::new(13), ideal[0].variables.clone().into())
+                    .reorder::<GrevLexOrder>()
+            })
+            .collect();
+
+        assert_eq!(gb.system, res);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/poly/polynomial.rs` & `symbolica-0.4.0/src/poly/polynomial.rs`

 * *Files 4% similar despite different names*

```diff
@@ -4,123 +4,133 @@
 use std::collections::{BTreeMap, BinaryHeap};
 use std::fmt::Display;
 use std::marker::PhantomData;
 use std::mem;
 use std::ops::{Add, Div, Mul, Neg, Sub};
 use std::sync::Arc;
 
+use crate::domains::algebraic_number::AlgebraicNumberRing;
 use crate::domains::integer::{Integer, IntegerRing};
 use crate::domains::rational::RationalField;
 use crate::domains::{EuclideanDomain, Field, Ring};
 use crate::printer::{PolynomialPrinter, PrintOptions};
 
 use super::gcd::PolynomialGCD;
+use super::univariate::UnivariatePolynomial;
 use super::{Exponent, LexOrder, MonomialOrder, Variable, INLINED_EXPONENTS};
 use smallvec::{smallvec, SmallVec};
 
 const MAX_DENSE_MUL_BUFFER_SIZE: usize = 1 << 24;
 thread_local! { static DENSE_MUL_BUFFER: Cell<Vec<u32>> = const { Cell::new(Vec::new()) }; }
 
-#[derive(Clone, PartialEq, Debug)]
+#[derive(Clone, PartialEq, Eq, Hash, Debug)]
 pub struct PolynomialRing<R: Ring, E: Exponent> {
-    ring: R,
-    nvars: usize,
-    var_map: Option<Arc<Vec<Variable>>>,
+    pub(crate) ring: R,
+    pub(crate) variables: Arc<Vec<Variable>>,
     _phantom_exp: PhantomData<E>,
 }
 
 impl<R: Ring, E: Exponent> PolynomialRing<R, E> {
-    pub fn new(
-        coeff_ring: R,
-        nvars: usize,
-        var_map: Option<Arc<Vec<Variable>>>,
-    ) -> PolynomialRing<R, E> {
+    pub fn new(coeff_ring: R, var_map: Arc<Vec<Variable>>) -> PolynomialRing<R, E> {
         PolynomialRing {
             ring: coeff_ring,
-            nvars,
-            var_map,
+            variables: var_map,
             _phantom_exp: PhantomData,
         }
     }
 
     pub fn new_from_poly(poly: &MultivariatePolynomial<R, E>) -> PolynomialRing<R, E> {
         PolynomialRing {
             ring: poly.field.clone(),
-            nvars: poly.nvars,
-            var_map: poly.var_map.clone(),
+            variables: poly.variables.clone(),
             _phantom_exp: PhantomData,
         }
     }
 }
 
 impl<R: Ring, E: Exponent> std::fmt::Display for PolynomialRing<R, E> {
     fn fmt(&self, _: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         Ok(())
     }
 }
 
 impl<R: Ring, E: Exponent> Ring for PolynomialRing<R, E> {
     type Element = MultivariatePolynomial<R, E>;
 
+    #[inline]
     fn add(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         a + b
     }
 
+    #[inline]
     fn sub(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         a - b
     }
 
+    #[inline]
     fn mul(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         a * b
     }
 
+    #[inline]
     fn add_assign(&self, a: &mut Self::Element, b: &Self::Element) {
-        *a = std::mem::replace(a, b.zero()) + b.clone();
+        *a = &*a + b;
     }
 
+    #[inline]
     fn sub_assign(&self, a: &mut Self::Element, b: &Self::Element) {
-        *a = std::mem::replace(a, b.zero()) - b.clone();
+        *a = &*a - b;
     }
 
+    #[inline]
     fn mul_assign(&self, a: &mut Self::Element, b: &Self::Element) {
         *a = std::mem::replace(a, b.zero()) * b;
     }
 
+    #[inline]
     fn add_mul_assign(&self, a: &mut Self::Element, b: &Self::Element, c: &Self::Element) {
         *a = std::mem::replace(a, b.zero()) + b * c
     }
 
+    #[inline]
     fn sub_mul_assign(&self, a: &mut Self::Element, b: &Self::Element, c: &Self::Element) {
         *a = std::mem::replace(a, b.zero()) - b * c
     }
 
+    #[inline]
     fn neg(&self, a: &Self::Element) -> Self::Element {
         a.clone().neg()
     }
 
+    #[inline]
     fn zero(&self) -> Self::Element {
-        MultivariatePolynomial::new(self.nvars, &self.ring, None, self.var_map.clone())
+        MultivariatePolynomial::new(&self.ring, None, self.variables.clone())
     }
 
+    #[inline]
     fn one(&self) -> Self::Element {
         self.zero().one()
     }
 
+    #[inline]
     fn nth(&self, n: u64) -> Self::Element {
         self.zero().constant(self.ring.nth(n))
     }
 
+    #[inline]
     fn pow(&self, b: &Self::Element, e: u64) -> Self::Element {
         b.pow(e as usize)
     }
 
+    #[inline]
     fn is_zero(a: &Self::Element) -> bool {
         a.is_zero()
     }
 
+    #[inline]
     fn is_one(&self, a: &Self::Element) -> bool {
         a.is_one()
     }
 
     fn one_is_gcd_unit() -> bool {
         false
     }
@@ -176,122 +186,109 @@
 
     fn gcd(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
         a.gcd(b)
     }
 }
 
 /// Multivariate polynomial with a sparse degree and variable dense representation.
-// TODO: implement EuclideanDomain for MultivariatePolynomial
 #[derive(Clone)]
-pub struct MultivariatePolynomial<F: Ring, E: Exponent, O: MonomialOrder = LexOrder> {
+pub struct MultivariatePolynomial<F: Ring, E: Exponent = u16, O: MonomialOrder = LexOrder> {
     // Data format: the i-th monomial is stored as coefficients[i] and
     // exponents[i * nvars .. (i + 1) * nvars]. Terms are always expanded and sorted by the exponents via
     // cmp_exponents().
     pub coefficients: Vec<F::Element>,
     pub exponents: Vec<E>,
-    pub nvars: usize,
     pub field: F,
-    pub var_map: Option<Arc<Vec<Variable>>>,
+    pub variables: Arc<Vec<Variable>>,
     pub(crate) _phantom: PhantomData<O>,
 }
 
 impl<F: Ring, E: Exponent, O: MonomialOrder> MultivariatePolynomial<F, E, O> {
     /// Constructs a zero polynomial. Instead of using this constructor,
     /// prefer to create new polynomials from existing ones, so that the
     /// variable map and field are inherited.
     #[inline]
-    pub fn new(
-        nvars: usize,
-        field: &F,
-        cap: Option<usize>,
-        var_map: Option<Arc<Vec<Variable>>>,
-    ) -> Self {
+    pub fn new(field: &F, cap: Option<usize>, variables: Arc<Vec<Variable>>) -> Self {
         Self {
             coefficients: Vec::with_capacity(cap.unwrap_or(0)),
-            exponents: Vec::with_capacity(cap.unwrap_or(0) * nvars),
-            nvars,
+            exponents: Vec::with_capacity(cap.unwrap_or(0) * variables.len()),
             field: field.clone(),
-            var_map,
+            variables,
             _phantom: PhantomData,
         }
     }
 
     /// Constructs a zero polynomial, inheriting the field and variable map from `self`.
     #[inline]
     pub fn zero(&self) -> Self {
         Self {
             coefficients: vec![],
             exponents: vec![],
-            nvars: self.nvars,
             field: self.field.clone(),
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Constructs a zero polynomial with the given number of variables and capacity,
     /// inheriting the field and variable map from `self`.
     #[inline]
     pub fn zero_with_capacity(&self, cap: usize) -> Self {
         Self {
             coefficients: Vec::with_capacity(cap),
-            exponents: Vec::with_capacity(cap * self.nvars),
-            nvars: self.nvars,
+            exponents: Vec::with_capacity(cap * self.nvars()),
             field: self.field.clone(),
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Constructs a constant polynomial,
     /// inheriting the field and variable map from `self`.
     #[inline]
     pub fn constant(&self, coeff: F::Element) -> Self {
         if F::is_zero(&coeff) {
             return self.zero();
         }
 
         Self {
             coefficients: vec![coeff],
-            exponents: vec![E::zero(); self.nvars],
-            nvars: self.nvars,
+            exponents: vec![E::zero(); self.nvars()],
             field: self.field.clone(),
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Constructs a polynomial that is one, inheriting the field and variable map from `self`.
     #[inline]
     pub fn one(&self) -> Self {
         Self {
             coefficients: vec![self.field.one()],
-            exponents: vec![E::zero(); self.nvars],
-            nvars: self.nvars,
+            exponents: vec![E::zero(); self.nvars()],
             field: self.field.clone(),
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Constructs a polynomial with a single term.
     #[inline]
     pub fn monomial(&self, coeff: F::Element, exponents: Vec<E>) -> Self {
-        debug_assert!(self.nvars == exponents.len());
+        debug_assert!(self.nvars() == exponents.len());
 
         if F::is_zero(&coeff) {
             return self.zero();
         }
 
         Self {
             coefficients: vec![coeff],
-            nvars: exponents.len(),
             exponents,
             field: self.field.clone(),
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Get the ith monomial
     pub fn to_monomial_view(&self, i: usize) -> MonomialView<F, E> {
         assert!(i < self.nterms());
@@ -301,15 +298,15 @@
             exponents: self.exponents(i),
         }
     }
 
     #[inline]
     pub fn reserve(&mut self, cap: usize) -> &mut Self {
         self.coefficients.reserve(cap);
-        self.exponents.reserve(cap * self.nvars);
+        self.exponents.reserve(cap * self.nvars());
         self
     }
 
     #[inline]
     pub fn is_zero(&self) -> bool {
         self.nterms() == 0
     }
@@ -326,15 +323,15 @@
     pub fn nterms(&self) -> usize {
         self.coefficients.len()
     }
 
     /// Returns the number of variables in the polynomial.
     #[inline]
     pub fn nvars(&self) -> usize {
-        self.nvars
+        self.variables.len()
     }
 
     /// Returns true if the polynomial is constant.
     #[inline]
     pub fn is_constant(&self) -> bool {
         if self.is_zero() {
             return true;
@@ -345,15 +342,15 @@
         debug_assert!(!F::is_zero(self.coefficients.first().unwrap()));
         return self.exponents.iter().all(|e| e.is_zero());
     }
 
     /// Get the constant term of the polynomial.
     #[inline]
     pub fn get_constant(&self) -> F::Element {
-        if self.is_zero() || !self.exponents.iter().all(|e| e.is_zero()) {
+        if self.is_zero() || !self.exponents(0).iter().all(|e| e.is_zero()) {
             return self.field.zero();
         }
 
         self.coefficients[0].clone()
     }
 
     /// Returns the `index`th monomial, starting from the back.
@@ -361,150 +358,173 @@
     pub fn coefficient_back(&self, index: usize) -> &F::Element {
         &self.coefficients[self.nterms() - index - 1]
     }
 
     /// Returns the slice for the exponents of the specified monomial.
     #[inline]
     pub fn exponents(&self, index: usize) -> &[E] {
-        //&self.exponents[index * self.nvars..(index + 1) * self.nvars]
+        //&self.exponents[index * self.nvars()..(index + 1) * self.nvars()]
         unsafe {
             self.exponents
-                .get_unchecked(index * self.nvars..(index + 1) * self.nvars)
+                .get_unchecked(index * self.nvars()..(index + 1) * self.nvars())
         }
     }
 
     /// Returns the slice for the exponents of the specified monomial
     /// starting from the back.
     #[inline]
     pub fn exponents_back(&self, index: usize) -> &[E] {
         let index = self.nterms() - index - 1;
-        &self.exponents[index * self.nvars..(index + 1) * self.nvars]
+        &self.exponents[index * self.nvars()..(index + 1) * self.nvars()]
     }
 
+    #[inline(always)]
     pub fn last_exponents(&self) -> &[E] {
-        assert!(self.nterms() > 0);
-        &self.exponents[(self.nterms() - 1) * self.nvars..self.nterms() * self.nvars]
+        //assert!(self.nterms() > 0);
+        &self.exponents[(self.nterms() - 1) * self.nvars()..self.nterms() * self.nvars()]
     }
 
     /// Returns the mutable slice for the exponents of the specified monomial.
     #[inline]
     pub fn exponents_mut(&mut self, index: usize) -> &mut [E] {
-        &mut self.exponents[index * self.nvars..(index + 1) * self.nvars]
+        let nvars = self.nvars();
+        &mut self.exponents[index * nvars..(index + 1) * nvars]
+    }
+
+    /// Returns an iterator over the exponents of every monomial.
+    #[inline]
+    pub fn exponents_iter(&self) -> std::slice::Chunks<E> {
+        self.exponents.chunks(self.nvars())
+    }
+
+    /// Returns an iterator over the mutable exponents of every monomial.
+    #[inline]
+    pub fn exponents_iter_mut(&mut self) -> std::slice::ChunksMut<E> {
+        let nvars = self.nvars();
+        self.exponents.chunks_mut(nvars)
     }
 
     /// Returns the number of variables in the polynomial.
     #[inline]
     pub fn clear(&mut self) {
         self.coefficients.clear();
         self.exponents.clear();
     }
 
-    /// Get the variable map.
-    pub fn get_var_map(&self) -> Option<&Arc<Vec<Variable>>> {
-        self.var_map.as_ref()
+    /// Get a copy of the variable list.
+    pub fn get_vars(&self) -> Arc<Vec<Variable>> {
+        self.variables.clone()
+    }
+
+    /// Get a reference to the variables list.
+    pub fn get_vars_ref(&self) -> &[Variable] {
+        self.variables.as_ref()
     }
 
     /// Unify the variable maps of two polynomials, i.e.
     /// rewrite a polynomial in `x` and one in `y` to a
     /// two polynomial in `x` and `y`.
     ///
     /// The variable map will be inherited from
     /// `self` and will be extended by variables occurring
     /// in `other`.
-    pub fn unify_var_map(&mut self, other: &mut Self) {
-        assert!(
-            (self.var_map.is_some() || self.nvars == 0)
-                && (other.var_map.is_some() || other.nvars == 0)
-        );
-
-        if self.var_map == other.var_map {
+    #[inline(always)]
+    pub fn unify_variables(&mut self, other: &mut Self) {
+        if self.variables == other.variables {
             return;
         }
 
-        let mut new_var_map = self
-            .var_map
-            .as_ref()
-            .map(|x| (**x).clone())
-            .unwrap_or_default();
-        let mut new_var_pos_other = vec![0; other.nvars];
-        for (pos, v) in new_var_pos_other.iter_mut().zip(
-            other
-                .var_map
-                .as_ref()
-                .map(|x| x.as_ref())
-                .unwrap_or(&vec![]),
-        ) {
+        self.unify_variables_impl(other)
+    }
+
+    fn unify_variables_impl(&mut self, other: &mut Self) {
+        let mut new_var_map = self.variables.as_ref().clone();
+        let mut new_var_pos_other = vec![0; other.nvars()];
+        for (pos, v) in new_var_pos_other.iter_mut().zip(other.variables.as_ref()) {
             if let Some(p) = new_var_map.iter().position(|x| x == v) {
                 *pos = p;
             } else {
                 *pos = new_var_map.len();
                 new_var_map.push(v.clone());
             }
         }
 
         let mut newexp = vec![E::zero(); new_var_map.len() * self.nterms()];
 
         for t in 0..self.nterms() {
-            newexp[t * new_var_map.len()..t * new_var_map.len() + self.nvars]
+            newexp[t * new_var_map.len()..t * new_var_map.len() + self.nvars()]
                 .copy_from_slice(self.exponents(t));
         }
 
-        self.nvars = new_var_map.len();
-        self.var_map = Some(Arc::new(new_var_map));
+        self.variables = Arc::new(new_var_map);
         self.exponents = newexp;
 
         // reconstruct 'other' with correct monomial ordering
         let mut newother = Self::new(
-            self.nvars,
             &other.field,
-            Some(other.nterms()),
-            self.var_map.clone(),
+            other.nterms().into(),
+            self.variables.clone().into(),
         );
-        let mut newexp = vec![E::zero(); self.nvars];
+        let mut newexp = vec![E::zero(); self.nvars()];
         for t in other.into_iter() {
             for c in &mut newexp {
                 *c = E::zero();
             }
 
             for (var, e) in t.exponents.iter().enumerate() {
                 newexp[new_var_pos_other[var]] = *e;
             }
             newother.append_monomial(t.coefficient.clone(), &newexp);
         }
         *other = newother;
     }
 
+    /// Unify the variable maps of all polynomials in the slice.
+    pub fn unify_variables_list(polys: &mut [Self]) {
+        if polys.len() < 2 {
+            return;
+        }
+
+        let (first, rest) = polys.split_first_mut().unwrap();
+        for _ in 0..2 {
+            for p in &mut *rest {
+                first.unify_variables(p);
+            }
+        }
+    }
+
     /// Reverse the monomial ordering in-place.
     fn reverse(&mut self) {
         let nterms = self.nterms();
+        let nvars = self.nvars();
         if nterms < 2 {
             return;
         }
 
         self.coefficients.reverse();
 
         let midu = if nterms % 2 == 0 {
-            self.nvars * (nterms / 2)
+            self.nvars() * (nterms / 2)
         } else {
-            self.nvars * (nterms / 2 + 1)
+            self.nvars() * (nterms / 2 + 1)
         };
 
         let (l, r) = self.exponents.split_at_mut(midu);
 
         let rend = r.len();
         for i in 0..nterms / 2 {
-            l[i * self.nvars..(i + 1) * self.nvars]
-                .swap_with_slice(&mut r[rend - (i + 1) * self.nvars..rend - i * self.nvars]);
+            l[i * nvars..(i + 1) * nvars]
+                .swap_with_slice(&mut r[rend - (i + 1) * nvars..rend - i * nvars]);
         }
     }
 
     /// Check if the polynomial is sorted and has only non-zero coefficients
     pub fn check_consistency(&self) {
         assert_eq!(self.coefficients.len(), self.nterms());
-        assert_eq!(self.exponents.len(), self.nterms() * self.nvars);
+        assert_eq!(self.exponents.len(), self.nterms() * self.nvars());
 
         for c in &self.coefficients {
             if F::is_zero(c) {
                 panic!("Inconsistent polynomial (0 coefficient): {}", self);
             }
         }
 
@@ -531,32 +551,32 @@
         let nterms = self.nterms();
         if nterms > 0 && exponents == self.last_exponents() {
             self.field
                 .add_assign(&mut self.coefficients[nterms - 1], &coefficient);
 
             if F::is_zero(&self.coefficients[nterms - 1]) {
                 self.coefficients.pop();
-                self.exponents.truncate((nterms - 1) * self.nvars);
+                self.exponents.truncate((nterms - 1) * self.nvars());
             }
         } else {
             self.coefficients.push(coefficient);
             self.exponents.extend_from_slice(exponents);
         }
     }
 
     /// Appends a monomial to the polynomial.
     pub fn append_monomial(&mut self, coefficient: F::Element, exponents: &[E]) {
         if F::is_zero(&coefficient) {
             return;
         }
-        if self.nvars != exponents.len() {
+        if self.nvars() != exponents.len() {
             panic!(
                 "nvars mismatched: got {}, expected {}",
                 exponents.len(),
-                self.nvars
+                self.nvars()
             );
         }
 
         // should we append to the back?
         if self.nterms() == 0 || O::cmp(self.last_exponents(), exponents).is_lt() {
             self.coefficients.push(coefficient);
             self.exponents.extend_from_slice(exponents);
@@ -581,16 +601,16 @@
                 Ordering::Equal => {
                     // Add the two coefficients.
                     self.field
                         .add_assign(&mut self.coefficients[m], &coefficient);
                     if F::is_zero(&self.coefficients[m]) {
                         // The coefficient becomes zero. Remove this monomial.
                         self.coefficients.remove(m);
-                        let i = m * self.nvars;
-                        self.exponents.splice(i..i + self.nvars, Vec::new());
+                        let i = m * self.nvars();
+                        self.exponents.splice(i..i + self.nvars(), Vec::new());
                     }
                     return;
                 }
                 Ordering::Greater => {
                     l = m + 1;
 
                     if l == self.nterms() {
@@ -608,25 +628,25 @@
 
                     r = m - 1;
                 }
             }
         }
 
         self.coefficients.insert(l, coefficient);
-        let i = l * self.nvars;
+        let i = l * self.nvars();
         self.exponents.splice(i..i, exponents.iter().cloned());
     }
 
     /// Take the derivative of the polynomial w.r.t the variable `var`.
     pub fn derivative(&self, var: usize) -> Self {
-        debug_assert!(var < self.nvars);
+        debug_assert!(var < self.nvars());
 
         let mut res = self.zero_with_capacity(self.nterms());
 
-        let mut exp = vec![E::zero(); self.nvars];
+        let mut exp = vec![E::zero(); self.nvars()];
         for x in self {
             if x.exponents[var] > E::zero() {
                 exp.copy_from_slice(x.exponents);
                 let pow = exp[var].to_u32() as u64;
                 exp[var] = exp[var] - E::one();
                 res.append_monomial(self.field.mul(x.coefficient, &self.field.nth(pow)), &exp);
             }
@@ -663,20 +683,18 @@
 
 impl<F: Ring + Display, E: Exponent, O: MonomialOrder> Display for MultivariatePolynomial<F, E, O> {
     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
         PolynomialPrinter::new(self).fmt(f)
     }
 }
 
-impl<F: Ring + PartialEq, E: Exponent, O: MonomialOrder> PartialEq
-    for MultivariatePolynomial<F, E, O>
-{
+impl<F: Ring, E: Exponent, O: MonomialOrder> PartialEq for MultivariatePolynomial<F, E, O> {
     #[inline]
     fn eq(&self, other: &Self) -> bool {
-        if self.nvars != other.nvars {
+        if self.nvars() != other.nvars() {
             if self.is_constant() != other.is_constant() {
                 return false;
             }
 
             if self.is_zero() != other.is_zero() {
                 return false;
             }
@@ -697,15 +715,23 @@
         if self.nterms() != other.nterms() {
             return false;
         }
         self.exponents.eq(&other.exponents) && self.coefficients.eq(&other.coefficients)
     }
 }
 
-impl<F: Ring + Eq, E: Exponent, O: MonomialOrder> Eq for MultivariatePolynomial<F, E, O> {}
+impl<F: Ring, E: Exponent, O: MonomialOrder> std::hash::Hash for MultivariatePolynomial<F, E, O> {
+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        self.coefficients.hash(state);
+        self.exponents.hash(state);
+        self.variables.hash(state);
+    }
+}
+
+impl<F: Ring, E: Exponent, O: MonomialOrder> Eq for MultivariatePolynomial<F, E, O> {}
 
 impl<R: Ring, E: Exponent, O: MonomialOrder> PartialOrd for MultivariatePolynomial<R, E, O> {
     /// An ordering of polynomials that has no intuitive meaning.
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
         Some(self.exponents.cmp(&other.exponents).then_with(|| {
             self.coefficients
                 .partial_cmp(&other.coefficients)
@@ -715,43 +741,41 @@
 }
 
 impl<F: Ring, E: Exponent, O: MonomialOrder> Add for MultivariatePolynomial<F, E, O> {
     type Output = Self;
 
     fn add(mut self, mut other: Self) -> Self::Output {
         debug_assert_eq!(self.field, other.field);
-        debug_assert!(other.var_map.is_none() || self.var_map == other.var_map); // TODO: remove?
+
+        self.unify_variables(&mut other);
 
         if self.is_zero() {
             return other;
         }
         if other.is_zero() {
             return self;
         }
-        if self.nvars != other.nvars {
-            panic!("nvars mismatched");
-        }
 
         // Merge the two polynomials, which are assumed to be already sorted.
 
         let mut new_coefficients = vec![self.field.zero(); self.nterms() + other.nterms()];
         let mut new_exponents: Vec<E> =
-            vec![E::zero(); self.nvars * (self.nterms() + other.nterms())];
+            vec![E::zero(); self.nvars() * (self.nterms() + other.nterms())];
         let mut new_nterms = 0;
         let mut i = 0;
         let mut j = 0;
 
         macro_rules! insert_monomial {
             ($source:expr, $index:expr) => {
                 mem::swap(
                     &mut new_coefficients[new_nterms],
                     &mut $source.coefficients[$index],
                 );
 
-                new_exponents[new_nterms * $source.nvars..(new_nterms + 1) * $source.nvars]
+                new_exponents[new_nterms * $source.nvars()..(new_nterms + 1) * $source.nvars()]
                     .clone_from_slice($source.exponents($index));
                 new_nterms += 1;
             };
         }
 
         while i < self.nterms() && j < other.nterms() {
             let c = O::cmp(self.exponents(i), other.exponents(j));
@@ -783,34 +807,112 @@
 
         while j < other.nterms() {
             insert_monomial!(other, j);
             j += 1;
         }
 
         new_coefficients.truncate(new_nterms);
-        new_exponents.truncate(self.nvars * new_nterms);
+        new_exponents.truncate(self.nvars() * new_nterms);
 
         Self {
             coefficients: new_coefficients,
             exponents: new_exponents,
-            nvars: self.nvars,
             field: self.field,
-            var_map: self.var_map,
+            variables: self.variables,
             _phantom: PhantomData,
         }
     }
 }
 
 impl<'a, 'b, F: Ring, E: Exponent, O: MonomialOrder> Add<&'a MultivariatePolynomial<F, E, O>>
     for &'b MultivariatePolynomial<F, E, O>
 {
     type Output = MultivariatePolynomial<F, E, O>;
 
-    fn add(self, other: &'a MultivariatePolynomial<F, E, O>) -> Self::Output {
-        (self.clone()).add(other.clone())
+    fn add(self, other: &MultivariatePolynomial<F, E, O>) -> Self::Output {
+        debug_assert_eq!(self.field, other.field);
+
+        if self.variables != other.variables {
+            let mut c1 = self.clone();
+            let mut c2 = other.clone();
+            c1.unify_variables(&mut c2);
+            return c1 + c2;
+        }
+
+        if self.is_zero() {
+            return other.clone();
+        }
+        if other.is_zero() {
+            return self.clone();
+        }
+
+        // Merge the two polynomials, which are assumed to be already sorted.
+        let mut new_coefficients = vec![self.field.zero(); self.nterms() + other.nterms()];
+        let mut new_exponents: Vec<E> =
+            vec![E::zero(); self.nvars() * (self.nterms() + other.nterms())];
+        let mut new_nterms = 0;
+        let mut i = 0;
+        let mut j = 0;
+
+        macro_rules! insert_monomial {
+            ($source:expr, $index:expr) => {
+                new_coefficients[new_nterms] = $source.coefficients[$index].clone();
+                new_exponents[new_nterms * $source.nvars()..(new_nterms + 1) * $source.nvars()]
+                    .clone_from_slice($source.exponents($index));
+                new_nterms += 1;
+            };
+        }
+
+        while i < self.nterms() && j < other.nterms() {
+            let c = O::cmp(self.exponents(i), other.exponents(j));
+            match c {
+                Ordering::Less => {
+                    insert_monomial!(self, i);
+                    i += 1;
+                }
+                Ordering::Greater => {
+                    insert_monomial!(other, j);
+                    j += 1;
+                }
+                Ordering::Equal => {
+                    let coeff = self
+                        .field
+                        .add(&self.coefficients[i], &other.coefficients[j]);
+                    if !F::is_zero(&coeff) {
+                        new_coefficients[new_nterms] = coeff;
+                        new_exponents[new_nterms * self.nvars()..(new_nterms + 1) * self.nvars()]
+                            .clone_from_slice(self.exponents(i));
+                        new_nterms += 1;
+                    }
+                    i += 1;
+                    j += 1;
+                }
+            }
+        }
+
+        while i < self.nterms() {
+            insert_monomial!(self, i);
+            i += 1;
+        }
+
+        while j < other.nterms() {
+            insert_monomial!(other, j);
+            j += 1;
+        }
+
+        new_coefficients.truncate(new_nterms);
+        new_exponents.truncate(self.nvars() * new_nterms);
+
+        MultivariatePolynomial {
+            coefficients: new_coefficients,
+            exponents: new_exponents,
+            field: self.field.clone(),
+            variables: self.variables.clone(),
+            _phantom: PhantomData,
+        }
     }
 }
 
 impl<F: Ring, E: Exponent, O: MonomialOrder> Sub for MultivariatePolynomial<F, E, O> {
     type Output = Self;
 
     fn sub(self, other: Self) -> Self::Output {
@@ -820,15 +922,15 @@
 
 impl<'a, 'b, F: Ring, E: Exponent, O: MonomialOrder> Sub<&'a MultivariatePolynomial<F, E, O>>
     for &'b MultivariatePolynomial<F, E, O>
 {
     type Output = MultivariatePolynomial<F, E, O>;
 
     fn sub(self, other: &'a MultivariatePolynomial<F, E, O>) -> Self::Output {
-        (self.clone()).add(other.clone().neg())
+        self + &other.clone().neg() // TODO: improve
     }
 }
 
 impl<F: Ring, E: Exponent, O: MonomialOrder> Neg for MultivariatePolynomial<F, E, O> {
     type Output = Self;
     fn neg(mut self) -> Self::Output {
         // Negate coefficients of all terms.
@@ -921,31 +1023,31 @@
             .flat_map(|i| self.exponents(*i))
             .cloned()
             .collect();
 
         MultivariatePolynomial {
             coefficients,
             exponents,
-            nvars: self.nvars,
             field: self.field.clone(),
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Multiply every coefficient with `other`.
     pub fn mul_coeff(mut self, other: F::Element) -> Self {
         for c in &mut self.coefficients {
             self.field.mul_assign(c, &other);
         }
 
         for i in (0..self.nterms()).rev() {
             if F::is_zero(&self.coefficients[i]) {
                 self.coefficients.remove(i);
-                self.exponents.drain(i * self.nvars..(i + 1) * self.nvars);
+                self.exponents
+                    .drain(i * self.nvars()..(i + 1) * self.nvars());
             }
         }
 
         self
     }
 
     /// Map a coefficient using the function `f`.
@@ -964,30 +1066,29 @@
                 exponents.extend(m.exponents);
             }
         }
 
         MultivariatePolynomial {
             coefficients,
             exponents,
-            nvars: self.nvars,
             field,
-            var_map: self.var_map.clone(),
+            variables: self.variables.clone(),
             _phantom: PhantomData,
         }
     }
 
     /// Add `exponents` to every exponent.
     pub fn mul_exp(mut self, exponents: &[E]) -> Self {
-        debug_assert_eq!(self.nvars, exponents.len());
+        debug_assert_eq!(self.nvars(), exponents.len());
 
-        if self.nvars == 0 {
+        if self.nvars() == 0 {
             return self;
         }
 
-        for e in self.exponents.chunks_mut(self.nvars) {
+        for e in self.exponents_iter_mut() {
             for (e1, e2) in e.iter_mut().zip(exponents) {
                 *e1 = e1.checked_add(e2).expect("overflow in adding exponents");
             }
         }
 
         self
     }
@@ -999,38 +1100,38 @@
 
     #[inline]
     pub fn max_exp(&self) -> &[E] {
         if self.coefficients.is_empty() {
             panic!("Cannot get max exponent of empty polynomial");
         }
 
-        &self.exponents[(self.nterms() - 1) * self.nvars..self.nterms() * self.nvars]
+        &self.exponents[(self.nterms() - 1) * self.nvars()..self.nterms() * self.nvars()]
     }
 
     /// Add a new monomial with coefficient `other` and exponent one.
-    pub fn add_monomial(mut self, other: F::Element) -> Self {
-        let nvars = self.nvars;
+    pub fn add_constant(mut self, other: F::Element) -> Self {
+        let nvars = self.nvars();
         self.append_monomial(other, &vec![E::zero(); nvars]);
         self
     }
 
     #[inline]
     fn mul_monomial(self, coefficient: &F::Element, exponents: &[E]) -> Self {
         self.mul_coeff(coefficient.clone()).mul_exp(exponents)
     }
 
     /// Get the degree of the variable `x`.
     /// This operation is O(n).
     pub fn degree(&self, x: usize) -> E {
-        if self.nvars == 0 {
+        if self.nvars() == 0 {
             return E::zero();
         }
 
         let mut max = E::zero();
-        for e in self.exponents.iter().skip(x).step_by(self.nvars) {
+        for e in self.exponents.iter().skip(x).step_by(self.nvars()) {
             if max < *e {
                 max = *e;
             }
         }
         max
     }
 
@@ -1074,15 +1175,15 @@
     /// Get the leading coefficient under a given variable ordering.
     /// This operation is O(n) if the variables are out of order.
     pub fn lcoeff_varorder(&self, vars: &[usize]) -> F::Element {
         if vars.windows(2).all(|s| s[0] < s[1]) {
             return self.lcoeff();
         }
 
-        let mut highest = vec![E::zero(); self.nvars];
+        let mut highest = vec![E::zero(); self.nvars()];
         let mut highestc = &self.field.zero();
 
         'nextmon: for m in self.into_iter() {
             let mut more = false;
             for &v in vars {
                 if more {
                     highest[v] = m.exponents[v];
@@ -1115,15 +1216,15 @@
             return lcoeff;
         }
 
         if d == E::zero() {
             return self.clone();
         }
 
-        let mut e = vec![E::zero(); self.nvars];
+        let mut e = vec![E::zero(); self.nvars()];
         for t in self {
             if t.exponents[x] == d {
                 e.copy_from_slice(t.exponents);
                 e[x] = E::zero();
                 lcoeff.append_monomial(t.coefficient.clone(), &e);
             }
         }
@@ -1138,18 +1239,18 @@
             return self.clone();
         }
         // the last variable should have the least sorting priority,
         // so the last term should still be the lcoeff
         let last = self.last_exponents();
 
         let mut res = self.zero();
-        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars];
+        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars()];
 
         for t in (0..self.nterms()).rev() {
-            if (0..self.nvars - 1).all(|i| self.exponents(t)[i] == last[i] || i == n) {
+            if (0..self.nvars() - 1).all(|i| self.exponents(t)[i] == last[i] || i == n) {
                 e[n] = self.exponents(t)[n];
                 res.append_monomial(self.coefficients[t].clone(), &e);
                 e[n] = E::zero();
             } else {
                 break;
             }
         }
@@ -1167,15 +1268,15 @@
 
         if vars.windows(2).all(|s| s[0] < s[1]) {
             return self.lcoeff_last(*vars.last().unwrap());
         }
 
         let (vars, lastvar) = vars.split_at(vars.len() - 1);
 
-        let mut highest = vec![E::zero(); self.nvars];
+        let mut highest = vec![E::zero(); self.nvars()];
         let mut indices = Vec::with_capacity(10);
 
         'nextmon: for (i, m) in self.into_iter().enumerate() {
             let mut more = false;
             for &v in vars {
                 if more {
                     highest[v] = m.exponents[v];
@@ -1193,90 +1294,105 @@
                     }
                 }
             }
             indices.push(i);
         }
 
         let mut res = self.zero();
-        let mut e = vec![E::zero(); self.nvars];
+        let mut e = vec![E::zero(); self.nvars()];
         for i in indices {
             e[lastvar[0]] = self.exponents(i)[lastvar[0]];
             res.append_monomial(self.coefficients[i].clone(), &e);
             e[lastvar[0]] = E::zero();
         }
         res
     }
 
     /// Change the order of the variables in the polynomial, using `order`.
     /// The map can also be reversed, by setting `inverse` to `true`.
-    ///
-    /// Note that the polynomial `var_map` is not updated.
-    pub fn rearrange(
+    pub(crate) fn rearrange_impl(
         &self,
         order: &[usize],
         inverse: bool,
+        update_variables: bool,
     ) -> MultivariatePolynomial<F, E, LexOrder> {
-        let mut new_exp = vec![E::zero(); self.nterms() * self.nvars];
-        for (e, er) in new_exp
-            .chunks_mut(self.nvars)
-            .zip(self.exponents.chunks(self.nvars))
-        {
+        let mut new_exp = vec![E::zero(); self.nterms() * self.nvars()];
+        for (e, er) in new_exp.chunks_mut(self.nvars()).zip(self.exponents_iter()) {
             for x in 0..order.len() {
                 if !inverse {
                     e[x] = er[order[x]];
                 } else {
                     e[order[x]] = er[x];
                 }
             }
         }
 
         let mut indices: Vec<usize> = (0..self.nterms()).collect();
-        indices.sort_unstable_by_key(|&i| &new_exp[i * self.nvars..(i + 1) * self.nvars]);
+        indices.sort_unstable_by_key(|&i| &new_exp[i * self.nvars()..(i + 1) * self.nvars()]);
 
         let mut res = self.zero_with_capacity(self.nterms());
 
         for i in indices {
             res.append_monomial(
                 self.coefficients[i].clone(),
-                &new_exp[i * self.nvars..(i + 1) * self.nvars],
+                &new_exp[i * self.nvars()..(i + 1) * self.nvars()],
             );
         }
 
+        if update_variables {
+            let mut vm = self.variables.as_ref().clone();
+            for x in 0..order.len() {
+                if !inverse {
+                    vm[x] = self.variables[order[x]].clone();
+                } else {
+                    vm[order[x]] = self.variables[x].clone();
+                }
+            }
+
+            res.variables = Arc::new(vm);
+        }
+
         res
     }
 
     /// Change the order of the variables in the polynomial, using `order`.
+    /// The map can also be reversed, by setting `inverse` to `true`.
+    pub fn rearrange(
+        &self,
+        order: &[usize],
+        inverse: bool,
+    ) -> MultivariatePolynomial<F, E, LexOrder> {
+        self.rearrange_impl(order, inverse, true)
+    }
+
+    /// Change the order of the variables in the polynomial, using `order`.
     /// The order may contain `None`, to signal unmapped indices. This operation
     /// allows the polynomial to grow in size.
     ///
     /// Note that the polynomial `var_map` is not updated.
     pub fn rearrange_with_growth(
         &self,
         order: &[Option<usize>],
     ) -> MultivariatePolynomial<F, E, LexOrder> {
         let mut new_exp = vec![E::zero(); self.nterms() * order.len()];
-        for (e, er) in new_exp
-            .chunks_mut(order.len())
-            .zip(self.exponents.chunks(self.nvars))
-        {
+        for (e, er) in new_exp.chunks_mut(order.len()).zip(self.exponents_iter()) {
             for x in 0..order.len() {
                 if let Some(v) = order[x] {
                     e[x] = er[v];
                 }
             }
         }
 
         let mut indices: Vec<usize> = (0..self.nterms()).collect();
         indices.sort_unstable_by_key(|&i| &new_exp[i * order.len()..(i + 1) * order.len()]);
 
         let mut res = MultivariatePolynomial::new(
-            order.len(),
             &self.field,
-            Some(self.nterms()),
-            self.var_map.clone(),
+            self.nterms().into(),
+            self.variables.clone().into(),
         );
 
         for i in indices {
             res.append_monomial(
                 self.coefficients[i].clone(),
                 &new_exp[i * order.len()..(i + 1) * order.len()],
             );
@@ -1284,16 +1400,20 @@
 
         res
     }
 
     /// Replace a variable `n` in the polynomial by an element from
     /// the ring `v`.
     pub fn replace(&self, n: usize, v: &F::Element) -> MultivariatePolynomial<F, E, LexOrder> {
+        if (n + 1..self.nvars()).all(|i| self.degree(i) == E::zero()) {
+            return self.replace_last(n, v);
+        }
+
         let mut res = self.zero_with_capacity(self.nterms());
-        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars];
+        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars()];
 
         // TODO: cache power taking?
         for t in self {
             if t.exponents[n] == E::zero() {
                 res.append_monomial(t.coefficient.clone(), t.exponents);
                 continue;
             }
@@ -1307,27 +1427,91 @@
             e[n] = E::zero();
             res.append_monomial(c, &e);
         }
 
         res
     }
 
+    /// Replace the last variable `n` in the polynomial by an element from
+    /// the ring `v`.
+    pub fn replace_last(&self, n: usize, v: &F::Element) -> MultivariatePolynomial<F, E, LexOrder> {
+        let mut res = self.zero_with_capacity(self.nterms());
+        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars()];
+
+        // TODO: cache power taking?
+        for t in self {
+            if t.exponents[n] == E::zero() {
+                res.append_monomial(t.coefficient.clone(), t.exponents);
+                continue;
+            }
+
+            let c = self.field.mul(
+                t.coefficient,
+                &self.field.pow(v, t.exponents[n].to_u32() as u64),
+            );
+
+            if F::is_zero(&c) {
+                continue;
+            }
+
+            e.copy_from_slice(t.exponents);
+            e[n] = E::zero();
+
+            if res.is_zero() || res.last_exponents() != e.as_slice() {
+                res.coefficients.push(c);
+                res.exponents.extend_from_slice(&e);
+            } else {
+                let l = res.coefficients.last_mut().unwrap();
+                self.field.add_assign(l, &c);
+
+                if F::is_zero(l) {
+                    res.coefficients.pop();
+                    res.exponents.truncate(res.exponents.len() - self.nvars());
+                }
+            }
+        }
+
+        res
+    }
+
+    /// Replace a variable `n` in the polynomial by an element from
+    /// the ring `v`.
+    pub fn replace_all(&self, r: &[F::Element]) -> F::Element {
+        let mut res = self.field.zero();
+
+        // TODO: cache power taking?
+        for t in self {
+            let mut c = t.coefficient.clone();
+
+            for (i, v) in r.iter().zip(t.exponents) {
+                if v != &E::zero() {
+                    self.field
+                        .mul_assign(&mut c, &self.field.pow(i, v.to_u32() as u64));
+                }
+            }
+
+            self.field.add_assign(&mut res, &c);
+        }
+
+        res
+    }
+
     /// Replace a variable `n` in the polynomial by a polynomial `v`.
     pub fn replace_with_poly(&self, n: usize, v: &Self) -> Self {
-        assert_eq!(self.var_map, v.var_map);
+        assert_eq!(self.variables, v.variables);
 
         if v.is_constant() {
             return self.replace(n, &v.lcoeff());
         }
 
         let mut res = self.zero_with_capacity(self.nterms());
-        let mut exp = vec![E::zero(); self.nvars];
+        let mut exp = vec![E::zero(); self.nvars()];
         for t in self {
             if t.exponents[n] == E::zero() {
-                res.append_monomial(t.coefficient.clone(), &t.exponents[..self.nvars]);
+                res.append_monomial(t.coefficient.clone(), &t.exponents[..self.nvars()]);
                 continue;
             }
 
             exp.copy_from_slice(t.exponents);
             exp[n] = E::zero();
 
             // TODO: cache v^e
@@ -1367,15 +1551,15 @@
 
             tm.entry(t.exponents[v])
                 .and_modify(|e| self.field.add_assign(e, &c))
                 .or_insert(c);
         }
 
         let mut res = self.zero();
-        let mut e = vec![E::zero(); self.nvars];
+        let mut e = vec![E::zero(); self.nvars()];
         for (k, c) in tm {
             e[v] = k;
             res.append_monomial(c, &e);
             e[v] = E::zero();
         }
 
         res
@@ -1383,14 +1567,18 @@
 
     /// Compute `self^pow`.
     pub fn pow(&self, mut pow: usize) -> Self {
         if pow == 0 {
             return self.one();
         }
 
+        if self.is_constant() {
+            return self.constant(self.field.pow(&self.lcoeff(), pow as u64));
+        }
+
         let mut x = self.clone();
         let mut y = self.one();
         while pow != 1 {
             if pow % 2 == 1 {
                 y = &y * &x;
                 pow -= 1;
             }
@@ -1398,17 +1586,53 @@
             x = &x * &x;
             pow /= 2;
         }
 
         x * &y
     }
 
+    pub fn to_univariate(&self, var: usize) -> UnivariatePolynomial<PolynomialRing<F, E>> {
+        let c = self.to_univariate_polynomial_list(var);
+
+        let mut p = UnivariatePolynomial::new(
+            &PolynomialRing::new_from_poly(self),
+            None,
+            Arc::new(self.variables[var].clone()),
+        );
+
+        if c.is_empty() {
+            return p;
+        }
+
+        p.coefficients = vec![p.field.zero(); c.last().unwrap().1.to_u32() as usize + 1];
+        for (q, e) in c {
+            p.coefficients[e.to_u32() as usize] = q;
+        }
+
+        p
+    }
+
+    pub fn to_univariate_from_univariate(&self, var: usize) -> UnivariatePolynomial<F> {
+        let mut p =
+            UnivariatePolynomial::new(&self.field, None, Arc::new(self.variables[var].clone()));
+
+        if self.is_zero() {
+            return p;
+        }
+
+        p.coefficients = vec![p.field.zero(); self.degree(var).to_u32() as usize + 1];
+        for (q, e) in self.coefficients.iter().zip(self.exponents_iter()) {
+            p.coefficients[e[var].to_u32() as usize] = q.clone();
+        }
+
+        p
+    }
+
     /// Create a univariate polynomial coefficient list out of a multivariate polynomial.
     /// The output is sorted in the degree.
-    // TODO: allow a MultivariatePolynomial as a coefficient
     pub fn to_univariate_polynomial_list(
         &self,
         x: usize,
     ) -> Vec<(MultivariatePolynomial<F, E, LexOrder>, E)> {
         if self.coefficients.is_empty() {
             return vec![];
         }
@@ -1420,15 +1644,15 @@
             if d > maxdeg {
                 maxdeg = d;
             }
         }
 
         // construct the coefficient per power of x
         let mut result = vec![];
-        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars];
+        let mut e: SmallVec<[E; INLINED_EXPONENTS]> = smallvec![E::zero(); self.nvars()];
         for d in 0..maxdeg.to_u32() + 1 {
             // TODO: add bounds estimate
             let mut a = self.zero();
             for t in 0..self.nterms() {
                 if self.exponents(t)[x].to_u32() == d {
                     for (i, ee) in self.exponents(t).iter().enumerate() {
                         e[i] = *ee;
@@ -1457,16 +1681,16 @@
             return HashMap::new();
         }
 
         let mut tm: HashMap<
             SmallVec<[E; INLINED_EXPONENTS]>,
             MultivariatePolynomial<F, E, LexOrder>,
         > = HashMap::new();
-        let mut e_not_in_xs = smallvec![E::zero(); self.nvars];
-        let mut e_in_xs = smallvec![E::zero(); self.nvars];
+        let mut e_not_in_xs = smallvec![E::zero(); self.nvars()];
+        let mut e_in_xs = smallvec![E::zero(); self.nvars()];
         for t in self {
             for (i, ee) in t.exponents.iter().enumerate() {
                 e_not_in_xs[i] = *ee;
                 e_in_xs[i] = E::zero();
             }
 
             for x in xs {
@@ -1496,14 +1720,51 @@
                     });
             }
         }
 
         tm
     }
 
+    /// Convert the polynomial to one in a number field, where the variable
+    /// of the number field is moved into the coefficient.
+    pub fn to_number_field(
+        &self,
+        field: &AlgebraicNumberRing<F>,
+    ) -> MultivariatePolynomial<AlgebraicNumberRing<F>, E> {
+        let var = &field.poly().get_vars_ref()[0];
+        let Some(var_index) = self.get_vars_ref().iter().position(|x| x == var) else {
+            return self.map_coeff(
+                |c| field.to_element(field.poly().constant(c.clone())),
+                field.clone(),
+            );
+        };
+
+        let polys = self.to_multivariate_polynomial_list(&[var_index], false);
+
+        // TODO: remove the variable from the variable map?
+        let mut poly =
+            MultivariatePolynomial::new(field, self.nterms().into(), self.variables.clone().into());
+        for (e, c) in polys {
+            let mut c2 = MultivariatePolynomial::new(
+                &self.field,
+                c.nterms().into(),
+                Arc::new(vec![self.variables.as_ref()[var_index].clone()]).into(),
+            );
+
+            c2.exponents = c
+                .exponents_iter()
+                .map(|x| x[var_index].to_u32() as u8)
+                .collect();
+            c2.coefficients = c.coefficients;
+
+            poly.append_monomial(field.to_element(c2), &e);
+        }
+        poly
+    }
+
     pub fn mul_univariate_dense(&self, rhs: &Self, max_pow: Option<usize>) -> Self {
         if self.is_constant() {
             if let Some(m) = max_pow {
                 if let Some(var) = rhs.last_exponents().iter().position(|e| *e != E::zero()) {
                     if rhs.degree(var).to_u32() > m as u32 {
                         return rhs
                             .mod_var(var, E::from_u32(m as u32 + 1))
@@ -1550,30 +1811,30 @@
                 }
 
                 self.field
                     .add_mul_assign(&mut coeffs[pos as usize], x.coefficient, y.coefficient);
             }
         }
 
-        let mut exp = vec![E::zero(); self.nvars];
+        let mut exp = vec![E::zero(); self.nvars()];
         let mut res = self.zero_with_capacity(coeffs.len());
         for (p, c) in coeffs.into_iter().enumerate() {
             if !F::is_zero(&c) {
                 exp[var] = E::from_u32(p as u32);
                 res.append_monomial(c, &exp);
             }
         }
         res
     }
 
     fn mul_dense(
         &self,
         rhs: &MultivariatePolynomial<F, E, LexOrder>,
     ) -> Option<MultivariatePolynomial<F, E, LexOrder>> {
-        let max_degs_rev = (0..self.nvars)
+        let max_degs_rev = (0..self.nvars())
             .rev()
             .map(|i| 1 + self.degree(i).to_u32() as usize + rhs.degree(i).to_u32() as usize)
             .collect::<Vec<_>>();
 
         if max_degs_rev.iter().filter(|x| **x > 0).count() == 1 {
             if max_degs_rev.iter().sum::<usize>() < 10000 {
                 return Some(self.mul_univariate_dense(rhs, None));
@@ -1615,27 +1876,24 @@
             for (ee, &x) in exp.iter_mut().rev().zip(max_degs_rev) {
                 *ee = E::from_u32(p % x as u32);
                 p /= x as u32;
             }
         }
 
         let mut uni_exp_self = vec![0; self.coefficients.len()];
-        for (es, s) in &mut uni_exp_self
-            .iter_mut()
-            .zip(self.exponents.chunks(self.nvars))
-        {
+        for (es, s) in &mut uni_exp_self.iter_mut().zip(self.exponents_iter()) {
             *es = to_uni_var(s, &max_degs_rev);
         }
 
         let mut uni_exp_rhs = vec![0; rhs.coefficients.len()];
-        for (es, s) in &mut uni_exp_rhs.iter_mut().zip(rhs.exponents.chunks(self.nvars)) {
+        for (es, s) in &mut uni_exp_rhs.iter_mut().zip(rhs.exponents_iter()) {
             *es = to_uni_var(s, &max_degs_rev);
         }
 
-        let mut exp = vec![E::zero(); self.nvars];
+        let mut exp = vec![E::zero(); self.nvars()];
         let mut r = self.zero_with_capacity(self.nterms().max(rhs.nterms()));
 
         // check if we need to use a dense indexing array to save memory
         if total < 1000 {
             let mut coeffs = vec![self.field.zero(); total];
 
             for (c1, e1) in self.coefficients.iter().zip(&uni_exp_self) {
@@ -1712,27 +1970,27 @@
     ) -> MultivariatePolynomial<F, E, LexOrder> {
         // place the smallest polynomial first, as this is faster
         // in the heap algorithm
         if self.nterms() > rhs.nterms() {
             return rhs.heap_mul(self);
         }
 
-        let degree_sum: Vec<_> = (0..self.nvars)
+        let degree_sum: Vec<_> = (0..self.nvars())
             .map(|i| self.degree(i).to_u32() as usize + rhs.degree(i).to_u32() as usize)
             .collect();
 
         // use a special routine if the exponents can be packed into a u64
         let mut pack_u8 = true;
-        if self.nvars <= 8
+        if self.nvars() <= 8
             && degree_sum.iter().all(|deg| {
                 if *deg > 255 {
                     pack_u8 = false;
                 }
 
-                *deg <= 255 || self.nvars <= 4 && *deg <= 65535
+                *deg <= 255 || self.nvars() <= 4 && *deg <= 65535
             })
         {
             return self.heap_mul_packed_exp(rhs, pack_u8);
         }
 
         let mut res = self.zero_with_capacity(self.nterms());
 
@@ -1747,15 +2005,15 @@
             .iter()
             .zip(rhs.exponents(0))
             .map(|(e1, e2)| *e1 + *e2)
             .collect();
         cache.insert(monom.clone(), vec![(0, 0)]);
         h.push(Reverse(monom));
 
-        let mut m_cache: Vec<E> = vec![E::zero(); self.nvars];
+        let mut m_cache: Vec<E> = vec![E::zero(); self.nvars()];
 
         // i=merged_index[j] signifies that self[i]*other[j] has been merged
         let mut merged_index = vec![0; rhs.nterms()];
         // in_heap[j] signifies that other[j] is in the heap
         let mut in_heap = vec![false; rhs.nterms()];
         in_heap[0] = true;
 
@@ -1842,36 +2100,22 @@
         &self,
         other: &MultivariatePolynomial<F, E, LexOrder>,
         pack_u8: bool,
     ) -> MultivariatePolynomial<F, E, LexOrder> {
         let mut res = self.zero_with_capacity(self.nterms() * other.nterms());
 
         let pack_a: Vec<_> = if pack_u8 {
-            self.exponents
-                .chunks(self.nvars)
-                .map(|c| E::pack(c))
-                .collect()
+            self.exponents_iter().map(|c| E::pack(c)).collect()
         } else {
-            self.exponents
-                .chunks(self.nvars)
-                .map(|c| E::pack_u16(c))
-                .collect()
+            self.exponents_iter().map(|c| E::pack_u16(c)).collect()
         };
         let pack_b: Vec<_> = if pack_u8 {
-            other
-                .exponents
-                .chunks(self.nvars)
-                .map(|c| E::pack(c))
-                .collect()
+            other.exponents_iter().map(|c| E::pack(c)).collect()
         } else {
-            other
-                .exponents
-                .chunks(self.nvars)
-                .map(|c| E::pack_u16(c))
-                .collect()
+            other.exponents_iter().map(|c| E::pack_u16(c)).collect()
         };
 
         let mut cache: BTreeMap<u64, Vec<(usize, usize)>> = BTreeMap::new();
         let mut q_cache: Vec<Vec<(usize, usize)>> = vec![];
 
         // create a min-heap since our polynomials are sorted smallest to largest
         let mut h: BinaryHeap<Reverse<u64>> = BinaryHeap::with_capacity(self.nterms());
@@ -1938,20 +2182,20 @@
 
             q_cache.push(q);
 
             if !F::is_zero(&coefficient) {
                 res.coefficients.push(coefficient);
                 let len = res.exponents.len();
 
-                res.exponents.resize(len + self.nvars, E::zero());
+                res.exponents.resize(len + self.nvars(), E::zero());
 
                 if pack_u8 {
-                    E::unpack(cur_mon.0, &mut res.exponents[len..len + self.nvars]);
+                    E::unpack(cur_mon.0, &mut res.exponents[len..len + self.nvars()]);
                 } else {
-                    E::unpack_u16(cur_mon.0, &mut res.exponents[len..len + self.nvars]);
+                    E::unpack_u16(cur_mon.0, &mut res.exponents[len..len + self.nvars()]);
                 }
             }
         }
         res
     }
 
     /// Synthetic division for univariate polynomials, where `div` is monic.
@@ -2024,22 +2268,24 @@
                     (coeff, true)
                 } else {
                     (coeff, false)
                 };
 
                 if div {
                     let nterms = q.nterms();
+                    let nvars = q.nvars();
                     q.coefficients.push(quot);
-                    q.exponents.resize((nterms + 1) * q.nvars, E::zero());
-                    q.exponents[nterms * q.nvars + var] = pow - m;
+                    q.exponents.resize((nterms + 1) * nvars, E::zero());
+                    q.exponents[nterms * nvars + var] = pow - m;
                 } else {
                     let nterms = r.nterms();
+                    let nvars = r.nvars();
                     r.coefficients.push(quot);
-                    r.exponents.resize((nterms + 1) * r.nvars, E::zero());
-                    r.exponents[nterms * r.nvars + var] = pow;
+                    r.exponents.resize((nterms + 1) * nvars, E::zero());
+                    r.exponents[nterms * nvars + var] = pow;
                 }
             }
 
             if pow.is_zero() {
                 break;
             }
 
@@ -2074,15 +2320,15 @@
             for j in (k..d).rev() {
                 v[j] = &v[j] + &v[j + 1].clone().mul_coeff(shift.clone());
             }
         }
 
         let mut poly = self.zero();
         for (i, mut v) in v.into_iter().enumerate() {
-            for x in v.exponents.chunks_mut(self.nvars) {
+            for x in v.exponents.chunks_mut(self.nvars()) {
                 x[var] = E::from_u32(i as u32);
             }
 
             for m in &v {
                 poly.append_monomial(m.coefficient.clone(), m.exponents);
             }
         }
@@ -2138,15 +2384,15 @@
         }
 
         // check if the leading coefficients divide
         if !F::is_zero(&self.field.rem(&self.lcoeff(), &div.lcoeff())) {
             return None;
         }
 
-        if (0..self.nvars).any(|v| self.degree(v) < div.degree(v)) {
+        if (0..self.nvars()).any(|v| self.degree(v) < div.degree(v)) {
             return None;
         }
 
         if self.field.is_characteristic_zero() {
             // test division of constant term (evaluation at x_i = 0)
             let c = div.get_constant();
             if !F::is_zero(&c)
@@ -2230,16 +2476,17 @@
             }
         }
 
         if div.nterms() == 1 {
             let mut q = self.clone();
             let dive = div.to_monomial_view(0);
 
-            if q.nvars > 0 {
-                for ee in q.exponents.chunks_mut(q.nvars) {
+            let nvars = q.nvars();
+            if nvars > 0 {
+                for ee in q.exponents.chunks_mut(nvars) {
                     for (e1, e2) in ee.iter_mut().zip(dive.exponents) {
                         if *e1 >= *e2 {
                             *e1 = *e1 - *e2;
                         } else {
                             return (self.zero(), self.clone());
                         }
                     }
@@ -2255,31 +2502,31 @@
                 }
             }
 
             return (q, self.zero());
         }
 
         // check if the division is univariate with the same variable
-        let degree_sum: Vec<_> = (0..self.nvars)
+        let degree_sum: Vec<_> = (0..self.nvars())
             .map(|i| self.degree(i).to_u32() as usize + div.degree(i).to_u32() as usize)
             .collect();
 
         if div.field.is_one(&div.lcoeff()) && degree_sum.iter().filter(|x| **x > 0).count() == 1 {
             return self.quot_rem_univariate_monic(div);
         }
 
         let mut pack_u8 = true;
-        if self.nvars <= 8
-            && (0..self.nvars).all(|i| {
+        if self.nvars() <= 8
+            && (0..self.nvars()).all(|i| {
                 let deg = self.degree(i).to_u32();
                 if deg > 127 {
                     pack_u8 = false;
                 }
 
-                deg <= 127 || self.nvars <= 4 && deg <= 32767
+                deg <= 127 || self.nvars() <= 4 && deg <= 32767
             })
         {
             self.heap_division_packed_exp(div, abort_on_remainder, pack_u8)
         } else {
             self.heap_division(div, abort_on_remainder)
         }
     }
@@ -2302,16 +2549,16 @@
         let mut merged_index_of_div_monomial_in_quotient = vec![0; div.nterms()];
 
         let mut cache: BTreeMap<Vec<E>, Vec<(usize, usize, bool)>> = BTreeMap::new();
 
         let mut h: BinaryHeap<Vec<E>> = BinaryHeap::with_capacity(self.nterms());
         let mut q_cache: Vec<Vec<(usize, usize, bool)>> = vec![];
 
-        let mut m = vec![E::zero(); div.nvars];
-        let mut m_cache = vec![E::zero(); div.nvars];
+        let mut m = vec![E::zero(); div.nvars()];
+        let mut m_cache = vec![E::zero(); div.nvars()];
         let mut c;
 
         let mut k = 0;
         while !h.is_empty() || k < self.nterms() {
             if k < self.nterms() && (h.is_empty() || self.exponents_back(k) >= h.peek().unwrap()) {
                 for (s, e) in m.iter_mut().zip(self.exponents_back(k)) {
                     *s = *e;
@@ -2543,34 +2790,22 @@
         MultivariatePolynomial<F, E, LexOrder>,
         MultivariatePolynomial<F, E, LexOrder>,
     ) {
         let mut q = self.zero_with_capacity(self.nterms());
         let mut r = self.zero();
 
         let pack_a: Vec<_> = if pack_u8 {
-            self.exponents
-                .chunks(self.nvars)
-                .map(|c| E::pack(c))
-                .collect()
+            self.exponents_iter().map(|c| E::pack(c)).collect()
         } else {
-            self.exponents
-                .chunks(self.nvars)
-                .map(|c| E::pack_u16(c))
-                .collect()
+            self.exponents_iter().map(|c| E::pack_u16(c)).collect()
         };
         let pack_div: Vec<_> = if pack_u8 {
-            div.exponents
-                .chunks(div.nvars)
-                .map(|c| E::pack(c))
-                .collect()
+            div.exponents_iter().map(|c| E::pack(c)).collect()
         } else {
-            div.exponents
-                .chunks(div.nvars)
-                .map(|c| E::pack_u16(c))
-                .collect()
+            div.exponents_iter().map(|c| E::pack_u16(c)).collect()
         };
 
         let mut div_monomial_in_heap = vec![false; div.nterms()];
         let mut merged_index_of_div_monomial_in_quotient = vec![0; div.nterms()];
 
         let mut cache: BTreeMap<u64, Vec<(usize, usize, bool)>> = BTreeMap::new();
 
@@ -2702,20 +2937,20 @@
                     } else {
                         return (self.zero(), self.clone());
                     }
                 }
 
                 q.coefficients.push(quot);
                 let len = q.exponents.len();
-                q.exponents.resize(len + self.nvars, E::zero());
+                q.exponents.resize(len + self.nvars(), E::zero());
 
                 if pack_u8 {
-                    E::unpack(q_e, &mut q.exponents[len..len + self.nvars]);
+                    E::unpack(q_e, &mut q.exponents[len..len + self.nvars()]);
                 } else {
-                    E::unpack_u16(q_e, &mut q.exponents[len..len + self.nvars]);
+                    E::unpack_u16(q_e, &mut q.exponents[len..len + self.nvars()]);
                 }
                 q_exp.push(q_e);
 
                 if div.nterms() == 1 {
                     continue;
                 }
 
@@ -2774,20 +3009,20 @@
                 }
             } else if abort_on_remainder {
                 r = self.one();
                 return (q, r);
             } else {
                 r.coefficients.push(c);
                 let len = r.exponents.len();
-                r.exponents.resize(len + self.nvars, E::zero());
+                r.exponents.resize(len + self.nvars(), E::zero());
 
                 if pack_u8 {
-                    E::unpack(m, &mut r.exponents[len..len + self.nvars]);
+                    E::unpack(m, &mut r.exponents[len..len + self.nvars()]);
                 } else {
-                    E::unpack_u16(m, &mut r.exponents[len..len + self.nvars]);
+                    E::unpack_u16(m, &mut r.exponents[len..len + self.nvars()]);
                 }
             }
         }
 
         // q and r have the highest monomials first
         q.reverse();
         r.reverse();
@@ -2797,27 +3032,64 @@
             if !(&q * div + r.clone() - self.clone()).is_zero() {
                 panic!("Division failed: ({})/({}): q={}, r={}", self, div, q, r);
             }
         }
 
         (q, r)
     }
+
+    /// Compute the p-adic expansion of the polynomial.
+    /// It returns `[a0, a1, a2, ...]` such that `a0 + a1 * p^1 + a2 * p^2 + ... = self`.
+    pub fn p_adic_expansion(&self, p: &Self) -> Vec<Self> {
+        let mut res = vec![];
+        let mut r = self.clone();
+        while !r.is_zero() {
+            let (q, rem) = r.quot_rem(p, true);
+            res.push(rem);
+            r = q;
+        }
+        res
+    }
 }
 
 impl<F: Field, E: Exponent, O: MonomialOrder> MultivariatePolynomial<F, E, O> {
     /// Make the polynomial monic, i.e., make the leading coefficient `1` by
     /// multiplying all monomials with `1/lcoeff`.
     pub fn make_monic(self) -> Self {
         if self.lcoeff() != self.field.one() {
             let ci = self.field.inv(&self.lcoeff());
             self.mul_coeff(ci)
         } else {
             self
         }
     }
+
+    /// Integrate the polynomial w.r.t the variable `var`,
+    /// producing the antiderivative with zero constant.
+    pub fn integrate(&self, var: usize) -> Self {
+        debug_assert!(var < self.nvars());
+        if self.is_zero() {
+            return self.zero();
+        }
+
+        let mut res = self.zero_with_capacity(self.nterms());
+
+        let mut exp = vec![E::zero(); self.nvars()];
+        for x in self {
+            exp.copy_from_slice(x.exponents);
+            let pow = exp[var].to_u32() as u64;
+            exp[var] = exp[var] + E::one();
+            res.append_monomial(
+                self.field.div(x.coefficient, &self.field.nth(pow + 1)),
+                &exp,
+            );
+        }
+
+        res
+    }
 }
 
 impl<F: Field, E: Exponent> MultivariatePolynomial<F, E, LexOrder> {
     /// Optimized division routine for univariate polynomials over a field, which
     /// makes the divisor monic first.
     pub fn quot_rem_univariate(
         &self,
@@ -3022,39 +3294,72 @@
 
         let mut poly = self.zero();
         let mut accum_inv = self.field.one();
         let sample_point_inv = self.field.inv(shift);
         for (i, mut v) in v.into_iter().enumerate() {
             v = v.mul_coeff(accum_inv.clone());
 
-            for x in v.exponents.chunks_mut(self.nvars) {
+            for x in v.exponents.chunks_mut(self.nvars()) {
                 x[var] = E::from_u32(i as u32);
             }
 
             for m in &v {
                 poly.append_monomial(m.coefficient.clone(), m.exponents);
             }
 
             self.field.mul_assign(&mut accum_inv, &sample_point_inv);
         }
 
         poly
     }
 }
 
+impl<R: Ring, E: Exponent> MultivariatePolynomial<AlgebraicNumberRing<R>, E> {
+    /// Convert the polynomial to a multivariate polynomial that contains the
+    /// variable in the number field.
+    pub fn from_number_field(&self) -> MultivariatePolynomial<R, E> {
+        let var = &self.field.poly().get_vars_ref()[0];
+
+        let var_map = if !self.get_vars_ref().contains(var) {
+            let mut v = self.get_vars_ref().to_vec();
+            v.push(var.clone());
+            Arc::new(v)
+        } else {
+            self.variables.clone()
+        };
+
+        let var_index = var_map.iter().position(|x| x == var).unwrap();
+
+        let mut poly = MultivariatePolynomial::new(
+            &self.field.poly().field,
+            self.nterms().into(),
+            var_map.into(),
+        );
+        let mut exp = vec![E::zero(); poly.nvars()];
+        for t in self {
+            exp[..self.nvars()].copy_from_slice(t.exponents);
+            for t2 in &t.coefficient.poly {
+                exp[var_index] = E::from_u32(t2.exponents[0].to_u32());
+                poly.append_monomial(t2.coefficient.clone(), &exp);
+            }
+        }
+
+        poly
+    }
+}
+
 impl<E: Exponent> From<&MultivariatePolynomial<IntegerRing, E>>
     for MultivariatePolynomial<RationalField, E>
 {
     fn from(val: &MultivariatePolynomial<IntegerRing, E>) -> Self {
         MultivariatePolynomial {
             coefficients: val.coefficients.iter().map(|x| x.into()).collect(),
             exponents: val.exponents.clone(),
-            nvars: val.nvars,
             field: RationalField,
-            var_map: val.var_map.clone(),
+            variables: val.variables.clone(),
             _phantom: PhantomData,
         }
     }
 }
 
 /// View object for a term in a multivariate polynomial.
 #[derive(Copy, Clone, Debug)]
@@ -3097,7 +3402,81 @@
     fn into_iter(self) -> Self::IntoIter {
         Self::IntoIter {
             poly: self,
             index: 0,
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{atom::Atom, domains::integer::Z};
+
+    #[test]
+    fn mul_packed() {
+        let p1 = Atom::parse("v1^2+v2^3*v3*+3*v1^4+4*v2*v3")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Z, None);
+        let b = &p1 * &p1;
+        let r = Atom::parse(
+            "16*v2^2*v3^2+8*v1^2*v2*v3+v1^4+24*v1^4*v2^4*v3^2+6*v1^6*v2^3*v3+9*v1^8*v2^6*v3^2",
+        )
+        .unwrap();
+        assert_eq!(b.to_expression(), r)
+    }
+
+    #[test]
+    fn mul_full() {
+        let p1 = Atom::parse("v1^2+v2^3*v3*+3*v1^4+4*v2*v3+v4+v5+v6*v1*v2+v7*v5+v8+v9*v8")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Z, None);
+        let b = &p1 * &p1;
+
+        let r = Atom::parse(
+            "16*v2^2*v3^2+8*v1*v2^2*v3*v6+8*v1^2*v2*v3+v1^2*v2^2*v6^2+2*v1^3*v2*v6+v1^4+24*v1^4*v2^4*v3^2+6*v1^5*v2^4*v3*v6+6*v1^6*v2^3*v3+9*v1^8*v2^6*v3^2+8*v8*v2*v3+8*v8*v2*v3*v9+2*v8*v1*v2*v6+2*v8*v1*v2*v9*v6+2*v8*v1^2+2*v8*v1^2*v9+6*v8*v1^4*v2^3*v3+6*v8*v1^4*v2^3*v3*v9+v8^2+2*v8^2*v9+v8^2*v9^2+8*v5*v2*v3+8*v5*v2*v3*v7+2*v5*v1*v2*v6+2*v5*v1*v2*v7*v6+2*v5*v1^2+2*v5*v1^2*v7+6*v5*v1^4*v2^3*v3+6*v5*v1^4*v2^3*v3*v7+2*v5*v8+2*v5*v8*v9+2*v5*v8*v7+2*v5*v8*v7*v9+v5^2+2*v5^2*v7+v5^2*v7^2+8*v4*v2*v3+2*v4*v1*v2*v6+2*v4*v1^2+6*v4*v1^4*v2^3*v3+2*v4*v8+2*v4*v8*v9+2*v4*v5+2*v4*v5*v7+v4^2",
+        )
+        .unwrap();
+        assert_eq!(b.to_expression(), r)
+    }
+
+    #[test]
+    fn div_packed() {
+        let p1 = Atom::parse("(v1+v2*5+v3*v2+v1*v2*v3)(v1+v2+v3)")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Z, None);
+
+        let p2 = Atom::parse("v1+v2+v3+1")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Z, p1.variables.clone().into());
+
+        let (q, r) = p1.quot_rem(&p2, false);
+        assert_eq!(
+            q.to_expression(),
+            Atom::parse("-1+5*v2+v1+v1*v2*v3").unwrap()
+        );
+        assert_eq!(
+            r.to_expression(),
+            Atom::parse("1+v3-4*v2+v2*v3^2+v2^2*v3").unwrap()
+        );
+    }
+
+    #[test]
+    fn div_full() {
+        let p1 = Atom::parse("(v1+v2*5+v3*v2+v1*v2*v3+v4+v5+v6+v7+v8+v9*v8)(v1+v2+v3)")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Z, None);
+
+        let p2 = Atom::parse("v1+v2+v3+1")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Z, p1.variables.clone().into());
+
+        let (q, r) = p1.quot_rem(&p2, false);
+        assert_eq!(
+            q.to_expression(),
+            Atom::parse("-1+v8+v8*v9+v7+v6+v5+v4+5*v2+v1+v1*v2*v3").unwrap()
+        );
+        assert_eq!(
+            r.to_expression(),
+            Atom::parse("1-v8-v8*v9-v7-v6-v5-v4+v3-4*v2+v2*v3^2+v2^2*v3").unwrap()
+        );
+    }
+}
```

### Comparing `symbolica-0.3.0/src/poly.rs` & `symbolica-0.4.0/src/poly.rs`

 * *Files 15% similar despite different names*

```diff
@@ -1,35 +1,37 @@
 pub mod evaluate;
 pub mod factor;
 pub mod gcd;
 pub mod groebner;
 pub mod polynomial;
+pub mod resultant;
+pub mod univariate;
 
 use std::borrow::Cow;
 use std::cmp::Ordering::{self, Equal};
 use std::fmt::{Debug, Display};
 use std::hash::Hash;
 use std::iter::Sum;
 use std::ops::{Add as OpAdd, AddAssign, DerefMut, Div, Mul as OpMul, Neg, Rem, Sub};
 use std::sync::Arc;
 
 use ahash::HashMap;
 use smallvec::{smallvec, SmallVec};
 use smartstring::{LazyCompact, SmartString};
 
+use crate::atom::{Atom, AtomView, Symbol};
 use crate::coefficient::{Coefficient, CoefficientView, ConvertToRing};
 use crate::domains::factorized_rational_polynomial::{
     FactorizedRationalPolynomial, FromNumeratorAndFactorizedDenominator,
 };
 use crate::domains::integer::Integer;
 use crate::domains::rational_polynomial::{FromNumeratorAndDenominator, RationalPolynomial};
 use crate::domains::{EuclideanDomain, Ring};
 use crate::parser::{Operator, Token};
-use crate::representations::{Atom, AtomView, Symbol};
-use crate::state::{RecycledAtom, State, Workspace};
+use crate::state::{State, Workspace};
 use crate::utils;
 
 use self::factor::Factorize;
 use self::gcd::PolynomialGCD;
 use self::polynomial::MultivariatePolynomial;
 
 pub const INLINED_EXPONENTS: usize = 6;
@@ -338,75 +340,160 @@
 
 /// A polynomial variable. It is either a (global) symbol
 /// a temporary variable (for internal use), an array entry,
 /// a function or any other non-polynomial part.
 #[derive(Clone, Hash, Eq, Debug)]
 pub enum Variable {
     Symbol(Symbol),
-    Temporary(usize),     // a temporary variable, for internal use
-    Array(Symbol, usize), // an array entry, e.g. a[0]
+    Temporary(usize), // a temporary variable, for internal use
     Function(Symbol, Arc<Atom>),
     Other(Arc<Atom>), // any other non-polynomial part, for example x^-1, x^y, etc.
 }
 
 impl PartialEq for Variable {
     fn eq(&self, other: &Self) -> bool {
         match (self, other) {
             (Variable::Symbol(a), Variable::Symbol(b)) => a == b,
             (Variable::Temporary(a), Variable::Temporary(b)) => a == b,
-            (Variable::Array(a, b), Variable::Array(c, d)) => a == c && b == d,
             (Variable::Function(a, b), Variable::Function(c, d)) => a == c && b == d,
             (Variable::Other(a), Variable::Other(b)) => a == b,
             _ => false,
         }
     }
 }
 
+impl std::fmt::Display for Variable {
+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+        match self {
+            Variable::Symbol(v) => f.write_str(State::get_name(*v)),
+            Variable::Temporary(t) => f.write_fmt(format_args!("_TMP_{}", *t)),
+            Variable::Function(_, a) | Variable::Other(a) => std::fmt::Display::fmt(a, f),
+        }
+    }
+}
+
 impl From<Symbol> for Variable {
     fn from(i: Symbol) -> Variable {
         Variable::Symbol(i)
     }
 }
 
 impl Variable {
     pub fn to_id(&self) -> Option<Symbol> {
         match self {
             Variable::Symbol(s) => Some(*s),
             _ => None,
         }
     }
 
-    pub fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
-        match self {
-            Variable::Symbol(v) => f.write_str(State::get_name(*v)),
-            Variable::Temporary(t) => f.write_fmt(format_args!("_TMP_{}", *t)),
-            Variable::Array(t, i) => f.write_fmt(format_args!("{}[{}]", State::get_name(*t), i)),
-            Variable::Function(_, a) | Variable::Other(a) => std::fmt::Display::fmt(a, f),
-        }
-    }
-
     pub fn to_string(&self) -> String {
         match self {
             Variable::Symbol(v) => format!("{}", State::get_name(*v)),
             Variable::Temporary(t) => format!("_TMP_{}", *t),
-            Variable::Array(t, i) => format!("{}[{}]", State::get_name(*t), i),
             Variable::Function(_, a) | Variable::Other(a) => format!("{}", a),
         }
     }
+
+    /// Check if the symbol `symbol` appears at most once in the variable map.
+    /// For example, `[x,f(x)]` is not independent in `x`, but `[x,y]` is.
+    pub fn is_independent_symbol(variables: &[Variable], symbol: Symbol) -> bool {
+        let mut seen = false;
+
+        for v in variables {
+            match v {
+                Variable::Symbol(s) => {
+                    if *s == symbol {
+                        if seen {
+                            return false;
+                        }
+                        seen = true;
+                    }
+                }
+                Variable::Function(_, f) | Variable::Other(f) => {
+                    if f.contains_symbol(symbol) {
+                        if seen {
+                            return false;
+                        }
+                        seen = true;
+                    }
+                }
+                Variable::Temporary(_) => {}
+            }
+        }
+
+        true
+    }
+}
+
+impl Atom {
+    /// Convert the atom to a polynomial, optionally in the variable ordering
+    /// specified by `var_map`. If new variables are encountered, they are
+    /// added to the variable map. Similarly, non-polynomial parts are automatically
+    /// defined as a new independent variable in the polynomial.
+    pub fn to_polynomial<R: EuclideanDomain + ConvertToRing, E: Exponent>(
+        &self,
+        field: &R,
+        var_map: Option<Arc<Vec<Variable>>>,
+    ) -> MultivariatePolynomial<R, E> {
+        self.as_view().to_polynomial(field, var_map)
+    }
+
+    /// Convert the atom to a rational polynomial, optionally in the variable ordering
+    /// specified by `var_map`. If new variables are encountered, they are
+    /// added to the variable map. Similarly, non-rational polynomial parts are automatically
+    /// defined as a new independent variable in the rational polynomial.
+    pub fn to_rational_polynomial<
+        R: EuclideanDomain + ConvertToRing,
+        RO: EuclideanDomain + PolynomialGCD<E>,
+        E: Exponent,
+    >(
+        &self,
+        field: &R,
+        out_field: &RO,
+        var_map: Option<Arc<Vec<Variable>>>,
+    ) -> RationalPolynomial<RO, E>
+    where
+        RationalPolynomial<RO, E>:
+            FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
+    {
+        self.as_view()
+            .to_rational_polynomial(field, out_field, var_map)
+    }
+
+    /// Convert the atom to a rational polynomial with factorized denominators, optionally in the variable ordering
+    /// specified by `var_map`. If new variables are encountered, they are
+    /// added to the variable map. Similarly, non-rational polynomial parts are automatically
+    /// defined as a new independent variable in the rational polynomial.
+    pub fn to_factorized_rational_polynomial<
+        R: EuclideanDomain + ConvertToRing,
+        RO: EuclideanDomain + PolynomialGCD<E>,
+        E: Exponent,
+    >(
+        &self,
+        field: &R,
+        out_field: &RO,
+        var_map: Option<Arc<Vec<Variable>>>,
+    ) -> FactorizedRationalPolynomial<RO, E>
+    where
+        FactorizedRationalPolynomial<RO, E>: FromNumeratorAndFactorizedDenominator<R, RO, E>
+            + FromNumeratorAndFactorizedDenominator<RO, RO, E>,
+        MultivariatePolynomial<RO, E>: Factorize,
+    {
+        self.as_view()
+            .to_factorized_rational_polynomial(field, out_field, var_map)
+    }
 }
 
 impl<'a> AtomView<'a> {
-    /// Convert an expression to a polynomial.
-    ///
-    /// This function requires an expanded polynomial. If this yields too many terms, consider using
-    /// calling `to_rational_polynomial` instead.
-    pub fn to_polynomial<R: Ring + ConvertToRing, E: Exponent>(
+    /// Convert an expanded expression to a polynomial.
+    fn to_polynomial_expanded<R: Ring + ConvertToRing, E: Exponent>(
         &self,
         field: &R,
         var_map: Option<&Arc<Vec<Variable>>>,
+        allow_new_vars: bool,
     ) -> Result<MultivariatePolynomial<R, E>, &'static str> {
         fn check_factor(
             factor: &AtomView<'_>,
             vars: &mut Vec<Variable>,
             allow_new_vars: bool,
         ) -> Result<(), &'static str> {
             match factor {
@@ -496,20 +583,20 @@
 
         // get all variables and check structure
         let mut vars = var_map.map(|v| (**v).clone()).unwrap_or_default();
         let mut n_terms = 0;
         match self {
             AtomView::Add(a) => {
                 for term in a.iter() {
-                    check_term(&term, &mut vars, var_map.is_none())?;
+                    check_term(&term, &mut vars, allow_new_vars)?;
                     n_terms += 1;
                 }
             }
             _ => {
-                check_term(self, &mut vars, var_map.is_none())?;
+                check_term(self, &mut vars, allow_new_vars)?;
                 n_terms += 1;
             }
         }
 
         fn parse_factor<R: Ring + ConvertToRing, E: Exponent>(
             factor: &AtomView<'_>,
             vars: &[Variable],
@@ -574,820 +661,443 @@
                 }
                 _ => parse_factor(term, vars, &mut coefficient, &mut exponents, field),
             }
 
             poly.append_monomial(coefficient, &exponents);
         }
 
-        let mut poly = MultivariatePolynomial::<R, E>::new(
-            vars.len(),
-            field,
-            Some(n_terms),
-            Some(Arc::new(vars.clone())),
-        );
+        let mut poly =
+            MultivariatePolynomial::<R, E>::new(field, Some(n_terms), Arc::new(vars.clone()));
 
         match self {
             AtomView::Add(a) => {
                 for term in a.iter() {
                     parse_term(&term, &vars, &mut poly, field);
                 }
             }
             _ => parse_term(self, &vars, &mut poly, field),
         }
 
         Ok(poly)
     }
 
-    /// Convert an expression to a rational polynomial if possible.
-    pub fn to_rational_polynomial<
-        R: EuclideanDomain + ConvertToRing,
-        RO: EuclideanDomain + PolynomialGCD<E>,
-        E: Exponent,
-    >(
-        &self,
-        field: &R,
-        out_field: &RO,
-        var_map: Option<&Arc<Vec<Variable>>>,
-    ) -> Result<RationalPolynomial<RO, E>, Cow<'static, str>>
-    where
-        RationalPolynomial<RO, E>:
-            FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
-    {
-        Workspace::get_local()
-            .with(|ws| self.to_rational_polynomial_with_ws(ws, field, out_field, var_map))
-    }
-
-    /// Convert an expression to a rational polynomial if possible.
-    pub(crate) fn to_rational_polynomial_with_ws<
-        R: EuclideanDomain + ConvertToRing,
-        RO: EuclideanDomain + PolynomialGCD<E>,
-        E: Exponent,
-    >(
+    /// Convert the atom to a polynomial, optionally in the variable ordering
+    /// specified by `var_map`. If new variables are encountered, they are
+    /// added to the variable map. Similarly, non-polynomial parts are automatically
+    /// defined as a new independent variable in the polynomial.
+    pub fn to_polynomial<R: EuclideanDomain + ConvertToRing, E: Exponent>(
         &self,
-        workspace: &Workspace,
         field: &R,
-        out_field: &RO,
-        var_map: Option<&Arc<Vec<Variable>>>,
-    ) -> Result<RationalPolynomial<RO, E>, Cow<'static, str>>
-    where
-        RationalPolynomial<RO, E>:
-            FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
-    {
-        // see if the current term can be cast into a polynomial using a fast routine
-        if let Ok(num) = self.to_polynomial(field, var_map) {
-            let den = num.one();
-            return Ok(RationalPolynomial::from_num_den(num, den, out_field, false));
-        }
-
-        match self {
-            AtomView::Num(_) | AtomView::Var(_) => {
-                let num = self.to_polynomial(field, var_map)?;
-                let den = num.one();
-                Ok(RationalPolynomial::from_num_den(num, den, out_field, false))
-            }
-            AtomView::Pow(p) => {
-                let (base, exp) = p.get_base_exp();
-                if let AtomView::Num(n) = exp {
-                    let num_n = n.get_coeff_view();
-
-                    if let CoefficientView::Natural(nn, nd) = num_n {
-                        if nd != 1 {
-                            Err("Exponent cannot be a fraction")?
-                        }
-
-                        if nn != -1 {
-                            let mut h = workspace.new_atom();
-                            if !self.expand_with_ws_into(workspace, &mut h) {
-                                // expansion did not change the input, so we are in a case of x^-3 or x^3
-                                let r = base.to_rational_polynomial_with_ws(
-                                    workspace, field, out_field, var_map,
-                                )?;
-
-                                if nn < 0 {
-                                    let r_inv = r.inv();
-                                    Ok(r_inv.pow(-nn as u64))
-                                } else {
-                                    Ok(r.pow(nn as u64))
-                                }
-                            } else {
-                                h.as_view().to_rational_polynomial_with_ws(
-                                    workspace, field, out_field, var_map,
-                                )
-                            }
-                        } else if nn < 0 {
-                            let r = base.to_rational_polynomial_with_ws(
-                                workspace, field, out_field, var_map,
-                            )?;
-                            Ok(r.inv())
-                        } else {
-                            base.to_rational_polynomial_with_ws(
-                                workspace, field, out_field, var_map,
-                            )
-                        }
-                    } else {
-                        Err("Exponent needs to be an integer")?
-                    }
-                } else {
-                    Err("Power needs to be a number")?
-                }
-            }
-            AtomView::Fun(_) => Err("Functions not allowed")?,
-            AtomView::Mul(m) => {
-                let mut r = RationalPolynomial::new(out_field, var_map.cloned());
-                r.numerator = r.numerator.add_monomial(out_field.one());
-                for arg in m.iter() {
-                    let mut arg_r =
-                        arg.to_rational_polynomial_with_ws(workspace, field, out_field, var_map)?;
-                    r.unify_var_map(&mut arg_r);
-                    r = &r * &arg_r;
-                }
-                Ok(r)
-            }
-            AtomView::Add(a) => {
-                let mut r = RationalPolynomial::new(out_field, var_map.cloned());
-                for arg in a.iter() {
-                    let mut arg_r =
-                        arg.to_rational_polynomial_with_ws(workspace, field, out_field, var_map)?;
-                    r.unify_var_map(&mut arg_r);
-                    r = &r + &arg_r;
-                }
-                Ok(r)
-            }
-        }
-    }
-
-    /// Convert an expression to a rational polynomial if possible.
-    pub fn to_factorized_rational_polynomial<
-        R: EuclideanDomain + ConvertToRing,
-        RO: EuclideanDomain + PolynomialGCD<E>,
-        E: Exponent,
-    >(
-        &self,
-        field: &R,
-        out_field: &RO,
-        var_map: Option<&Arc<Vec<Variable>>>,
-    ) -> Result<FactorizedRationalPolynomial<RO, E>, Cow<'static, str>>
-    where
-        FactorizedRationalPolynomial<RO, E>: FromNumeratorAndFactorizedDenominator<R, RO, E>
-            + FromNumeratorAndFactorizedDenominator<RO, RO, E>,
-        MultivariatePolynomial<RO, E>: Factorize,
-    {
-        Workspace::get_local().with(|ws| {
-            self.to_factorized_rational_polynomial_with_ws(ws, field, out_field, var_map)
-        })
-    }
-
-    /// Convert an expression to a rational polynomial if possible.
-    pub(crate) fn to_factorized_rational_polynomial_with_ws<
-        R: EuclideanDomain + ConvertToRing,
-        RO: EuclideanDomain + PolynomialGCD<E>,
-        E: Exponent,
-    >(
-        &self,
-        workspace: &Workspace,
-        field: &R,
-        out_field: &RO,
-        var_map: Option<&Arc<Vec<Variable>>>,
-    ) -> Result<FactorizedRationalPolynomial<RO, E>, Cow<'static, str>>
-    where
-        FactorizedRationalPolynomial<RO, E>: FromNumeratorAndFactorizedDenominator<R, RO, E>
-            + FromNumeratorAndFactorizedDenominator<RO, RO, E>,
-        MultivariatePolynomial<RO, E>: Factorize,
-    {
-        // see if the current term can be cast into a polynomial using a fast routine
-        if let Ok(num) = self.to_polynomial(field, var_map) {
-            let den = vec![(num.one(), 1)];
-            return Ok(FactorizedRationalPolynomial::from_num_den(
-                num, den, out_field, false,
-            ));
-        }
-
-        match self {
-            AtomView::Num(_) | AtomView::Var(_) => {
-                let num = self.to_polynomial(field, var_map)?;
-                let den = vec![(num.one(), 1)];
-                Ok(FactorizedRationalPolynomial::from_num_den(
-                    num, den, out_field, false,
-                ))
-            }
-            AtomView::Pow(p) => {
-                let (base, exp) = p.get_base_exp();
-                if let AtomView::Num(n) = exp {
-                    let num_n = n.get_coeff_view();
-
-                    if let CoefficientView::Natural(nn, nd) = num_n {
-                        if nd != 1 {
-                            Err("Exponent cannot be a fraction")?
-                        }
-
-                        if nn != -1 {
-                            let mut h = workspace.new_atom();
-                            if !self.expand_with_ws_into(workspace, &mut h) {
-                                // expansion did not change the input, so we are in a case of x^-3 or x^3
-                                let r = base.to_factorized_rational_polynomial_with_ws(
-                                    workspace, field, out_field, var_map,
-                                )?;
-
-                                if nn < 0 {
-                                    let r_inv = r.inv();
-                                    Ok(r_inv.pow(-nn as u64))
-                                } else {
-                                    Ok(r.pow(nn as u64))
-                                }
-                            } else {
-                                h.as_view().to_factorized_rational_polynomial_with_ws(
-                                    workspace, field, out_field, var_map,
-                                )
-                            }
-                        } else if nn < 0 {
-                            let r = base.to_factorized_rational_polynomial_with_ws(
-                                workspace, field, out_field, var_map,
-                            )?;
-                            Ok(r.inv())
-                        } else {
-                            base.to_factorized_rational_polynomial_with_ws(
-                                workspace, field, out_field, var_map,
-                            )
-                        }
-                    } else {
-                        Err("Exponent needs to be an integer")?
-                    }
-                } else {
-                    Err("Power needs to be a number")?
-                }
-            }
-            AtomView::Fun(_) => Err("Functions not allowed")?,
-            AtomView::Mul(m) => {
-                let mut r = FactorizedRationalPolynomial::new(out_field, var_map.cloned());
-                r.numerator = r.numerator.add_monomial(out_field.one());
-                r.numer_coeff = out_field.one();
-                for arg in m.iter() {
-                    let mut arg_r = arg.to_factorized_rational_polynomial_with_ws(
-                        workspace, field, out_field, var_map,
-                    )?;
-                    r.unify_var_map(&mut arg_r);
-                    r = &r * &arg_r;
-                }
-                Ok(r)
-            }
-            AtomView::Add(a) => {
-                let mut r = FactorizedRationalPolynomial::new(out_field, var_map.cloned());
-                for arg in a.iter() {
-                    let mut arg_r = arg.to_factorized_rational_polynomial_with_ws(
-                        workspace, field, out_field, var_map,
-                    )?;
-                    r.unify_var_map(&mut arg_r);
-                    r = &r + &arg_r;
-                }
-                Ok(r)
-            }
-        }
+        var_map: Option<Arc<Vec<Variable>>>,
+    ) -> MultivariatePolynomial<R, E> {
+        self.to_polynomial_impl(field, var_map.as_ref().unwrap_or(&Arc::new(Vec::new())))
     }
 
-    /// Convert an expression to a polynomial, creating new temporary variables for
-    /// all non-polynomial subexpressions. These are stored in `map`.
-    pub fn to_polynomial_with_map<R: EuclideanDomain + ConvertToRing, E: Exponent>(
+    pub fn to_polynomial_impl<R: EuclideanDomain + ConvertToRing, E: Exponent>(
         &self,
         field: &R,
-        map: &mut HashMap<AtomView<'a>, Variable>,
+        var_map: &Arc<Vec<Variable>>,
     ) -> MultivariatePolynomial<R, E> {
         // see if the current term can be cast into a polynomial using a fast routine
-        if let Ok(num) = self.to_polynomial(field, None) {
+        if let Ok(num) = self.to_polynomial_expanded(field, Some(var_map), true) {
             return num;
         }
 
         match self {
             AtomView::Num(_) | AtomView::Var(_) => {
-                // done by simple routine above
-                unreachable!()
+                unreachable!("This case should have been handled by the fast routine")
             }
             AtomView::Pow(p) => {
                 // the case var^exp is already treated, so this must be a case that requires a map
                 // check if the exponent is a positive integer, if so the base must be mapped
                 // otherwise, map the entire power
 
                 // TODO: make sure that this coefficient does not depend on any of the variables in var_map
 
                 let (base, exp) = p.get_base_exp();
 
                 if let AtomView::Num(n) = exp {
                     let num_n = n.get_coeff_view();
                     if let CoefficientView::Natural(nn, nd) = num_n {
                         if nd == 1 && nn > 0 && nn < u32::MAX as i64 {
-                            let id = if let Some(x) = map.get(&base) {
-                                x.clone()
-                            } else {
-                                let new_id = Variable::Temporary(map.len());
-                                map.insert(base, new_id.clone());
-                                new_id
-                            };
-
-                            // generate id^pow
-                            let mut r = MultivariatePolynomial::new(
-                                1,
-                                field,
-                                None,
-                                Some(Arc::new(vec![id])),
-                            );
-                            r.append_monomial(field.one(), &[E::from_u32(nn as u32)]);
-                            return r;
+                            return base.to_polynomial_impl(field, var_map).pow(nn as usize);
                         }
                     }
                 }
 
-                let id = if let Some(x) = map.get(self) {
-                    x.clone()
+                // check if we have seen this variable before
+                if let Some(id) = var_map.iter().position(|v| match v {
+                    Variable::Other(vv) => vv.as_view() == *self,
+                    _ => false,
+                }) {
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[id] = E::one();
+                    MultivariatePolynomial::new(field, None, var_map.clone())
+                        .monomial(field.one(), exp)
                 } else {
-                    let new_id = Variable::Temporary(map.len());
-                    map.insert(*self, new_id.clone());
-                    new_id
-                };
+                    let mut var_map = var_map.as_ref().clone();
+                    var_map.push(Variable::Other(Arc::new(self.to_owned())));
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[var_map.len() - 1] = E::one();
 
-                let mut r = MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                r.append_monomial(field.one(), &[E::one()]);
-                r
+                    MultivariatePolynomial::new(field, None, Arc::new(var_map))
+                        .monomial(field.one(), exp)
+                }
             }
             AtomView::Fun(f) => {
                 // TODO: make sure that this coefficient does not depend on any of the variables in var_map
 
-                // check if the argument consists of a single positive integer. If so, treat the function as an array
-                if f.get_nargs() == 1 {
-                    let arg = f.iter().next().unwrap();
-
-                    if let AtomView::Num(n) = arg {
-                        if let CoefficientView::Natural(n, 1) = n.get_coeff_view() {
-                            if n >= 0 {
-                                let id = Variable::Array(f.get_symbol(), n as usize);
-                                let mut r = MultivariatePolynomial::new(
-                                    1,
-                                    field,
-                                    None,
-                                    Some(Arc::new(vec![id])),
-                                );
-                                r.append_monomial(field.one(), &[E::one()]);
-                                return r;
-                            }
-                        }
-                    }
-                }
-
-                let id = if let Some(x) = map.get(self) {
-                    x.clone()
+                // check if we have seen this variable before
+                if let Some(id) = var_map.iter().position(|v| match v {
+                    Variable::Function(_, vv) => vv.as_view() == *self,
+                    _ => false,
+                }) {
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[id] = E::one();
+                    MultivariatePolynomial::new(field, None, var_map.clone())
+                        .monomial(field.one(), exp)
                 } else {
-                    let new_id = Variable::Temporary(map.len());
-                    map.insert(*self, new_id.clone());
-                    new_id
-                };
+                    let mut var_map = var_map.as_ref().clone();
+                    var_map.push(Variable::Function(
+                        f.get_symbol(),
+                        Arc::new(self.to_owned()),
+                    ));
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[var_map.len() - 1] = E::one();
 
-                let mut r = MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                r.append_monomial(field.one(), &[E::one()]);
-                r
+                    MultivariatePolynomial::new(field, None, Arc::new(var_map))
+                        .monomial(field.one(), exp)
+                }
             }
             AtomView::Mul(m) => {
-                let mut r = MultivariatePolynomial::new(0, field, None, None);
-                r = r.add_monomial(field.one());
+                let mut r =
+                    MultivariatePolynomial::new(field, None, var_map.clone()).constant(field.one());
                 for arg in m.iter() {
-                    let mut arg_r = arg.to_polynomial_with_map(field, map);
-                    r.unify_var_map(&mut arg_r);
+                    let mut arg_r = arg.to_polynomial_impl(field, &r.variables);
+                    r.unify_variables(&mut arg_r);
                     r = &r * &arg_r;
                 }
                 r
             }
             AtomView::Add(a) => {
-                let mut r = MultivariatePolynomial::new(0, field, None, None);
+                let mut r = MultivariatePolynomial::new(field, None, var_map.clone());
                 for arg in a.iter() {
-                    let mut arg_r = arg.to_polynomial_with_map(field, map);
-                    r.unify_var_map(&mut arg_r);
+                    let mut arg_r = arg.to_polynomial_impl(field, &r.variables);
+                    r.unify_variables(&mut arg_r);
                     r = &r + &arg_r;
                 }
                 r
             }
         }
     }
 
-    /// Convert an expression to a polynomial, converting all  non-polynomial subexpressions as independent variables.
-    pub fn to_polynomial_with_conversion<R: EuclideanDomain + ConvertToRing, E: Exponent>(
+    /// Convert the atom to a rational polynomial, optionally in the variable ordering
+    /// specified by `var_map`. If new variables are encountered, they are
+    /// added to the variable map. Similarly, non-rational polynomial parts are automatically
+    /// defined as a new independent variable in the rational polynomial.
+    pub fn to_rational_polynomial<
+        R: EuclideanDomain + ConvertToRing,
+        RO: EuclideanDomain + PolynomialGCD<E>,
+        E: Exponent,
+    >(
         &self,
         field: &R,
-    ) -> MultivariatePolynomial<R, E> {
-        // see if the current term can be cast into a polynomial using a fast routine
-        if let Ok(num) = self.to_polynomial(field, None) {
-            return num;
-        }
-
-        match self {
-            AtomView::Num(_) | AtomView::Var(_) => {
-                // done by simple routine above
-                unreachable!()
-            }
-            AtomView::Pow(p) => {
-                // the case var^exp is already treated, so this must be a case that requires a map
-                // check if the exponent is a positive integer, if so the base must be mapped
-                // otherwise, map the entire power
-
-                // TODO: make sure that this coefficient does not depend on any of the variables in var_map
-
-                let (base, exp) = p.get_base_exp();
-
-                if let AtomView::Num(n) = exp {
-                    let num_n = n.get_coeff_view();
-                    if let CoefficientView::Natural(nn, nd) = num_n {
-                        if nd == 1 && nn > 0 && nn < u32::MAX as i64 {
-                            return base.to_polynomial_with_conversion(field).pow(nn as usize);
-                        }
-                    }
-                }
-
-                let id = Variable::Other(Arc::new(self.to_owned()));
-
-                let mut r = MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                r.append_monomial(field.one(), &[E::one()]);
-                r
-            }
-            AtomView::Fun(f) => {
-                // TODO: make sure that this coefficient does not depend on any of the variables in var_map
-
-                // check if the argument consists of a single positive integer. If so, treat the function as an array
-                if f.get_nargs() == 1 {
-                    let arg = f.iter().next().unwrap();
-
-                    if let AtomView::Num(n) = arg {
-                        if let CoefficientView::Natural(n, 1) = n.get_coeff_view() {
-                            if n >= 0 {
-                                let id = Variable::Array(f.get_symbol(), n as usize);
-                                let mut r = MultivariatePolynomial::new(
-                                    1,
-                                    field,
-                                    None,
-                                    Some(Arc::new(vec![id])),
-                                );
-                                r.append_monomial(field.one(), &[E::one()]);
-                                return r;
-                            }
-                        }
-                    }
-                }
-
-                let id = Variable::Function(f.get_symbol(), Arc::new(self.to_owned()));
-
-                let mut r = MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                r.append_monomial(field.one(), &[E::one()]);
-                r
-            }
-            AtomView::Mul(m) => {
-                let mut r = MultivariatePolynomial::new(0, field, None, None);
-                r = r.add_monomial(field.one());
-                for arg in m.iter() {
-                    let mut arg_r = arg.to_polynomial_with_conversion(field);
-                    r.unify_var_map(&mut arg_r);
-                    r = &r * &arg_r;
-                }
-                r
-            }
-            AtomView::Add(a) => {
-                let mut r = MultivariatePolynomial::new(0, field, None, None);
-                for arg in a.iter() {
-                    let mut arg_r = arg.to_polynomial_with_conversion(field);
-                    r.unify_var_map(&mut arg_r);
-                    r = &r + &arg_r;
-                }
-                r
-            }
-        }
+        out_field: &RO,
+        var_map: Option<Arc<Vec<Variable>>>,
+    ) -> RationalPolynomial<RO, E>
+    where
+        RationalPolynomial<RO, E>:
+            FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
+    {
+        Workspace::get_local().with(|ws| {
+            self.to_rational_polynomial_impl(
+                ws,
+                field,
+                out_field,
+                var_map.as_ref().unwrap_or(&Arc::new(Vec::new())),
+            )
+        })
     }
 
-    /// Convert an expression to a rational polynomial, creating new temporary variables for
-    /// all non-rational subexpressions. These are stored in `map`.
-    pub(crate) fn to_rational_polynomial_with_map<
+    fn to_rational_polynomial_impl<
         R: EuclideanDomain + ConvertToRing,
         RO: EuclideanDomain + PolynomialGCD<E>,
         E: Exponent,
     >(
         &self,
         workspace: &Workspace,
         field: &R,
         out_field: &RO,
-        map: &mut HashMap<RecycledAtom, Variable>,
+        var_map: &Arc<Vec<Variable>>,
     ) -> RationalPolynomial<RO, E>
     where
         RationalPolynomial<RO, E>:
             FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
     {
         // see if the current term can be cast into a polynomial using a fast routine
-        if let Ok(num) = self.to_polynomial(field, None) {
+        if let Ok(num) = self.to_polynomial_expanded(field, Some(var_map), true) {
             let den = num.one();
             return RationalPolynomial::from_num_den(num, den, out_field, false);
         }
 
         match self {
             AtomView::Num(_) | AtomView::Var(_) => {
-                // should be covered by the easy check
-                unreachable!()
+                unreachable!("This case should have been handled by the fast routine")
             }
             AtomView::Pow(p) => {
                 let (base, exp) = p.get_base_exp();
                 if let AtomView::Num(n) = exp {
                     let num_n = n.get_coeff_view();
 
                     if let CoefficientView::Natural(nn, nd) = num_n {
-                        if nd != 1 {
-                            // convert base^(1/nd) to a new variable
-                            let mut pow_h = workspace.new_atom();
-                            pow_h.to_pow(
-                                base,
-                                workspace
-                                    .new_num(Coefficient::Rational((1, nd).into()))
-                                    .as_view(),
-                            );
-
-                            let id = if let Some(x) = map.get(&pow_h) {
-                                x.clone()
+                        if nd == 1 {
+                            let b = base
+                                .to_rational_polynomial_impl(workspace, field, out_field, var_map);
+
+                            return if nn < 0 {
+                                let b_inv = b.inv();
+                                b_inv.pow(-nn as u64)
                             } else {
-                                let new_id = Variable::Temporary(map.len());
-                                map.insert(pow_h, new_id.clone());
-                                new_id
+                                b.pow(nn as u64)
                             };
-
-                            let mut p = MultivariatePolynomial::new(
-                                1,
-                                field,
-                                None,
-                                Some(Arc::new(vec![id])),
-                            );
-                            p.append_monomial(
-                                field.one(),
-                                &[E::from_u32(nn.unsigned_abs() as u32)],
-                            );
-                            let den = p.one();
-                            let r = RationalPolynomial::from_num_den(p, den, out_field, false);
-
-                            if nn < 0 {
-                                r.inv()
-                            } else {
-                                r
-                            }
-                        } else if nn != -1 {
-                            let mut h = workspace.new_atom();
-                            if !self.expand_with_ws_into(workspace, &mut h) {
-                                // expansion did not change the input, so we are in a case of x^-3 or x^3
-                                let r = base.to_rational_polynomial_with_map(
-                                    workspace, field, out_field, map,
-                                );
-
-                                if nn < 0 {
-                                    let r_inv = r.inv();
-                                    r_inv.pow(-nn as u64)
-                                } else {
-                                    r.pow(nn as u64)
-                                }
-                            } else {
-                                h.as_view().to_rational_polynomial_with_map(
-                                    workspace, field, out_field, map,
-                                )
-                            }
-                        } else if nn < 0 {
-                            let r = base
-                                .to_rational_polynomial_with_map(workspace, field, out_field, map);
-                            r.inv()
-                        } else {
-                            base.to_rational_polynomial_with_map(workspace, field, out_field, map)
                         }
-                    } else {
-                        // non-integer exponent, convert to new variable
-                        let mut a = workspace.new_atom();
-                        a.set_from_view(self);
-                        let id = if let Some(x) = map.get(&a) {
-                            x.clone()
-                        } else {
-                            let new_id = Variable::Temporary(map.len());
-                            map.insert(a, new_id.clone());
-                            new_id
-                        };
-
-                        let mut r =
-                            MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                        r.append_monomial(field.one(), &[E::one()]);
-                        let den = r.one();
-                        RationalPolynomial::from_num_den(r, den, out_field, false)
                     }
+                }
+
+                // non-integer exponent, convert to new variable
+                if let Some(id) = var_map.iter().position(|v| match v {
+                    Variable::Other(vv) => vv.as_view() == *self,
+                    _ => false,
+                }) {
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[id] = E::one();
+                    let r = MultivariatePolynomial::new(field, None, var_map.clone())
+                        .monomial(field.one(), exp);
+                    let den = r.one();
+                    RationalPolynomial::from_num_den(r, den, out_field, false)
                 } else {
-                    // non-number exponent, convert to new variable
-                    let mut a = workspace.new_atom();
-                    a.set_from_view(self);
-                    let id = if let Some(x) = map.get(&a) {
-                        x.clone()
-                    } else {
-                        let new_id = Variable::Temporary(map.len());
-                        map.insert(a, new_id.clone());
-                        new_id
-                    };
+                    let mut var_map = var_map.as_ref().clone();
+                    var_map.push(Variable::Other(Arc::new(self.to_owned())));
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[var_map.len() - 1] = E::one();
 
-                    let mut r =
-                        MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                    r.append_monomial(field.one(), &[E::one()]);
+                    let r = MultivariatePolynomial::new(field, None, Arc::new(var_map))
+                        .monomial(field.one(), exp);
                     let den = r.one();
                     RationalPolynomial::from_num_den(r, den, out_field, false)
                 }
             }
-            AtomView::Fun(_) => {
-                let mut a = workspace.new_atom();
-                a.set_from_view(self);
-                let id = if let Some(x) = map.get(&a) {
-                    x.clone()
+            AtomView::Fun(f) => {
+                // check if we have seen this variable before
+                if let Some(id) = var_map.iter().position(|v| match v {
+                    Variable::Function(_, vv) => vv.as_view() == *self,
+                    _ => false,
+                }) {
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[id] = E::one();
+                    let r = MultivariatePolynomial::new(field, None, var_map.clone())
+                        .monomial(field.one(), exp);
+                    let den = r.one();
+                    RationalPolynomial::from_num_den(r, den, out_field, false)
                 } else {
-                    let new_id = Variable::Temporary(map.len());
-                    map.insert(a, new_id.clone());
-                    new_id
-                };
-
-                let mut r = MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                r.append_monomial(field.one(), &[E::one()]);
-                let den = r.one();
-                RationalPolynomial::from_num_den(r, den, out_field, false)
+                    let mut var_map = var_map.as_ref().clone();
+                    var_map.push(Variable::Function(
+                        f.get_symbol(),
+                        Arc::new(self.to_owned()),
+                    ));
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[var_map.len() - 1] = E::one();
+
+                    let r = MultivariatePolynomial::new(field, None, Arc::new(var_map))
+                        .monomial(field.one(), exp);
+
+                    let den = r.one();
+                    RationalPolynomial::from_num_den(r, den, out_field, false)
+                }
             }
             AtomView::Mul(m) => {
-                let mut r = RationalPolynomial::new(out_field, None);
-                r.numerator = r.numerator.add_monomial(out_field.one());
+                let mut r = RationalPolynomial::new(out_field, var_map.clone());
+                r.numerator = r.numerator.add_constant(out_field.one());
                 for arg in m.iter() {
-                    let mut arg_r =
-                        arg.to_rational_polynomial_with_map(workspace, field, out_field, map);
-                    r.unify_var_map(&mut arg_r);
+                    let mut arg_r = arg.to_rational_polynomial_impl(
+                        workspace,
+                        field,
+                        out_field,
+                        &r.numerator.variables,
+                    );
+                    r.unify_variables(&mut arg_r);
                     r = &r * &arg_r;
                 }
                 r
             }
             AtomView::Add(a) => {
-                let mut r = RationalPolynomial::new(out_field, None);
+                let mut r = RationalPolynomial::new(out_field, var_map.clone());
                 for arg in a.iter() {
-                    let mut arg_r =
-                        arg.to_rational_polynomial_with_map(workspace, field, out_field, map);
-                    r.unify_var_map(&mut arg_r);
+                    let mut arg_r = arg.to_rational_polynomial_impl(
+                        workspace,
+                        field,
+                        out_field,
+                        &r.numerator.variables,
+                    );
+                    r.unify_variables(&mut arg_r);
                     r = &r + &arg_r;
                 }
                 r
             }
         }
     }
 
-    pub fn to_rational_polynomial_with_conversion<
+    /// Convert the atom to a rational polynomial with factorized denominators, optionally in the variable ordering
+    /// specified by `var_map`. If new variables are encountered, they are
+    /// added to the variable map. Similarly, non-rational polynomial parts are automatically
+    /// defined as a new independent variable in the rational polynomial.
+    pub fn to_factorized_rational_polynomial<
         R: EuclideanDomain + ConvertToRing,
         RO: EuclideanDomain + PolynomialGCD<E>,
         E: Exponent,
     >(
         &self,
         field: &R,
         out_field: &RO,
-    ) -> RationalPolynomial<RO, E>
+        var_map: Option<Arc<Vec<Variable>>>,
+    ) -> FactorizedRationalPolynomial<RO, E>
     where
-        RationalPolynomial<RO, E>:
-            FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
+        FactorizedRationalPolynomial<RO, E>: FromNumeratorAndFactorizedDenominator<R, RO, E>
+            + FromNumeratorAndFactorizedDenominator<RO, RO, E>,
+        MultivariatePolynomial<RO, E>: Factorize,
     {
-        Workspace::get_local()
-            .with(|ws| self.to_rational_polynomial_with_conversion_impl(&ws, field, out_field))
+        Workspace::get_local().with(|ws| {
+            self.to_factorized_rational_polynomial_impl(
+                ws,
+                field,
+                out_field,
+                var_map.as_ref().unwrap_or(&Arc::new(Vec::new())),
+            )
+        })
     }
 
-    /// Convert an expression to a rational polynomial, converting all non-rational subexpressions
-    /// to independent variables.
-    fn to_rational_polynomial_with_conversion_impl<
+    pub fn to_factorized_rational_polynomial_impl<
         R: EuclideanDomain + ConvertToRing,
         RO: EuclideanDomain + PolynomialGCD<E>,
         E: Exponent,
     >(
         &self,
         workspace: &Workspace,
         field: &R,
         out_field: &RO,
-    ) -> RationalPolynomial<RO, E>
+        var_map: &Arc<Vec<Variable>>,
+    ) -> FactorizedRationalPolynomial<RO, E>
     where
-        RationalPolynomial<RO, E>:
-            FromNumeratorAndDenominator<R, RO, E> + FromNumeratorAndDenominator<RO, RO, E>,
+        FactorizedRationalPolynomial<RO, E>: FromNumeratorAndFactorizedDenominator<R, RO, E>
+            + FromNumeratorAndFactorizedDenominator<RO, RO, E>,
+        MultivariatePolynomial<RO, E>: Factorize,
     {
         // see if the current term can be cast into a polynomial using a fast routine
-        if let Ok(num) = self.to_polynomial(field, None) {
-            let den = num.one();
-            return RationalPolynomial::from_num_den(num, den, out_field, false);
+        if let Ok(num) = self.to_polynomial_expanded(field, Some(var_map), true) {
+            let den = vec![(num.one(), 1)];
+            return FactorizedRationalPolynomial::from_num_den(num, den, out_field, false);
         }
 
         match self {
             AtomView::Num(_) | AtomView::Var(_) => {
-                // should be covered by the easy check
-                unreachable!()
+                unreachable!("This case should have been handled by the fast routine")
             }
             AtomView::Pow(p) => {
                 let (base, exp) = p.get_base_exp();
                 if let AtomView::Num(n) = exp {
                     let num_n = n.get_coeff_view();
 
                     if let CoefficientView::Natural(nn, nd) = num_n {
-                        if nd != 1 {
-                            // convert base^(1/nd) to a new variable
-                            let mut pow_h = workspace.new_atom();
-                            pow_h.to_pow(
-                                base,
-                                workspace
-                                    .new_num(Coefficient::Rational((1, nd).into()))
-                                    .as_view(),
-                            );
-
-                            let id = Variable::Other(Arc::new(pow_h.as_view().to_owned()));
-
-                            let mut p = MultivariatePolynomial::new(
-                                1,
-                                field,
-                                None,
-                                Some(Arc::new(vec![id])),
-                            );
-                            p.append_monomial(
-                                field.one(),
-                                &[E::from_u32(nn.unsigned_abs() as u32)],
+                        if nd == 1 {
+                            let b = base.to_factorized_rational_polynomial_impl(
+                                workspace, field, out_field, var_map,
                             );
 
-                            let den = p.one();
-                            let r = RationalPolynomial::from_num_den(p, den, out_field, false);
-
-                            if nn < 0 {
-                                r.inv()
-                            } else {
-                                r
-                            }
-                        } else if nn != -1 {
-                            let mut h = workspace.new_atom();
-                            if !self.expand_with_ws_into(workspace, &mut h) {
-                                // expansion did not change the input, so we are in a case of x^-3 or x^3
-                                let r = base.to_rational_polynomial_with_conversion_impl(
-                                    workspace, field, out_field,
-                                );
-
-                                if nn < 0 {
-                                    let r_inv = r.inv();
-                                    r_inv.pow(-nn as u64)
-                                } else {
-                                    r.pow(nn as u64)
-                                }
+                            return if nn < 0 {
+                                let b_inv = b.inv();
+                                b_inv.pow(-nn as u64)
                             } else {
-                                h.as_view().to_rational_polynomial_with_conversion_impl(
-                                    workspace, field, out_field,
-                                )
-                            }
-                        } else if nn < 0 {
-                            let r = base.to_rational_polynomial_with_conversion_impl(
-                                workspace, field, out_field,
-                            );
-                            r.inv()
-                        } else {
-                            base.to_rational_polynomial_with_conversion_impl(
-                                workspace, field, out_field,
-                            )
+                                b.pow(nn as u64)
+                            };
                         }
-                    } else {
-                        // non-integer exponent, convert to new variable
-                        let id = Variable::Other(Arc::new(self.to_owned()));
-
-                        let mut r =
-                            MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                        r.append_monomial(field.one(), &[E::one()]);
-                        let den = r.one();
-                        RationalPolynomial::from_num_den(r, den, out_field, false)
                     }
-                } else {
-                    // non-number exponent, convert to new variable
-                    let id = Variable::Other(Arc::new(self.to_owned()));
+                }
 
-                    let mut r =
-                        MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                    r.append_monomial(field.one(), &[E::one()]);
-                    let den = r.one();
-                    RationalPolynomial::from_num_den(r, den, out_field, false)
+                // non-integer exponent, convert to new variable
+                if let Some(id) = var_map.iter().position(|v| match v {
+                    Variable::Other(vv) => vv.as_view() == *self,
+                    _ => false,
+                }) {
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[id] = E::one();
+                    let r = MultivariatePolynomial::new(field, None, var_map.clone())
+                        .monomial(field.one(), exp);
+                    FactorizedRationalPolynomial::from_num_den(r, vec![], out_field, false)
+                } else {
+                    let mut var_map = var_map.as_ref().clone();
+                    var_map.push(Variable::Other(Arc::new(self.to_owned())));
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[var_map.len() - 1] = E::one();
+
+                    let r = MultivariatePolynomial::new(field, None, Arc::new(var_map))
+                        .monomial(field.one(), exp);
+                    FactorizedRationalPolynomial::from_num_den(r, vec![], out_field, false)
                 }
             }
             AtomView::Fun(f) => {
-                let id = Variable::Function(f.get_symbol(), Arc::new(self.to_owned()));
+                // check if we have seen this variable before
+                if let Some(id) = var_map.iter().position(|v| match v {
+                    Variable::Function(_, vv) => vv.as_view() == *self,
+                    _ => false,
+                }) {
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[id] = E::one();
+                    let r = MultivariatePolynomial::new(field, None, var_map.clone())
+                        .monomial(field.one(), exp);
+                    FactorizedRationalPolynomial::from_num_den(r, vec![], out_field, false)
+                } else {
+                    let mut var_map = var_map.as_ref().clone();
+                    var_map.push(Variable::Function(
+                        f.get_symbol(),
+                        Arc::new(self.to_owned()),
+                    ));
+                    let mut exp = vec![E::zero(); var_map.len()];
+                    exp[var_map.len() - 1] = E::one();
 
-                let mut r = MultivariatePolynomial::new(1, field, None, Some(Arc::new(vec![id])));
-                r.append_monomial(field.one(), &[E::one()]);
-                let den = r.one();
-                RationalPolynomial::from_num_den(r, den, out_field, false)
+                    let r = MultivariatePolynomial::new(field, None, Arc::new(var_map))
+                        .monomial(field.one(), exp);
+                    FactorizedRationalPolynomial::from_num_den(r, vec![], out_field, false)
+                }
             }
             AtomView::Mul(m) => {
-                let mut r = RationalPolynomial::new(out_field, None);
-                r.numerator = r.numerator.add_monomial(out_field.one());
+                let mut r = FactorizedRationalPolynomial::new(out_field, var_map.clone());
+                r.numerator = r.numerator.add_constant(out_field.one());
+                r.numer_coeff = out_field.one();
                 for arg in m.iter() {
-                    let mut arg_r = arg
-                        .to_rational_polynomial_with_conversion_impl(workspace, field, out_field);
-                    r.unify_var_map(&mut arg_r);
+                    let mut arg_r = arg.to_factorized_rational_polynomial_impl(
+                        workspace,
+                        field,
+                        out_field,
+                        &r.numerator.variables,
+                    );
+                    r.unify_variables(&mut arg_r);
                     r = &r * &arg_r;
                 }
                 r
             }
             AtomView::Add(a) => {
-                let mut r = RationalPolynomial::new(out_field, None);
+                let mut r = FactorizedRationalPolynomial::new(out_field, var_map.clone());
                 for arg in a.iter() {
-                    let mut arg_r = arg
-                        .to_rational_polynomial_with_conversion_impl(workspace, field, out_field);
-                    r.unify_var_map(&mut arg_r);
+                    let mut arg_r = arg.to_factorized_rational_polynomial_impl(
+                        workspace,
+                        field,
+                        out_field,
+                        &r.numerator.variables,
+                    );
+                    r.unify_variables(&mut arg_r);
                     r = &r + &arg_r;
                 }
                 r
             }
         }
     }
 }
@@ -1413,19 +1123,14 @@
         &self,
         workspace: &Workspace,
         map: &HashMap<Variable, AtomView>,
         out: &mut Atom,
     ) where
         R::Element: Into<Coefficient>,
     {
-        let var_map = self
-            .var_map
-            .as_ref()
-            .expect("No variable map present in polynomial");
-
         if self.is_zero() {
             out.set_from_view(&workspace.new_num(0).as_view());
             return;
         }
 
         let add = out.to_add();
 
@@ -1433,28 +1138,24 @@
         let mut var_h = workspace.new_atom();
         let mut num_h = workspace.new_atom();
         let mut pow_h = workspace.new_atom();
 
         for monomial in self {
             let mul = mul_h.to_mul();
 
-            for (var_id, &pow) in var_map.iter().zip(monomial.exponents) {
+            for (var_id, &pow) in self.variables.iter().zip(monomial.exponents) {
                 if pow > E::zero() {
                     match var_id {
                         Variable::Symbol(v) => {
                             var_h.to_var(*v);
                         }
                         Variable::Temporary(_) => {
                             let a = map.get(var_id).expect("Variable missing from map");
                             var_h.set_from_view(a);
                         }
-                        Variable::Array(n, i) => {
-                            let fun = var_h.to_fun(*n);
-                            fun.add_arg(workspace.new_num(*i as i64).as_view());
-                        }
                         Variable::Function(_, a) | Variable::Other(a) => {
                             var_h.set_from_view(&a.as_view());
                         }
                     }
 
                     if pow > E::one() {
                         num_h.to_num((pow.to_u32() as i64).into());
@@ -1649,46 +1350,37 @@
 
             poly.append_monomial(coefficient, &exponents);
             Ok(())
         }
 
         match self {
             Token::Op(_, _, Operator::Add, args) => {
-                let mut poly = MultivariatePolynomial::<R, E>::new(
-                    var_map.len(),
-                    field,
-                    Some(args.len()),
-                    Some(var_map.clone()),
-                );
+                let mut poly =
+                    MultivariatePolynomial::<R, E>::new(field, Some(args.len()), var_map.clone());
 
                 for term in args {
                     parse_term(term, var_name_map, &mut poly, field)?;
                 }
                 Ok(poly)
             }
             _ => {
-                let mut poly = MultivariatePolynomial::<R, E>::new(
-                    var_map.len(),
-                    field,
-                    Some(1),
-                    Some(var_map.clone()),
-                );
+                let mut poly = MultivariatePolynomial::<R, E>::new(field, Some(1), var_map.clone());
                 parse_term(self, var_name_map, &mut poly, field)?;
                 Ok(poly)
             }
         }
     }
 
     /// Convert a parsed expression to a rational polynomial if possible,
     /// skipping the conversion to a Symbolica expression. This method
     /// is faster if the parsed expression is already in the same format
     /// i.e. the ordering is the same
     pub fn to_rational_polynomial<
         R: EuclideanDomain + ConvertToRing,
-        RO: EuclideanDomain + PolynomialGCD<E>,
+        RO: EuclideanDomain + ConvertToRing + PolynomialGCD<E>,
         E: Exponent,
     >(
         &self,
         field: &R,
         out_field: &RO,
         var_map: &Arc<Vec<Variable>>,
         var_name_map: &[SmartString<LazyCompact>],
@@ -1740,65 +1432,63 @@
                     let r =
                         args[0].to_rational_polynomial(field, out_field, var_map, var_name_map)?;
                     Ok(r.inv())
                 } else {
                     Workspace::get_local().with(|ws| {
                         let mut atom = ws.new_atom();
                         self.to_atom_with_output_and_var_map(ws, var_map, var_name_map, &mut atom)?;
-                        atom.as_view().to_rational_polynomial_with_ws(
-                            ws,
-                            field,
-                            out_field,
-                            Some(var_map),
-                        )
+                        Ok(atom
+                            .as_view()
+                            .to_rational_polynomial_impl(ws, field, out_field, var_map))
                     })
                 }
             }
             Token::Op(_, _, Operator::Mul, args) => {
-                let mut r = RationalPolynomial::new(out_field, Some(var_map.clone()));
-                r.numerator = r.numerator.add_monomial(out_field.one());
+                let mut r = RationalPolynomial::new(out_field, var_map.clone());
+                r.numerator = r.numerator.add_constant(out_field.one());
                 for arg in args {
                     let mut arg_r =
                         arg.to_rational_polynomial(field, out_field, var_map, var_name_map)?;
-                    r.unify_var_map(&mut arg_r);
+                    r.unify_variables(&mut arg_r);
                     r = &r * &arg_r;
                 }
                 Ok(r)
             }
             Token::Op(_, _, Operator::Add, args) => {
-                let mut r = RationalPolynomial::new(out_field, Some(var_map.clone()));
+                let mut r = RationalPolynomial::new(out_field, var_map.clone());
                 for arg in args {
                     let mut arg_r =
                         arg.to_rational_polynomial(field, out_field, var_map, var_name_map)?;
-                    r.unify_var_map(&mut arg_r);
+                    r.unify_variables(&mut arg_r);
                     r = &r + &arg_r;
                 }
                 Ok(r)
             }
             Token::Op(_, _, Operator::Neg, args) => {
                 let r = args[0].to_rational_polynomial(field, out_field, var_map, var_name_map)?;
 
                 Ok(r.neg())
             }
             _ => Workspace::get_local().with(|ws| {
                 let mut atom = ws.new_atom();
                 self.to_atom_with_output_and_var_map(ws, var_map, var_name_map, &mut atom)?;
-                atom.as_view()
-                    .to_rational_polynomial_with_ws(ws, field, out_field, Some(var_map))
+                Ok(atom
+                    .as_view()
+                    .to_rational_polynomial_impl(ws, field, out_field, var_map))
             }),
         }
     }
 
     /// Convert a parsed expression to a rational polynomial if possible,
     /// skipping the conversion to a Symbolica expression. This method
     /// is faster if the parsed expression is already in the same format
     /// i.e. the ordering is the same
     pub fn to_factorized_rational_polynomial<
         R: EuclideanDomain + ConvertToRing,
-        RO: EuclideanDomain + PolynomialGCD<E>,
+        RO: EuclideanDomain + ConvertToRing + PolynomialGCD<E>,
         E: Exponent,
     >(
         &self,
         field: &R,
         out_field: &RO,
         var_map: &Arc<Vec<Variable>>,
         var_name_map: &[SmartString<LazyCompact>],
@@ -1893,54 +1583,51 @@
                         var_name_map,
                     )?;
                     Ok(r.inv())
                 } else {
                     Workspace::get_local().with(|ws| {
                         let mut atom = ws.new_atom();
                         self.to_atom_with_output_and_var_map(ws, var_map, var_name_map, &mut atom)?;
-                        atom.as_view().to_factorized_rational_polynomial_with_ws(
-                            ws,
-                            field,
-                            out_field,
-                            Some(var_map),
-                        )
+                        Ok(atom
+                            .as_view()
+                            .to_factorized_rational_polynomial_impl(ws, field, out_field, var_map))
                     })
                 }
             }
             Token::Op(_, _, Operator::Mul, args) => {
-                let mut r = FactorizedRationalPolynomial::new(out_field, Some(var_map.clone()));
-                r.numerator = r.numerator.add_monomial(out_field.one());
+                let mut r = FactorizedRationalPolynomial::new(out_field, var_map.clone());
+                r.numerator = r.numerator.add_constant(out_field.one());
                 r.numer_coeff = out_field.one();
                 for arg in args {
                     if let Token::Op(_, _, Operator::Inv, inv_args) = arg {
                         debug_assert!(inv_args.len() == 1);
                         let mut arg_r = inv_args[0].to_factorized_rational_polynomial(
                             field,
                             out_field,
                             var_map,
                             var_name_map,
                         )?;
 
-                        r.unify_var_map(&mut arg_r);
+                        r.unify_variables(&mut arg_r);
                         r = &r / &arg_r;
                     } else {
                         let mut arg_r = arg.to_factorized_rational_polynomial(
                             field,
                             out_field,
                             var_map,
                             var_name_map,
                         )?;
-                        r.unify_var_map(&mut arg_r);
+                        r.unify_variables(&mut arg_r);
                         r = &r * &arg_r;
                     }
                 }
                 Ok(r)
             }
             Token::Op(_, _, Operator::Add, args) => {
-                let mut r = FactorizedRationalPolynomial::new(out_field, Some(var_map.clone()));
+                let mut r = FactorizedRationalPolynomial::new(out_field, var_map.clone());
 
                 // sort based on length, as this may improve performance
                 let mut polys: Vec<FactorizedRationalPolynomial<_, _>> = args
                     .iter()
                     .map(|arg| {
                         arg.to_factorized_rational_polynomial(
                             field,
@@ -1956,15 +1643,15 @@
                         + p.denominators
                             .iter()
                             .map(|(x, _)| x.nterms())
                             .sum::<usize>()
                 });
 
                 for mut p in polys {
-                    r.unify_var_map(&mut p);
+                    r.unify_variables(&mut p);
                     r = &r + &p;
                 }
                 Ok(r)
             }
             Token::Op(_, _, Operator::Neg, args) => {
                 let r = args[0].to_factorized_rational_polynomial(
                     field,
@@ -1974,17 +1661,14 @@
                 )?;
 
                 Ok(r.neg())
             }
             _ => Workspace::get_local().with(|ws| {
                 let mut atom = ws.new_atom();
                 self.to_atom_with_output_and_var_map(ws, var_map, var_name_map, &mut atom)?;
-                atom.as_view().to_factorized_rational_polynomial_with_ws(
-                    ws,
-                    field,
-                    out_field,
-                    Some(var_map),
-                )
+                Ok(atom
+                    .as_view()
+                    .to_factorized_rational_polynomial_impl(ws, field, out_field, var_map))
             }),
         }
     }
 }
```

### Comparing `symbolica-0.3.0/src/printer.rs` & `symbolica-0.4.0/src/printer.rs`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,30 @@
 use std::fmt::{self, Display, Write};
 
 use colored::Colorize;
 
 use crate::{
+    atom::{
+        representation::FunView, AddView, AtomView, MulView, NumView, PowView, Symbol, VarView,
+    },
     coefficient::CoefficientView,
     domains::{
         factorized_rational_polynomial::FactorizedRationalPolynomial,
         finite_field::FiniteFieldCore, rational_polynomial::RationalPolynomial, Ring, RingPrinter,
     },
     poly::{polynomial::MultivariatePolynomial, Exponent, MonomialOrder},
-    representations::{default::FunView, AddView, AtomView, MulView, NumView, PowView, VarView},
     state::State,
     tensors::matrix::Matrix,
 };
 
 #[derive(Debug, Copy, Clone)]
 pub struct PrintOptions {
     pub terms_on_new_line: bool,
     pub color_top_level_sum: bool,
-    pub color_builtin_functions: bool,
+    pub color_builtin_symbols: bool,
     pub print_finite_field: bool,
     pub symmetric_representation_for_finite_field: bool,
     pub explicit_rational_polynomial: bool,
     pub number_thousands_separator: Option<char>,
     pub multiplication_operator: char,
     pub square_brackets_for_function: bool,
     pub num_exp_as_superscript: bool,
@@ -31,15 +33,15 @@
 
 impl PrintOptions {
     /// Print the output in a Mathematica-readable format.
     pub fn mathematica() -> PrintOptions {
         Self {
             terms_on_new_line: false,
             color_top_level_sum: false,
-            color_builtin_functions: false,
+            color_builtin_symbols: false,
             print_finite_field: true,
             symmetric_representation_for_finite_field: false,
             explicit_rational_polynomial: false,
             number_thousands_separator: None,
             multiplication_operator: ' ',
             square_brackets_for_function: true,
             num_exp_as_superscript: false,
@@ -48,33 +50,50 @@
     }
 
     /// Print the output in a Latex input format.
     pub fn latex() -> PrintOptions {
         Self {
             terms_on_new_line: false,
             color_top_level_sum: false,
-            color_builtin_functions: false,
+            color_builtin_symbols: false,
             print_finite_field: true,
             symmetric_representation_for_finite_field: false,
             explicit_rational_polynomial: false,
             number_thousands_separator: None,
             multiplication_operator: ' ',
             square_brackets_for_function: false,
             num_exp_as_superscript: false,
             latex: true,
         }
     }
+
+    /// Print the output suitable for a file.
+    pub fn file() -> PrintOptions {
+        Self {
+            terms_on_new_line: false,
+            color_top_level_sum: false,
+            color_builtin_symbols: false,
+            print_finite_field: false,
+            symmetric_representation_for_finite_field: false,
+            explicit_rational_polynomial: false,
+            number_thousands_separator: None,
+            multiplication_operator: '*',
+            square_brackets_for_function: false,
+            num_exp_as_superscript: false,
+            latex: false,
+        }
+    }
 }
 
 impl Default for PrintOptions {
     fn default() -> Self {
         Self {
             terms_on_new_line: false,
             color_top_level_sum: true,
-            color_builtin_functions: true,
+            color_builtin_symbols: true,
             print_finite_field: true,
             symmetric_representation_for_finite_field: false,
             explicit_rational_polynomial: false,
             number_thousands_separator: None,
             multiplication_operator: '*',
             square_brackets_for_function: false,
             num_exp_as_superscript: false,
@@ -82,14 +101,15 @@
         }
     }
 }
 
 #[derive(Debug, Copy, Clone)]
 pub struct PrintState {
     pub level: usize,
+    pub top_level_add_child: bool,
     pub explicit_sign: bool,
     pub superscript: bool,
 }
 
 macro_rules! define_formatters {
     ($($a:ident),*) => {
         $(
@@ -137,21 +157,28 @@
     }
 }
 
 impl<'a> fmt::Display for AtomPrinter<'a> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         let print_state = PrintState {
             level: 0,
+            top_level_add_child: false,
             explicit_sign: false,
             superscript: false,
         };
         self.atom.fmt_output(f, &self.print_opts, print_state)
     }
 }
 
+impl std::fmt::Display for Symbol {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.write_str(State::get_name(*self))
+    }
+}
+
 impl<'a> AtomView<'a> {
     fn fmt_debug(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
         match self {
             AtomView::Num(n) => n.fmt_debug(fmt),
             AtomView::Var(v) => v.fmt_debug(fmt),
             AtomView::Fun(f) => f.fmt_debug(fmt),
             AtomView::Pow(p) => p.fmt_debug(fmt),
@@ -187,27 +214,35 @@
     fn fmt_output(
         &self,
         f: &mut fmt::Formatter,
         opts: &PrintOptions,
         print_state: PrintState,
     ) -> fmt::Result {
         if print_state.explicit_sign {
-            if print_state.level == 1 && opts.color_top_level_sum {
+            if print_state.top_level_add_child && opts.color_top_level_sum {
                 f.write_fmt(format_args!("{}", "+".yellow()))?;
             } else {
                 f.write_char('+')?;
             }
         }
 
         let id = self.get_symbol();
         let name = State::get_name(id);
-        if name.ends_with('_') {
-            f.write_fmt(format_args!("{}", name.as_str().cyan().italic()))
-        } else if opts.color_builtin_functions && State::is_builtin(id) {
-            f.write_fmt(format_args!("{}", name.as_str().purple()))
+
+        if opts.latex {
+            match id {
+                State::E => f.write_char('e'),
+                State::PI => f.write_str("\\pi"),
+                State::I => f.write_char('i'),
+                _ => f.write_str(name),
+            }
+        } else if opts.color_builtin_symbols && name.ends_with('_') {
+            f.write_fmt(format_args!("{}", name.cyan().italic()))
+        } else if opts.color_builtin_symbols && State::is_builtin(id) {
+            f.write_fmt(format_args!("{}", name.purple()))
         } else {
             f.write_str(name)
         }
     }
 
     fn fmt_debug(&self, f: &mut fmt::Formatter) -> fmt::Result {
         <Self as std::fmt::Debug>::fmt(self, f)
@@ -264,23 +299,23 @@
         let is_negative = match d {
             CoefficientView::Natural(n, _) => n < 0,
             CoefficientView::Large(r) => r.is_negative(),
             _ => false,
         };
 
         if is_negative {
-            if print_state.level == 1 && opts.color_top_level_sum {
+            if print_state.top_level_add_child && opts.color_top_level_sum {
                 f.write_fmt(format_args!("{}", "-".yellow()))?;
             } else if print_state.superscript {
                 f.write_char('')?;
             } else {
                 f.write_char('-')?;
             }
         } else if print_state.explicit_sign {
-            if print_state.level == 1 && opts.color_top_level_sum {
+            if print_state.top_level_add_child && opts.color_top_level_sum {
                 f.write_fmt(format_args!("{}", "+".yellow()))?;
             } else {
                 f.write_char('+')?;
             }
         }
 
         match d {
@@ -358,35 +393,36 @@
     ) -> fmt::Result {
         // write the coefficient first
         let mut first = true;
         let mut skip_num = false;
         if let Some(AtomView::Num(n)) = self.iter().last() {
             // write -1*x as -x
             if n.get_coeff_view() == CoefficientView::Natural(-1, 1) {
-                if print_state.level == 1 && opts.color_top_level_sum {
+                if print_state.top_level_add_child && opts.color_top_level_sum {
                     f.write_fmt(format_args!("{}", "-".yellow()))?;
                 } else {
                     f.write_char('-')?;
                 }
 
                 first = true;
             } else {
                 n.fmt_output(f, opts, print_state)?;
                 first = false;
             }
 
             skip_num = true;
         } else if print_state.explicit_sign {
-            if print_state.level == 1 && opts.color_top_level_sum {
+            if print_state.top_level_add_child && opts.color_top_level_sum {
                 f.write_fmt(format_args!("{}", "+".yellow()))?;
             } else {
                 f.write_char('+')?;
             }
         }
 
+        print_state.top_level_add_child = false;
         print_state.level += 1;
         print_state.explicit_sign = false;
         for x in self.iter().take(if skip_num {
             self.get_nargs() - 1
         } else {
             self.get_nargs()
         }) {
@@ -396,17 +432,25 @@
                 } else {
                     f.write_char(opts.multiplication_operator)?;
                 }
             }
             first = false;
 
             if let AtomView::Add(_) = x {
-                f.write_char('(')?;
+                if opts.latex {
+                    f.write_str("\\left(")?;
+                } else {
+                    f.write_char('(')?;
+                }
                 x.fmt_output(f, opts, print_state)?;
-                f.write_char(')')?;
+                if opts.latex {
+                    f.write_str("\\right)")?;
+                } else {
+                    f.write_char(')')?;
+                }
             } else {
                 x.fmt_output(f, opts, print_state)?;
             }
         }
         Ok(())
     }
 }
@@ -415,53 +459,62 @@
     fn fmt_output(
         &self,
         f: &mut fmt::Formatter,
         opts: &PrintOptions,
         mut print_state: PrintState,
     ) -> fmt::Result {
         if print_state.explicit_sign {
-            if print_state.level == 1 && opts.color_top_level_sum {
+            if print_state.top_level_add_child && opts.color_top_level_sum {
                 f.write_fmt(format_args!("{}", "+".yellow()))?;
             } else {
                 f.write_char('+')?;
             }
         }
 
         let id = self.get_symbol();
         let name = State::get_name(id);
-        if name.ends_with('_') {
-            f.write_fmt(format_args!("{}", name.as_str().cyan().italic()))?;
+
+        if opts.latex {
+            if name == "cos" || name == "sin" || name == "exp" || name == "log" {
+                f.write_fmt(format_args!("\\{}\\!\\left(", name))?;
+            } else {
+                f.write_fmt(format_args!("{}\\!\\left(", name))?;
+            }
         } else {
-            // check if the function name is built in
-            if opts.color_builtin_functions && State::is_builtin(id) {
-                f.write_fmt(format_args!("{}", name.as_str().purple()))?;
+            if opts.color_builtin_symbols && name.ends_with('_') {
+                f.write_fmt(format_args!("{}", name.cyan().italic()))?;
+            } else if opts.color_builtin_symbols && State::is_builtin(id) {
+                f.write_fmt(format_args!("{}", name.purple()))?;
             } else {
                 f.write_str(name)?;
             }
-        }
 
-        if opts.square_brackets_for_function {
-            f.write_char('[')?;
-        } else {
-            f.write_char('(')?;
+            if opts.square_brackets_for_function {
+                f.write_char('[')?;
+            } else {
+                f.write_char('(')?;
+            }
         }
 
+        print_state.top_level_add_child = false;
         print_state.level += 1;
         print_state.explicit_sign = false;
         let mut first = true;
         for x in self.iter() {
             if !first {
                 f.write_char(',')?;
             }
             first = false;
 
             x.fmt_output(f, opts, print_state)?;
         }
 
-        if opts.square_brackets_for_function {
+        if opts.latex {
+            f.write_str("\\right)")
+        } else if opts.square_brackets_for_function {
             f.write_char(']')
         } else {
             f.write_char(')')
         }
     }
 
     fn fmt_debug(&self, f: &mut fmt::Formatter) -> fmt::Result {
@@ -473,24 +526,25 @@
     fn fmt_output(
         &self,
         f: &mut fmt::Formatter,
         opts: &PrintOptions,
         mut print_state: PrintState,
     ) -> fmt::Result {
         if print_state.explicit_sign {
-            if print_state.level == 1 && opts.color_top_level_sum {
+            if print_state.top_level_add_child && opts.color_top_level_sum {
                 f.write_fmt(format_args!("{}", "+".yellow()))?;
             } else {
                 f.write_char('+')?;
             }
         }
 
         let b = self.get_base();
         let e = self.get_exp();
 
+        print_state.top_level_add_child = false;
         print_state.level += 1;
         print_state.explicit_sign = false;
 
         let mut superscript_exponent = false;
         if opts.latex {
             if let AtomView::Num(n) = e {
                 if n.get_coeff_view() == CoefficientView::Natural(-1, 1) {
@@ -511,17 +565,25 @@
                 || if let AtomView::Num(n) = b {
                     !n.get_coeff_view().is_integer()
                 } else {
                     false
                 };
 
         if base_needs_parentheses {
-            f.write_char('(')?;
+            if opts.latex {
+                f.write_str("\\left(")?;
+            } else {
+                f.write_char('(')?;
+            }
             b.fmt_output(f, opts, print_state)?;
-            f.write_char(')')?;
+            if opts.latex {
+                f.write_str("\\right)")?;
+            } else {
+                f.write_char(')')?;
+            }
         } else {
             b.fmt_output(f, opts, print_state)?;
         }
 
         if !superscript_exponent {
             f.write_char('^')?;
         }
@@ -558,18 +620,19 @@
     fn fmt_output(
         &self,
         f: &mut fmt::Formatter,
         opts: &PrintOptions,
         mut print_state: PrintState,
     ) -> fmt::Result {
         let mut first = true;
+        print_state.top_level_add_child = print_state.level == 0;
         print_state.level += 1;
 
         for x in self.iter() {
-            if !first && print_state.level == 1 && opts.terms_on_new_line {
+            if !first && print_state.top_level_add_child && opts.terms_on_new_line {
                 f.write_char('\n')?;
                 f.write_char('\t')?;
             }
             print_state.explicit_sign = !first;
             first = false;
 
             x.fmt_output(f, opts, print_state)?;
@@ -1080,18 +1143,21 @@
     for PolynomialPrinter<'a, F, E, O>
 {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         if f.sign_plus() {
             f.write_char('+')?;
         }
 
-        let var_map: Vec<String> = match self.poly.var_map.as_ref() {
-            Some(v) => v.iter().map(|v| v.to_string()).collect(),
-            None => (0..self.poly.nvars).map(|i| format!("x{}", i)).collect(),
-        };
+        let var_map: Vec<String> = self
+            .poly
+            .variables
+            .as_ref()
+            .iter()
+            .map(|v| v.to_string())
+            .collect();
 
         let mut is_first_term = true;
         for monomial in self.poly {
             let mut is_first_factor = true;
             if self.poly.field.is_one(monomial.coefficient) {
                 if !is_first_term {
                     write!(f, "+")?;
@@ -1227,7 +1293,124 @@
                     f.write_char(',')?;
                 }
             }
             f.write_char('}')
         }
     }
 }
+
+#[cfg(test)]
+mod test {
+    use colored::control::ShouldColorize;
+
+    use crate::{
+        atom::Atom,
+        domains::{finite_field::Zp, integer::Z},
+        printer::{AtomPrinter, PolynomialPrinter, PrintOptions},
+    };
+
+    #[test]
+    fn atoms() {
+        let a = Atom::parse("f(x,y^2)^(x+z)/5+3").unwrap();
+
+        if ShouldColorize::from_env().should_colorize() {
+            assert_eq!(format!("{}", a), "1/5*f(x,y^2)^(x+z)\u{1b}[33m+\u{1b}[0m3");
+        } else {
+            assert_eq!(format!("{}", a), "1/5*f(x,y^2)^(x+z)+3");
+        }
+
+        assert_eq!(
+            format!(
+                "{}",
+                AtomPrinter::new_with_options(a.as_view(), PrintOptions::latex())
+            ),
+            "\\frac{1}{5} f\\!\\left(x,y^{2}\\right)^{x+z}+3"
+        );
+
+        assert_eq!(
+            format!(
+                "{}",
+                AtomPrinter::new_with_options(a.as_view(), PrintOptions::mathematica())
+            ),
+            "1/5 f[x,y^2]^(x+z)+3"
+        );
+
+        let a = Atom::parse("8127389217 x^2").unwrap();
+        assert_eq!(
+            format!(
+                "{}",
+                AtomPrinter::new_with_options(
+                    a.as_view(),
+                    PrintOptions {
+                        terms_on_new_line: true,
+                        color_top_level_sum: false,
+                        color_builtin_symbols: false,
+                        print_finite_field: true,
+                        symmetric_representation_for_finite_field: false,
+                        explicit_rational_polynomial: false,
+                        number_thousands_separator: Some('_'),
+                        multiplication_operator: ' ',
+                        square_brackets_for_function: false,
+                        num_exp_as_superscript: true,
+                        latex: false
+                    }
+                )
+            ),
+            "812_738_921_7 x"
+        );
+    }
+
+    #[test]
+    fn polynomials() {
+        let a = Atom::parse("15 x^2")
+            .unwrap()
+            .to_polynomial::<_, u8>(&Zp::new(17), None);
+        assert_eq!(
+            format!(
+                "{}",
+                PolynomialPrinter::new_with_options(
+                    &a,
+                    PrintOptions {
+                        terms_on_new_line: true,
+                        color_top_level_sum: false,
+                        color_builtin_symbols: false,
+                        print_finite_field: true,
+                        symmetric_representation_for_finite_field: true,
+                        explicit_rational_polynomial: false,
+                        number_thousands_separator: Some('_'),
+                        multiplication_operator: ' ',
+                        square_brackets_for_function: false,
+                        num_exp_as_superscript: false,
+                        latex: false
+                    }
+                )
+            ),
+            "-2*x^2 % 17"
+        );
+    }
+
+    #[test]
+    fn rational_polynomials() {
+        let a = Atom::parse("15 x^2 / (1+x)")
+            .unwrap()
+            .to_rational_polynomial::<_, _, u8>(&Z, &Z, None);
+        assert_eq!(format!("{}", a), "15*x^2/(1+x)");
+
+        let a = Atom::parse("(15 x^2 + 6) / (1+x)")
+            .unwrap()
+            .to_rational_polynomial::<_, _, u8>(&Z, &Z, None);
+        assert_eq!(format!("{}", a), "(6+15*x^2)/(1+x)");
+    }
+
+    #[test]
+    fn factorized_rational_polynomials() {
+        let a = Atom::parse("15 x^2 / ((1+x)(x+2))")
+            .unwrap()
+            .to_factorized_rational_polynomial::<_, _, u8>(&Z, &Z, None);
+        assert_eq!(format!("{}", a), "15*x^2/((1+x)(2+x))");
+
+        let a = Atom::parse("(15 x^2 + 6) / ((1+x)(x+2))")
+            .unwrap()
+            .to_factorized_rational_polynomial::<_, _, u8>(&Z, &Z, None);
+        assert_eq!(format!("{}", a), "3*(2+5*x^2)/((1+x)(2+x))");
+    }
+}
```

### Comparing `symbolica-0.3.0/src/representations/coefficient.rs` & `symbolica-0.4.0/src/atom/coefficient.rs`

 * *Files identical despite different names*

### Comparing `symbolica-0.3.0/src/representations/default.rs` & `symbolica-0.4.0/src/atom/representation.rs`

 * *Files 3% similar despite different names*

```diff
@@ -184,14 +184,19 @@
     }
 
     #[inline(always)]
     pub fn as_view(&self) -> AtomView {
         AtomView::Var(self.to_var_view())
     }
 
+    #[inline]
+    pub fn get_symbol(&self) -> Symbol {
+        self.to_var_view().get_symbol()
+    }
+
     #[inline(always)]
     pub fn into_raw(self) -> RawAtom {
         self.data
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
@@ -320,14 +325,24 @@
 
     #[inline(always)]
     pub fn as_view(&self) -> AtomView {
         AtomView::Fun(self.to_fun_view())
     }
 
     #[inline(always)]
+    pub fn get_symbol(&self) -> Symbol {
+        self.to_fun_view().get_symbol()
+    }
+
+    #[inline(always)]
+    pub fn get_nargs(&self) -> usize {
+        self.to_fun_view().get_nargs()
+    }
+
+    #[inline(always)]
     pub fn into_raw(self) -> RawAtom {
         self.data
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 pub struct Pow {
@@ -550,14 +565,19 @@
 
     #[inline(always)]
     pub fn as_view(&self) -> AtomView {
         AtomView::Mul(self.to_mul_view())
     }
 
     #[inline(always)]
+    pub fn get_nargs(&self) -> usize {
+        self.to_mul_view().get_nargs()
+    }
+
+    #[inline(always)]
     pub fn into_raw(self) -> RawAtom {
         self.data
     }
 }
 
 #[derive(Clone, PartialEq, Eq, Hash)]
 pub struct Add {
@@ -671,14 +691,19 @@
 
     #[inline(always)]
     pub fn as_view(&self) -> AtomView {
         AtomView::Add(self.to_add_view())
     }
 
     #[inline(always)]
+    pub fn get_nargs(&self) -> usize {
+        self.to_add_view().get_nargs()
+    }
+
+    #[inline(always)]
     pub fn into_raw(self) -> RawAtom {
         self.data
     }
 }
 
 impl<'a> VarView<'a> {
     #[inline]
```

### Comparing `symbolica-0.3.0/src/representations.rs` & `symbolica-0.4.0/src/atom.rs`

 * *Files 5% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 mod coefficient;
-pub mod default;
+pub mod representation;
 
 use crate::{
     coefficient::Coefficient,
     parser::Token,
     printer::AtomPrinter,
     state::{RecycledAtom, Workspace},
 };
 use std::{cmp::Ordering, hash::Hash, ops::DerefMut};
 
-pub use self::default::{
+pub use self::representation::{
     Add, AddView, Fun, ListIterator, ListSlice, Mul, MulView, Num, NumView, Pow, PowView, Var,
     VarView,
 };
-use self::default::{FunView, RawAtom};
+use self::representation::{FunView, RawAtom};
 
 /// A symbol, for example the name of a variable or the name of a function,
 /// together with its properties.
-/// Should be created using `get_or_insert` of `State`.
+/// Should be created using `get_symbol` of `State`.
 #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
 pub struct Symbol {
     id: u32,
     wildcard_level: u8,
     is_symmetric: bool,
     is_antisymmetric: bool,
     is_linear: bool,
@@ -322,14 +322,24 @@
     /// Negate `self`, writing the result in `out`.
     pub fn neg_with_ws_into(&self, workspace: &Workspace, out: &mut Atom) {
         self.neg_no_norm(workspace)
             .as_view()
             .normalize(workspace, out);
     }
 
+    /// Get the symbol of a variable or function.
+    #[inline(always)]
+    pub fn get_symbol(&self) -> Option<Symbol> {
+        match self {
+            AtomView::Var(v) => Some(v.get_symbol()),
+            AtomView::Fun(f) => Some(f.get_symbol()),
+            _ => None,
+        }
+    }
+
     pub fn get_byte_size(&self) -> usize {
         match self {
             AtomView::Num(n) => n.get_byte_size(),
             AtomView::Var(v) => v.get_byte_size(),
             AtomView::Fun(f) => f.get_byte_size(),
             AtomView::Pow(p) => p.get_byte_size(),
             AtomView::Mul(m) => m.get_byte_size(),
@@ -521,16 +531,26 @@
             Atom::Pow(p) => AtomView::Pow(p.to_pow_view()),
             Atom::Mul(m) => AtomView::Mul(m.to_mul_view()),
             Atom::Add(a) => AtomView::Add(a.to_add_view()),
             Atom::Empty => unreachable!("Empty atom"),
         }
     }
 
+    /// Get the symbol of a variable or function.
+    #[inline(always)]
+    pub fn get_symbol(&self) -> Option<Symbol> {
+        match self {
+            Atom::Var(v) => Some(v.get_symbol()),
+            Atom::Fun(f) => Some(f.get_symbol()),
+            _ => None,
+        }
+    }
+
     #[inline(always)]
-    pub fn set_normalized(&mut self, normalized: bool) {
+    pub(crate) fn set_normalized(&mut self, normalized: bool) {
         match self {
             Atom::Num(_) => {}
             Atom::Var(_) => {}
             Atom::Fun(a) => a.set_normalized(normalized),
             Atom::Pow(a) => a.set_normalized(normalized),
             Atom::Mul(a) => a.set_normalized(normalized),
             Atom::Add(a) => a.set_normalized(normalized),
@@ -540,20 +560,19 @@
 }
 
 /// A constructor of a function,
 ///
 /// For example:
 /// ```
 /// # use symbolica::{
-/// #     representations::{Atom, AsAtomView, FunctionBuilder},
+/// #     atom::{Atom, AsAtomView, FunctionBuilder},
 /// #     state::{FunctionAttribute, State},
 /// # };
 /// # fn main() {
-/// ///
-/// let f_id = State::get_or_insert_fn("f", Some(vec![FunctionAttribute::Symmetric])).unwrap();
+/// let f_id = State::get_symbol_with_attributes("f", vec![FunctionAttribute::Symmetric]).unwrap();
 /// let fb = FunctionBuilder::new(f_id);
 /// let a = fb
 ///     .add_arg(&Atom::new_num(3))
 ///     .add_arg(&Atom::new_num(2))
 ///     .add_arg(&Atom::new_num(1))
 ///     .finish();
 ///
@@ -1013,7 +1032,50 @@
             self.as_view().div_with_ws_into(ws, n.as_view(), &mut t);
             std::mem::swap(&mut self, &mut t);
         });
 
         self
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{
+        atom::{Atom, FunctionBuilder},
+        fun,
+        state::State,
+    };
+
+    #[test]
+    fn debug() {
+        let x = Atom::parse("v1+f1(v2)").unwrap();
+        assert_eq!(
+            format!("{:?}", x),
+            "AddView { data: [5, 15, 0, 0, 0, 1, 2, 2, 1, 12, 3, 5, 0, 0, 0, 1, 42, 2, 1, 13] }"
+        );
+        assert_eq!(
+            x.get_all_symbols(true),
+            [
+                State::get_symbol("v1"),
+                State::get_symbol("v2"),
+                State::get_symbol("f1")
+            ]
+            .into_iter()
+            .collect(),
+        );
+        assert_eq!(x.as_view().get_byte_size(), 20);
+    }
+
+    #[test]
+    fn composition() {
+        let v1 = Atom::parse("v1").unwrap();
+        let v2 = Atom::parse("v2").unwrap();
+        let f1_id = State::get_symbol("f1");
+
+        let f1 = fun!(f1_id, v1, v2, Atom::new_num(2));
+
+        let r = (-(&v2 + &v1 + 2) * &v2 * 6).npow(5) / &v2.pow(&v1) * &f1 / 4;
+
+        let res = Atom::parse("1/4*(v2^v1)^-1*(-6*v2*(v1+v2+2))^5*f1(v1,v2,2)").unwrap();
+        assert_eq!(res, r);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/state.rs` & `symbolica-0.4.0/src/state.rs`

 * *Files 16% similar despite different names*

```diff
@@ -1,26 +1,28 @@
 use std::hash::Hash;
 use std::mem::ManuallyDrop;
+use std::sync::atomic::{AtomicUsize, Ordering};
 use std::sync::RwLock;
 use std::thread::LocalKey;
 use std::{
     cell::RefCell,
     collections::hash_map::Entry,
     ops::{Deref, DerefMut},
 };
 
 use ahash::{HashMap, HashMapExt};
 use append_only_vec::AppendOnlyVec;
 use once_cell::sync::Lazy;
 use smartstring::alias::String;
 
+use crate::domains::finite_field::Zp64;
 use crate::{
+    atom::{Atom, Symbol},
     coefficient::Coefficient,
-    domains::finite_field::{FiniteField, FiniteFieldCore},
-    representations::{Atom, Symbol},
+    domains::finite_field::FiniteFieldCore,
     LicenseManager, LICENSE_MANAGER,
 };
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub struct FiniteFieldIndex(pub(crate) usize);
 
 #[derive(Clone, Copy, PartialEq)]
@@ -28,15 +30,16 @@
     Symmetric,
     Antisymmetric,
     Linear,
 }
 
 static STATE: Lazy<RwLock<State>> = Lazy::new(|| RwLock::new(State::new()));
 static ID_TO_STR: AppendOnlyVec<String> = AppendOnlyVec::<String>::new();
-static FINITE_FIELDS: AppendOnlyVec<FiniteField<u64>> = AppendOnlyVec::<FiniteField<u64>>::new();
+static FINITE_FIELDS: AppendOnlyVec<Zp64> = AppendOnlyVec::<Zp64>::new();
+static SYMBOL_OFFSET: AtomicUsize = AtomicUsize::new(0);
 
 thread_local!(
     /// A thread-local workspace, that stores recyclable atoms. By making it const and
     /// `ManuallyDrop`, the fastest implementation is chosen for the current platform.
     /// In principle this leaks memory, but Symbolica only uses thread pools that live as
     /// long as the main thread, so this is no issue.
     static WORKSPACE: ManuallyDrop<Workspace> = const { ManuallyDrop::new(Workspace::new()) }
@@ -74,163 +77,225 @@
         LICENSE_MANAGER.get_or_init(LicenseManager::new).check();
 
         let mut state = State {
             str_to_id: HashMap::new(),
         };
 
         for x in Self::BUILTIN_VAR_LIST {
-            state.get_or_insert_var_impl(x);
+            state.get_symbol_impl(x);
+        }
+
+        #[cfg(test)]
+        {
+            state.initialize_test();
         }
 
         state
     }
 
     /// Get the global state.
     #[inline]
     pub(crate) fn get_global_state() -> &'static RwLock<State> {
         &STATE
     }
 
+    /// Initialize the global state for testing purposes by allocating
+    /// variables and functions with the names v0, ..., v29, f0, ..., f29,
+    /// that can be used in concurrently run unit tests without interference.
+    #[cfg(test)]
+    fn initialize_test(&mut self) {
+        for i in 0..30 {
+            let _ = self.get_symbol_impl(&format!("v{}", i));
+        }
+        for i in 0..30 {
+            let _ = self.get_symbol_impl(&format!("f{}", i));
+        }
+        for i in 0..5 {
+            let _ = self.get_symbol_with_attributes_impl(
+                &format!("fs{}", i),
+                &[FunctionAttribute::Symmetric],
+            );
+        }
+        for i in 0..5 {
+            let _ = self.get_symbol_with_attributes_impl(
+                &format!("fa{}", i),
+                &[FunctionAttribute::Antisymmetric],
+            );
+        }
+        for i in 0..5 {
+            let _ = self
+                .get_symbol_with_attributes_impl(&format!("fl{}", i), &[FunctionAttribute::Linear]);
+        }
+        for i in 0..5 {
+            let _ = self.get_symbol_with_attributes_impl(
+                &format!("fsl{}", i),
+                &[FunctionAttribute::Symmetric, FunctionAttribute::Linear],
+            );
+        }
+    }
+
+    /// Remove all user-defined symbols from the state. This will invalidate all
+    /// currently existing atoms, and hence this function is unsafe.
+    ///
+    /// Example:
+    /// ```
+    /// State::get_symbol_with_attributes("f", vec![FunctionAttribute::Symmetric]).unwrap();
+    /// unsafe { State::reset(); }
+    /// State::get_symbol_with_attributes("f", vec![FunctionAttribute::Antisymmetric]).unwrap();
+    /// ```
+    pub unsafe fn reset() {
+        let mut state = STATE.write().unwrap();
+
+        state.str_to_id.clear();
+        SYMBOL_OFFSET.store(ID_TO_STR.len(), Ordering::Relaxed);
+
+        for x in Self::BUILTIN_VAR_LIST {
+            state.get_symbol_impl(x);
+        }
+
+        #[cfg(test)]
+        {
+            state.initialize_test();
+        }
+    }
+
     /// Iterate over all defined symbols.
-    pub fn symbol_iter<'a>() -> impl Iterator<Item = &'a str> {
-        ID_TO_STR.iter().map(|s| s.as_str())
+    pub fn symbol_iter() -> impl Iterator<Item = &'static str> {
+        ID_TO_STR
+            .iter()
+            .skip(SYMBOL_OFFSET.load(Ordering::Relaxed))
+            .map(|s| s.as_str())
     }
 
     /// Returns `true` iff this identifier is defined by Symbolica.
     pub fn is_builtin(id: Symbol) -> bool {
         id.get_id() < Self::BUILTIN_VAR_LIST.len() as u32
     }
 
-    /// Get the id for a certain name if the name is already registered,
-    /// else register it and return a new id.
-    pub fn get_or_insert_var<S: AsRef<str>>(name: S) -> Symbol {
-        STATE.write().unwrap().get_or_insert_var_impl(name.as_ref())
+    /// Get the symbol for a certain name if the name is already registered,
+    /// else register it and return a new symbol without attributes.
+    ///
+    /// To register a symbol with attributes, use [`State::get_symbol_with_attributes`].
+    pub fn get_symbol<S: AsRef<str>>(name: S) -> Symbol {
+        STATE.write().unwrap().get_symbol_impl(name.as_ref())
     }
 
-    pub(crate) fn get_or_insert_var_impl(&mut self, name: &str) -> Symbol {
+    pub(crate) fn get_symbol_impl(&mut self, name: &str) -> Symbol {
         match self.str_to_id.entry(name.into()) {
             Entry::Occupied(o) => *o.get(),
             Entry::Vacant(v) => {
-                if ID_TO_STR.len() == u32::MAX as usize - 1 {
+                let offset = SYMBOL_OFFSET.load(Ordering::Relaxed);
+                if ID_TO_STR.len() - offset == u32::MAX as usize - 1 {
                     panic!("Too many variables defined");
                 }
 
                 let mut wildcard_level = 0;
                 for x in name.chars().rev() {
                     if x != '_' {
                         break;
                     }
                     wildcard_level += 1;
                 }
 
                 // there is no synchronization issue since only one thread can insert at a time
                 // as the state itself is behind a mutex
-                let new_index = ID_TO_STR.push(name.into());
+                let id = ID_TO_STR.push(name.into()) - offset;
 
-                let new_id = Symbol::init_var(new_index as u32, wildcard_level);
-                v.insert(new_id);
-                new_id
+                let new_symbol = Symbol::init_var(id as u32, wildcard_level);
+                v.insert(new_symbol);
+                new_symbol
             }
         }
     }
 
-    /// Get the id of a certain function name if the name is already registered,
-    /// else register it and return a new id.
+    /// Get the symbol for a certain name if the name is already registered,
+    /// else register it and return a new symbol with the given attributes.
     ///
-    /// Providing an attribute `None` means that the attributes will be fetched from
-    /// the state if the function exists, or the attribute list will be empty if not.
-    pub fn get_or_insert_fn<S: AsRef<str>>(
+    /// This function will return an error when an existing symbol is redefined
+    /// with different attributes.
+    pub fn get_symbol_with_attributes<S: AsRef<str>>(
         name: S,
-        attributes: Option<Vec<FunctionAttribute>>,
+        attributes: &[FunctionAttribute],
     ) -> Result<Symbol, String> {
         STATE
             .write()
             .unwrap()
-            .get_or_insert_fn_impl(name.as_ref(), attributes)
+            .get_symbol_with_attributes_impl(name.as_ref(), attributes)
     }
 
-    pub(crate) fn get_or_insert_fn_impl(
+    pub(crate) fn get_symbol_with_attributes_impl(
         &mut self,
         name: &str,
-        attributes: Option<Vec<FunctionAttribute>>,
+        attributes: &[FunctionAttribute],
     ) -> Result<Symbol, String> {
         match self.str_to_id.entry(name.into()) {
             Entry::Occupied(o) => {
                 let r = *o.get();
-                if let Some(attributes) = attributes {
-                    let new_id = Symbol::init_fn(
-                        r.get_id(),
-                        r.get_wildcard_level(),
-                        attributes.contains(&FunctionAttribute::Symmetric),
-                        attributes.contains(&FunctionAttribute::Antisymmetric),
-                        attributes.contains(&FunctionAttribute::Linear),
-                    );
-
-                    if r == new_id {
-                        Ok(r)
-                    } else {
-                        Err(format!("Function {} redefined with new attributes", name).into())
-                    }
-                } else {
+
+                let new_id = Symbol::init_fn(
+                    r.get_id(),
+                    r.get_wildcard_level(),
+                    attributes.contains(&FunctionAttribute::Symmetric),
+                    attributes.contains(&FunctionAttribute::Antisymmetric),
+                    attributes.contains(&FunctionAttribute::Linear),
+                );
+
+                if r == new_id {
                     Ok(r)
+                } else {
+                    Err(format!("Function {} redefined with new attributes", name).into())
                 }
             }
             Entry::Vacant(v) => {
-                if ID_TO_STR.len() == u32::MAX as usize - 1 {
+                let offset = SYMBOL_OFFSET.load(Ordering::Relaxed);
+                if ID_TO_STR.len() - offset == u32::MAX as usize - 1 {
                     panic!("Too many variables defined");
                 }
 
                 // there is no synchronization issue since only one thread can insert at a time
                 // as the state itself is behind a mutex
-                let new_index = ID_TO_STR.push(name.into());
+                let id = ID_TO_STR.push(name.into()) - offset;
 
                 let mut wildcard_level = 0;
                 for x in name.chars().rev() {
                     if x != '_' {
                         break;
                     }
                     wildcard_level += 1;
                 }
 
-                let new_id = if let Some(attributes) = attributes {
-                    Symbol::init_fn(
-                        new_index as u32,
-                        wildcard_level,
-                        attributes.contains(&FunctionAttribute::Symmetric),
-                        attributes.contains(&FunctionAttribute::Antisymmetric),
-                        attributes.contains(&FunctionAttribute::Linear),
-                    )
-                } else {
-                    Symbol::init_fn(new_index as u32, wildcard_level, false, false, false)
-                };
+                let new_symbol = Symbol::init_fn(
+                    id as u32,
+                    wildcard_level,
+                    attributes.contains(&FunctionAttribute::Symmetric),
+                    attributes.contains(&FunctionAttribute::Antisymmetric),
+                    attributes.contains(&FunctionAttribute::Linear),
+                );
 
-                v.insert(new_id);
+                v.insert(new_symbol);
 
-                Ok(new_id)
+                Ok(new_symbol)
             }
         }
     }
 
     /// Get the name for a given symbol.
-    pub fn get_name<'a>(id: Symbol) -> &'a String {
-        &ID_TO_STR[id.get_id() as usize]
+    pub fn get_name(id: Symbol) -> &'static str {
+        &ID_TO_STR[id.get_id() as usize + SYMBOL_OFFSET.load(Ordering::Relaxed)]
     }
 
-    pub fn get_finite_field<'a>(fi: FiniteFieldIndex) -> &'a FiniteField<u64> {
+    pub fn get_finite_field(fi: FiniteFieldIndex) -> &'static Zp64 {
         &FINITE_FIELDS[fi.0]
     }
 
-    pub fn get_or_insert_finite_field(f: FiniteField<u64>) -> FiniteFieldIndex {
+    pub fn get_or_insert_finite_field(f: Zp64) -> FiniteFieldIndex {
         STATE.write().unwrap().get_or_insert_finite_field_impl(f)
     }
 
-    pub(crate) fn get_or_insert_finite_field_impl(
-        &mut self,
-        f: FiniteField<u64>,
-    ) -> FiniteFieldIndex {
+    pub(crate) fn get_or_insert_finite_field_impl(&mut self, f: Zp64) -> FiniteFieldIndex {
         for (i, f2) in FINITE_FIELDS.iter().enumerate() {
             if f.get_prime() == f2.get_prime() {
                 return FiniteFieldIndex(i);
             }
         }
 
         let index = FINITE_FIELDS.push(f);
```

### Comparing `symbolica-0.3.0/src/streaming.rs` & `symbolica-0.4.0/src/streaming.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 use std::sync::Mutex;
 
 use rayon::prelude::*;
 
 use crate::{
-    representations::{Atom, AtomView},
+    atom::{Atom, AtomView},
     state::{RecycledAtom, Workspace},
 };
 
 struct TermInputStream {
     mem_buf: Vec<Atom>,
 }
 
@@ -85,20 +85,25 @@
         self.sort();
 
         if self.mem_buf.is_empty() {
             Atom::new_num(0)
         } else if self.mem_buf.len() == 1 {
             self.mem_buf.pop().unwrap()
         } else {
-            let mut out = Atom::default();
-            let add = out.to_add();
-            for x in self.mem_buf.drain(..) {
-                add.extend(x.as_view());
-            }
-            out
+            Workspace::get_local().with(|ws| {
+                let mut a = ws.new_atom();
+                let add = a.to_add();
+                for x in self.mem_buf.drain(..) {
+                    add.extend(x.as_view());
+                }
+
+                let mut out = Atom::new();
+                a.as_view().normalize(ws, &mut out);
+                out
+            })
         }
     }
 }
 
 /// A term streamer that allows for mapping
 pub struct TermStreamer {
     exp_in: TermInputStream,
@@ -169,7 +174,32 @@
     }
 
     /// Convert the term stream into an expression. This may exceed the available memory.
     pub fn to_expression(&mut self) -> Atom {
         self.exp_out.to_expression()
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{atom::Atom, id::Pattern, streaming::TermStreamer};
+
+    #[test]
+    fn main() {
+        let input = Atom::parse("v1 + f1(v1) + 2*f1(v2) + 7*f1(v3)").unwrap();
+        let pattern = Pattern::parse("f(x_)").unwrap();
+        let rhs = Pattern::parse("f1(v1) + v1").unwrap();
+
+        let mut stream = TermStreamer::new_from(input);
+
+        // map every term in the expression
+        stream = stream.map(|workspace, x| {
+            let mut out1 = workspace.new_atom();
+            pattern.replace_all_into(x.as_view(), &rhs, None, None, &mut out1);
+            out1.expand()
+        });
+
+        let r = stream.to_expression();
+        let res = Atom::parse("v1+f1(v1)+2*f1(v2)+7*f1(v3)").unwrap();
+        assert_eq!(r, res);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/tensors/matrix.rs` & `symbolica-0.4.0/src/tensors/matrix.rs`

 * *Files 14% similar despite different names*

```diff
@@ -104,15 +104,15 @@
                 return Err("Matrix is not rectangular".to_string());
             }
 
             data.extend(d);
         }
 
         Ok(Matrix {
-            nrows: data.len() as u32,
+            nrows: (data.len() / cols) as u32,
             ncols: cols as u32,
             data,
             field,
         })
     }
 
     /// Return the number of rows.
@@ -751,7 +751,124 @@
             data: (0..nvars).map(|i| m[(i, nvars)].clone()).collect(),
             field: m.field,
         };
 
         Ok(result)
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{
+        domains::{integer::Z, rational::Q},
+        tensors::matrix::Matrix,
+    };
+
+    #[test]
+    fn basics() {
+        let a = Matrix::from_linear(
+            vec![
+                1u64.into(),
+                2u64.into(),
+                3u64.into(),
+                4u64.into(),
+                5u64.into(),
+                6u64.into(),
+            ],
+            2,
+            3,
+            Z,
+        )
+        .unwrap();
+
+        assert_eq!(
+            a.transpose().data,
+            vec![1.into(), 4.into(), 2.into(), 5.into(), 3.into(), 6.into()]
+        );
+
+        assert_eq!(
+            a.clone().into_transposed().data,
+            vec![1.into(), 4.into(), 2.into(), 5.into(), 3.into(), 6.into()]
+        );
+
+        assert_eq!(
+            (-a.clone()).data,
+            vec![
+                (-1).into(),
+                (-2).into(),
+                (-3).into(),
+                (-4).into(),
+                (-5).into(),
+                (-6).into()
+            ]
+        );
+
+        assert_eq!(
+            (&a - &a).data,
+            vec![0.into(), 0.into(), 0.into(), 0.into(), 0.into(), 0.into()]
+        );
+
+        let b = Matrix::from_nested_vec(
+            vec![
+                vec![7u64.into(), 8u64.into()],
+                vec![9u64.into(), 10u64.into()],
+                vec![11u64.into(), 12u64.into()],
+            ],
+            Z,
+        )
+        .unwrap();
+
+        let c = &a * &b;
+
+        assert_eq!(c.data, vec![58.into(), 64.into(), 139.into(), 154.into()]);
+        assert_eq!(&c[1], &[139.into(), 154.into()]);
+        assert_eq!(c[(0, 1)], 64.into());
+
+        let c_m = c.map(|x| x * &2u64.into(), Z);
+        assert_eq!(
+            c_m.data,
+            vec![116.into(), 128.into(), 278.into(), 308.into()]
+        );
+    }
+
+    #[test]
+    fn solve() {
+        let a = Matrix::from_linear(
+            vec![
+                1u64.into(),
+                2u64.into(),
+                3u64.into(),
+                4u64.into(),
+                5u64.into(),
+                16u64.into(),
+                7u64.into(),
+                8u64.into(),
+                9u64.into(),
+            ],
+            3,
+            3,
+            Q,
+        )
+        .unwrap();
+
+        assert_eq!(
+            a.inv().unwrap().data,
+            vec![
+                (-83, 60).into(),
+                (1, 10).into(),
+                (17, 60).into(),
+                (19, 15).into(),
+                (-1, 5).into(),
+                (-1, 15).into(),
+                (-1, 20).into(),
+                (1, 10).into(),
+                (-1, 20).into()
+            ]
+        );
+        assert_eq!(a.det().unwrap(), 60.into());
+
+        let b = Matrix::from_linear(vec![1u64.into(), 2u64.into(), 3u64.into()], 3, 1, Q).unwrap();
+
+        let r = a.solve(&b).unwrap();
+        assert_eq!(r.data, vec![(-1, 3).into(), (2, 3).into(), 0.into()]);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/transformer.rs` & `symbolica-0.4.0/src/transformer.rs`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 use std::time::Instant;
 
 use crate::{
+    atom::{Atom, AtomView, Symbol},
     coefficient::{Coefficient, CoefficientView},
     combinatorics::{partitions, unique_permutations},
     id::{Condition, MatchSettings, Pattern, WildcardAndRestriction},
     printer::{AtomPrinter, PrintOptions},
-    representations::{Atom, AtomView, Symbol},
     state::{State, Workspace},
 };
 use ahash::HashMap;
 use colored::Colorize;
 use dyn_clone::DynClone;
 
 pub trait Map:
@@ -66,28 +66,31 @@
     Derivative(Symbol),
     /// Derive the rhs w.r.t a variable.
     TaylorSeries(Symbol, Atom, u32),
     /// Apply find-and-replace on the rhs.
     ReplaceAll(
         Pattern,
         Pattern,
-        Option<Condition<WildcardAndRestriction>>,
-        Option<MatchSettings>,
+        Condition<WildcardAndRestriction>,
+        MatchSettings,
     ),
     /// Take the product of a list of arguments in the rhs.
     Product,
     /// Take the sum of a list of arguments in the rhs.
     Sum,
     /// Return the number of arguments of a function in the input.
     /// If the argument of `ArgCount` is `true`, only the number
     /// of arguments of `arg()` is returned and 1 is returned otherwise.
     /// If the argument is `false`, 0 is returned for non-functions.
     ArgCount(bool),
     /// Map the rhs with a user-specified function.
     Map(Box<dyn Map>),
+    /// Apply a transformation to each argument of the `arg()` function.
+    /// If the input is not `arg()`, map the current input.
+    ForEach(Vec<Transformer>),
     /// Split a `Mul` or `Add` into a list of arguments.
     Split,
     Partition(Vec<(Symbol, usize)>, bool, bool),
     Sort,
     Deduplicate,
     Permutations(Symbol),
     Repeat(Vec<Transformer>),
@@ -104,14 +107,15 @@
             Transformer::ReplaceAll(pat, rhs, ..) => {
                 f.debug_tuple("ReplaceAll").field(pat).field(rhs).finish()
             }
             Transformer::Product => f.debug_tuple("Product").finish(),
             Transformer::Sum => f.debug_tuple("Sum").finish(),
             Transformer::ArgCount(p) => f.debug_tuple("ArgCount").field(p).finish(),
             Transformer::Map(_) => f.debug_tuple("Map").finish(),
+            Transformer::ForEach(t) => f.debug_tuple("ForEach").field(t).finish(),
             Transformer::Split => f.debug_tuple("Split").finish(),
             Transformer::Partition(g, b1, b2) => f
                 .debug_tuple("Partition")
                 .field(g)
                 .field(b1)
                 .field(b2)
                 .finish(),
@@ -153,28 +157,46 @@
     pub fn new_partition_repeat(partition: (Symbol, usize)) -> Transformer {
         Transformer::Partition(vec![partition], false, true)
     }
 
     pub fn execute(
         orig_input: AtomView<'_>,
         chain: &[Transformer],
-
         workspace: &Workspace,
         out: &mut Atom,
     ) -> Result<(), TransformerError> {
         out.set_from_view(&orig_input);
         let mut tmp = workspace.new_atom();
         for t in chain {
             std::mem::swap(out, &mut tmp);
             let input = tmp.as_view();
 
             match t {
                 Transformer::Map(f) => {
                     f(input, out)?;
                 }
+                Transformer::ForEach(t) => {
+                    if let AtomView::Fun(f) = input {
+                        if f.get_symbol() == State::ARG {
+                            let mut ff = workspace.new_atom();
+                            let ff = ff.to_fun(State::ARG);
+
+                            let mut a = workspace.new_atom();
+                            for arg in f.iter() {
+                                Self::execute(arg, t, workspace, &mut a)?;
+                                ff.add_arg(a.as_view());
+                            }
+
+                            ff.as_view().normalize(workspace, out);
+                            continue;
+                        }
+                    }
+
+                    Self::execute(input, t, workspace, out)?;
+                }
                 Transformer::Expand => {
                     input.expand_with_ws_into(workspace, out);
                 }
                 Transformer::Derivative(x) => {
                     input.derivative_with_ws_into(*x, workspace, out);
                 }
                 Transformer::TaylorSeries(x, expansion_point, depth) => {
@@ -187,16 +209,16 @@
                     );
                 }
                 Transformer::ReplaceAll(pat, rhs, cond, settings) => {
                     pat.replace_all_with_ws_into(
                         input,
                         rhs,
                         workspace,
-                        cond.as_ref(),
-                        settings.as_ref(),
+                        cond.into(),
+                        settings.into(),
                         out,
                     );
                 }
                 Transformer::Product => {
                     if let AtomView::Fun(f) = input {
                         if f.get_symbol() == State::ARG {
                             let mut mul_h = workspace.new_atom();
@@ -472,7 +494,157 @@
                 }
             }
         }
 
         Ok(())
     }
 }
+
+#[cfg(test)]
+mod test {
+    use crate::{
+        atom::{Atom, FunctionBuilder},
+        id::{Condition, Match, MatchSettings, Pattern, PatternRestriction},
+        printer::PrintOptions,
+        state::{State, Workspace},
+        transformer::StatsOptions,
+    };
+
+    use super::Transformer;
+
+    #[test]
+    fn expand_derivative() {
+        let p = Atom::parse("(1+v1)^2").unwrap();
+
+        let mut out = Atom::new();
+        Workspace::get_local().with(|ws| {
+            Transformer::execute(
+                p.as_view(),
+                &[
+                    Transformer::Expand,
+                    Transformer::Derivative(State::get_symbol("v1")),
+                ],
+                ws,
+                &mut out,
+            )
+            .unwrap()
+        });
+
+        let r = Atom::parse("2+2*v1").unwrap();
+        assert_eq!(out, r);
+    }
+
+    #[test]
+    fn split_argcount() {
+        let p = Atom::parse("v1+v2+v3").unwrap();
+
+        let mut out = Atom::new();
+        Workspace::get_local().with(|ws| {
+            Transformer::execute(
+                p.as_view(),
+                &[Transformer::Split, Transformer::ArgCount(true)],
+                ws,
+                &mut out,
+            )
+            .unwrap()
+        });
+
+        let r = Atom::parse("3").unwrap();
+        assert_eq!(out, r);
+    }
+
+    #[test]
+    fn product_series() {
+        let p = Atom::parse("arg(x,x+1,3)").unwrap();
+
+        let mut out = Atom::new();
+        Workspace::get_local().with(|ws| {
+            Transformer::execute(
+                p.as_view(),
+                &[
+                    Transformer::Product,
+                    Transformer::TaylorSeries(State::get_symbol("x"), Atom::new_num(1), 3),
+                ],
+                ws,
+                &mut out,
+            )
+            .unwrap()
+        });
+
+        let r = Atom::parse("3*(x-1)^2+9*(x-1)+6").unwrap();
+        assert_eq!(out, r);
+    }
+
+    #[test]
+    fn sort_deduplicate() {
+        let p = Atom::parse("f1(3,2,1,3)").unwrap();
+
+        let mut out = Atom::new();
+        Workspace::get_local().with(|ws| {
+            Transformer::execute(
+                p.as_view(),
+                &[
+                    Transformer::ReplaceAll(
+                        Pattern::parse("f1(x__)").unwrap(),
+                        Pattern::parse("x__").unwrap(),
+                        Condition::default(),
+                        MatchSettings::default(),
+                    ),
+                    Transformer::Sort,
+                    Transformer::Deduplicate,
+                    Transformer::Map(Box::new(|x, out| {
+                        let mut f = FunctionBuilder::new(State::get_symbol("f1"));
+                        f = f.add_arg(x);
+                        *out = f.finish();
+                        Ok(())
+                    })),
+                ],
+                ws,
+                &mut out,
+            )
+            .unwrap()
+        });
+
+        let r = Atom::parse("f1(1,2,3)").unwrap();
+        assert_eq!(out, r);
+    }
+
+    #[test]
+    fn deep_nesting() {
+        let p = Atom::parse("arg(3,2,1,3)").unwrap();
+
+        let mut out = Atom::new();
+        Workspace::get_local().with(|ws| {
+            Transformer::execute(
+                p.as_view(),
+                &[Transformer::Repeat(vec![Transformer::Stats(
+                    StatsOptions {
+                        tag: "test".to_owned(),
+                        color_medium_change_threshold: Some(10.),
+                        color_large_change_threshold: Some(100.),
+                    },
+                    vec![Transformer::ForEach(vec![
+                        Transformer::Print(PrintOptions::default()),
+                        Transformer::ReplaceAll(
+                            Pattern::parse("x_").unwrap(),
+                            Pattern::parse("x_-1").unwrap(),
+                            (
+                                State::get_symbol("x_"),
+                                PatternRestriction::Filter(Box::new(|x| {
+                                    x != &Match::Single(Atom::new_num(0).as_view())
+                                })),
+                            )
+                                .into(),
+                            MatchSettings::default(),
+                        ),
+                    ])],
+                )])],
+                ws,
+                &mut out,
+            )
+            .unwrap()
+        });
+
+        let r = Atom::parse("arg(0,0,0,0)").unwrap();
+        assert_eq!(out, r);
+    }
+}
```

### Comparing `symbolica-0.3.0/src/utils.rs` & `symbolica-0.4.0/src/utils.rs`

 * *Files identical despite different names*

### Comparing `symbolica-0.3.0/symbolica.pyi` & `symbolica-0.4.0/symbolica.pyi`

 * *Files 2% similar despite different names*

```diff
@@ -143,22 +143,29 @@
     @classmethod
     def funs(_cls, *names: str) -> Sequence[Function]:
         """
         Create a Symbolica function for every name in `*names`.
         """
 
     @classmethod
-    def num(_cls, num: int) -> Expression:
-        """Create a new Symbolica number.
+    def num(_cls, num: int | float, max_denom: Optional[int] = None) -> Expression:
+        """Create a new Symbolica number from an int or a float.
+        A floating point number is converted to its rational number equivalent,
+        but it can also be truncated by specifying the maximal denominator value.
 
         Examples
         --------
         >>> e = Expression.num(1) / 2
         >>> print(e)
         1/2
+
+        >>> print(Expression.num(0.33))
+        >>> print(Expression.num(0.33, 5))
+        5944751508129055/18014398509481984
+        1/3
         """
 
     @classmethod
     def get_all_symbol_names(_cls) -> list[str]:
         """Return all defined symbol names (function names and variables)."""
 
     @classmethod
@@ -196,15 +203,15 @@
     def get_byte_size(self) -> int:
         """ Get the number of bytes that this expression takes up in memory."""
 
     def pretty_str(
         self,
         terms_on_new_line: bool = False,
         color_top_level_sum: bool = True,
-        color_builtin_functions: bool = True,
+        color_builtin_symbols: bool = True,
         print_finite_field: bool = True,
         symmetric_representation_for_finite_field: bool = False,
         explicit_rational_polynomial: bool = False,
         number_thousands_separator: Optional[str] = None,
         multiplication_operator: str = "*",
         square_brackets_for_function: bool = False,
         num_exp_as_superscript: bool = True,
@@ -626,90 +633,140 @@
         >>> x, y = Expression.vars('x', 'y')
         >>> var, coeff = Expression.funs('var', 'coeff')
         >>> e = 5*x + x * y + x**2 + 5
         >>>
         >>> print(e.collect(x, key_map=lambda x: var(x), coeff_map=lambda x: coeff(x)))
 
         yields `var(1)*coeff(5)+var(x)*coeff(y+5)+var(x^2)*coeff(1)`.
+
+        Parameters
+        ----------
+        key_map: A function to be applied to the quantity collected in
+        coeff_map: A function to be applied to the coefficient
         """
 
     def coefficient_list(
         self, x: Expression
     ) -> Sequence[Tuple[Expression, Expression]]:
         """Collect terms involving the same power of `x`, where `x` is a variable or function name.
         Return the list of key-coefficient pairs and the remainder that matched no key.
 
         Examples
         --------
 
-        >>> from symbolica import Expression
+        >>> from symbolica import *
         >>> x, y = Expression.vars('x', 'y')
         >>> e = 5*x + x * y + x**2 + 5
         >>>
         >>> for a in e.coefficient_list(x):
         >>>     print(a[0], a[1])
 
         yields
         ```
         x y+5
         x^2 1
         1 5
         ```
         """
 
+    def coefficient(self, x: Expression) -> Expression:
+        """Collect terms involving the literal occurrence of `x`.
+
+        Examples
+        --------
+
+        >>> from symbolica import *
+        >>> x, y = Expression.vars('x', 'y')
+        >>> e = 5*x + x * y + x**2 + y*x**2
+        >>> print(e.coefficient(x**2))
+
+        yields
+
+        ```
+        y + 1
+        ```
+        """
+
     def derivative(self, x: Expression) -> Expression:
         """Derive the expression w.r.t the variable `x`."""
 
     def taylor_series(
         self,
         x: Expression,
         expansion_point: Expression | int,
         depth: int,
     ) -> Expression:
         """Taylor expand in `x` around `expansion_point` to depth `depth`."""
 
-    def to_polynomial(self, vars: Optional[Sequence[Expression]] = None) -> Polynomial:
-        """Convert the expression to a polynomial, optionally, with the variables and the ordering specified in `vars`."""
+    def apart(self, x: Expression) -> Expression:
+        """Compute the partial fraction decomposition in `x`.
+
+        Examples
+        --------
 
-    def to_polynomial_with_conversion(self) -> Polynomial:
-        """Convert the expression to a polynomial, converting all non-polynomial parts to new, independent variables."""
+        >>> from symbolica import Expression
+        >>> x = Expression.var('x')
+        >>> p = Expression.parse('1/((x+y)*(x^2+x*y+1)(x+1))')
+        >>> print(p.apart(x))
+        """
+
+    def together(self) -> Expression:
+        """Write the expression over a common denominator.
+
+        Examples
+        --------
+
+        >>> from symbolica import Expression
+        >>> p = Expression.parse('v1^2/2+v1^3/v4*v2+v3/(1+v4)')
+        >>> print(p.together())
+        """
+
+    def to_polynomial(self, vars: Optional[Sequence[Expression]] = None) -> Polynomial:
+        """Convert the expression to a polynomial, optionally, with the variable ordering specified in `vars`.
+        All non-polynomial parts will be converted to new, independent variables.
+        """
 
     def to_rational_polynomial(
         self,
         vars: Optional[Sequence[Expression]] = None,
     ) -> RationalPolynomial:
         """
-        Convert the expression to a rational polynomial, optionally, with the variables and the ordering specified in `vars`.
+        Convert the expression to a rational polynomial, optionally, with the variable ordering specified in `vars`.
         The latter is useful if it is known in advance that more variables may be added in the future to the
         rational polynomial through composition with other rational polynomials.
 
+        All non-rational polynomial parts are converted to new, independent variables.
+
         Examples
         --------
         >>> a = Expression.parse('(1 + 3*x1 + 5*x2 + 7*x3 + 9*x4 + 11*x5 + 13*x6 + 15*x7)^2 - 1').to_rational_polynomial()
         >>> print(a)
         """
 
     def to_rational_polynomial_small_exponent(
         self,
         vars: Optional[Sequence[Expression]] = None,
     ) -> RationalPolynomial:
         """Similar to `to_rational_polynomial()`, but the power of each variable is limited to 255."""
 
-    def to_rational_polynomial_with_conversion(self) -> RationalPolynomial:
-        """Convert the expression to a rational polynomial, converting all non-rational polynomial parts to new, independent variables."""
-
     def match(
         self,
         lhs: Transformer | Expression | int,
         cond: Optional[PatternRestriction] = None,
+        level_range: Optional[Tuple[int, Optional[int]]] = None,
+        level_is_tree_depth: Optional[bool] = False,
     ) -> MatchIterator:
         """
         Return an iterator over the pattern `self` matching to `lhs`.
         Restrictions on pattern can be supplied through `cond`.
 
+        The `level_range` specifies the `[min,max]` level at which the pattern is allowed to match.
+        The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree,
+        depending on `level_is_tree_depth`.
+
         Examples
         --------
 
         >>> x, x_ = Expression.vars('x','x_')
         >>> f = Expression.fun('f')
         >>> e = f(x)*f(1)*f(2)*f(3)
         >>> for match in e.match(f(x_)):
@@ -718,14 +775,16 @@
         """
 
     def replace(
         self,
         lhs: Transformer | Expression | int,
         rhs: Transformer | Expression | int,
         cond: Optional[PatternRestriction] = None,
+        level_range: Optional[Tuple[int, Optional[int]]] = None,
+        level_is_tree_depth: Optional[bool] = False,
     ) -> ReplaceIterator:
         """
         Return an iterator over the replacement of the pattern `self` on `lhs` by `rhs`.
         Restrictions on pattern can be supplied through `cond`.
 
         Examples
         --------
@@ -739,40 +798,56 @@
 
         Yields:
         ```
         f(2)*f(2)*f(3)
         f(1)*f(3)*f(3)
         f(1)*f(2)*f(4)
         ```
+
+        Parameters
+        ----------
+        lhs: The pattern to match.
+        rhs: The right-hand side to replace the matched subexpression with.
+        cond: Conditions on the pattern.
+        level_range: Specifies the `[min,max]` level at which the pattern is allowed to match. The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree, depending on `level_is_tree_depth`.
+        level_is_tree_depth: If set to `True`, the level is increased when going one level deeper in the expression tree.
         """
 
     def replace_all(
         self,
         pattern: Transformer | Expression | int,
         rhs: Transformer | Expression | int,
         cond: Optional[PatternRestriction] = None,
         non_greedy_wildcards: Optional[Sequence[Expression]] = None,
+        level_range: Optional[Tuple[int, Optional[int]]] = None,
+        level_is_tree_depth: Optional[bool] = False,
         repeat: Optional[bool] = False,
     ) -> Expression:
         """
-        Replace all atoms matching the pattern `pattern` by the right-hand side `rhs`.
-        Restrictions on pattern can be supplied through `cond`.
-        The settings `non_greedy_wildcards` can be used to specify
-        wildcards that try to match as little as possible.
-
-        The entire operation can be repeated until there are no more matches using `repeat=True`.
+        Replace all subexpressions matching the pattern `pattern` by the right-hand side `rhs`.
 
         Examples
         --------
 
         >>> x, w1_, w2_ = Expression.vars('x','w1_','w2_')
         >>> f = Expression.fun('f')
         >>> e = f(3,x)
         >>> r = e.replace_all(f(w1_,w2_), f(w1_ - 1, w2_**2), (w1_ >= 1) & w2_.is_var())
         >>> print(r)
+
+        Parameters
+        ----------
+        self: The expression to match and replace on.
+        pattern: The pattern to match.
+        rhs: The right-hand side to replace the matched subexpression with.
+        cond: Conditions on the pattern.
+        non_greedy_wildcards: Wildcards that try to match as little as possible.
+        level_range: Specifies the `[min,max]` level at which the pattern is allowed to match. The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree, depending on `level_is_tree_depth`.
+        level_is_tree_depth: If set to `True`, the level is increased when going one level deeper in the expression tree.
+        repeat: If set to `True`, the entire operation will be repeated until there are no more matches.
         """
 
     @classmethod
     def solve_linear_system(
         _cls,
         system: Sequence[Expression],
         variables: Sequence[Expression],
@@ -1059,14 +1134,26 @@
         >>> from symbolica import Expression, Transformer
         >>> x_ = Expression.var('x_')
         >>> f = Expression.fun('f')
         >>> e = f(2).replace_all(f(x_), x_.transform().map(lambda r: r**2))
         >>> print(e)
         """
 
+    def for_each(self, *transformers: Transformer) -> Transformer:
+        """Create a transformer that applies a transformer chain to every argument of the `arg()` function.
+        If the input is not `arg()`, the transformer is applied to the input.
+
+        Examples
+        --------
+        >>> from symbolica import Expression
+        >>> x = Expression.var('x')
+        >>> f = Expression.fun('f')
+        >>> e = (1+x).transform().split().for_each(Transformer().map(f)).execute()
+        """
+
     def check_interrupt(self) -> Transformer:
         """Create a transformer that checks for a Python interrupt,
         such as ctrl-c and aborts the current transformer.
 
         Examples
         --------
         >>> from symbolica import *
@@ -1148,36 +1235,45 @@
 
     def replace_all(
         self,
         pat: Transformer | Expression | int,
         rhs: Transformer | Expression | int,
         cond: Optional[PatternRestriction] = None,
         non_greedy_wildcards: Optional[Sequence[Expression]] = None,
+        level_range: Optional[Tuple[int, Optional[int]]] = None,
+        level_is_tree_depth: Optional[bool] = False,
     ) -> Transformer:
         """
-        Create a transformer that replaces all patterns matching the left-hand side `self` by the right-hand side `rhs`.
-        Restrictions on pattern can be supplied through `cond`.
-        The settings `non_greedy_wildcards` can be used to specify
-        wildcards that try to match as little as possible.
+        Create a transformer that replaces all subexpressions matching the pattern `pat` by the right-hand side `rhs`.
 
         Examples
         --------
 
         >>> x, w1_, w2_ = Expression.vars('x','w1_','w2_')
         >>> f = Expression.fun('f')
         >>> e = f(3,x)
         >>> r = e.transform().replace_all(f(w1_,w2_), f(w1_ - 1, w2_**2), (w1_ >= 1) & w2_.is_var())
         >>> print(r)
+
+        Parameters
+        ----------
+        pat: The pattern to match.
+        rhs: The right-hand side to replace the matched subexpression with.
+        cond: Conditions on the pattern.
+        non_greedy_wildcards: Wildcards that try to match as little as possible.
+        level_range: Specifies the `[min,max]` level at which the pattern is allowed to match. The first level is 0 and the level is increased when going into a function or one level deeper in the expression tree, depending on `level_is_tree_depth`.
+        level_is_tree_depth: If set to `True`, the level is increased when going one level deeper in the expression tree.
+        repeat: If set to `True`, the entire operation will be repeated until there are no more matches.
         """
 
     def print(
         self,
         terms_on_new_line: bool = False,
         color_top_level_sum: bool = True,
-        color_builtin_functions: bool = True,
+        color_builtin_symbols: bool = True,
         print_finite_field: bool = True,
         symmetric_representation_for_finite_field: bool = False,
         explicit_rational_polynomial: bool = False,
         number_thousands_separator: Optional[str] = None,
         multiplication_operator: str = "*",
         square_brackets_for_function: bool = False,
         num_exp_as_superscript: bool = True,
@@ -1335,15 +1431,15 @@
     def to_latex(self) -> str:
         """Convert the polynomial into a LaTeX string."""
 
     def pretty_str(
         self,
         terms_on_new_line: bool = False,
         color_top_level_sum: bool = True,
-        color_builtin_functions: bool = True,
+        color_builtin_symbols: bool = True,
         print_finite_field: bool = True,
         symmetric_representation_for_finite_field: bool = False,
         explicit_rational_polynomial: bool = False,
         number_thousands_separator: Optional[str] = None,
         multiplication_operator: str = "*",
         square_brackets_for_function: bool = False,
         num_exp_as_superscript: bool = True,
@@ -1374,23 +1470,26 @@
 
     def __mul__(self, rhs: Polynomial) -> Polynomial:
         """Multiply two polynomials `self` and `rhs`, returning the result."""
 
     def __truediv__(self, rhs: Polynomial) -> Polynomial:
         """Divide the polynomial `self` by `rhs` if possible, returning the result."""
 
-    def quot_rem(self, rhs: Polynomial) -> Polynomial:
+    def quot_rem(self, rhs: Polynomial) -> Tuple[Polynomial, Polynomial]:
         """Divide `self` by `rhs`, returning the quotient and remainder."""
 
     def __neg__(self) -> Polynomial:
         """Negate the polynomial."""
 
     def gcd(self, rhs: Polynomial) -> Polynomial:
         """Compute the greatest common divisor (GCD) of two polynomials."""
 
+    def resultant(self, rhs: Polynomial, var: Expression) -> Polynomial:
+        """Compute the resultant of two polynomials with respect to the variable `var`."""
+
     def to_integer_polynomial(self) -> IntegerPolynomial:
         """Convert the polynomial to a polynomial with integer coefficients, if possible."""
 
     def to_finite_field(self, prime: int) -> FiniteFieldPolynomial:
         """Convert the coefficients of the polynomial to a finite field with prime `prime`."""
 
     def optimize(self, iterations: int = 1000, to_file: str | None = None) -> Evaluator:
@@ -1435,14 +1534,26 @@
 
         >>> from symbolica import Expression
         >>> x = Expression.var('x')
         >>> p = Expression.parse('x^2+2').to_polynomial()
         >>> print(p.derivative(x))
         """
 
+    def integrate(self, x: Expression) -> Polynomial:
+        """Integrate the polynomial in `x`.
+
+        Examples
+        --------
+
+        >>> from symbolica import Expression
+        >>> x = Expression.var('x')
+        >>> p = Expression.parse('x^2+2').to_polynomial()
+        >>> print(p.integrate(x))
+        """
+
     def content(self) -> Polynomial:
         """Get the content, i.e., the GCD of the coefficients.
 
         Examples
         --------
 
         >>> from symbolica import Expression
@@ -1544,15 +1655,15 @@
     def to_latex(self) -> str:
         """Convert the polynomial into a LaTeX string."""
 
     def pretty_str(
         self,
         terms_on_new_line: bool = False,
         color_top_level_sum: bool = True,
-        color_builtin_functions: bool = True,
+        color_builtin_symbols: bool = True,
         print_finite_field: bool = True,
         symmetric_representation_for_finite_field: bool = False,
         explicit_rational_polynomial: bool = False,
         number_thousands_separator: Optional[str] = None,
         multiplication_operator: str = "*",
         square_brackets_for_function: bool = False,
         num_exp_as_superscript: bool = True,
@@ -1583,23 +1694,26 @@
 
     def __mul__(self, rhs: IntegerPolynomial) -> IntegerPolynomial:
         """Multiply two polynomials `self` and `rhs`, returning the result."""
 
     def __truediv__(self, rhs: IntegerPolynomial) -> IntegerPolynomial:
         """Divide the polynomial `self` by `rhs` if possible, returning the result."""
 
-    def quot_rem(self, rhs: IntegerPolynomial) -> IntegerPolynomial:
+    def quot_rem(self, rhs: IntegerPolynomial) -> Tuple[IntegerPolynomial, IntegerPolynomial]:
         """Divide `self` by `rhs`, returning the quotient and remainder."""
 
     def __neg__(self) -> IntegerPolynomial:
         """Negate the polynomial."""
 
     def gcd(self, rhs: IntegerPolynomial) -> IntegerPolynomial:
         """Compute the greatest common divisor (GCD) of two polynomials."""
 
+    def resultant(self, rhs: IntegerPolynomial, var: Expression) -> IntegerPolynomial:
+        """Compute the resultant of two polynomials with respect to the variable `var`."""
+
     def factor_square_free(self) -> list[Tuple[IntegerPolynomial, int]]:
         """Compute the square-free factorization of the polynomial.
 
         Examples
         --------
 
         >>> from symbolica import Expression
@@ -1628,51 +1742,51 @@
         """Take a derivative in `x`.
 
         Examples
         --------
 
         >>> from symbolica import Expression
         >>> x = Expression.var('x')
-        >>> p = Expression.parse('x^2+2').to_polynomial()
+        >>> p = Expression.parse('x^2+2').to_polynomial().to_integer_polynomial()
         >>> print(p.derivative(x))
         """
 
     def content(self) -> IntegerPolynomial:
         """Get the content, i.e., the GCD of the coefficients.
 
         Examples
         --------
 
         >>> from symbolica import Expression
-        >>> p = Expression.parse('3x^2+6x+9').to_polynomial()
+        >>> p = Expression.parse('3x^2+6x+9').to_polynomial().to_integer_polynomial()
         >>> print(p.content())
         """
 
     def coefficient_list(self, x: Expression) -> list[Tuple[int, IntegerPolynomial]]:
         """Get the coefficient list in `x`.
 
         Examples
         --------
 
         >>> from symbolica import Expression
         >>> x = Expression.var('x')
-        >>> p = Expression.parse('x*y+2*x+x^2').to_polynomial()
+        >>> p = Expression.parse('x*y+2*x+x^2').to_polynomial().to_integer_polynomial()
         >>> for n, pp in p.coefficient_list(x):
         >>>     print(n, pp)
         """
 
     def to_expression(self) -> Expression:
         """ Convert the polynomial to an expression.
 
         Examples
         --------
 
         >>> from symbolica import Expression
         >>> e = Expression.parse('x*y+2*x+x^2')
-        >>> p = e.to_polynomial()
+        >>> p = e.to_polynomial().to_integer_polynomial()
         >>> print((e - p.to_expression()).expand())
         """
 
     def replace(self, x: Expression, v: Polynomial) -> Polynomial:
         """Replace the variable `x` with a polynomial `v`.
 
         Examples
@@ -1718,15 +1832,15 @@
     def to_latex(self) -> str:
         """Convert the polynomial into a LaTeX string."""
 
     def pretty_str(
         self,
         terms_on_new_line: bool = False,
         color_top_level_sum: bool = True,
-        color_builtin_functions: bool = True,
+        color_builtin_symbols: bool = True,
         print_finite_field: bool = True,
         symmetric_representation_for_finite_field: bool = False,
         explicit_rational_polynomial: bool = False,
         number_thousands_separator: Optional[str] = None,
         multiplication_operator: str = "*",
         square_brackets_for_function: bool = False,
         num_exp_as_superscript: bool = True,
@@ -1757,23 +1871,26 @@
 
     def __mul__(self, rhs: FiniteFieldPolynomial) -> FiniteFieldPolynomial:
         """Multiply two polynomials `self` and `rhs`, returning the result."""
 
     def __truediv__(self, rhs: FiniteFieldPolynomial) -> FiniteFieldPolynomial:
         """Divide the polynomial `self` by `rhs` if possible, returning the result."""
 
-    def quot_rem(self, rhs: FiniteFieldPolynomial) -> FiniteFieldPolynomial:
+    def quot_rem(self, rhs: FiniteFieldPolynomial) -> Tuple[FiniteFieldPolynomial, FiniteFieldPolynomial]:
         """Divide `self` by `rhs`, returning the quotient and remainder."""
 
     def __neg__(self) -> FiniteFieldPolynomial:
         """Negate the polynomial."""
 
     def gcd(self, rhs: FiniteFieldPolynomial) -> FiniteFieldPolynomial:
         """Compute the greatest common divisor (GCD) of two polynomials."""
 
+    def resultant(self, rhs: FiniteFieldPolynomial, var: Expression) -> FiniteFieldPolynomial:
+        """Compute the resultant of two polynomials with respect to the variable `var`."""
+
     def optimize(self, iterations: int = 1000, to_file: str | None = None) -> Evaluator:
         """
         Optimize the polynomial for evaluation using `iterations` number of iterations.
         The optimized output can be exported in a C++ format using `to_file`.
 
         Returns an evaluator for the polynomial.
         """
@@ -1814,14 +1931,26 @@
 
         >>> from symbolica import Expression
         >>> x = Expression.var('x')
         >>> p = Expression.parse('x^2+2').to_polynomial()
         >>> print(p.derivative(x))
         """
 
+    def integrate(self, x: Expression) -> FiniteFieldPolynomial:
+        """Integrate the polynomial in `x`.
+
+        Examples
+        --------
+
+        >>> from symbolica import Expression
+        >>> x = Expression.var('x')
+        >>> p = Expression.parse('x^2+2').to_polynomial()
+        >>> print(p.integrate(x))
+        """
+
     def content(self) -> FiniteFieldPolynomial:
         """Get the content, i.e., the GCD of the coefficients.
 
         Examples
         --------
 
         >>> from symbolica import Expression
@@ -1842,31 +1971,31 @@
         >>>     print(n, pp)
         """
 
     @classmethod
     def groebner_basis(_cls, system: list[FiniteFieldPolynomial], grevlex: bool = True, print_stats: bool = False) -> list[FiniteFieldPolynomial]:
         """Compute the Groebner basis of a polynomial system.
 
-        If `grevlex=True`, reverse graded lexicographical ordering is used,
-        otherwise the ordering is lexicographical.
-
-        If `print_stats=True` intermediate statistics will be printed.
-
         Examples
         --------
         >>> basis = Polynomial.groebner_basis(
         >>>     [Expression.parse("a b c d - 1").to_polynomial(),
         >>>     Expression.parse("a b c + a b d + a c d + b c d").to_polynomial(),
         >>>     Expression.parse("a b + b c + a d + c d").to_polynomial(),
         >>>     Expression.parse("a + b + c + d").to_polynomial()],
         >>>     grevlex=True,
         >>>     print_stats=True
         >>> )
         >>> for p in basis:
         >>>     print(p)
+
+        Parameters
+        ----------
+        grevlex: if `True`, reverse graded lexicographical ordering is used, otherwise the ordering is lexicographical.
+        print_stats: if `True`, intermediate statistics will be printed.
         """
 
     def replace(self, x: Expression, v: Polynomial) -> Polynomial:
         """Replace the variable `x` with a polynomial `v`.
 
         Examples
         --------
```

### Comparing `symbolica-0.3.0/PKG-INFO` & `symbolica-0.4.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-Metadata-Version: 2.1
+Metadata-Version: 2.3
 Name: symbolica
-Version: 0.3.0
+Version: 0.4.0
 Classifier: Development Status :: 3 - Alpha
 Classifier: Programming Language :: Rust
 Classifier: Topic :: Scientific/Engineering :: Mathematics
 License-File: License.md
 License-File: License.md
 Summary: Symbolica is a blazing fast computer algebra system
 Keywords: math,algebra,polynomial,expression,manipulation
@@ -20,14 +20,15 @@
   <br>
 </h1>
 
 <p align="center">
 <a href="https://symbolica.io"><img alt="Symbolica website" src="https://img.shields.io/static/v1?label=symbolica&message=website&color=orange&style=flat-square"></a>
   <a href="https://reform.zulipchat.com"><img alt="Zulip Chat" src="https://img.shields.io/static/v1?label=zulip&message=discussions&color=blue&style=flat-square"></a>
     <a href="https://github.com/benruijl/symbolica"><img alt="Symbolica website" src="https://img.shields.io/static/v1?label=github&message=development&color=green&style=flat-square&logo=github"></a>
+    <a href="https://app.codecov.io/gh/benruijl/symbolica"><img alt="Codecov" src="https://img.shields.io/codecov/c/github/benruijl/symbolica?token=N43MATK5XJ&style=flat-square"></a>
 </p>
 
 # Symbolica
 
 Symbolica is a blazing fast and modern computer algebra system which aims to handle huge expressions. It can easily be incorporated into existing projects using its Python, Rust or C++ bindings.
 Check out the live [Jupyter Notebook demo](https://colab.research.google.com/drive/1VAtND2kddgBwNt1Tjsai8vnbVIbgg-7D?usp=sharing)!
 
@@ -61,15 +62,15 @@
 
 ## Rust
 
 If you want to use Symbolica as a library in Rust, simply include it in the `Cargo.toml`:
 
 ```toml
 [dependencies]
-symbolica = "0.3"
+symbolica = "0.4"
 ```
 
 # Examples
 
 Below we list some examples of the features of Symbolica. Check the [guide](https://symbolica.io/docs/) for a complete overview.
 
 ### Pattern matching
```

#### html2text {}

```diff
@@ -1,19 +1,19 @@
-Metadata-Version: 2.1 Name: symbolica Version: 0.3.0 Classifier: Development
+Metadata-Version: 2.3 Name: symbolica Version: 0.4.0 Classifier: Development
 Status :: 3 - Alpha Classifier: Programming Language :: Rust Classifier: Topic
 :: Scientific/Engineering :: Mathematics License-File: License.md License-File:
 License.md Summary: Symbolica is a blazing fast computer algebra system
 Keywords: math,algebra,polynomial,expression,manipulation Author: Ben Ruijl
 Author-email: benruyl@gmail.com Description-Content-Type: text/markdown;
 charset=UTF-8; variant=GFM Project-URL: homepage, https://symbolica.io Project-
 URL: repository, https://github.com/benruijl/symbolica
                                     ************
                                     [[llooggoo]]
                                      ************
-              _[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]_[_Z_u_l_i_p_ _C_h_a_t_]_[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]
+          _[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]_[_Z_u_l_i_p_ _C_h_a_t_]_[_S_y_m_b_o_l_i_c_a_ _w_e_b_s_i_t_e_]_[_C_o_d_e_c_o_v_]
 # Symbolica Symbolica is a blazing fast and modern computer algebra system
 which aims to handle huge expressions. It can easily be incorporated into
 existing projects using its Python, Rust or C++ bindings. Check out the live
 [Jupyter Notebook demo](https://colab.research.google.com/drive/
 1VAtND2kddgBwNt1Tjsai8vnbVIbgg-7D?usp=sharing)! For documentation and more, see
 [symbolica.io](https://symbolica.io). ## Quick Example Symbolica allows you to
 build and manipulate mathematical expressions through matching and replacing
@@ -22,15 +22,15 @@
 (probably) already know, by using Symbolica's bindings to Python, Rust and C++:
 [A demo of Symbolica]# Installation Visit the [Get Started](https://
 symbolica.io/docs/get_started.html) page for detailed installation
 instructions. ## Python Symbolica can be installed for Python >3.5 using `pip`:
 ```sh pip install symbolica ``` The installation may take some time on Mac OS
 and Windows, as it may have to compile Symbolica. ## Rust If you want to use
 Symbolica as a library in Rust, simply include it in the `Cargo.toml`: ```toml
-[dependencies] symbolica = "0.3" ``` # Examples Below we list some examples of
+[dependencies] symbolica = "0.4" ``` # Examples Below we list some examples of
 the features of Symbolica. Check the [guide](https://symbolica.io/docs/) for a
 complete overview. ### Pattern matching Variables ending with a `_` are
 wildcards that match to any subexpression. In the following example we try to
 match the pattern `f(w1_,w2_)`: ```python from symbolica import Expression x,
 y, w1_, w2_ = Expression.vars('x','y','w1_','w2_') f = Expression.fun('f') e =
 f(3,x)*y**2+5 r = e.replace_all(f(w1_,w2_), f(w1_ - 1, w2_**2)) print(r) ```
 which yields `y^2*f(2,x^2)+5`. ### Solving a linear system Solve a linear
```

