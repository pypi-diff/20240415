# Comparing `tmp/libqasm-0.6.2-cp39-cp39-win_amd64.whl.zip` & `tmp/libqasm-0.6.3-cp39-cp39-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,23 @@
-Zip file size: 771913 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat        3 b- defN 24-Apr-11 15:41 cqasm/__init__.py
--rw-rw-rw-  2.0 fat     2850 b- defN 24-Apr-11 15:41 cqasm/v3x/__init__.py
--rw-rw-rw-  2.0 fat   423200 b- defN 24-Apr-11 15:43 cqasm/v3x/ast.py
--rw-rw-rw-  2.0 fat     1219 b- defN 24-Apr-11 15:41 cqasm/v3x/instruction.py
--rw-rw-rw-  2.0 fat     1731 b- defN 24-Apr-11 15:41 cqasm/v3x/primitives.py
--rw-rw-rw-  2.0 fat    88893 b- defN 24-Apr-11 15:43 cqasm/v3x/semantic.py
--rw-rw-rw-  2.0 fat    53029 b- defN 24-Apr-11 15:43 cqasm/v3x/types.py
--rw-rw-rw-  2.0 fat    63394 b- defN 24-Apr-11 15:43 cqasm/v3x/values.py
--rw-rw-rw-  2.0 fat      752 b- defN 24-Apr-11 15:41 libQasm/__init__.py
--rw-rw-rw-  2.0 fat  2280960 b- defN 24-Apr-11 15:44 libQasm/_libQasm.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    31677 b- defN 24-Apr-11 15:44 libQasm/libQasm.py
--rw-rw-rw-  2.0 fat      579 b- defN 24-Apr-11 15:44 libqasm-0.6.2.dist-info/LICENSE.md
--rw-rw-rw-  2.0 fat     6103 b- defN 24-Apr-11 15:44 libqasm-0.6.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-11 15:44 libqasm-0.6.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       14 b- defN 24-Apr-11 15:44 libqasm-0.6.2.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1252 b- defN 24-Apr-11 15:44 libqasm-0.6.2.dist-info/RECORD
-16 files, 2955756 bytes uncompressed, 769889 bytes compressed:  74.0%
+Zip file size: 1827574 bytes, number of entries: 21
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-15 20:35 libqasm.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-15 20:35 libqasm-0.6.3.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-15 20:35 cqasm/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-15 20:35 libQasm/
+-rw-r--r--  2.0 unx       14 b- defN 24-Apr-15 20:35 libqasm-0.6.3.dist-info/top_level.txt
+-rw-r--r--  2.0 unx     5913 b- defN 24-Apr-15 20:35 libqasm-0.6.3.dist-info/METADATA
+-rw-r--r--  2.0 unx      149 b- defN 24-Apr-15 20:35 libqasm-0.6.3.dist-info/WHEEL
+-rw-rw-r--  2.0 unx     1280 b- defN 24-Apr-15 20:35 libqasm-0.6.3.dist-info/RECORD
+-rw-r--r--  2.0 unx      566 b- defN 24-Apr-15 20:35 libqasm-0.6.3.dist-info/LICENSE.md
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-15 20:35 cqasm/v3x/
+-rw-r--r--  2.0 unx        2 b- defN 24-Apr-15 20:35 cqasm/__init__.py
+-rw-r--r--  2.0 unx    61680 b- defN 24-Apr-15 20:35 cqasm/v3x/values.py
+-rw-r--r--  2.0 unx     1177 b- defN 24-Apr-15 20:35 cqasm/v3x/instruction.py
+-rw-r--r--  2.0 unx    51593 b- defN 24-Apr-15 20:35 cqasm/v3x/types.py
+-rw-r--r--  2.0 unx     2785 b- defN 24-Apr-15 20:35 cqasm/v3x/__init__.py
+-rw-r--r--  2.0 unx    86535 b- defN 24-Apr-15 20:35 cqasm/v3x/semantic.py
+-rw-r--r--  2.0 unx     1664 b- defN 24-Apr-15 20:35 cqasm/v3x/primitives.py
+-rw-r--r--  2.0 unx   412518 b- defN 24-Apr-15 20:35 cqasm/v3x/ast.py
+-rw-r--r--  2.0 unx    30595 b- defN 24-Apr-15 20:35 libQasm/libQasm.py
+-rw-r--r--  2.0 unx      727 b- defN 24-Apr-15 20:35 libQasm/__init__.py
+-rw-r--r--  2.0 unx  6219144 b- defN 24-Apr-15 20:35 libQasm/_libQasm.cpython-39-x86_64-linux-gnu.so
+21 files, 6876342 bytes uncompressed, 1825024 bytes compressed:  73.5%
```

## zipnote {}

```diff
@@ -1,49 +1,64 @@
-Filename: cqasm/__init__.py
+Filename: libqasm.libs/
 Comment: 
 
-Filename: cqasm/v3x/__init__.py
+Filename: libqasm-0.6.3.dist-info/
 Comment: 
 
-Filename: cqasm/v3x/ast.py
+Filename: cqasm/
 Comment: 
 
-Filename: cqasm/v3x/instruction.py
+Filename: libQasm/
 Comment: 
 
-Filename: cqasm/v3x/primitives.py
+Filename: libqasm-0.6.3.dist-info/top_level.txt
 Comment: 
 
-Filename: cqasm/v3x/semantic.py
+Filename: libqasm-0.6.3.dist-info/METADATA
 Comment: 
 
-Filename: cqasm/v3x/types.py
+Filename: libqasm-0.6.3.dist-info/WHEEL
+Comment: 
+
+Filename: libqasm-0.6.3.dist-info/RECORD
+Comment: 
+
+Filename: libqasm-0.6.3.dist-info/LICENSE.md
+Comment: 
+
+Filename: cqasm/v3x/
+Comment: 
+
+Filename: cqasm/__init__.py
 Comment: 
 
 Filename: cqasm/v3x/values.py
 Comment: 
 
-Filename: libQasm/__init__.py
+Filename: cqasm/v3x/instruction.py
 Comment: 
 
-Filename: libQasm/_libQasm.cp39-win_amd64.pyd
+Filename: cqasm/v3x/types.py
 Comment: 
 
-Filename: libQasm/libQasm.py
+Filename: cqasm/v3x/__init__.py
 Comment: 
 
-Filename: libqasm-0.6.2.dist-info/LICENSE.md
+Filename: cqasm/v3x/semantic.py
 Comment: 
 
-Filename: libqasm-0.6.2.dist-info/METADATA
+Filename: cqasm/v3x/primitives.py
 Comment: 
 
-Filename: libqasm-0.6.2.dist-info/WHEEL
+Filename: cqasm/v3x/ast.py
 Comment: 
 
-Filename: libqasm-0.6.2.dist-info/top_level.txt
+Filename: libQasm/libQasm.py
+Comment: 
+
+Filename: libQasm/__init__.py
 Comment: 
 
-Filename: libqasm-0.6.2.dist-info/RECORD
+Filename: libQasm/_libQasm.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## cqasm/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-#
+#
```

## cqasm/v3x/__init__.py

 * *Ordering differences only*

```diff
@@ -1,65 +1,65 @@
-import cqasm.v3x.ast as ast
-import cqasm.v3x.semantic as semantic
-import libQasm
-
-
-class Analyzer(libQasm.V3xAnalyzer):
-    # parse_file and parse_string are static methods because they do not change the status of the analyzer
-    # Instead, they just invoke free functions that create a temporary instance of a parser
-    # analyze_file and analyze_string are not static methods because they change the status of the analyzer
-
-    # parse_file, parse_string, analyze_file, and analyze_string return a vector of strings
-    # If the length of the vector is 1, the string is a serialization of the AST
-    # Otherwise, it is a list of errors
-
-    @staticmethod
-    def parse_file(*args):
-        ret = libQasm.V3xAnalyzer.parse_file(*args)
-        if len(ret) == 1:
-            serialized_ast_str = str(ret[0])
-            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
-            deserialized_ast = ast.Root.deserialize(serialized_ast_bytes)
-            return deserialized_ast
-        return [str(error) for error in ret[1:]]
-
-    @staticmethod
-    def parse_string(*args):
-        ret = libQasm.V3xAnalyzer.parse_string(*args)
-        if len(ret) == 1:
-            serialized_ast_str = str(ret[0])
-            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
-            deserialized_ast = ast.Root.deserialize(serialized_ast_bytes)
-            return deserialized_ast
-        return [str(error) for error in ret[1:]]
-
-    def analyze_file(self, *args):
-        ret = super().analyze_file(*args)
-        if len(ret) == 1:
-            serialized_ast_str = str(ret[0])
-            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
-            deserialized_ast = semantic.Program.deserialize(serialized_ast_bytes)
-            return deserialized_ast
-        return [str(error) for error in ret[1:]]
-
-    def analyze_string(self, *args):
-        ret = super().analyze_string(*args)
-        if len(ret) == 1:
-            serialized_ast_str = str(ret[0])
-            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
-            deserialized_ast = semantic.Program.deserialize(serialized_ast_bytes)
-            return deserialized_ast
-        return [str(error) for error in ret[1:]]
-
-    @staticmethod
-    def parse_file_to_json(*args):
-        return libQasm.V3xAnalyzer.parse_file_to_json(*args)
-
-    @staticmethod
-    def parse_string_to_json(*args):
-        return libQasm.V3xAnalyzer.parse_string_to_json(*args)
-
-    def analyze_file_to_json(self, *args):
-        return super().analyze_file_to_json(*args)
-
-    def analyze_string_to_json(self, *args):
-        return super().analyze_string_to_json(*args)
+import cqasm.v3x.ast as ast
+import cqasm.v3x.semantic as semantic
+import libQasm
+
+
+class Analyzer(libQasm.V3xAnalyzer):
+    # parse_file and parse_string are static methods because they do not change the status of the analyzer
+    # Instead, they just invoke free functions that create a temporary instance of a parser
+    # analyze_file and analyze_string are not static methods because they change the status of the analyzer
+
+    # parse_file, parse_string, analyze_file, and analyze_string return a vector of strings
+    # If the length of the vector is 1, the string is a serialization of the AST
+    # Otherwise, it is a list of errors
+
+    @staticmethod
+    def parse_file(*args):
+        ret = libQasm.V3xAnalyzer.parse_file(*args)
+        if len(ret) == 1:
+            serialized_ast_str = str(ret[0])
+            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
+            deserialized_ast = ast.Root.deserialize(serialized_ast_bytes)
+            return deserialized_ast
+        return [str(error) for error in ret[1:]]
+
+    @staticmethod
+    def parse_string(*args):
+        ret = libQasm.V3xAnalyzer.parse_string(*args)
+        if len(ret) == 1:
+            serialized_ast_str = str(ret[0])
+            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
+            deserialized_ast = ast.Root.deserialize(serialized_ast_bytes)
+            return deserialized_ast
+        return [str(error) for error in ret[1:]]
+
+    def analyze_file(self, *args):
+        ret = super().analyze_file(*args)
+        if len(ret) == 1:
+            serialized_ast_str = str(ret[0])
+            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
+            deserialized_ast = semantic.Program.deserialize(serialized_ast_bytes)
+            return deserialized_ast
+        return [str(error) for error in ret[1:]]
+
+    def analyze_string(self, *args):
+        ret = super().analyze_string(*args)
+        if len(ret) == 1:
+            serialized_ast_str = str(ret[0])
+            serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
+            deserialized_ast = semantic.Program.deserialize(serialized_ast_bytes)
+            return deserialized_ast
+        return [str(error) for error in ret[1:]]
+
+    @staticmethod
+    def parse_file_to_json(*args):
+        return libQasm.V3xAnalyzer.parse_file_to_json(*args)
+
+    @staticmethod
+    def parse_string_to_json(*args):
+        return libQasm.V3xAnalyzer.parse_string_to_json(*args)
+
+    def analyze_file_to_json(self, *args):
+        return super().analyze_file_to_json(*args)
+
+    def analyze_string_to_json(self, *args):
+        return super().analyze_string_to_json(*args)
```

## cqasm/v3x/ast.py

```diff
@@ -1,11014 +1,11021 @@
-import functools
-import struct
-import cqasm.v3x.primitives
-
-
-_typemap = {}
-
-
-def _cbor_read_intlike(cbor, offset, info):
-    """Parses the additional information and reads any additional bytes it
-    specifies the existence of, and returns the encoded integer. offset
-    should point to the byte immediately following the initial byte. Returns
-    the encoded integer and the offset immediately following the object."""
-
-    # Info less than 24 is a shorthand for the integer itself.
-    if info < 24:
-        return info, offset
-
-    # 24 is 8-bit following the info byte.
-    if info == 24:
-        return cbor[offset], offset + 1
-
-    # 25 is 16-bit following the info byte.
-    if info == 25:
-        val, = struct.unpack('>H', cbor[offset:offset+2])
-        return val, offset + 2
-
-    # 26 is 32-bit following the info byte.
-    if info == 26:
-        val, = struct.unpack('>I', cbor[offset:offset+4])
-        return val, offset + 4
-
-    # 27 is 64-bit following the info byte.
-    if info == 27:
-        val, = struct.unpack('>Q', cbor[offset:offset+8])
-        return val, offset + 8
-
-    # Info greater than or equal to 28 is illegal. Note that 31 is used for
-    # indefinite lengths, so this must be checked prior to calling this
-    # method.
-    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
-
-
-def _sub_cbor_to_py(cbor, offset):
-    """Converts the CBOR object starting at cbor[offset] to its Python
-    representation for as far as tree-gen supports CBOR. Returns this Python
-    representation and the offset immediately following the CBOR representation
-    thereof. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    # Read the initial byte.
-    initial = cbor[offset]
-    typ = initial >> 5
-    info = initial & 0x1F
-    offset += 1
-
-    # Handle unsigned integer (0) and negative integer (1).
-    if typ <= 1:
-        value, offset = _cbor_read_intlike(cbor, offset, info)
-        if typ == 1:
-            value = -1 - value
-        return value, offset
-
-    # Handle byte string (2) and UTF-8 string (3).
-    if typ <= 3:
-
-        # Gather components of the string in here.
-        if info == 31:
-
-            # Handle indefinite length strings. These consist of a
-            # break-terminated (0xFF) list of definite-length strings of the
-            # same type.
-            value = []
-            while True:
-                sub_initial = cbor[offset]; offset += 1
-                if sub_initial == 0xFF:
-                    break
-                sub_typ = sub_initial >> 5
-                sub_info = sub_initial & 0x1F
-                if sub_typ != typ:
-                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
-
-                # Seek past definite-length string component. The size in
-                # bytes is encoded as an integer.
-                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
-                value.append(cbor[offset:offset + size])
-                offset += size
-            value = b''.join(value)
-
-        else:
-
-            # Handle definite-length strings. The size in bytes is encoded as
-            # an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            value = cbor[offset:offset + size]
-            offset += size
-
-        if typ == 3:
-            value = value.decode('UTF-8')
-        return value, offset
-
-    # Handle array (4) and map (5).
-    if typ <= 5:
-
-        # Create result container.
-        container = [] if typ == 4 else {}
-
-        # Handle indefinite length arrays and maps.
-        if info == 31:
-
-            # Read objects/object pairs until we encounter a break.
-            while cbor[offset] != 0xFF:
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-            # Seek past the break.
-            offset += 1
-
-        else:
-
-            # Handle definite-length arrays and maps. The amount of
-            # objects/object pairs is encoded as an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            for _ in range(size):
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-        return container, offset
-
-    # Handle semantic tags.
-    if typ == 6:
-
-        # We don't use semantic tags for anything, but ignoring them is
-        # legal and reading past them is easy enough.
-        _, offset = _cbor_read_intlike(cbor, offset, info)
-        return _sub_cbor_to_py(cbor, offset)
-
-    # Handle major type 7. Here, the type is defined by the additional info.
-    # Additional info 24 is reserved for having the type specified by the
-    # next byte, but all such values are unassigned.
-    if info == 20:
-        # false
-        return False, offset
-
-    if info == 21:
-        # true
-        return True, offset
-
-    if info == 22:
-        # null
-        return None, offset
-
-    if info == 23:
-        # Undefined value.
-        raise ValueError('invalid CBOR: undefined value is not supported')
-
-    if info == 25:
-        # Half-precision float.
-        raise ValueError('invalid CBOR: half-precision float is not supported')
-
-    if info == 26:
-        # Single-precision float.
-        raise ValueError('invalid CBOR: single-precision float is not supported')
-
-    if info == 27:
-        # Double-precision float.
-        value, = struct.unpack('>d', cbor[offset:offset+8])
-        return value, offset + 8
-
-    if info == 31:
-        # Break value used for indefinite-length objects.
-        raise ValueError('invalid CBOR: unexpected break')
-
-    raise ValueError('invalid CBOR: unknown type code')
-
-
-def _cbor_to_py(cbor):
-    """Converts the given CBOR object (bytes) to its Python representation for
-    as far as tree-gen supports CBOR. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    value, length = _sub_cbor_to_py(cbor, 0)
-    if length < len(cbor):
-        raise ValueError('invalid CBOR: garbage at the end')
-    return value
-
-
-class _Cbor(bytes):
-    """Marker class indicating that this bytes object represents CBOR."""
-    pass
-
-
-def _cbor_write_intlike(value, major=0):
-    """Converts the given integer to its minimal representation in CBOR. The
-    major code can be overridden to write lengths for strings, arrays, and
-    maps."""
-
-    # Negative integers use major code 1.
-    if value < 0:
-        major = 1
-        value = -1 - value
-    initial = major << 5
-
-    # Use the minimal representation.
-    if value < 24:
-        return struct.pack('>B', initial | value)
-    if value < 0x100:
-        return struct.pack('>BB', initial | 24, value)
-    if value < 0x10000:
-        return struct.pack('>BH', initial | 25, value)
-    if value < 0x100000000:
-        return struct.pack('>BI', initial | 26, value)
-    if value < 0x10000000000000000:
-        return struct.pack('>BQ', initial | 27, value)
-
-    raise ValueError('integer too large for CBOR (bigint not supported)')
-
-
-def _py_to_cbor(value, type_converter=None):
-    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
-    that takes a value and either converts it to a primitive for serialization,
-    converts it to a _Cbor object manually, or raises a TypeError if no
-    conversion is known. If no type_converter is specified, a TypeError is
-    raised in all cases the type_converter would otherwise be called. The cbor
-    serialization is returned using a _Cbor object, which is just a marker class
-    behaving just like bytes."""
-    if isinstance(value, _Cbor):
-        return value
-
-    if isinstance(value, int):
-        return _Cbor(_cbor_write_intlike(value))
-
-    if isinstance(value, float):
-        return _Cbor(struct.pack('>Bd', 0xFB, value))
-
-    if isinstance(value, str):
-        value = value.encode('UTF-8')
-        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
-
-    if isinstance(value, bytes):
-        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
-
-    if value is False:
-        return _Cbor(b'\xF4')
-
-    if value is True:
-        return _Cbor(b'\xF5')
-
-    if value is None:
-        return _Cbor(b'\xF6')
-
-    if isinstance(value, (list, tuple)):
-        cbor = [_cbor_write_intlike(len(value), 4)]
-        for val in value:
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if isinstance(value, dict):
-        cbor = [_cbor_write_intlike(len(value), 5)]
-        for key, val in sorted(value.items()):
-            if not isinstance(key, str):
-                raise TypeError('dict keys must be strings')
-            cbor.append(_py_to_cbor(key, type_converter))
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if type_converter is not None:
-        return _py_to_cbor(type_converter(value))
-
-    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
-
-
-class NotWellFormed(ValueError):
-    """Exception class for well-formedness checks."""
-
-    def __init__(self, msg):
-        super().__init__('not well-formed: ' + str(msg))
-
-
-class Node(object):
-    """Base class for nodes."""
-
-    __slots__ = ['_annot']
-
-    def __init__(self):
-        super().__init__()
-        self._annot = {}
-
-    def __getitem__(self, key):
-        """Returns the annotation object with the specified key, or raises
-        KeyError if not found."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        return self._annot[key]
-
-    def __setitem__(self, key, val):
-        """Assigns the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        self._annot[key] = val
-
-    def __delitem__(self, key):
-        """Deletes the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        del self._annot[key]
-
-    def __contains__(self, key):
-        """Returns whether an annotation exists for the specified key."""
-        return key in self._annot
-
-    @staticmethod
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it. Note that this is overridden
-        by the actual node class implementations; this base function does very
-        little."""
-        if id_map is None:
-            id_map = {}
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes. Note that this is
-        overridden by the actual node class implementations; this base function
-        always raises an exception."""
-        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
-
-    def check_well_formed(self):
-        """Checks whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links).
-
-        If it isn't well-formed, a NotWellFormed is thrown."""
-        self.check_complete()
-
-    def is_well_formed(self):
-        """Returns whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links)."""
-        try:
-            self.check_well_formed()
-            return True
-        except NotWellFormed:
-            return False
-
-    def copy(self):
-        """Returns a shallow copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
-
-    def clone(self):
-        """Returns a deep copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
-
-    @classmethod
-    def deserialize(cls, cbor):
-        """Attempts to deserialize the given cbor object (either as bytes or as
-        its Python primitive representation) into a node of this type."""
-        if isinstance(cbor, bytes):
-            cbor = _cbor_to_py(cbor)
-        seq_to_ob = {}
-        links = []
-        root = cls._deserialize(cbor, seq_to_ob, links)
-        for link_setter, seq in links:
-            ob = seq_to_ob.get(seq, None)
-            if ob is None:
-                raise ValueError('found link to nonexistent object')
-            link_setter(ob)
-        return root
-
-    def serialize(self):
-        """Serializes this node into its cbor representation in the form of a
-        bytes object."""
-        id_map = self.find_reachable()
-        self.check_complete(id_map)
-        return _py_to_cbor(self._serialize(id_map))
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        node_type = _typemap.get(cbor.get('@t'), None)
-        if node_type is None:
-            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
-        return node_type._deserialize(cbor, seq_to_ob, links)
-
-
-@functools.total_ordering
-class _Multiple(object):
-    """Base class for the Any* and Many* edge helper classes. Inheriting
-    classes must set the class constant _T to the node type they are made
-    for."""
-
-    __slots__ = ['_l']
-
-    def __init__(self,  *args, **kwargs):
-        super().__init__()
-        self._l = list(*args, **kwargs)
-        for idx, val in enumerate(self._l):
-            if not isinstance(val, self._T):
-                raise TypeError(
-                    'object {!r} at index {:d} is not an instance of {!r}'
-                    .format(val, idx, self._T))
-
-    def __repr__(self):
-        return '{}({!r})'.format(type(self).__name__, self._l)
-
-    def clone(self):
-        return self.__class__(map(lambda node: node.clone(), self._l))
-
-    def __len__(self):
-        return len(self._l)
-
-    def __getitem__(self, idx):
-        return self._l[idx]
-
-    def __setitem__(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, idx, self._T))
-        self._l[idx] = val
-
-    def __delitem__(self, idx):
-        del self._l[idx]
-
-    def __iter__(self):
-        return iter(self._l)
-
-    def __reversed__(self):
-        return reversed(self._l)
-
-    def __contains__(self, val):
-        return val in self._l
-
-    def append(self, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.append(val)
-
-    def extend(self, iterable):
-        for val in iterable:
-            self.append(val)
-
-    def insert(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.insert(idx, val)
-
-    def remote(self, val):
-        self._l.remove(val)
-
-    def pop(self, idx=-1):
-        return self._l.pop(idx)
-
-    def clear(self):
-        self._l.clear()
-
-    def idx(self, val, start=0, end=-1):
-        return self._l.idx(val, start, end)
-
-    def count(self, val):
-        return self._l.count(val)
-
-    def sort(self, key=None, reverse=False):
-        self._l.sort(key=key, reverse=reverse)
-
-    def reverse(self):
-        self._l.reverse()
-
-    def copy(self):
-        return self.__class__(self)
-
-    def __eq__(self, other):
-        if not isinstance(other, _Multiple):
-            return False
-        return self._l == other._l
-
-    def __lt__(self, other):
-        return self._l < other._l
-
-    def __iadd__(self, other):
-        self.extend(other)
-
-    def __add__(self, other):
-        copy = self.copy()
-        copy += other
-        return copy
-
-    def __imul__(self, other):
-        self._l *= other
-
-    def __mul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-    def __rmul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-
-class MultiNode(_Multiple):
-    """Wrapper for an edge with multiple Node objects."""
-
-    _T = Node
-
-
-def _cloned(obj):
-    """Attempts to clone the given object by calling its clone() method, if it
-    has one."""
-    if hasattr(obj, 'clone'):
-        return obj.clone()
-    return obj
-
-
-class Expression(Node):
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'BooleanLiteral':
-            return BooleanLiteral._deserialize(cbor, seq_to_ob, links)
-        if typ == 'IntegerLiteral':
-            return IntegerLiteral._deserialize(cbor, seq_to_ob, links)
-        if typ == 'FloatLiteral':
-            return FloatLiteral._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Index':
-            return Index._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Identifier':
-            return Identifier._deserialize(cbor, seq_to_ob, links)
-        if typ == 'FunctionCall':
-            return FunctionCall._deserialize(cbor, seq_to_ob, links)
-        if typ == 'UnaryMinusExpression':
-            return UnaryMinusExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseNotExpression':
-            return BitwiseNotExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalNotExpression':
-            return LogicalNotExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'PowerExpression':
-            return PowerExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ProductExpression':
-            return ProductExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'DivisionExpression':
-            return DivisionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ModuloExpression':
-            return ModuloExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'AdditionExpression':
-            return AdditionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'SubtractionExpression':
-            return SubtractionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ShiftLeftExpression':
-            return ShiftLeftExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ShiftRightExpression':
-            return ShiftRightExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpGtExpression':
-            return CmpGtExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpLtExpression':
-            return CmpLtExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpGeExpression':
-            return CmpGeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpLeExpression':
-            return CmpLeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpEqExpression':
-            return CmpEqExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpNeExpression':
-            return CmpNeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseAndExpression':
-            return BitwiseAndExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseXorExpression':
-            return BitwiseXorExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseOrExpression':
-            return BitwiseOrExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalAndExpression':
-            return LogicalAndExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalXorExpression':
-            return LogicalXorExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalOrExpression':
-            return LogicalOrExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'TernaryConditionalExpression':
-            return TernaryConditionalExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Expression'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiExpression(_Multiple):
-    """Wrapper for an edge with multiple Expression objects."""
-
-    _T = Expression
-
-
-_typemap['Expression'] = Expression
-
-class BinaryExpression(Expression):
-    __slots__ = [
-        '_attr_lhs',
-        '_attr_rhs',
-    ]
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__()
-        self.lhs = lhs
-        self.rhs = rhs
-
-    @property
-    def lhs(self):
-        return self._attr_lhs
-
-    @lhs.setter
-    def lhs(self, val):
-        if val is None:
-            del self.lhs
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('lhs must be of type Expression')
-            val = Expression(val)
-        self._attr_lhs = val
-
-    @lhs.deleter
-    def lhs(self):
-        self._attr_lhs = None
-
-    @property
-    def rhs(self):
-        return self._attr_rhs
-
-    @rhs.setter
-    def rhs(self, val):
-        if val is None:
-            del self.rhs
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('rhs must be of type Expression')
-            val = Expression(val)
-        self._attr_rhs = val
-
-    @rhs.deleter
-    def rhs(self):
-        self._attr_rhs = None
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'PowerExpression':
-            return PowerExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ProductExpression':
-            return ProductExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'DivisionExpression':
-            return DivisionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ModuloExpression':
-            return ModuloExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'AdditionExpression':
-            return AdditionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'SubtractionExpression':
-            return SubtractionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ShiftLeftExpression':
-            return ShiftLeftExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ShiftRightExpression':
-            return ShiftRightExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpGtExpression':
-            return CmpGtExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpLtExpression':
-            return CmpLtExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpGeExpression':
-            return CmpGeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpLeExpression':
-            return CmpLeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpEqExpression':
-            return CmpEqExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpNeExpression':
-            return CmpNeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseAndExpression':
-            return BitwiseAndExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseXorExpression':
-            return BitwiseXorExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseOrExpression':
-            return BitwiseOrExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalAndExpression':
-            return LogicalAndExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalXorExpression':
-            return LogicalXorExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalOrExpression':
-            return LogicalOrExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BinaryExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBinaryExpression(_Multiple):
-    """Wrapper for an edge with multiple BinaryExpression objects."""
-
-    _T = BinaryExpression
-
-
-_typemap['BinaryExpression'] = BinaryExpression
-
-class ArithmeticExpression(BinaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'PowerExpression':
-            return PowerExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ProductExpression':
-            return ProductExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'DivisionExpression':
-            return DivisionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ModuloExpression':
-            return ModuloExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'AdditionExpression':
-            return AdditionExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'SubtractionExpression':
-            return SubtractionExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ArithmeticExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiArithmeticExpression(_Multiple):
-    """Wrapper for an edge with multiple ArithmeticExpression objects."""
-
-    _T = ArithmeticExpression
-
-
-_typemap['ArithmeticExpression'] = ArithmeticExpression
-
-class AdditionExpression(ArithmeticExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, AdditionExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('AdditionExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return AdditionExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return AdditionExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'AdditionExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected AdditionExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the AdditionExpression node.
-        node = AdditionExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'AdditionExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiAdditionExpression(_Multiple):
-    """Wrapper for an edge with multiple AdditionExpression objects."""
-
-    _T = AdditionExpression
-
-
-_typemap['AdditionExpression'] = AdditionExpression
-
-class Annotated(Node):
-    """Represents a node that carries annotation data"""
-
-    __slots__ = [
-        '_attr_annotations',
-    ]
-
-    def __init__(
-        self,
-        annotations=None,
-    ):
-        super().__init__()
-        self.annotations = annotations
-
-    @property
-    def annotations(self):
-        """Zero or more annotations attached to this object."""
-        return self._attr_annotations
-
-    @annotations.setter
-    def annotations(self, val):
-        if val is None:
-            del self.annotations
-            return
-        if not isinstance(val, MultiAnnotationData):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('annotations must be of type MultiAnnotationData')
-            val = MultiAnnotationData(val)
-        self._attr_annotations = val
-
-    @annotations.deleter
-    def annotations(self):
-        self._attr_annotations = MultiAnnotationData()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Variable':
-            return Variable._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Gate':
-            return Gate._deserialize(cbor, seq_to_ob, links)
-        if typ == 'MeasureInstruction':
-            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Annotated'}
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiAnnotated(_Multiple):
-    """Wrapper for an edge with multiple Annotated objects."""
-
-    _T = Annotated
-
-
-_typemap['Annotated'] = Annotated
-
-class AnnotationData(Node):
-    __slots__ = [
-        '_attr_interface',
-        '_attr_operation',
-        '_attr_operands',
-    ]
-
-    def __init__(
-        self,
-        interface=None,
-        operation=None,
-        operands=None,
-    ):
-        super().__init__()
-        self.interface = interface
-        self.operation = operation
-        self.operands = operands
-
-    @property
-    def interface(self):
-        """The interface this annotation is intended for. If a target doesn't
-        support an interface, it should silently ignore the annotation."""
-        return self._attr_interface
-
-    @interface.setter
-    def interface(self, val):
-        if val is None:
-            del self.interface
-            return
-        if not isinstance(val, Identifier):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('interface must be of type Identifier')
-            val = Identifier(val)
-        self._attr_interface = val
-
-    @interface.deleter
-    def interface(self):
-        self._attr_interface = None
-
-    @property
-    def operation(self):
-        """The operation within the interface that this annotation is intended
-        for. If a target supports the corresponding interface but not the
-        operation, it should throw an error."""
-        return self._attr_operation
-
-    @operation.setter
-    def operation(self, val):
-        if val is None:
-            del self.operation
-            return
-        if not isinstance(val, Identifier):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operation must be of type Identifier')
-            val = Identifier(val)
-        self._attr_operation = val
-
-    @operation.deleter
-    def operation(self):
-        self._attr_operation = None
-
-    @property
-    def operands(self):
-        """Any operands attached to the annotation."""
-        return self._attr_operands
-
-    @operands.setter
-    def operands(self, val):
-        if val is None:
-            del self.operands
-            return
-        if not isinstance(val, ExpressionList):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operands must be of type ExpressionList')
-            val = ExpressionList(val)
-        self._attr_operands = val
-
-    @operands.deleter
-    def operands(self):
-        self._attr_operands = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, AnnotationData):
-            return False
-        if self.interface != other.interface:
-            return False
-        if self.operation != other.operation:
-            return False
-        if self.operands != other.operands:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('AnnotationData(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('interface: ')
-        if self.interface is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.interface.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('operation: ')
-        if self.operation is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.operation.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('operands: ')
-        if self.operands is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.operands.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_interface is not None:
-            self._attr_interface.find_reachable(id_map)
-        if self._attr_operation is not None:
-            self._attr_operation.find_reachable(id_map)
-        if self._attr_operands is not None:
-            self._attr_operands.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_interface is None:
-            raise NotWellFormed('interface is required but not set')
-        if self._attr_interface is not None:
-            self._attr_interface.check_complete(id_map)
-        if self._attr_operation is None:
-            raise NotWellFormed('operation is required but not set')
-        if self._attr_operation is not None:
-            self._attr_operation.check_complete(id_map)
-        if self._attr_operands is None:
-            raise NotWellFormed('operands is required but not set')
-        if self._attr_operands is not None:
-            self._attr_operands.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return AnnotationData(
-            interface=self._attr_interface,
-            operation=self._attr_operation,
-            operands=self._attr_operands
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return AnnotationData(
-            interface=_cloned(self._attr_interface),
-            operation=_cloned(self._attr_operation),
-            operands=_cloned(self._attr_operands)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'AnnotationData':
-            raise ValueError('found node serialization for ' + typ + ', but expected AnnotationData')
-
-        # Deserialize the interface field.
-        field = cbor.get('interface', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field interface')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field interface')
-        if field.get('@t', None) is None:
-            f_interface = None
-        else:
-            f_interface = Identifier._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the operation field.
-        field = cbor.get('operation', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operation')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field operation')
-        if field.get('@t', None) is None:
-            f_operation = None
-        else:
-            f_operation = Identifier._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the operands field.
-        field = cbor.get('operands', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operands')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field operands')
-        if field.get('@t', None) is None:
-            f_operands = None
-        else:
-            f_operands = ExpressionList._deserialize(field, seq_to_ob, links)
-
-        # Construct the AnnotationData node.
-        node = AnnotationData(f_interface, f_operation, f_operands)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'AnnotationData'}
-
-        # Serialize the interface field.
-        field = {'@T': '1'}
-        if self._attr_interface is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_interface._serialize(id_map))
-        cbor['interface'] = field
-
-        # Serialize the operation field.
-        field = {'@T': '1'}
-        if self._attr_operation is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_operation._serialize(id_map))
-        cbor['operation'] = field
-
-        # Serialize the operands field.
-        field = {'@T': '1'}
-        if self._attr_operands is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_operands._serialize(id_map))
-        cbor['operands'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiAnnotationData(_Multiple):
-    """Wrapper for an edge with multiple AnnotationData objects."""
-
-    _T = AnnotationData
-
-
-_typemap['AnnotationData'] = AnnotationData
-
-class BitwiseExpression(BinaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'BitwiseAndExpression':
-            return BitwiseAndExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseXorExpression':
-            return BitwiseXorExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseOrExpression':
-            return BitwiseOrExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBitwiseExpression(_Multiple):
-    """Wrapper for an edge with multiple BitwiseExpression objects."""
-
-    _T = BitwiseExpression
-
-
-_typemap['BitwiseExpression'] = BitwiseExpression
-
-class BitwiseAndExpression(BitwiseExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, BitwiseAndExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('BitwiseAndExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return BitwiseAndExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return BitwiseAndExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'BitwiseAndExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseAndExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the BitwiseAndExpression node.
-        node = BitwiseAndExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseAndExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBitwiseAndExpression(_Multiple):
-    """Wrapper for an edge with multiple BitwiseAndExpression objects."""
-
-    _T = BitwiseAndExpression
-
-
-_typemap['BitwiseAndExpression'] = BitwiseAndExpression
-
-class UnaryExpression(Expression):
-    __slots__ = [
-        '_attr_expr',
-    ]
-
-    def __init__(
-        self,
-        expr=None,
-    ):
-        super().__init__()
-        self.expr = expr
-
-    @property
-    def expr(self):
-        return self._attr_expr
-
-    @expr.setter
-    def expr(self, val):
-        if val is None:
-            del self.expr
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('expr must be of type Expression')
-            val = Expression(val)
-        self._attr_expr = val
-
-    @expr.deleter
-    def expr(self):
-        self._attr_expr = None
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'UnaryMinusExpression':
-            return UnaryMinusExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'BitwiseNotExpression':
-            return BitwiseNotExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalNotExpression':
-            return LogicalNotExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'UnaryExpression'}
-
-        # Serialize the expr field.
-        field = {'@T': '1'}
-        if self._attr_expr is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_expr._serialize(id_map))
-        cbor['expr'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiUnaryExpression(_Multiple):
-    """Wrapper for an edge with multiple UnaryExpression objects."""
-
-    _T = UnaryExpression
-
-
-_typemap['UnaryExpression'] = UnaryExpression
-
-class BitwiseNotExpression(UnaryExpression):
-    """One's complement."""
-
-    __slots__ = []
-
-    def __init__(
-        self,
-        expr=None,
-    ):
-        super().__init__(expr=expr)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, BitwiseNotExpression):
-            return False
-        if self.expr != other.expr:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('BitwiseNotExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('expr: ')
-        if self.expr is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_expr is not None:
-            self._attr_expr.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_expr is None:
-            raise NotWellFormed('expr is required but not set')
-        if self._attr_expr is not None:
-            self._attr_expr.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return BitwiseNotExpression(
-            expr=self._attr_expr
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return BitwiseNotExpression(
-            expr=_cloned(self._attr_expr)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'BitwiseNotExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseNotExpression')
-
-        # Deserialize the expr field.
-        field = cbor.get('expr', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field expr')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field expr')
-        if field.get('@t', None) is None:
-            f_expr = None
-        else:
-            f_expr = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the BitwiseNotExpression node.
-        node = BitwiseNotExpression(f_expr)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseNotExpression'}
-
-        # Serialize the expr field.
-        field = {'@T': '1'}
-        if self._attr_expr is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_expr._serialize(id_map))
-        cbor['expr'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBitwiseNotExpression(_Multiple):
-    """Wrapper for an edge with multiple BitwiseNotExpression objects."""
-
-    _T = BitwiseNotExpression
-
-
-_typemap['BitwiseNotExpression'] = BitwiseNotExpression
-
-class BitwiseOrExpression(BitwiseExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, BitwiseOrExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('BitwiseOrExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return BitwiseOrExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return BitwiseOrExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'BitwiseOrExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseOrExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the BitwiseOrExpression node.
-        node = BitwiseOrExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseOrExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBitwiseOrExpression(_Multiple):
-    """Wrapper for an edge with multiple BitwiseOrExpression objects."""
-
-    _T = BitwiseOrExpression
-
-
-_typemap['BitwiseOrExpression'] = BitwiseOrExpression
-
-class BitwiseXorExpression(BitwiseExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, BitwiseXorExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('BitwiseXorExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return BitwiseXorExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return BitwiseXorExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'BitwiseXorExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseXorExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the BitwiseXorExpression node.
-        node = BitwiseXorExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseXorExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBitwiseXorExpression(_Multiple):
-    """Wrapper for an edge with multiple BitwiseXorExpression objects."""
-
-    _T = BitwiseXorExpression
-
-
-_typemap['BitwiseXorExpression'] = BitwiseXorExpression
-
-class Block(Node):
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'GlobalBlock':
-            return GlobalBlock._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Block'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBlock(_Multiple):
-    """Wrapper for an edge with multiple Block objects."""
-
-    _T = Block
-
-
-_typemap['Block'] = Block
-
-class Statement(Annotated):
-    __slots__ = []
-
-    def __init__(
-        self,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Variable':
-            return Variable._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Gate':
-            return Gate._deserialize(cbor, seq_to_ob, links)
-        if typ == 'MeasureInstruction':
-            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Statement'}
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiStatement(_Multiple):
-    """Wrapper for an edge with multiple Statement objects."""
-
-    _T = Statement
-
-
-_typemap['Statement'] = Statement
-
-class BlockStatement(Statement):
-    __slots__ = []
-
-    def __init__(
-        self,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Variable':
-            return Variable._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Gate':
-            return Gate._deserialize(cbor, seq_to_ob, links)
-        if typ == 'MeasureInstruction':
-            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BlockStatement'}
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBlockStatement(_Multiple):
-    """Wrapper for an edge with multiple BlockStatement objects."""
-
-    _T = BlockStatement
-
-
-_typemap['BlockStatement'] = BlockStatement
-
-class BooleanLiteral(Expression):
-    __slots__ = [
-        '_attr_value',
-    ]
-
-    def __init__(
-        self,
-        value=None,
-    ):
-        super().__init__()
-        self.value = value
-
-    @property
-    def value(self):
-        return self._attr_value
-
-    @value.setter
-    def value(self, val):
-        if val is None:
-            del self.value
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Bool):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('value must be of type cqasm.v3x.primitives.Bool')
-            val = cqasm.v3x.primitives.Bool(val)
-        self._attr_value = val
-
-    @value.deleter
-    def value(self):
-        self._attr_value = cqasm.v3x.primitives.Bool()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, BooleanLiteral):
-            return False
-        if self.value != other.value:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('BooleanLiteral(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('value: ')
-        s.append(str(self.value) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return BooleanLiteral(
-            value=self._attr_value
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return BooleanLiteral(
-            value=_cloned(self._attr_value)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'BooleanLiteral':
-            raise ValueError('found node serialization for ' + typ + ', but expected BooleanLiteral')
-
-        # Deserialize the value field.
-        field = cbor.get('value', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field value')
-        if hasattr(cqasm.v3x.primitives.Bool, 'deserialize_cbor'):
-            f_value = cqasm.v3x.primitives.Bool.deserialize_cbor(field)
-        else:
-            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Bool, field)
-
-        # Construct the BooleanLiteral node.
-        node = BooleanLiteral(f_value)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'BooleanLiteral'}
-
-        # Serialize the value field.
-        if hasattr(self._attr_value, 'serialize_cbor'):
-            cbor['value'] = self._attr_value.serialize_cbor()
-        else:
-            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Bool, self._attr_value)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBooleanLiteral(_Multiple):
-    """Wrapper for an edge with multiple BooleanLiteral objects."""
-
-    _T = BooleanLiteral
-
-
-_typemap['BooleanLiteral'] = BooleanLiteral
-
-class EqualityExpression(BinaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'CmpEqExpression':
-            return CmpEqExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpNeExpression':
-            return CmpNeExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'EqualityExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiEqualityExpression(_Multiple):
-    """Wrapper for an edge with multiple EqualityExpression objects."""
-
-    _T = EqualityExpression
-
-
-_typemap['EqualityExpression'] = EqualityExpression
-
-class CmpEqExpression(EqualityExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, CmpEqExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('CmpEqExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return CmpEqExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return CmpEqExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'CmpEqExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected CmpEqExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the CmpEqExpression node.
-        node = CmpEqExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'CmpEqExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiCmpEqExpression(_Multiple):
-    """Wrapper for an edge with multiple CmpEqExpression objects."""
-
-    _T = CmpEqExpression
-
-
-_typemap['CmpEqExpression'] = CmpEqExpression
-
-class ComparisonExpression(BinaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'CmpGtExpression':
-            return CmpGtExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpLtExpression':
-            return CmpLtExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpGeExpression':
-            return CmpGeExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'CmpLeExpression':
-            return CmpLeExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ComparisonExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiComparisonExpression(_Multiple):
-    """Wrapper for an edge with multiple ComparisonExpression objects."""
-
-    _T = ComparisonExpression
-
-
-_typemap['ComparisonExpression'] = ComparisonExpression
-
-class CmpGeExpression(ComparisonExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, CmpGeExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('CmpGeExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return CmpGeExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return CmpGeExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'CmpGeExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected CmpGeExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the CmpGeExpression node.
-        node = CmpGeExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'CmpGeExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiCmpGeExpression(_Multiple):
-    """Wrapper for an edge with multiple CmpGeExpression objects."""
-
-    _T = CmpGeExpression
-
-
-_typemap['CmpGeExpression'] = CmpGeExpression
-
-class CmpGtExpression(ComparisonExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, CmpGtExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('CmpGtExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return CmpGtExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return CmpGtExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'CmpGtExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected CmpGtExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the CmpGtExpression node.
-        node = CmpGtExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'CmpGtExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiCmpGtExpression(_Multiple):
-    """Wrapper for an edge with multiple CmpGtExpression objects."""
-
-    _T = CmpGtExpression
-
-
-_typemap['CmpGtExpression'] = CmpGtExpression
-
-class CmpLeExpression(ComparisonExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, CmpLeExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('CmpLeExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return CmpLeExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return CmpLeExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'CmpLeExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected CmpLeExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the CmpLeExpression node.
-        node = CmpLeExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'CmpLeExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiCmpLeExpression(_Multiple):
-    """Wrapper for an edge with multiple CmpLeExpression objects."""
-
-    _T = CmpLeExpression
-
-
-_typemap['CmpLeExpression'] = CmpLeExpression
-
-class CmpLtExpression(ComparisonExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, CmpLtExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('CmpLtExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return CmpLtExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return CmpLtExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'CmpLtExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected CmpLtExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the CmpLtExpression node.
-        node = CmpLtExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'CmpLtExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiCmpLtExpression(_Multiple):
-    """Wrapper for an edge with multiple CmpLtExpression objects."""
-
-    _T = CmpLtExpression
-
-
-_typemap['CmpLtExpression'] = CmpLtExpression
-
-class CmpNeExpression(EqualityExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, CmpNeExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('CmpNeExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return CmpNeExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return CmpNeExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'CmpNeExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected CmpNeExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the CmpNeExpression node.
-        node = CmpNeExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'CmpNeExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiCmpNeExpression(_Multiple):
-    """Wrapper for an edge with multiple CmpNeExpression objects."""
-
-    _T = CmpNeExpression
-
-
-_typemap['CmpNeExpression'] = CmpNeExpression
-
-class DivisionExpression(ArithmeticExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, DivisionExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('DivisionExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return DivisionExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return DivisionExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'DivisionExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected DivisionExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the DivisionExpression node.
-        node = DivisionExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'DivisionExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiDivisionExpression(_Multiple):
-    """Wrapper for an edge with multiple DivisionExpression objects."""
-
-    _T = DivisionExpression
-
-
-_typemap['DivisionExpression'] = DivisionExpression
-
-class ExpressionList(Node):
-    __slots__ = [
-        '_attr_items',
-    ]
-
-    def __init__(
-        self,
-        items=None,
-    ):
-        super().__init__()
-        self.items = items
-
-    @property
-    def items(self):
-        return self._attr_items
-
-    @items.setter
-    def items(self, val):
-        if val is None:
-            del self.items
-            return
-        if not isinstance(val, MultiExpression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('items must be of type MultiExpression')
-            val = MultiExpression(val)
-        self._attr_items = val
-
-    @items.deleter
-    def items(self):
-        self._attr_items = MultiExpression()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ExpressionList):
-            return False
-        if self.items != other.items:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ExpressionList(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('items: ')
-        if not self.items:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.items:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        for el in self._attr_items:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        for child in self._attr_items:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ExpressionList(
-            items=self._attr_items.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ExpressionList(
-            items=_cloned(self._attr_items)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ExpressionList':
-            raise ValueError('found node serialization for ' + typ + ', but expected ExpressionList')
-
-        # Deserialize the items field.
-        field = cbor.get('items', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field items')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field items')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_items = MultiExpression()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_items.append(Expression._deserialize(element, seq_to_ob, links))
-
-        # Construct the ExpressionList node.
-        node = ExpressionList(f_items)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ExpressionList'}
-
-        # Serialize the items field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_items:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['items'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiExpressionList(_Multiple):
-    """Wrapper for an edge with multiple ExpressionList objects."""
-
-    _T = ExpressionList
-
-
-_typemap['ExpressionList'] = ExpressionList
-
-class FloatLiteral(Expression):
-    __slots__ = [
-        '_attr_value',
-    ]
-
-    def __init__(
-        self,
-        value=None,
-    ):
-        super().__init__()
-        self.value = value
-
-    @property
-    def value(self):
-        return self._attr_value
-
-    @value.setter
-    def value(self, val):
-        if val is None:
-            del self.value
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Float):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('value must be of type cqasm.v3x.primitives.Float')
-            val = cqasm.v3x.primitives.Float(val)
-        self._attr_value = val
-
-    @value.deleter
-    def value(self):
-        self._attr_value = cqasm.v3x.primitives.Float()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, FloatLiteral):
-            return False
-        if self.value != other.value:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('FloatLiteral(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('value: ')
-        s.append(str(self.value) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return FloatLiteral(
-            value=self._attr_value
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return FloatLiteral(
-            value=_cloned(self._attr_value)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'FloatLiteral':
-            raise ValueError('found node serialization for ' + typ + ', but expected FloatLiteral')
-
-        # Deserialize the value field.
-        field = cbor.get('value', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field value')
-        if hasattr(cqasm.v3x.primitives.Float, 'deserialize_cbor'):
-            f_value = cqasm.v3x.primitives.Float.deserialize_cbor(field)
-        else:
-            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Float, field)
-
-        # Construct the FloatLiteral node.
-        node = FloatLiteral(f_value)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'FloatLiteral'}
-
-        # Serialize the value field.
-        if hasattr(self._attr_value, 'serialize_cbor'):
-            cbor['value'] = self._attr_value.serialize_cbor()
-        else:
-            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Float, self._attr_value)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiFloatLiteral(_Multiple):
-    """Wrapper for an edge with multiple FloatLiteral objects."""
-
-    _T = FloatLiteral
-
-
-_typemap['FloatLiteral'] = FloatLiteral
-
-class FunctionCall(Expression):
-    __slots__ = [
-        '_attr_name',
-        '_attr_arguments',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-        arguments=None,
-    ):
-        super().__init__()
-        self.name = name
-        self.arguments = arguments
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, Identifier):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type Identifier')
-            val = Identifier(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = None
-
-    @property
-    def arguments(self):
-        return self._attr_arguments
-
-    @arguments.setter
-    def arguments(self, val):
-        if val is None:
-            del self.arguments
-            return
-        if not isinstance(val, ExpressionList):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('arguments must be of type ExpressionList')
-            val = ExpressionList(val)
-        self._attr_arguments = val
-
-    @arguments.deleter
-    def arguments(self):
-        self._attr_arguments = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, FunctionCall):
-            return False
-        if self.name != other.name:
-            return False
-        if self.arguments != other.arguments:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('FunctionCall(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        if self.name is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('arguments: ')
-        if self.arguments is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.arguments.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_name is not None:
-            self._attr_name.find_reachable(id_map)
-        if self._attr_arguments is not None:
-            self._attr_arguments.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_name is None:
-            raise NotWellFormed('name is required but not set')
-        if self._attr_name is not None:
-            self._attr_name.check_complete(id_map)
-        if self._attr_arguments is not None:
-            self._attr_arguments.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return FunctionCall(
-            name=self._attr_name,
-            arguments=self._attr_arguments
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return FunctionCall(
-            name=_cloned(self._attr_name),
-            arguments=_cloned(self._attr_arguments)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'FunctionCall':
-            raise ValueError('found node serialization for ' + typ + ', but expected FunctionCall')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field name')
-        if field.get('@t', None) is None:
-            f_name = None
-        else:
-            f_name = Identifier._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the arguments field.
-        field = cbor.get('arguments', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field arguments')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field arguments')
-        if field.get('@t', None) is None:
-            f_arguments = None
-        else:
-            f_arguments = ExpressionList._deserialize(field, seq_to_ob, links)
-
-        # Construct the FunctionCall node.
-        node = FunctionCall(f_name, f_arguments)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'FunctionCall'}
-
-        # Serialize the name field.
-        field = {'@T': '1'}
-        if self._attr_name is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_name._serialize(id_map))
-        cbor['name'] = field
-
-        # Serialize the arguments field.
-        field = {'@T': '?'}
-        if self._attr_arguments is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_arguments._serialize(id_map))
-        cbor['arguments'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiFunctionCall(_Multiple):
-    """Wrapper for an edge with multiple FunctionCall objects."""
-
-    _T = FunctionCall
-
-
-_typemap['FunctionCall'] = FunctionCall
-
-class Instruction(BlockStatement):
-    __slots__ = []
-
-    def __init__(
-        self,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Gate':
-            return Gate._deserialize(cbor, seq_to_ob, links)
-        if typ == 'MeasureInstruction':
-            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Instruction'}
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiInstruction(_Multiple):
-    """Wrapper for an edge with multiple Instruction objects."""
-
-    _T = Instruction
-
-
-_typemap['Instruction'] = Instruction
-
-class Gate(Instruction):
-    __slots__ = [
-        '_attr_name',
-        '_attr_operands',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-        operands=None,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-        self.name = name
-        self.operands = operands
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, Identifier):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type Identifier')
-            val = Identifier(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = None
-
-    @property
-    def operands(self):
-        return self._attr_operands
-
-    @operands.setter
-    def operands(self, val):
-        if val is None:
-            del self.operands
-            return
-        if not isinstance(val, ExpressionList):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operands must be of type ExpressionList')
-            val = ExpressionList(val)
-        self._attr_operands = val
-
-    @operands.deleter
-    def operands(self):
-        self._attr_operands = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Gate):
-            return False
-        if self.name != other.name:
-            return False
-        if self.operands != other.operands:
-            return False
-        if self.annotations != other.annotations:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Gate(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        if self.name is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('operands: ')
-        if self.operands is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.operands.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('annotations: ')
-        if not self.annotations:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.annotations:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_name is not None:
-            self._attr_name.find_reachable(id_map)
-        if self._attr_operands is not None:
-            self._attr_operands.find_reachable(id_map)
-        for el in self._attr_annotations:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_name is None:
-            raise NotWellFormed('name is required but not set')
-        if self._attr_name is not None:
-            self._attr_name.check_complete(id_map)
-        if self._attr_operands is None:
-            raise NotWellFormed('operands is required but not set')
-        if self._attr_operands is not None:
-            self._attr_operands.check_complete(id_map)
-        for child in self._attr_annotations:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Gate(
-            name=self._attr_name,
-            operands=self._attr_operands,
-            annotations=self._attr_annotations.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Gate(
-            name=_cloned(self._attr_name),
-            operands=_cloned(self._attr_operands),
-            annotations=_cloned(self._attr_annotations)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Gate':
-            raise ValueError('found node serialization for ' + typ + ', but expected Gate')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field name')
-        if field.get('@t', None) is None:
-            f_name = None
-        else:
-            f_name = Identifier._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the operands field.
-        field = cbor.get('operands', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operands')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field operands')
-        if field.get('@t', None) is None:
-            f_operands = None
-        else:
-            f_operands = ExpressionList._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the annotations field.
-        field = cbor.get('annotations', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field annotations')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field annotations')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_annotations = MultiAnnotationData()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
-
-        # Construct the Gate node.
-        node = Gate(f_name, f_operands, f_annotations)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Gate'}
-
-        # Serialize the name field.
-        field = {'@T': '1'}
-        if self._attr_name is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_name._serialize(id_map))
-        cbor['name'] = field
-
-        # Serialize the operands field.
-        field = {'@T': '1'}
-        if self._attr_operands is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_operands._serialize(id_map))
-        cbor['operands'] = field
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiGate(_Multiple):
-    """Wrapper for an edge with multiple Gate objects."""
-
-    _T = Gate
-
-
-_typemap['Gate'] = Gate
-
-class GlobalBlock(Block):
-    __slots__ = [
-        '_attr_qubit_variable_declaration',
-        '_attr_gates',
-        '_attr_measure_instruction',
-    ]
-
-    def __init__(
-        self,
-        qubit_variable_declaration=None,
-        gates=None,
-        measure_instruction=None,
-    ):
-        super().__init__()
-        self.qubit_variable_declaration = qubit_variable_declaration
-        self.gates = gates
-        self.measure_instruction = measure_instruction
-
-    @property
-    def qubit_variable_declaration(self):
-        return self._attr_qubit_variable_declaration
-
-    @qubit_variable_declaration.setter
-    def qubit_variable_declaration(self, val):
-        if val is None:
-            del self.qubit_variable_declaration
-            return
-        if not isinstance(val, Variable):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('qubit_variable_declaration must be of type Variable')
-            val = Variable(val)
-        self._attr_qubit_variable_declaration = val
-
-    @qubit_variable_declaration.deleter
-    def qubit_variable_declaration(self):
-        self._attr_qubit_variable_declaration = None
-
-    @property
-    def gates(self):
-        return self._attr_gates
-
-    @gates.setter
-    def gates(self, val):
-        if val is None:
-            del self.gates
-            return
-        if not isinstance(val, MultiGate):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('gates must be of type MultiGate')
-            val = MultiGate(val)
-        self._attr_gates = val
-
-    @gates.deleter
-    def gates(self):
-        self._attr_gates = MultiGate()
-
-    @property
-    def measure_instruction(self):
-        return self._attr_measure_instruction
-
-    @measure_instruction.setter
-    def measure_instruction(self, val):
-        if val is None:
-            del self.measure_instruction
-            return
-        if not isinstance(val, MeasureInstruction):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('measure_instruction must be of type MeasureInstruction')
-            val = MeasureInstruction(val)
-        self._attr_measure_instruction = val
-
-    @measure_instruction.deleter
-    def measure_instruction(self):
-        self._attr_measure_instruction = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, GlobalBlock):
-            return False
-        if self.qubit_variable_declaration != other.qubit_variable_declaration:
-            return False
-        if self.gates != other.gates:
-            return False
-        if self.measure_instruction != other.measure_instruction:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('GlobalBlock(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('qubit_variable_declaration: ')
-        if self.qubit_variable_declaration is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.qubit_variable_declaration.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('gates: ')
-        if not self.gates:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.gates:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        s.append('  '*indent)
-        s.append('measure_instruction: ')
-        if self.measure_instruction is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.measure_instruction.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.find_reachable(id_map)
-        for el in self._attr_gates:
-            el.find_reachable(id_map)
-        if self._attr_measure_instruction is not None:
-            self._attr_measure_instruction.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_qubit_variable_declaration is None:
-            raise NotWellFormed('qubit_variable_declaration is required but not set')
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.check_complete(id_map)
-        for child in self._attr_gates:
-            child.check_complete(id_map)
-        if self._attr_measure_instruction is not None:
-            self._attr_measure_instruction.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return GlobalBlock(
-            qubit_variable_declaration=self._attr_qubit_variable_declaration,
-            gates=self._attr_gates.copy(),
-            measure_instruction=self._attr_measure_instruction
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return GlobalBlock(
-            qubit_variable_declaration=_cloned(self._attr_qubit_variable_declaration),
-            gates=_cloned(self._attr_gates),
-            measure_instruction=_cloned(self._attr_measure_instruction)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'GlobalBlock':
-            raise ValueError('found node serialization for ' + typ + ', but expected GlobalBlock')
-
-        # Deserialize the qubit_variable_declaration field.
-        field = cbor.get('qubit_variable_declaration', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field qubit_variable_declaration')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field qubit_variable_declaration')
-        if field.get('@t', None) is None:
-            f_qubit_variable_declaration = None
-        else:
-            f_qubit_variable_declaration = Variable._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the gates field.
-        field = cbor.get('gates', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field gates')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field gates')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_gates = MultiGate()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_gates.append(Gate._deserialize(element, seq_to_ob, links))
-
-        # Deserialize the measure_instruction field.
-        field = cbor.get('measure_instruction', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field measure_instruction')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field measure_instruction')
-        if field.get('@t', None) is None:
-            f_measure_instruction = None
-        else:
-            f_measure_instruction = MeasureInstruction._deserialize(field, seq_to_ob, links)
-
-        # Construct the GlobalBlock node.
-        node = GlobalBlock(f_qubit_variable_declaration, f_gates, f_measure_instruction)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'GlobalBlock'}
-
-        # Serialize the qubit_variable_declaration field.
-        field = {'@T': '1'}
-        if self._attr_qubit_variable_declaration is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_qubit_variable_declaration._serialize(id_map))
-        cbor['qubit_variable_declaration'] = field
-
-        # Serialize the gates field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_gates:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['gates'] = field
-
-        # Serialize the measure_instruction field.
-        field = {'@T': '?'}
-        if self._attr_measure_instruction is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_measure_instruction._serialize(id_map))
-        cbor['measure_instruction'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiGlobalBlock(_Multiple):
-    """Wrapper for an edge with multiple GlobalBlock objects."""
-
-    _T = GlobalBlock
-
-
-_typemap['GlobalBlock'] = GlobalBlock
-
-class Identifier(Expression):
-    __slots__ = [
-        '_attr_name',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-    ):
-        super().__init__()
-        self.name = name
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Str):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
-            val = cqasm.v3x.primitives.Str(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = cqasm.v3x.primitives.Str()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Identifier):
-            return False
-        if self.name != other.name:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Identifier(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        s.append(str(self.name) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Identifier(
-            name=self._attr_name
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Identifier(
-            name=_cloned(self._attr_name)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Identifier':
-            raise ValueError('found node serialization for ' + typ + ', but expected Identifier')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
-            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
-        else:
-            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
-
-        # Construct the Identifier node.
-        node = Identifier(f_name)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Identifier'}
-
-        # Serialize the name field.
-        if hasattr(self._attr_name, 'serialize_cbor'):
-            cbor['name'] = self._attr_name.serialize_cbor()
-        else:
-            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIdentifier(_Multiple):
-    """Wrapper for an edge with multiple Identifier objects."""
-
-    _T = Identifier
-
-
-_typemap['Identifier'] = Identifier
-
-class Index(Expression):
-    __slots__ = [
-        '_attr_expr',
-        '_attr_indices',
-    ]
-
-    def __init__(
-        self,
-        expr=None,
-        indices=None,
-    ):
-        super().__init__()
-        self.expr = expr
-        self.indices = indices
-
-    @property
-    def expr(self):
-        return self._attr_expr
-
-    @expr.setter
-    def expr(self, val):
-        if val is None:
-            del self.expr
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('expr must be of type Expression')
-            val = Expression(val)
-        self._attr_expr = val
-
-    @expr.deleter
-    def expr(self):
-        self._attr_expr = None
-
-    @property
-    def indices(self):
-        return self._attr_indices
-
-    @indices.setter
-    def indices(self, val):
-        if val is None:
-            del self.indices
-            return
-        if not isinstance(val, IndexList):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('indices must be of type IndexList')
-            val = IndexList(val)
-        self._attr_indices = val
-
-    @indices.deleter
-    def indices(self):
-        self._attr_indices = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Index):
-            return False
-        if self.expr != other.expr:
-            return False
-        if self.indices != other.indices:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Index(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('expr: ')
-        if self.expr is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('indices: ')
-        if self.indices is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.indices.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_expr is not None:
-            self._attr_expr.find_reachable(id_map)
-        if self._attr_indices is not None:
-            self._attr_indices.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_expr is None:
-            raise NotWellFormed('expr is required but not set')
-        if self._attr_expr is not None:
-            self._attr_expr.check_complete(id_map)
-        if self._attr_indices is None:
-            raise NotWellFormed('indices is required but not set')
-        if self._attr_indices is not None:
-            self._attr_indices.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Index(
-            expr=self._attr_expr,
-            indices=self._attr_indices
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Index(
-            expr=_cloned(self._attr_expr),
-            indices=_cloned(self._attr_indices)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Index':
-            raise ValueError('found node serialization for ' + typ + ', but expected Index')
-
-        # Deserialize the expr field.
-        field = cbor.get('expr', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field expr')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field expr')
-        if field.get('@t', None) is None:
-            f_expr = None
-        else:
-            f_expr = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the indices field.
-        field = cbor.get('indices', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field indices')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field indices')
-        if field.get('@t', None) is None:
-            f_indices = None
-        else:
-            f_indices = IndexList._deserialize(field, seq_to_ob, links)
-
-        # Construct the Index node.
-        node = Index(f_expr, f_indices)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Index'}
-
-        # Serialize the expr field.
-        field = {'@T': '1'}
-        if self._attr_expr is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_expr._serialize(id_map))
-        cbor['expr'] = field
-
-        # Serialize the indices field.
-        field = {'@T': '1'}
-        if self._attr_indices is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_indices._serialize(id_map))
-        cbor['indices'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIndex(_Multiple):
-    """Wrapper for an edge with multiple Index objects."""
-
-    _T = Index
-
-
-_typemap['Index'] = Index
-
-class IndexEntry(Node):
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'IndexItem':
-            return IndexItem._deserialize(cbor, seq_to_ob, links)
-        if typ == 'IndexRange':
-            return IndexRange._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'IndexEntry'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIndexEntry(_Multiple):
-    """Wrapper for an edge with multiple IndexEntry objects."""
-
-    _T = IndexEntry
-
-
-_typemap['IndexEntry'] = IndexEntry
-
-class IndexItem(IndexEntry):
-    """Zero based."""
-
-    __slots__ = [
-        '_attr_index',
-    ]
-
-    def __init__(
-        self,
-        index=None,
-    ):
-        super().__init__()
-        self.index = index
-
-    @property
-    def index(self):
-        return self._attr_index
-
-    @index.setter
-    def index(self, val):
-        if val is None:
-            del self.index
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('index must be of type Expression')
-            val = Expression(val)
-        self._attr_index = val
-
-    @index.deleter
-    def index(self):
-        self._attr_index = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, IndexItem):
-            return False
-        if self.index != other.index:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('IndexItem(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('index: ')
-        if self.index is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.index.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_index is not None:
-            self._attr_index.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_index is None:
-            raise NotWellFormed('index is required but not set')
-        if self._attr_index is not None:
-            self._attr_index.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return IndexItem(
-            index=self._attr_index
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return IndexItem(
-            index=_cloned(self._attr_index)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'IndexItem':
-            raise ValueError('found node serialization for ' + typ + ', but expected IndexItem')
-
-        # Deserialize the index field.
-        field = cbor.get('index', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field index')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field index')
-        if field.get('@t', None) is None:
-            f_index = None
-        else:
-            f_index = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the IndexItem node.
-        node = IndexItem(f_index)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'IndexItem'}
-
-        # Serialize the index field.
-        field = {'@T': '1'}
-        if self._attr_index is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_index._serialize(id_map))
-        cbor['index'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIndexItem(_Multiple):
-    """Wrapper for an edge with multiple IndexItem objects."""
-
-    _T = IndexItem
-
-
-_typemap['IndexItem'] = IndexItem
-
-class IndexList(Node):
-    __slots__ = [
-        '_attr_items',
-    ]
-
-    def __init__(
-        self,
-        items=None,
-    ):
-        super().__init__()
-        self.items = items
-
-    @property
-    def items(self):
-        return self._attr_items
-
-    @items.setter
-    def items(self, val):
-        if val is None:
-            del self.items
-            return
-        if not isinstance(val, MultiIndexEntry):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('items must be of type MultiIndexEntry')
-            val = MultiIndexEntry(val)
-        self._attr_items = val
-
-    @items.deleter
-    def items(self):
-        self._attr_items = MultiIndexEntry()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, IndexList):
-            return False
-        if self.items != other.items:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('IndexList(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('items: ')
-        if not self.items:
-            s.append('!MISSING\n')
-        else:
-            s.append('[\n')
-            for child in self.items:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        for el in self._attr_items:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if not self._attr_items:
-            raise NotWellFormed('items needs at least one node but has zero')
-        for child in self._attr_items:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return IndexList(
-            items=self._attr_items.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return IndexList(
-            items=_cloned(self._attr_items)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'IndexList':
-            raise ValueError('found node serialization for ' + typ + ', but expected IndexList')
-
-        # Deserialize the items field.
-        field = cbor.get('items', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field items')
-        if field.get('@T') != '+':
-            raise ValueError('unexpected edge type for field items')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_items = MultiIndexEntry()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_items.append(IndexEntry._deserialize(element, seq_to_ob, links))
-
-        # Construct the IndexList node.
-        node = IndexList(f_items)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'IndexList'}
-
-        # Serialize the items field.
-        field = {'@T': '+'}
-        lst = []
-        for el in self._attr_items:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['items'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIndexList(_Multiple):
-    """Wrapper for an edge with multiple IndexList objects."""
-
-    _T = IndexList
-
-
-_typemap['IndexList'] = IndexList
-
-class IndexRange(IndexEntry):
-    """ Inclusive."""
-
-    __slots__ = [
-        '_attr_first',
-        '_attr_last',
-    ]
-
-    def __init__(
-        self,
-        first=None,
-        last=None,
-    ):
-        super().__init__()
-        self.first = first
-        self.last = last
-
-    @property
-    def first(self):
-        return self._attr_first
-
-    @first.setter
-    def first(self, val):
-        if val is None:
-            del self.first
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('first must be of type Expression')
-            val = Expression(val)
-        self._attr_first = val
-
-    @first.deleter
-    def first(self):
-        self._attr_first = None
-
-    @property
-    def last(self):
-        return self._attr_last
-
-    @last.setter
-    def last(self, val):
-        if val is None:
-            del self.last
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('last must be of type Expression')
-            val = Expression(val)
-        self._attr_last = val
-
-    @last.deleter
-    def last(self):
-        self._attr_last = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, IndexRange):
-            return False
-        if self.first != other.first:
-            return False
-        if self.last != other.last:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('IndexRange(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('first: ')
-        if self.first is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.first.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('last: ')
-        if self.last is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.last.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_first is not None:
-            self._attr_first.find_reachable(id_map)
-        if self._attr_last is not None:
-            self._attr_last.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_first is None:
-            raise NotWellFormed('first is required but not set')
-        if self._attr_first is not None:
-            self._attr_first.check_complete(id_map)
-        if self._attr_last is None:
-            raise NotWellFormed('last is required but not set')
-        if self._attr_last is not None:
-            self._attr_last.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return IndexRange(
-            first=self._attr_first,
-            last=self._attr_last
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return IndexRange(
-            first=_cloned(self._attr_first),
-            last=_cloned(self._attr_last)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'IndexRange':
-            raise ValueError('found node serialization for ' + typ + ', but expected IndexRange')
-
-        # Deserialize the first field.
-        field = cbor.get('first', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field first')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field first')
-        if field.get('@t', None) is None:
-            f_first = None
-        else:
-            f_first = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the last field.
-        field = cbor.get('last', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field last')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field last')
-        if field.get('@t', None) is None:
-            f_last = None
-        else:
-            f_last = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the IndexRange node.
-        node = IndexRange(f_first, f_last)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'IndexRange'}
-
-        # Serialize the first field.
-        field = {'@T': '1'}
-        if self._attr_first is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_first._serialize(id_map))
-        cbor['first'] = field
-
-        # Serialize the last field.
-        field = {'@T': '1'}
-        if self._attr_last is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_last._serialize(id_map))
-        cbor['last'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIndexRange(_Multiple):
-    """Wrapper for an edge with multiple IndexRange objects."""
-
-    _T = IndexRange
-
-
-_typemap['IndexRange'] = IndexRange
-
-class IntegerLiteral(Expression):
-    __slots__ = [
-        '_attr_value',
-    ]
-
-    def __init__(
-        self,
-        value=None,
-    ):
-        super().__init__()
-        self.value = value
-
-    @property
-    def value(self):
-        return self._attr_value
-
-    @value.setter
-    def value(self, val):
-        if val is None:
-            del self.value
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Int):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('value must be of type cqasm.v3x.primitives.Int')
-            val = cqasm.v3x.primitives.Int(val)
-        self._attr_value = val
-
-    @value.deleter
-    def value(self):
-        self._attr_value = cqasm.v3x.primitives.Int()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, IntegerLiteral):
-            return False
-        if self.value != other.value:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('IntegerLiteral(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('value: ')
-        s.append(str(self.value) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return IntegerLiteral(
-            value=self._attr_value
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return IntegerLiteral(
-            value=_cloned(self._attr_value)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'IntegerLiteral':
-            raise ValueError('found node serialization for ' + typ + ', but expected IntegerLiteral')
-
-        # Deserialize the value field.
-        field = cbor.get('value', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field value')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_value = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the IntegerLiteral node.
-        node = IntegerLiteral(f_value)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'IntegerLiteral'}
-
-        # Serialize the value field.
-        if hasattr(self._attr_value, 'serialize_cbor'):
-            cbor['value'] = self._attr_value.serialize_cbor()
-        else:
-            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_value)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIntegerLiteral(_Multiple):
-    """Wrapper for an edge with multiple IntegerLiteral objects."""
-
-    _T = IntegerLiteral
-
-
-_typemap['IntegerLiteral'] = IntegerLiteral
-
-class Keyword(Node):
-    __slots__ = [
-        '_attr_name',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-    ):
-        super().__init__()
-        self.name = name
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Str):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
-            val = cqasm.v3x.primitives.Str(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = cqasm.v3x.primitives.Str()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Keyword):
-            return False
-        if self.name != other.name:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Keyword(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        s.append(str(self.name) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Keyword(
-            name=self._attr_name
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Keyword(
-            name=_cloned(self._attr_name)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Keyword':
-            raise ValueError('found node serialization for ' + typ + ', but expected Keyword')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
-            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
-        else:
-            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
-
-        # Construct the Keyword node.
-        node = Keyword(f_name)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Keyword'}
-
-        # Serialize the name field.
-        if hasattr(self._attr_name, 'serialize_cbor'):
-            cbor['name'] = self._attr_name.serialize_cbor()
-        else:
-            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiKeyword(_Multiple):
-    """Wrapper for an edge with multiple Keyword objects."""
-
-    _T = Keyword
-
-
-_typemap['Keyword'] = Keyword
-
-class LogicalExpression(BinaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'LogicalAndExpression':
-            return LogicalAndExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalXorExpression':
-            return LogicalXorExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'LogicalOrExpression':
-            return LogicalOrExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'LogicalExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiLogicalExpression(_Multiple):
-    """Wrapper for an edge with multiple LogicalExpression objects."""
-
-    _T = LogicalExpression
-
-
-_typemap['LogicalExpression'] = LogicalExpression
-
-class LogicalAndExpression(LogicalExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, LogicalAndExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('LogicalAndExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return LogicalAndExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return LogicalAndExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'LogicalAndExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected LogicalAndExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the LogicalAndExpression node.
-        node = LogicalAndExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'LogicalAndExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiLogicalAndExpression(_Multiple):
-    """Wrapper for an edge with multiple LogicalAndExpression objects."""
-
-    _T = LogicalAndExpression
-
-
-_typemap['LogicalAndExpression'] = LogicalAndExpression
-
-class LogicalNotExpression(UnaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        expr=None,
-    ):
-        super().__init__(expr=expr)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, LogicalNotExpression):
-            return False
-        if self.expr != other.expr:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('LogicalNotExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('expr: ')
-        if self.expr is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_expr is not None:
-            self._attr_expr.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_expr is None:
-            raise NotWellFormed('expr is required but not set')
-        if self._attr_expr is not None:
-            self._attr_expr.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return LogicalNotExpression(
-            expr=self._attr_expr
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return LogicalNotExpression(
-            expr=_cloned(self._attr_expr)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'LogicalNotExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected LogicalNotExpression')
-
-        # Deserialize the expr field.
-        field = cbor.get('expr', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field expr')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field expr')
-        if field.get('@t', None) is None:
-            f_expr = None
-        else:
-            f_expr = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the LogicalNotExpression node.
-        node = LogicalNotExpression(f_expr)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'LogicalNotExpression'}
-
-        # Serialize the expr field.
-        field = {'@T': '1'}
-        if self._attr_expr is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_expr._serialize(id_map))
-        cbor['expr'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiLogicalNotExpression(_Multiple):
-    """Wrapper for an edge with multiple LogicalNotExpression objects."""
-
-    _T = LogicalNotExpression
-
-
-_typemap['LogicalNotExpression'] = LogicalNotExpression
-
-class LogicalOrExpression(LogicalExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, LogicalOrExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('LogicalOrExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return LogicalOrExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return LogicalOrExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'LogicalOrExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected LogicalOrExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the LogicalOrExpression node.
-        node = LogicalOrExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'LogicalOrExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiLogicalOrExpression(_Multiple):
-    """Wrapper for an edge with multiple LogicalOrExpression objects."""
-
-    _T = LogicalOrExpression
-
-
-_typemap['LogicalOrExpression'] = LogicalOrExpression
-
-class LogicalXorExpression(LogicalExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, LogicalXorExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('LogicalXorExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return LogicalXorExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return LogicalXorExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'LogicalXorExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected LogicalXorExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the LogicalXorExpression node.
-        node = LogicalXorExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'LogicalXorExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiLogicalXorExpression(_Multiple):
-    """Wrapper for an edge with multiple LogicalXorExpression objects."""
-
-    _T = LogicalXorExpression
-
-
-_typemap['LogicalXorExpression'] = LogicalXorExpression
-
-class MeasureInstruction(Instruction):
-    __slots__ = [
-        '_attr_name',
-        '_attr_operand',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-        operand=None,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-        self.name = name
-        self.operand = operand
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, Identifier):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type Identifier')
-            val = Identifier(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = None
-
-    @property
-    def operand(self):
-        return self._attr_operand
-
-    @operand.setter
-    def operand(self, val):
-        if val is None:
-            del self.operand
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operand must be of type Expression')
-            val = Expression(val)
-        self._attr_operand = val
-
-    @operand.deleter
-    def operand(self):
-        self._attr_operand = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, MeasureInstruction):
-            return False
-        if self.name != other.name:
-            return False
-        if self.operand != other.operand:
-            return False
-        if self.annotations != other.annotations:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('MeasureInstruction(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        if self.name is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('operand: ')
-        if self.operand is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.operand.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('annotations: ')
-        if not self.annotations:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.annotations:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_name is not None:
-            self._attr_name.find_reachable(id_map)
-        if self._attr_operand is not None:
-            self._attr_operand.find_reachable(id_map)
-        for el in self._attr_annotations:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_name is None:
-            raise NotWellFormed('name is required but not set')
-        if self._attr_name is not None:
-            self._attr_name.check_complete(id_map)
-        if self._attr_operand is None:
-            raise NotWellFormed('operand is required but not set')
-        if self._attr_operand is not None:
-            self._attr_operand.check_complete(id_map)
-        for child in self._attr_annotations:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return MeasureInstruction(
-            name=self._attr_name,
-            operand=self._attr_operand,
-            annotations=self._attr_annotations.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return MeasureInstruction(
-            name=_cloned(self._attr_name),
-            operand=_cloned(self._attr_operand),
-            annotations=_cloned(self._attr_annotations)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'MeasureInstruction':
-            raise ValueError('found node serialization for ' + typ + ', but expected MeasureInstruction')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field name')
-        if field.get('@t', None) is None:
-            f_name = None
-        else:
-            f_name = Identifier._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the operand field.
-        field = cbor.get('operand', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operand')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field operand')
-        if field.get('@t', None) is None:
-            f_operand = None
-        else:
-            f_operand = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the annotations field.
-        field = cbor.get('annotations', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field annotations')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field annotations')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_annotations = MultiAnnotationData()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
-
-        # Construct the MeasureInstruction node.
-        node = MeasureInstruction(f_name, f_operand, f_annotations)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'MeasureInstruction'}
-
-        # Serialize the name field.
-        field = {'@T': '1'}
-        if self._attr_name is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_name._serialize(id_map))
-        cbor['name'] = field
-
-        # Serialize the operand field.
-        field = {'@T': '1'}
-        if self._attr_operand is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_operand._serialize(id_map))
-        cbor['operand'] = field
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiMeasureInstruction(_Multiple):
-    """Wrapper for an edge with multiple MeasureInstruction objects."""
-
-    _T = MeasureInstruction
-
-
-_typemap['MeasureInstruction'] = MeasureInstruction
-
-class ModuloExpression(ArithmeticExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ModuloExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ModuloExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ModuloExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ModuloExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ModuloExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected ModuloExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the ModuloExpression node.
-        node = ModuloExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ModuloExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiModuloExpression(_Multiple):
-    """Wrapper for an edge with multiple ModuloExpression objects."""
-
-    _T = ModuloExpression
-
-
-_typemap['ModuloExpression'] = ModuloExpression
-
-class PowerExpression(ArithmeticExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, PowerExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('PowerExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return PowerExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return PowerExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'PowerExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected PowerExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the PowerExpression node.
-        node = PowerExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'PowerExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiPowerExpression(_Multiple):
-    """Wrapper for an edge with multiple PowerExpression objects."""
-
-    _T = PowerExpression
-
-
-_typemap['PowerExpression'] = PowerExpression
-
-class ProductExpression(ArithmeticExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ProductExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ProductExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ProductExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ProductExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ProductExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected ProductExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the ProductExpression node.
-        node = ProductExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ProductExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiProductExpression(_Multiple):
-    """Wrapper for an edge with multiple ProductExpression objects."""
-
-    _T = ProductExpression
-
-
-_typemap['ProductExpression'] = ProductExpression
-
-class Root(Node):
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Program':
-            return Program._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Root'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiRoot(_Multiple):
-    """Wrapper for an edge with multiple Root objects."""
-
-    _T = Root
-
-
-_typemap['Root'] = Root
-
-class Program(Root):
-    __slots__ = [
-        '_attr_version',
-        '_attr_block',
-    ]
-
-    def __init__(
-        self,
-        version=None,
-        block=None,
-    ):
-        super().__init__()
-        self.version = version
-        self.block = block
-
-    @property
-    def version(self):
-        return self._attr_version
-
-    @version.setter
-    def version(self, val):
-        if val is None:
-            del self.version
-            return
-        if not isinstance(val, Version):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('version must be of type Version')
-            val = Version(val)
-        self._attr_version = val
-
-    @version.deleter
-    def version(self):
-        self._attr_version = None
-
-    @property
-    def block(self):
-        return self._attr_block
-
-    @block.setter
-    def block(self, val):
-        if val is None:
-            del self.block
-            return
-        if not isinstance(val, GlobalBlock):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('block must be of type GlobalBlock')
-            val = GlobalBlock(val)
-        self._attr_block = val
-
-    @block.deleter
-    def block(self):
-        self._attr_block = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Program):
-            return False
-        if self.version != other.version:
-            return False
-        if self.block != other.block:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Program(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('version: ')
-        if self.version is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.version.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('block: ')
-        if self.block is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.block.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_version is not None:
-            self._attr_version.find_reachable(id_map)
-        if self._attr_block is not None:
-            self._attr_block.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_version is None:
-            raise NotWellFormed('version is required but not set')
-        if self._attr_version is not None:
-            self._attr_version.check_complete(id_map)
-        if self._attr_block is not None:
-            self._attr_block.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Program(
-            version=self._attr_version,
-            block=self._attr_block
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Program(
-            version=_cloned(self._attr_version),
-            block=_cloned(self._attr_block)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Program':
-            raise ValueError('found node serialization for ' + typ + ', but expected Program')
-
-        # Deserialize the version field.
-        field = cbor.get('version', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field version')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field version')
-        if field.get('@t', None) is None:
-            f_version = None
-        else:
-            f_version = Version._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the block field.
-        field = cbor.get('block', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field block')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field block')
-        if field.get('@t', None) is None:
-            f_block = None
-        else:
-            f_block = GlobalBlock._deserialize(field, seq_to_ob, links)
-
-        # Construct the Program node.
-        node = Program(f_version, f_block)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Program'}
-
-        # Serialize the version field.
-        field = {'@T': '1'}
-        if self._attr_version is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_version._serialize(id_map))
-        cbor['version'] = field
-
-        # Serialize the block field.
-        field = {'@T': '?'}
-        if self._attr_block is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_block._serialize(id_map))
-        cbor['block'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiProgram(_Multiple):
-    """Wrapper for an edge with multiple Program objects."""
-
-    _T = Program
-
-
-_typemap['Program'] = Program
-
-class ShiftExpression(BinaryExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'ShiftLeftExpression':
-            return ShiftLeftExpression._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ShiftRightExpression':
-            return ShiftRightExpression._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ShiftExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiShiftExpression(_Multiple):
-    """Wrapper for an edge with multiple ShiftExpression objects."""
-
-    _T = ShiftExpression
-
-
-_typemap['ShiftExpression'] = ShiftExpression
-
-class ShiftLeftExpression(ShiftExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ShiftLeftExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ShiftLeftExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ShiftLeftExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ShiftLeftExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ShiftLeftExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected ShiftLeftExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the ShiftLeftExpression node.
-        node = ShiftLeftExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ShiftLeftExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiShiftLeftExpression(_Multiple):
-    """Wrapper for an edge with multiple ShiftLeftExpression objects."""
-
-    _T = ShiftLeftExpression
-
-
-_typemap['ShiftLeftExpression'] = ShiftLeftExpression
-
-class ShiftRightExpression(ShiftExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ShiftRightExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ShiftRightExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ShiftRightExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ShiftRightExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ShiftRightExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected ShiftRightExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the ShiftRightExpression node.
-        node = ShiftRightExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ShiftRightExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiShiftRightExpression(_Multiple):
-    """Wrapper for an edge with multiple ShiftRightExpression objects."""
-
-    _T = ShiftRightExpression
-
-
-_typemap['ShiftRightExpression'] = ShiftRightExpression
-
-class SubtractionExpression(ArithmeticExpression):
-    __slots__ = []
-
-    def __init__(
-        self,
-        lhs=None,
-        rhs=None,
-    ):
-        super().__init__(lhs=lhs, rhs=rhs)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, SubtractionExpression):
-            return False
-        if self.lhs != other.lhs:
-            return False
-        if self.rhs != other.rhs:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('SubtractionExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('lhs: ')
-        if self.lhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('rhs: ')
-        if self.rhs is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_lhs is not None:
-            self._attr_lhs.find_reachable(id_map)
-        if self._attr_rhs is not None:
-            self._attr_rhs.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_lhs is None:
-            raise NotWellFormed('lhs is required but not set')
-        if self._attr_lhs is not None:
-            self._attr_lhs.check_complete(id_map)
-        if self._attr_rhs is None:
-            raise NotWellFormed('rhs is required but not set')
-        if self._attr_rhs is not None:
-            self._attr_rhs.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return SubtractionExpression(
-            lhs=self._attr_lhs,
-            rhs=self._attr_rhs
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return SubtractionExpression(
-            lhs=_cloned(self._attr_lhs),
-            rhs=_cloned(self._attr_rhs)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'SubtractionExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected SubtractionExpression')
-
-        # Deserialize the lhs field.
-        field = cbor.get('lhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field lhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field lhs')
-        if field.get('@t', None) is None:
-            f_lhs = None
-        else:
-            f_lhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the rhs field.
-        field = cbor.get('rhs', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field rhs')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field rhs')
-        if field.get('@t', None) is None:
-            f_rhs = None
-        else:
-            f_rhs = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the SubtractionExpression node.
-        node = SubtractionExpression(f_lhs, f_rhs)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'SubtractionExpression'}
-
-        # Serialize the lhs field.
-        field = {'@T': '1'}
-        if self._attr_lhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_lhs._serialize(id_map))
-        cbor['lhs'] = field
-
-        # Serialize the rhs field.
-        field = {'@T': '1'}
-        if self._attr_rhs is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_rhs._serialize(id_map))
-        cbor['rhs'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiSubtractionExpression(_Multiple):
-    """Wrapper for an edge with multiple SubtractionExpression objects."""
-
-    _T = SubtractionExpression
-
-
-_typemap['SubtractionExpression'] = SubtractionExpression
-
-class TernaryConditionalExpression(Expression):
-    __slots__ = [
-        '_attr_cond',
-        '_attr_if_true',
-        '_attr_if_false',
-    ]
-
-    def __init__(
-        self,
-        cond=None,
-        if_true=None,
-        if_false=None,
-    ):
-        super().__init__()
-        self.cond = cond
-        self.if_true = if_true
-        self.if_false = if_false
-
-    @property
-    def cond(self):
-        return self._attr_cond
-
-    @cond.setter
-    def cond(self, val):
-        if val is None:
-            del self.cond
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('cond must be of type Expression')
-            val = Expression(val)
-        self._attr_cond = val
-
-    @cond.deleter
-    def cond(self):
-        self._attr_cond = None
-
-    @property
-    def if_true(self):
-        return self._attr_if_true
-
-    @if_true.setter
-    def if_true(self, val):
-        if val is None:
-            del self.if_true
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('if_true must be of type Expression')
-            val = Expression(val)
-        self._attr_if_true = val
-
-    @if_true.deleter
-    def if_true(self):
-        self._attr_if_true = None
-
-    @property
-    def if_false(self):
-        return self._attr_if_false
-
-    @if_false.setter
-    def if_false(self, val):
-        if val is None:
-            del self.if_false
-            return
-        if not isinstance(val, Expression):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('if_false must be of type Expression')
-            val = Expression(val)
-        self._attr_if_false = val
-
-    @if_false.deleter
-    def if_false(self):
-        self._attr_if_false = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, TernaryConditionalExpression):
-            return False
-        if self.cond != other.cond:
-            return False
-        if self.if_true != other.if_true:
-            return False
-        if self.if_false != other.if_false:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('TernaryConditionalExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('cond: ')
-        if self.cond is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.cond.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('if_true: ')
-        if self.if_true is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.if_true.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('if_false: ')
-        if self.if_false is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.if_false.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_cond is not None:
-            self._attr_cond.find_reachable(id_map)
-        if self._attr_if_true is not None:
-            self._attr_if_true.find_reachable(id_map)
-        if self._attr_if_false is not None:
-            self._attr_if_false.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_cond is None:
-            raise NotWellFormed('cond is required but not set')
-        if self._attr_cond is not None:
-            self._attr_cond.check_complete(id_map)
-        if self._attr_if_true is None:
-            raise NotWellFormed('if_true is required but not set')
-        if self._attr_if_true is not None:
-            self._attr_if_true.check_complete(id_map)
-        if self._attr_if_false is None:
-            raise NotWellFormed('if_false is required but not set')
-        if self._attr_if_false is not None:
-            self._attr_if_false.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return TernaryConditionalExpression(
-            cond=self._attr_cond,
-            if_true=self._attr_if_true,
-            if_false=self._attr_if_false
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return TernaryConditionalExpression(
-            cond=_cloned(self._attr_cond),
-            if_true=_cloned(self._attr_if_true),
-            if_false=_cloned(self._attr_if_false)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'TernaryConditionalExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected TernaryConditionalExpression')
-
-        # Deserialize the cond field.
-        field = cbor.get('cond', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field cond')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field cond')
-        if field.get('@t', None) is None:
-            f_cond = None
-        else:
-            f_cond = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the if_true field.
-        field = cbor.get('if_true', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field if_true')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field if_true')
-        if field.get('@t', None) is None:
-            f_if_true = None
-        else:
-            f_if_true = Expression._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the if_false field.
-        field = cbor.get('if_false', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field if_false')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field if_false')
-        if field.get('@t', None) is None:
-            f_if_false = None
-        else:
-            f_if_false = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the TernaryConditionalExpression node.
-        node = TernaryConditionalExpression(f_cond, f_if_true, f_if_false)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'TernaryConditionalExpression'}
-
-        # Serialize the cond field.
-        field = {'@T': '1'}
-        if self._attr_cond is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_cond._serialize(id_map))
-        cbor['cond'] = field
-
-        # Serialize the if_true field.
-        field = {'@T': '1'}
-        if self._attr_if_true is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_if_true._serialize(id_map))
-        cbor['if_true'] = field
-
-        # Serialize the if_false field.
-        field = {'@T': '1'}
-        if self._attr_if_false is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_if_false._serialize(id_map))
-        cbor['if_false'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiTernaryConditionalExpression(_Multiple):
-    """Wrapper for an edge with multiple TernaryConditionalExpression objects.
-    """
-
-    _T = TernaryConditionalExpression
-
-
-_typemap['TernaryConditionalExpression'] = TernaryConditionalExpression
-
-class Type(Node):
-    __slots__ = [
-        '_attr_name',
-        '_attr_size',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-        size=None,
-    ):
-        super().__init__()
-        self.name = name
-        self.size = size
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, Keyword):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type Keyword')
-            val = Keyword(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = None
-
-    @property
-    def size(self):
-        return self._attr_size
-
-    @size.setter
-    def size(self, val):
-        if val is None:
-            del self.size
-            return
-        if not isinstance(val, IntegerLiteral):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('size must be of type IntegerLiteral')
-            val = IntegerLiteral(val)
-        self._attr_size = val
-
-    @size.deleter
-    def size(self):
-        self._attr_size = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Type):
-            return False
-        if self.name != other.name:
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Type(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        if self.name is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('size: ')
-        if self.size is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.size.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_name is not None:
-            self._attr_name.find_reachable(id_map)
-        if self._attr_size is not None:
-            self._attr_size.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_name is None:
-            raise NotWellFormed('name is required but not set')
-        if self._attr_name is not None:
-            self._attr_name.check_complete(id_map)
-        if self._attr_size is not None:
-            self._attr_size.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Type(
-            name=self._attr_name,
-            size=self._attr_size
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Type(
-            name=_cloned(self._attr_name),
-            size=_cloned(self._attr_size)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Type':
-            raise ValueError('found node serialization for ' + typ + ', but expected Type')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field name')
-        if field.get('@t', None) is None:
-            f_name = None
-        else:
-            f_name = Keyword._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the size field.
-        field = cbor.get('size', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field size')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field size')
-        if field.get('@t', None) is None:
-            f_size = None
-        else:
-            f_size = IntegerLiteral._deserialize(field, seq_to_ob, links)
-
-        # Construct the Type node.
-        node = Type(f_name, f_size)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Type'}
-
-        # Serialize the name field.
-        field = {'@T': '1'}
-        if self._attr_name is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_name._serialize(id_map))
-        cbor['name'] = field
-
-        # Serialize the size field.
-        field = {'@T': '?'}
-        if self._attr_size is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_size._serialize(id_map))
-        cbor['size'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiType(_Multiple):
-    """Wrapper for an edge with multiple Type objects."""
-
-    _T = Type
-
-
-_typemap['Type'] = Type
-
-class UnaryMinusExpression(UnaryExpression):
-    """Two's complement."""
-
-    __slots__ = []
-
-    def __init__(
-        self,
-        expr=None,
-    ):
-        super().__init__(expr=expr)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, UnaryMinusExpression):
-            return False
-        if self.expr != other.expr:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('UnaryMinusExpression(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('expr: ')
-        if self.expr is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_expr is not None:
-            self._attr_expr.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_expr is None:
-            raise NotWellFormed('expr is required but not set')
-        if self._attr_expr is not None:
-            self._attr_expr.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return UnaryMinusExpression(
-            expr=self._attr_expr
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return UnaryMinusExpression(
-            expr=_cloned(self._attr_expr)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'UnaryMinusExpression':
-            raise ValueError('found node serialization for ' + typ + ', but expected UnaryMinusExpression')
-
-        # Deserialize the expr field.
-        field = cbor.get('expr', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field expr')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field expr')
-        if field.get('@t', None) is None:
-            f_expr = None
-        else:
-            f_expr = Expression._deserialize(field, seq_to_ob, links)
-
-        # Construct the UnaryMinusExpression node.
-        node = UnaryMinusExpression(f_expr)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'UnaryMinusExpression'}
-
-        # Serialize the expr field.
-        field = {'@T': '1'}
-        if self._attr_expr is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_expr._serialize(id_map))
-        cbor['expr'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiUnaryMinusExpression(_Multiple):
-    """Wrapper for an edge with multiple UnaryMinusExpression objects."""
-
-    _T = UnaryMinusExpression
-
-
-_typemap['UnaryMinusExpression'] = UnaryMinusExpression
-
-class Variable(BlockStatement):
-    """One variable declaration of some type."""
-
-    __slots__ = [
-        '_attr_name',
-        '_attr_typ',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-        typ=None,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-        self.name = name
-        self.typ = typ
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, Identifier):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type Identifier')
-            val = Identifier(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = None
-
-    @property
-    def typ(self):
-        return self._attr_typ
-
-    @typ.setter
-    def typ(self, val):
-        if val is None:
-            del self.typ
-            return
-        if not isinstance(val, Type):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('typ must be of type Type')
-            val = Type(val)
-        self._attr_typ = val
-
-    @typ.deleter
-    def typ(self):
-        self._attr_typ = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Variable):
-            return False
-        if self.name != other.name:
-            return False
-        if self.typ != other.typ:
-            return False
-        if self.annotations != other.annotations:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Variable(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        if self.name is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('typ: ')
-        if self.typ is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.typ.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('annotations: ')
-        if not self.annotations:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.annotations:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_name is not None:
-            self._attr_name.find_reachable(id_map)
-        if self._attr_typ is not None:
-            self._attr_typ.find_reachable(id_map)
-        for el in self._attr_annotations:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_name is None:
-            raise NotWellFormed('name is required but not set')
-        if self._attr_name is not None:
-            self._attr_name.check_complete(id_map)
-        if self._attr_typ is None:
-            raise NotWellFormed('typ is required but not set')
-        if self._attr_typ is not None:
-            self._attr_typ.check_complete(id_map)
-        for child in self._attr_annotations:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Variable(
-            name=self._attr_name,
-            typ=self._attr_typ,
-            annotations=self._attr_annotations.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Variable(
-            name=_cloned(self._attr_name),
-            typ=_cloned(self._attr_typ),
-            annotations=_cloned(self._attr_annotations)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Variable':
-            raise ValueError('found node serialization for ' + typ + ', but expected Variable')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field name')
-        if field.get('@t', None) is None:
-            f_name = None
-        else:
-            f_name = Identifier._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the typ field.
-        field = cbor.get('typ', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field typ')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field typ')
-        if field.get('@t', None) is None:
-            f_typ = None
-        else:
-            f_typ = Type._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the annotations field.
-        field = cbor.get('annotations', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field annotations')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field annotations')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_annotations = MultiAnnotationData()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
-
-        # Construct the Variable node.
-        node = Variable(f_name, f_typ, f_annotations)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Variable'}
-
-        # Serialize the name field.
-        field = {'@T': '1'}
-        if self._attr_name is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_name._serialize(id_map))
-        cbor['name'] = field
-
-        # Serialize the typ field.
-        field = {'@T': '1'}
-        if self._attr_typ is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_typ._serialize(id_map))
-        cbor['typ'] = field
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiVariable(_Multiple):
-    """Wrapper for an edge with multiple Variable objects."""
-
-    _T = Variable
-
-
-_typemap['Variable'] = Variable
-
-class Version(Node):
-    __slots__ = [
-        '_attr_items',
-    ]
-
-    def __init__(
-        self,
-        items=None,
-    ):
-        super().__init__()
-        self.items = items
-
-    @property
-    def items(self):
-        return self._attr_items
-
-    @items.setter
-    def items(self, val):
-        if val is None:
-            del self.items
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Version):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('items must be of type cqasm.v3x.primitives.Version')
-            val = cqasm.v3x.primitives.Version(val)
-        self._attr_items = val
-
-    @items.deleter
-    def items(self):
-        self._attr_items = cqasm.v3x.primitives.Version()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Version):
-            return False
-        if self.items != other.items:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Version(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('items: ')
-        s.append(str(self.items) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Version(
-            items=self._attr_items
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Version(
-            items=_cloned(self._attr_items)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Version':
-            raise ValueError('found node serialization for ' + typ + ', but expected Version')
-
-        # Deserialize the items field.
-        field = cbor.get('items', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field items')
-        if hasattr(cqasm.v3x.primitives.Version, 'deserialize_cbor'):
-            f_items = cqasm.v3x.primitives.Version.deserialize_cbor(field)
-        else:
-            f_items = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Version, field)
-
-        # Construct the Version node.
-        node = Version(f_items)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Version'}
-
-        # Serialize the items field.
-        if hasattr(self._attr_items, 'serialize_cbor'):
-            cbor['items'] = self._attr_items.serialize_cbor()
-        else:
-            cbor['items'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Version, self._attr_items)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiVersion(_Multiple):
-    """Wrapper for an edge with multiple Version objects."""
-
-    _T = Version
-
-
-_typemap['Version'] = Version
-
+import functools
+import struct
+import cqasm.v3x.primitives
+
+
+_typemap = {}
+
+
+def _cbor_read_intlike(cbor, offset, info):
+    """Parses the additional information and reads any additional bytes it
+    specifies the existence of, and returns the encoded integer. offset
+    should point to the byte immediately following the initial byte. Returns
+    the encoded integer and the offset immediately following the object."""
+
+    # Info less than 24 is a shorthand for the integer itself.
+    if info < 24:
+        return info, offset
+
+    # 24 is 8-bit following the info byte.
+    if info == 24:
+        return cbor[offset], offset + 1
+
+    # 25 is 16-bit following the info byte.
+    if info == 25:
+        val, = struct.unpack('>H', cbor[offset:offset+2])
+        return val, offset + 2
+
+    # 26 is 32-bit following the info byte.
+    if info == 26:
+        val, = struct.unpack('>I', cbor[offset:offset+4])
+        return val, offset + 4
+
+    # 27 is 64-bit following the info byte.
+    if info == 27:
+        val, = struct.unpack('>Q', cbor[offset:offset+8])
+        return val, offset + 8
+
+    # Info greater than or equal to 28 is illegal. Note that 31 is used for
+    # indefinite lengths, so this must be checked prior to calling this
+    # method.
+    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
+
+
+def _sub_cbor_to_py(cbor, offset):
+    """Converts the CBOR object starting at cbor[offset] to its Python
+    representation for as far as tree-gen supports CBOR. Returns this Python
+    representation and the offset immediately following the CBOR representation
+    thereof. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    # Read the initial byte.
+    initial = cbor[offset]
+    typ = initial >> 5
+    info = initial & 0x1F
+    offset += 1
+
+    # Handle unsigned integer (0) and negative integer (1).
+    if typ <= 1:
+        value, offset = _cbor_read_intlike(cbor, offset, info)
+        if typ == 1:
+            value = -1 - value
+        return value, offset
+
+    # Handle byte string (2) and UTF-8 string (3).
+    if typ <= 3:
+
+        # Gather components of the string in here.
+        if info == 31:
+
+            # Handle indefinite length strings. These consist of a
+            # break-terminated (0xFF) list of definite-length strings of the
+            # same type.
+            value = []
+            while True:
+                sub_initial = cbor[offset]; offset += 1
+                if sub_initial == 0xFF:
+                    break
+                sub_typ = sub_initial >> 5
+                sub_info = sub_initial & 0x1F
+                if sub_typ != typ:
+                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
+
+                # Seek past definite-length string component. The size in
+                # bytes is encoded as an integer.
+                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
+                value.append(cbor[offset:offset + size])
+                offset += size
+            value = b''.join(value)
+
+        else:
+
+            # Handle definite-length strings. The size in bytes is encoded as
+            # an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            value = cbor[offset:offset + size]
+            offset += size
+
+        if typ == 3:
+            value = value.decode('UTF-8')
+        return value, offset
+
+    # Handle array (4) and map (5).
+    if typ <= 5:
+
+        # Create result container.
+        container = [] if typ == 4 else {}
+
+        # Handle indefinite length arrays and maps.
+        if info == 31:
+
+            # Read objects/object pairs until we encounter a break.
+            while cbor[offset] != 0xFF:
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+            # Seek past the break.
+            offset += 1
+
+        else:
+
+            # Handle definite-length arrays and maps. The amount of
+            # objects/object pairs is encoded as an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            for _ in range(size):
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+        return container, offset
+
+    # Handle semantic tags.
+    if typ == 6:
+
+        # We don't use semantic tags for anything, but ignoring them is
+        # legal and reading past them is easy enough.
+        _, offset = _cbor_read_intlike(cbor, offset, info)
+        return _sub_cbor_to_py(cbor, offset)
+
+    # Handle major type 7. Here, the type is defined by the additional info.
+    # Additional info 24 is reserved for having the type specified by the
+    # next byte, but all such values are unassigned.
+    if info == 20:
+        # false
+        return False, offset
+
+    if info == 21:
+        # true
+        return True, offset
+
+    if info == 22:
+        # null
+        return None, offset
+
+    if info == 23:
+        # Undefined value.
+        raise ValueError('invalid CBOR: undefined value is not supported')
+
+    if info == 25:
+        # Half-precision float.
+        raise ValueError('invalid CBOR: half-precision float is not supported')
+
+    if info == 26:
+        # Single-precision float.
+        raise ValueError('invalid CBOR: single-precision float is not supported')
+
+    if info == 27:
+        # Double-precision float.
+        value, = struct.unpack('>d', cbor[offset:offset+8])
+        return value, offset + 8
+
+    if info == 31:
+        # Break value used for indefinite-length objects.
+        raise ValueError('invalid CBOR: unexpected break')
+
+    raise ValueError('invalid CBOR: unknown type code')
+
+
+def _cbor_to_py(cbor):
+    """Converts the given CBOR object (bytes) to its Python representation for
+    as far as tree-gen supports CBOR. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    value, length = _sub_cbor_to_py(cbor, 0)
+    if length < len(cbor):
+        raise ValueError('invalid CBOR: garbage at the end')
+    return value
+
+
+class _Cbor(bytes):
+    """Marker class indicating that this bytes object represents CBOR."""
+    pass
+
+
+def _cbor_write_intlike(value, major=0):
+    """Converts the given integer to its minimal representation in CBOR. The
+    major code can be overridden to write lengths for strings, arrays, and
+    maps."""
+
+    # Negative integers use major code 1.
+    if value < 0:
+        major = 1
+        value = -1 - value
+    initial = major << 5
+
+    # Use the minimal representation.
+    if value < 24:
+        return struct.pack('>B', initial | value)
+    if value < 0x100:
+        return struct.pack('>BB', initial | 24, value)
+    if value < 0x10000:
+        return struct.pack('>BH', initial | 25, value)
+    if value < 0x100000000:
+        return struct.pack('>BI', initial | 26, value)
+    if value < 0x10000000000000000:
+        return struct.pack('>BQ', initial | 27, value)
+
+    raise ValueError('integer too large for CBOR (bigint not supported)')
+
+
+def _py_to_cbor(value, type_converter=None):
+    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
+    that takes a value and either converts it to a primitive for serialization,
+    converts it to a _Cbor object manually, or raises a TypeError if no
+    conversion is known. If no type_converter is specified, a TypeError is
+    raised in all cases the type_converter would otherwise be called. The cbor
+    serialization is returned using a _Cbor object, which is just a marker class
+    behaving just like bytes."""
+    if isinstance(value, _Cbor):
+        return value
+
+    if isinstance(value, int):
+        return _Cbor(_cbor_write_intlike(value))
+
+    if isinstance(value, float):
+        return _Cbor(struct.pack('>Bd', 0xFB, value))
+
+    if isinstance(value, str):
+        value = value.encode('UTF-8')
+        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
+
+    if isinstance(value, bytes):
+        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
+
+    if value is False:
+        return _Cbor(b'\xF4')
+
+    if value is True:
+        return _Cbor(b'\xF5')
+
+    if value is None:
+        return _Cbor(b'\xF6')
+
+    if isinstance(value, (list, tuple)):
+        cbor = [_cbor_write_intlike(len(value), 4)]
+        for val in value:
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if isinstance(value, dict):
+        cbor = [_cbor_write_intlike(len(value), 5)]
+        for key, val in sorted(value.items()):
+            if not isinstance(key, str):
+                raise TypeError('dict keys must be strings')
+            cbor.append(_py_to_cbor(key, type_converter))
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if type_converter is not None:
+        return _py_to_cbor(type_converter(value))
+
+    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
+
+
+class NotWellFormed(ValueError):
+    """Exception class for well-formedness checks."""
+
+    def __init__(self, msg):
+        super().__init__('not well-formed: ' + str(msg))
+
+
+class Node(object):
+    """Base class for nodes."""
+
+    __slots__ = ['_annot']
+
+    def __init__(self):
+        super().__init__()
+        self._annot = {}
+
+    def __getitem__(self, key):
+        """Returns the annotation object with the specified key, or raises
+        KeyError if not found."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        return self._annot[key]
+
+    def __setitem__(self, key, val):
+        """Assigns the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        self._annot[key] = val
+
+    def __delitem__(self, key):
+        """Deletes the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        del self._annot[key]
+
+    def __contains__(self, key):
+        """Returns whether an annotation exists for the specified key."""
+        return key in self._annot
+
+    @staticmethod
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it. Note that this is overridden
+        by the actual node class implementations; this base function does very
+        little."""
+        if id_map is None:
+            id_map = {}
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes. Note that this is
+        overridden by the actual node class implementations; this base function
+        always raises an exception."""
+        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
+
+    def check_well_formed(self):
+        """Checks whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links).
+
+        If it isn't well-formed, a NotWellFormed is thrown."""
+        self.check_complete()
+
+    def is_well_formed(self):
+        """Returns whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links)."""
+        try:
+            self.check_well_formed()
+            return True
+        except NotWellFormed:
+            return False
+
+    def copy(self):
+        """Returns a shallow copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
+
+    def clone(self):
+        """Returns a deep copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
+
+    @classmethod
+    def deserialize(cls, cbor):
+        """Attempts to deserialize the given cbor object (either as bytes or as
+        its Python primitive representation) into a node of this type."""
+        if isinstance(cbor, bytes):
+            cbor = _cbor_to_py(cbor)
+        seq_to_ob = {}
+        links = []
+        root = cls._deserialize(cbor, seq_to_ob, links)
+        for link_setter, seq in links:
+            ob = seq_to_ob.get(seq, None)
+            if ob is None:
+                raise ValueError('found link to nonexistent object')
+            link_setter(ob)
+        return root
+
+    def serialize(self):
+        """Serializes this node into its cbor representation in the form of a
+        bytes object."""
+        id_map = self.find_reachable()
+        self.check_complete(id_map)
+        return _py_to_cbor(self._serialize(id_map))
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        node_type = _typemap.get(cbor.get('@t'), None)
+        if node_type is None:
+            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
+        return node_type._deserialize(cbor, seq_to_ob, links)
+
+
+@functools.total_ordering
+class _Multiple(object):
+    """Base class for the Any* and Many* edge helper classes. Inheriting
+    classes must set the class constant _T to the node type they are made
+    for."""
+
+    __slots__ = ['_l']
+
+    def __init__(self,  *args, **kwargs):
+        super().__init__()
+        self._l = list(*args, **kwargs)
+        for idx, val in enumerate(self._l):
+            if not isinstance(val, self._T):
+                raise TypeError(
+                    'object {!r} at index {:d} is not an instance of {!r}'
+                    .format(val, idx, self._T))
+
+    def __repr__(self):
+        return '{}({!r})'.format(type(self).__name__, self._l)
+
+    def clone(self):
+        return self.__class__(map(lambda node: node.clone(), self._l))
+
+    def __len__(self):
+        return len(self._l)
+
+    def __getitem__(self, idx):
+        return self._l[idx]
+
+    def __setitem__(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, idx, self._T))
+        self._l[idx] = val
+
+    def __delitem__(self, idx):
+        del self._l[idx]
+
+    def __iter__(self):
+        return iter(self._l)
+
+    def __reversed__(self):
+        return reversed(self._l)
+
+    def __contains__(self, val):
+        return val in self._l
+
+    def append(self, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.append(val)
+
+    def extend(self, iterable):
+        for val in iterable:
+            self.append(val)
+
+    def insert(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.insert(idx, val)
+
+    def remote(self, val):
+        self._l.remove(val)
+
+    def pop(self, idx=-1):
+        return self._l.pop(idx)
+
+    def clear(self):
+        self._l.clear()
+
+    def idx(self, val, start=0, end=-1):
+        return self._l.idx(val, start, end)
+
+    def count(self, val):
+        return self._l.count(val)
+
+    def sort(self, key=None, reverse=False):
+        self._l.sort(key=key, reverse=reverse)
+
+    def reverse(self):
+        self._l.reverse()
+
+    def copy(self):
+        return self.__class__(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, _Multiple):
+            return False
+        return self._l == other._l
+
+    def __lt__(self, other):
+        return self._l < other._l
+
+    def __iadd__(self, other):
+        self.extend(other)
+
+    def __add__(self, other):
+        copy = self.copy()
+        copy += other
+        return copy
+
+    def __imul__(self, other):
+        self._l *= other
+
+    def __mul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+    def __rmul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+
+class MultiNode(_Multiple):
+    """Wrapper for an edge with multiple Node objects."""
+
+    _T = Node
+
+
+def _cloned(obj):
+    """Attempts to clone the given object by calling its clone() method, if it
+    has one."""
+    if hasattr(obj, 'clone'):
+        return obj.clone()
+    return obj
+
+
+class Expression(Node):
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'BooleanLiteral':
+            return BooleanLiteral._deserialize(cbor, seq_to_ob, links)
+        if typ == 'IntegerLiteral':
+            return IntegerLiteral._deserialize(cbor, seq_to_ob, links)
+        if typ == 'FloatLiteral':
+            return FloatLiteral._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Index':
+            return Index._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Identifier':
+            return Identifier._deserialize(cbor, seq_to_ob, links)
+        if typ == 'FunctionCall':
+            return FunctionCall._deserialize(cbor, seq_to_ob, links)
+        if typ == 'UnaryMinusExpression':
+            return UnaryMinusExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseNotExpression':
+            return BitwiseNotExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalNotExpression':
+            return LogicalNotExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'PowerExpression':
+            return PowerExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ProductExpression':
+            return ProductExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'DivisionExpression':
+            return DivisionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ModuloExpression':
+            return ModuloExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'AdditionExpression':
+            return AdditionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'SubtractionExpression':
+            return SubtractionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ShiftLeftExpression':
+            return ShiftLeftExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ShiftRightExpression':
+            return ShiftRightExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpGtExpression':
+            return CmpGtExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpLtExpression':
+            return CmpLtExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpGeExpression':
+            return CmpGeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpLeExpression':
+            return CmpLeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpEqExpression':
+            return CmpEqExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpNeExpression':
+            return CmpNeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseAndExpression':
+            return BitwiseAndExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseXorExpression':
+            return BitwiseXorExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseOrExpression':
+            return BitwiseOrExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalAndExpression':
+            return LogicalAndExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalXorExpression':
+            return LogicalXorExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalOrExpression':
+            return LogicalOrExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'TernaryConditionalExpression':
+            return TernaryConditionalExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Expression'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiExpression(_Multiple):
+    """Wrapper for an edge with multiple Expression objects."""
+
+    _T = Expression
+
+
+_typemap['Expression'] = Expression
+
+class BinaryExpression(Expression):
+    __slots__ = [
+        '_attr_lhs',
+        '_attr_rhs',
+    ]
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__()
+        self.lhs = lhs
+        self.rhs = rhs
+
+    @property
+    def lhs(self):
+        return self._attr_lhs
+
+    @lhs.setter
+    def lhs(self, val):
+        if val is None:
+            del self.lhs
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('lhs must be of type Expression')
+            val = Expression(val)
+        self._attr_lhs = val
+
+    @lhs.deleter
+    def lhs(self):
+        self._attr_lhs = None
+
+    @property
+    def rhs(self):
+        return self._attr_rhs
+
+    @rhs.setter
+    def rhs(self, val):
+        if val is None:
+            del self.rhs
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('rhs must be of type Expression')
+            val = Expression(val)
+        self._attr_rhs = val
+
+    @rhs.deleter
+    def rhs(self):
+        self._attr_rhs = None
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'PowerExpression':
+            return PowerExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ProductExpression':
+            return ProductExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'DivisionExpression':
+            return DivisionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ModuloExpression':
+            return ModuloExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'AdditionExpression':
+            return AdditionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'SubtractionExpression':
+            return SubtractionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ShiftLeftExpression':
+            return ShiftLeftExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ShiftRightExpression':
+            return ShiftRightExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpGtExpression':
+            return CmpGtExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpLtExpression':
+            return CmpLtExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpGeExpression':
+            return CmpGeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpLeExpression':
+            return CmpLeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpEqExpression':
+            return CmpEqExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpNeExpression':
+            return CmpNeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseAndExpression':
+            return BitwiseAndExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseXorExpression':
+            return BitwiseXorExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseOrExpression':
+            return BitwiseOrExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalAndExpression':
+            return LogicalAndExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalXorExpression':
+            return LogicalXorExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalOrExpression':
+            return LogicalOrExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BinaryExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBinaryExpression(_Multiple):
+    """Wrapper for an edge with multiple BinaryExpression objects."""
+
+    _T = BinaryExpression
+
+
+_typemap['BinaryExpression'] = BinaryExpression
+
+class ArithmeticExpression(BinaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'PowerExpression':
+            return PowerExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ProductExpression':
+            return ProductExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'DivisionExpression':
+            return DivisionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ModuloExpression':
+            return ModuloExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'AdditionExpression':
+            return AdditionExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'SubtractionExpression':
+            return SubtractionExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ArithmeticExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiArithmeticExpression(_Multiple):
+    """Wrapper for an edge with multiple ArithmeticExpression objects."""
+
+    _T = ArithmeticExpression
+
+
+_typemap['ArithmeticExpression'] = ArithmeticExpression
+
+class AdditionExpression(ArithmeticExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, AdditionExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('AdditionExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return AdditionExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return AdditionExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'AdditionExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected AdditionExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the AdditionExpression node.
+        node = AdditionExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'AdditionExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiAdditionExpression(_Multiple):
+    """Wrapper for an edge with multiple AdditionExpression objects."""
+
+    _T = AdditionExpression
+
+
+_typemap['AdditionExpression'] = AdditionExpression
+
+class Annotated(Node):
+    """Represents a node that carries annotation data"""
+
+    __slots__ = [
+        '_attr_annotations',
+    ]
+
+    def __init__(
+        self,
+        annotations=None,
+    ):
+        super().__init__()
+        self.annotations = annotations
+
+    @property
+    def annotations(self):
+        """Zero or more annotations attached to this object."""
+        return self._attr_annotations
+
+    @annotations.setter
+    def annotations(self, val):
+        if val is None:
+            del self.annotations
+            return
+        if not isinstance(val, MultiAnnotationData):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('annotations must be of type MultiAnnotationData')
+            val = MultiAnnotationData(val)
+        self._attr_annotations = val
+
+    @annotations.deleter
+    def annotations(self):
+        self._attr_annotations = MultiAnnotationData()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Variable':
+            return Variable._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Gate':
+            return Gate._deserialize(cbor, seq_to_ob, links)
+        if typ == 'MeasureInstruction':
+            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Annotated'}
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiAnnotated(_Multiple):
+    """Wrapper for an edge with multiple Annotated objects."""
+
+    _T = Annotated
+
+
+_typemap['Annotated'] = Annotated
+
+class AnnotationData(Node):
+    __slots__ = [
+        '_attr_interface',
+        '_attr_operation',
+        '_attr_operands',
+    ]
+
+    def __init__(
+        self,
+        interface=None,
+        operation=None,
+        operands=None,
+    ):
+        super().__init__()
+        self.interface = interface
+        self.operation = operation
+        self.operands = operands
+
+    @property
+    def interface(self):
+        """The interface this annotation is intended for. If a target doesn't
+        support an interface, it should silently ignore the annotation."""
+        return self._attr_interface
+
+    @interface.setter
+    def interface(self, val):
+        if val is None:
+            del self.interface
+            return
+        if not isinstance(val, Identifier):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('interface must be of type Identifier')
+            val = Identifier(val)
+        self._attr_interface = val
+
+    @interface.deleter
+    def interface(self):
+        self._attr_interface = None
+
+    @property
+    def operation(self):
+        """The operation within the interface that this annotation is intended
+        for. If a target supports the corresponding interface but not the
+        operation, it should throw an error."""
+        return self._attr_operation
+
+    @operation.setter
+    def operation(self, val):
+        if val is None:
+            del self.operation
+            return
+        if not isinstance(val, Identifier):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operation must be of type Identifier')
+            val = Identifier(val)
+        self._attr_operation = val
+
+    @operation.deleter
+    def operation(self):
+        self._attr_operation = None
+
+    @property
+    def operands(self):
+        """Any operands attached to the annotation."""
+        return self._attr_operands
+
+    @operands.setter
+    def operands(self, val):
+        if val is None:
+            del self.operands
+            return
+        if not isinstance(val, ExpressionList):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operands must be of type ExpressionList')
+            val = ExpressionList(val)
+        self._attr_operands = val
+
+    @operands.deleter
+    def operands(self):
+        self._attr_operands = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, AnnotationData):
+            return False
+        if self.interface != other.interface:
+            return False
+        if self.operation != other.operation:
+            return False
+        if self.operands != other.operands:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('AnnotationData(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('interface: ')
+        if self.interface is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.interface.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('operation: ')
+        if self.operation is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.operation.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('operands: ')
+        if self.operands is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.operands.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_interface is not None:
+            self._attr_interface.find_reachable(id_map)
+        if self._attr_operation is not None:
+            self._attr_operation.find_reachable(id_map)
+        if self._attr_operands is not None:
+            self._attr_operands.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_interface is None:
+            raise NotWellFormed('interface is required but not set')
+        if self._attr_interface is not None:
+            self._attr_interface.check_complete(id_map)
+        if self._attr_operation is None:
+            raise NotWellFormed('operation is required but not set')
+        if self._attr_operation is not None:
+            self._attr_operation.check_complete(id_map)
+        if self._attr_operands is None:
+            raise NotWellFormed('operands is required but not set')
+        if self._attr_operands is not None:
+            self._attr_operands.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return AnnotationData(
+            interface=self._attr_interface,
+            operation=self._attr_operation,
+            operands=self._attr_operands
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return AnnotationData(
+            interface=_cloned(self._attr_interface),
+            operation=_cloned(self._attr_operation),
+            operands=_cloned(self._attr_operands)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'AnnotationData':
+            raise ValueError('found node serialization for ' + typ + ', but expected AnnotationData')
+
+        # Deserialize the interface field.
+        field = cbor.get('interface', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field interface')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field interface')
+        if field.get('@t', None) is None:
+            f_interface = None
+        else:
+            f_interface = Identifier._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the operation field.
+        field = cbor.get('operation', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operation')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field operation')
+        if field.get('@t', None) is None:
+            f_operation = None
+        else:
+            f_operation = Identifier._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the operands field.
+        field = cbor.get('operands', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operands')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field operands')
+        if field.get('@t', None) is None:
+            f_operands = None
+        else:
+            f_operands = ExpressionList._deserialize(field, seq_to_ob, links)
+
+        # Construct the AnnotationData node.
+        node = AnnotationData(f_interface, f_operation, f_operands)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'AnnotationData'}
+
+        # Serialize the interface field.
+        field = {'@T': '1'}
+        if self._attr_interface is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_interface._serialize(id_map))
+        cbor['interface'] = field
+
+        # Serialize the operation field.
+        field = {'@T': '1'}
+        if self._attr_operation is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_operation._serialize(id_map))
+        cbor['operation'] = field
+
+        # Serialize the operands field.
+        field = {'@T': '1'}
+        if self._attr_operands is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_operands._serialize(id_map))
+        cbor['operands'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiAnnotationData(_Multiple):
+    """Wrapper for an edge with multiple AnnotationData objects."""
+
+    _T = AnnotationData
+
+
+_typemap['AnnotationData'] = AnnotationData
+
+class BitwiseExpression(BinaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'BitwiseAndExpression':
+            return BitwiseAndExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseXorExpression':
+            return BitwiseXorExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseOrExpression':
+            return BitwiseOrExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBitwiseExpression(_Multiple):
+    """Wrapper for an edge with multiple BitwiseExpression objects."""
+
+    _T = BitwiseExpression
+
+
+_typemap['BitwiseExpression'] = BitwiseExpression
+
+class BitwiseAndExpression(BitwiseExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, BitwiseAndExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('BitwiseAndExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return BitwiseAndExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return BitwiseAndExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'BitwiseAndExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseAndExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the BitwiseAndExpression node.
+        node = BitwiseAndExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseAndExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBitwiseAndExpression(_Multiple):
+    """Wrapper for an edge with multiple BitwiseAndExpression objects."""
+
+    _T = BitwiseAndExpression
+
+
+_typemap['BitwiseAndExpression'] = BitwiseAndExpression
+
+class UnaryExpression(Expression):
+    __slots__ = [
+        '_attr_expr',
+    ]
+
+    def __init__(
+        self,
+        expr=None,
+    ):
+        super().__init__()
+        self.expr = expr
+
+    @property
+    def expr(self):
+        return self._attr_expr
+
+    @expr.setter
+    def expr(self, val):
+        if val is None:
+            del self.expr
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('expr must be of type Expression')
+            val = Expression(val)
+        self._attr_expr = val
+
+    @expr.deleter
+    def expr(self):
+        self._attr_expr = None
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'UnaryMinusExpression':
+            return UnaryMinusExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitwiseNotExpression':
+            return BitwiseNotExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalNotExpression':
+            return LogicalNotExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'UnaryExpression'}
+
+        # Serialize the expr field.
+        field = {'@T': '1'}
+        if self._attr_expr is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_expr._serialize(id_map))
+        cbor['expr'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiUnaryExpression(_Multiple):
+    """Wrapper for an edge with multiple UnaryExpression objects."""
+
+    _T = UnaryExpression
+
+
+_typemap['UnaryExpression'] = UnaryExpression
+
+class BitwiseNotExpression(UnaryExpression):
+    """One's complement."""
+
+    __slots__ = []
+
+    def __init__(
+        self,
+        expr=None,
+    ):
+        super().__init__(expr=expr)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, BitwiseNotExpression):
+            return False
+        if self.expr != other.expr:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('BitwiseNotExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('expr: ')
+        if self.expr is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_expr is not None:
+            self._attr_expr.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_expr is None:
+            raise NotWellFormed('expr is required but not set')
+        if self._attr_expr is not None:
+            self._attr_expr.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return BitwiseNotExpression(
+            expr=self._attr_expr
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return BitwiseNotExpression(
+            expr=_cloned(self._attr_expr)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'BitwiseNotExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseNotExpression')
+
+        # Deserialize the expr field.
+        field = cbor.get('expr', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field expr')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field expr')
+        if field.get('@t', None) is None:
+            f_expr = None
+        else:
+            f_expr = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the BitwiseNotExpression node.
+        node = BitwiseNotExpression(f_expr)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseNotExpression'}
+
+        # Serialize the expr field.
+        field = {'@T': '1'}
+        if self._attr_expr is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_expr._serialize(id_map))
+        cbor['expr'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBitwiseNotExpression(_Multiple):
+    """Wrapper for an edge with multiple BitwiseNotExpression objects."""
+
+    _T = BitwiseNotExpression
+
+
+_typemap['BitwiseNotExpression'] = BitwiseNotExpression
+
+class BitwiseOrExpression(BitwiseExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, BitwiseOrExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('BitwiseOrExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return BitwiseOrExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return BitwiseOrExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'BitwiseOrExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseOrExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the BitwiseOrExpression node.
+        node = BitwiseOrExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseOrExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBitwiseOrExpression(_Multiple):
+    """Wrapper for an edge with multiple BitwiseOrExpression objects."""
+
+    _T = BitwiseOrExpression
+
+
+_typemap['BitwiseOrExpression'] = BitwiseOrExpression
+
+class BitwiseXorExpression(BitwiseExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, BitwiseXorExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('BitwiseXorExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return BitwiseXorExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return BitwiseXorExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'BitwiseXorExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected BitwiseXorExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the BitwiseXorExpression node.
+        node = BitwiseXorExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BitwiseXorExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBitwiseXorExpression(_Multiple):
+    """Wrapper for an edge with multiple BitwiseXorExpression objects."""
+
+    _T = BitwiseXorExpression
+
+
+_typemap['BitwiseXorExpression'] = BitwiseXorExpression
+
+class Block(Node):
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'GlobalBlock':
+            return GlobalBlock._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Block'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBlock(_Multiple):
+    """Wrapper for an edge with multiple Block objects."""
+
+    _T = Block
+
+
+_typemap['Block'] = Block
+
+class Statement(Annotated):
+    __slots__ = []
+
+    def __init__(
+        self,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Variable':
+            return Variable._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Gate':
+            return Gate._deserialize(cbor, seq_to_ob, links)
+        if typ == 'MeasureInstruction':
+            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Statement'}
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiStatement(_Multiple):
+    """Wrapper for an edge with multiple Statement objects."""
+
+    _T = Statement
+
+
+_typemap['Statement'] = Statement
+
+class BlockStatement(Statement):
+    __slots__ = []
+
+    def __init__(
+        self,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Variable':
+            return Variable._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Gate':
+            return Gate._deserialize(cbor, seq_to_ob, links)
+        if typ == 'MeasureInstruction':
+            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BlockStatement'}
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBlockStatement(_Multiple):
+    """Wrapper for an edge with multiple BlockStatement objects."""
+
+    _T = BlockStatement
+
+
+_typemap['BlockStatement'] = BlockStatement
+
+class BooleanLiteral(Expression):
+    __slots__ = [
+        '_attr_value',
+    ]
+
+    def __init__(
+        self,
+        value=None,
+    ):
+        super().__init__()
+        self.value = value
+
+    @property
+    def value(self):
+        return self._attr_value
+
+    @value.setter
+    def value(self, val):
+        if val is None:
+            del self.value
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Bool):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('value must be of type cqasm.v3x.primitives.Bool')
+            val = cqasm.v3x.primitives.Bool(val)
+        self._attr_value = val
+
+    @value.deleter
+    def value(self):
+        self._attr_value = cqasm.v3x.primitives.Bool()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, BooleanLiteral):
+            return False
+        if self.value != other.value:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('BooleanLiteral(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('value: ')
+        s.append(str(self.value) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return BooleanLiteral(
+            value=self._attr_value
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return BooleanLiteral(
+            value=_cloned(self._attr_value)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'BooleanLiteral':
+            raise ValueError('found node serialization for ' + typ + ', but expected BooleanLiteral')
+
+        # Deserialize the value field.
+        field = cbor.get('value', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field value')
+        if hasattr(cqasm.v3x.primitives.Bool, 'deserialize_cbor'):
+            f_value = cqasm.v3x.primitives.Bool.deserialize_cbor(field)
+        else:
+            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Bool, field)
+
+        # Construct the BooleanLiteral node.
+        node = BooleanLiteral(f_value)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BooleanLiteral'}
+
+        # Serialize the value field.
+        if hasattr(self._attr_value, 'serialize_cbor'):
+            cbor['value'] = self._attr_value.serialize_cbor()
+        else:
+            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Bool, self._attr_value)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBooleanLiteral(_Multiple):
+    """Wrapper for an edge with multiple BooleanLiteral objects."""
+
+    _T = BooleanLiteral
+
+
+_typemap['BooleanLiteral'] = BooleanLiteral
+
+class EqualityExpression(BinaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'CmpEqExpression':
+            return CmpEqExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpNeExpression':
+            return CmpNeExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'EqualityExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiEqualityExpression(_Multiple):
+    """Wrapper for an edge with multiple EqualityExpression objects."""
+
+    _T = EqualityExpression
+
+
+_typemap['EqualityExpression'] = EqualityExpression
+
+class CmpEqExpression(EqualityExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, CmpEqExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('CmpEqExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return CmpEqExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return CmpEqExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'CmpEqExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected CmpEqExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the CmpEqExpression node.
+        node = CmpEqExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'CmpEqExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiCmpEqExpression(_Multiple):
+    """Wrapper for an edge with multiple CmpEqExpression objects."""
+
+    _T = CmpEqExpression
+
+
+_typemap['CmpEqExpression'] = CmpEqExpression
+
+class ComparisonExpression(BinaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'CmpGtExpression':
+            return CmpGtExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpLtExpression':
+            return CmpLtExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpGeExpression':
+            return CmpGeExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'CmpLeExpression':
+            return CmpLeExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ComparisonExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiComparisonExpression(_Multiple):
+    """Wrapper for an edge with multiple ComparisonExpression objects."""
+
+    _T = ComparisonExpression
+
+
+_typemap['ComparisonExpression'] = ComparisonExpression
+
+class CmpGeExpression(ComparisonExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, CmpGeExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('CmpGeExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return CmpGeExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return CmpGeExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'CmpGeExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected CmpGeExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the CmpGeExpression node.
+        node = CmpGeExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'CmpGeExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiCmpGeExpression(_Multiple):
+    """Wrapper for an edge with multiple CmpGeExpression objects."""
+
+    _T = CmpGeExpression
+
+
+_typemap['CmpGeExpression'] = CmpGeExpression
+
+class CmpGtExpression(ComparisonExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, CmpGtExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('CmpGtExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return CmpGtExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return CmpGtExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'CmpGtExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected CmpGtExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the CmpGtExpression node.
+        node = CmpGtExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'CmpGtExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiCmpGtExpression(_Multiple):
+    """Wrapper for an edge with multiple CmpGtExpression objects."""
+
+    _T = CmpGtExpression
+
+
+_typemap['CmpGtExpression'] = CmpGtExpression
+
+class CmpLeExpression(ComparisonExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, CmpLeExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('CmpLeExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return CmpLeExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return CmpLeExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'CmpLeExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected CmpLeExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the CmpLeExpression node.
+        node = CmpLeExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'CmpLeExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiCmpLeExpression(_Multiple):
+    """Wrapper for an edge with multiple CmpLeExpression objects."""
+
+    _T = CmpLeExpression
+
+
+_typemap['CmpLeExpression'] = CmpLeExpression
+
+class CmpLtExpression(ComparisonExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, CmpLtExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('CmpLtExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return CmpLtExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return CmpLtExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'CmpLtExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected CmpLtExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the CmpLtExpression node.
+        node = CmpLtExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'CmpLtExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiCmpLtExpression(_Multiple):
+    """Wrapper for an edge with multiple CmpLtExpression objects."""
+
+    _T = CmpLtExpression
+
+
+_typemap['CmpLtExpression'] = CmpLtExpression
+
+class CmpNeExpression(EqualityExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, CmpNeExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('CmpNeExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return CmpNeExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return CmpNeExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'CmpNeExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected CmpNeExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the CmpNeExpression node.
+        node = CmpNeExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'CmpNeExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiCmpNeExpression(_Multiple):
+    """Wrapper for an edge with multiple CmpNeExpression objects."""
+
+    _T = CmpNeExpression
+
+
+_typemap['CmpNeExpression'] = CmpNeExpression
+
+class DivisionExpression(ArithmeticExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, DivisionExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('DivisionExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return DivisionExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return DivisionExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'DivisionExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected DivisionExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the DivisionExpression node.
+        node = DivisionExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'DivisionExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiDivisionExpression(_Multiple):
+    """Wrapper for an edge with multiple DivisionExpression objects."""
+
+    _T = DivisionExpression
+
+
+_typemap['DivisionExpression'] = DivisionExpression
+
+class ExpressionList(Node):
+    __slots__ = [
+        '_attr_items',
+    ]
+
+    def __init__(
+        self,
+        items=None,
+    ):
+        super().__init__()
+        self.items = items
+
+    @property
+    def items(self):
+        return self._attr_items
+
+    @items.setter
+    def items(self, val):
+        if val is None:
+            del self.items
+            return
+        if not isinstance(val, MultiExpression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('items must be of type MultiExpression')
+            val = MultiExpression(val)
+        self._attr_items = val
+
+    @items.deleter
+    def items(self):
+        self._attr_items = MultiExpression()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ExpressionList):
+            return False
+        if self.items != other.items:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ExpressionList(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('items: ')
+        if not self.items:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.items:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        for el in self._attr_items:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        for child in self._attr_items:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ExpressionList(
+            items=self._attr_items.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ExpressionList(
+            items=_cloned(self._attr_items)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ExpressionList':
+            raise ValueError('found node serialization for ' + typ + ', but expected ExpressionList')
+
+        # Deserialize the items field.
+        field = cbor.get('items', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field items')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field items')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_items = MultiExpression()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_items.append(Expression._deserialize(element, seq_to_ob, links))
+
+        # Construct the ExpressionList node.
+        node = ExpressionList(f_items)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ExpressionList'}
+
+        # Serialize the items field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_items:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['items'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiExpressionList(_Multiple):
+    """Wrapper for an edge with multiple ExpressionList objects."""
+
+    _T = ExpressionList
+
+
+_typemap['ExpressionList'] = ExpressionList
+
+class FloatLiteral(Expression):
+    __slots__ = [
+        '_attr_value',
+    ]
+
+    def __init__(
+        self,
+        value=None,
+    ):
+        super().__init__()
+        self.value = value
+
+    @property
+    def value(self):
+        return self._attr_value
+
+    @value.setter
+    def value(self, val):
+        if val is None:
+            del self.value
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Float):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('value must be of type cqasm.v3x.primitives.Float')
+            val = cqasm.v3x.primitives.Float(val)
+        self._attr_value = val
+
+    @value.deleter
+    def value(self):
+        self._attr_value = cqasm.v3x.primitives.Float()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, FloatLiteral):
+            return False
+        if self.value != other.value:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('FloatLiteral(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('value: ')
+        s.append(str(self.value) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return FloatLiteral(
+            value=self._attr_value
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return FloatLiteral(
+            value=_cloned(self._attr_value)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'FloatLiteral':
+            raise ValueError('found node serialization for ' + typ + ', but expected FloatLiteral')
+
+        # Deserialize the value field.
+        field = cbor.get('value', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field value')
+        if hasattr(cqasm.v3x.primitives.Float, 'deserialize_cbor'):
+            f_value = cqasm.v3x.primitives.Float.deserialize_cbor(field)
+        else:
+            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Float, field)
+
+        # Construct the FloatLiteral node.
+        node = FloatLiteral(f_value)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'FloatLiteral'}
+
+        # Serialize the value field.
+        if hasattr(self._attr_value, 'serialize_cbor'):
+            cbor['value'] = self._attr_value.serialize_cbor()
+        else:
+            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Float, self._attr_value)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiFloatLiteral(_Multiple):
+    """Wrapper for an edge with multiple FloatLiteral objects."""
+
+    _T = FloatLiteral
+
+
+_typemap['FloatLiteral'] = FloatLiteral
+
+class FunctionCall(Expression):
+    __slots__ = [
+        '_attr_name',
+        '_attr_arguments',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+        arguments=None,
+    ):
+        super().__init__()
+        self.name = name
+        self.arguments = arguments
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, Identifier):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type Identifier')
+            val = Identifier(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = None
+
+    @property
+    def arguments(self):
+        return self._attr_arguments
+
+    @arguments.setter
+    def arguments(self, val):
+        if val is None:
+            del self.arguments
+            return
+        if not isinstance(val, ExpressionList):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('arguments must be of type ExpressionList')
+            val = ExpressionList(val)
+        self._attr_arguments = val
+
+    @arguments.deleter
+    def arguments(self):
+        self._attr_arguments = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, FunctionCall):
+            return False
+        if self.name != other.name:
+            return False
+        if self.arguments != other.arguments:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('FunctionCall(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        if self.name is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('arguments: ')
+        if self.arguments is None:
+            s.append('-\n')
+        else:
+            s.append('<\n')
+            s.append(self.arguments.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_name is not None:
+            self._attr_name.find_reachable(id_map)
+        if self._attr_arguments is not None:
+            self._attr_arguments.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_name is None:
+            raise NotWellFormed('name is required but not set')
+        if self._attr_name is not None:
+            self._attr_name.check_complete(id_map)
+        if self._attr_arguments is not None:
+            self._attr_arguments.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return FunctionCall(
+            name=self._attr_name,
+            arguments=self._attr_arguments
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return FunctionCall(
+            name=_cloned(self._attr_name),
+            arguments=_cloned(self._attr_arguments)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'FunctionCall':
+            raise ValueError('found node serialization for ' + typ + ', but expected FunctionCall')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field name')
+        if field.get('@t', None) is None:
+            f_name = None
+        else:
+            f_name = Identifier._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the arguments field.
+        field = cbor.get('arguments', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field arguments')
+        if field.get('@T') != '?':
+            raise ValueError('unexpected edge type for field arguments')
+        if field.get('@t', None) is None:
+            f_arguments = None
+        else:
+            f_arguments = ExpressionList._deserialize(field, seq_to_ob, links)
+
+        # Construct the FunctionCall node.
+        node = FunctionCall(f_name, f_arguments)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'FunctionCall'}
+
+        # Serialize the name field.
+        field = {'@T': '1'}
+        if self._attr_name is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_name._serialize(id_map))
+        cbor['name'] = field
+
+        # Serialize the arguments field.
+        field = {'@T': '?'}
+        if self._attr_arguments is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_arguments._serialize(id_map))
+        cbor['arguments'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiFunctionCall(_Multiple):
+    """Wrapper for an edge with multiple FunctionCall objects."""
+
+    _T = FunctionCall
+
+
+_typemap['FunctionCall'] = FunctionCall
+
+class Instruction(BlockStatement):
+    __slots__ = []
+
+    def __init__(
+        self,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Gate':
+            return Gate._deserialize(cbor, seq_to_ob, links)
+        if typ == 'MeasureInstruction':
+            return MeasureInstruction._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Instruction'}
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiInstruction(_Multiple):
+    """Wrapper for an edge with multiple Instruction objects."""
+
+    _T = Instruction
+
+
+_typemap['Instruction'] = Instruction
+
+class Gate(Instruction):
+    __slots__ = [
+        '_attr_name',
+        '_attr_operands',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+        operands=None,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+        self.name = name
+        self.operands = operands
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, Identifier):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type Identifier')
+            val = Identifier(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = None
+
+    @property
+    def operands(self):
+        return self._attr_operands
+
+    @operands.setter
+    def operands(self, val):
+        if val is None:
+            del self.operands
+            return
+        if not isinstance(val, ExpressionList):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operands must be of type ExpressionList')
+            val = ExpressionList(val)
+        self._attr_operands = val
+
+    @operands.deleter
+    def operands(self):
+        self._attr_operands = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Gate):
+            return False
+        if self.name != other.name:
+            return False
+        if self.operands != other.operands:
+            return False
+        if self.annotations != other.annotations:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Gate(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        if self.name is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('operands: ')
+        if self.operands is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.operands.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('annotations: ')
+        if not self.annotations:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.annotations:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_name is not None:
+            self._attr_name.find_reachable(id_map)
+        if self._attr_operands is not None:
+            self._attr_operands.find_reachable(id_map)
+        for el in self._attr_annotations:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_name is None:
+            raise NotWellFormed('name is required but not set')
+        if self._attr_name is not None:
+            self._attr_name.check_complete(id_map)
+        if self._attr_operands is None:
+            raise NotWellFormed('operands is required but not set')
+        if self._attr_operands is not None:
+            self._attr_operands.check_complete(id_map)
+        for child in self._attr_annotations:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Gate(
+            name=self._attr_name,
+            operands=self._attr_operands,
+            annotations=self._attr_annotations.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Gate(
+            name=_cloned(self._attr_name),
+            operands=_cloned(self._attr_operands),
+            annotations=_cloned(self._attr_annotations)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Gate':
+            raise ValueError('found node serialization for ' + typ + ', but expected Gate')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field name')
+        if field.get('@t', None) is None:
+            f_name = None
+        else:
+            f_name = Identifier._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the operands field.
+        field = cbor.get('operands', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operands')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field operands')
+        if field.get('@t', None) is None:
+            f_operands = None
+        else:
+            f_operands = ExpressionList._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the annotations field.
+        field = cbor.get('annotations', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field annotations')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field annotations')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_annotations = MultiAnnotationData()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
+
+        # Construct the Gate node.
+        node = Gate(f_name, f_operands, f_annotations)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Gate'}
+
+        # Serialize the name field.
+        field = {'@T': '1'}
+        if self._attr_name is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_name._serialize(id_map))
+        cbor['name'] = field
+
+        # Serialize the operands field.
+        field = {'@T': '1'}
+        if self._attr_operands is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_operands._serialize(id_map))
+        cbor['operands'] = field
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiGate(_Multiple):
+    """Wrapper for an edge with multiple Gate objects."""
+
+    _T = Gate
+
+
+_typemap['Gate'] = Gate
+
+class GlobalBlock(Block):
+    __slots__ = [
+        '_attr_qubit_variable_declaration',
+        '_attr_gates',
+        '_attr_measure_instructions',
+    ]
+
+    def __init__(
+        self,
+        qubit_variable_declaration=None,
+        gates=None,
+        measure_instructions=None,
+    ):
+        super().__init__()
+        self.qubit_variable_declaration = qubit_variable_declaration
+        self.gates = gates
+        self.measure_instructions = measure_instructions
+
+    @property
+    def qubit_variable_declaration(self):
+        return self._attr_qubit_variable_declaration
+
+    @qubit_variable_declaration.setter
+    def qubit_variable_declaration(self, val):
+        if val is None:
+            del self.qubit_variable_declaration
+            return
+        if not isinstance(val, Variable):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('qubit_variable_declaration must be of type Variable')
+            val = Variable(val)
+        self._attr_qubit_variable_declaration = val
+
+    @qubit_variable_declaration.deleter
+    def qubit_variable_declaration(self):
+        self._attr_qubit_variable_declaration = None
+
+    @property
+    def gates(self):
+        return self._attr_gates
+
+    @gates.setter
+    def gates(self, val):
+        if val is None:
+            del self.gates
+            return
+        if not isinstance(val, MultiGate):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('gates must be of type MultiGate')
+            val = MultiGate(val)
+        self._attr_gates = val
+
+    @gates.deleter
+    def gates(self):
+        self._attr_gates = MultiGate()
+
+    @property
+    def measure_instructions(self):
+        return self._attr_measure_instructions
+
+    @measure_instructions.setter
+    def measure_instructions(self, val):
+        if val is None:
+            del self.measure_instructions
+            return
+        if not isinstance(val, MultiMeasureInstruction):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('measure_instructions must be of type MultiMeasureInstruction')
+            val = MultiMeasureInstruction(val)
+        self._attr_measure_instructions = val
+
+    @measure_instructions.deleter
+    def measure_instructions(self):
+        self._attr_measure_instructions = MultiMeasureInstruction()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, GlobalBlock):
+            return False
+        if self.qubit_variable_declaration != other.qubit_variable_declaration:
+            return False
+        if self.gates != other.gates:
+            return False
+        if self.measure_instructions != other.measure_instructions:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('GlobalBlock(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('qubit_variable_declaration: ')
+        if self.qubit_variable_declaration is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.qubit_variable_declaration.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('gates: ')
+        if not self.gates:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.gates:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        s.append('  '*indent)
+        s.append('measure_instructions: ')
+        if not self.measure_instructions:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.measure_instructions:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_qubit_variable_declaration is not None:
+            self._attr_qubit_variable_declaration.find_reachable(id_map)
+        for el in self._attr_gates:
+            el.find_reachable(id_map)
+        for el in self._attr_measure_instructions:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_qubit_variable_declaration is None:
+            raise NotWellFormed('qubit_variable_declaration is required but not set')
+        if self._attr_qubit_variable_declaration is not None:
+            self._attr_qubit_variable_declaration.check_complete(id_map)
+        for child in self._attr_gates:
+            child.check_complete(id_map)
+        for child in self._attr_measure_instructions:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return GlobalBlock(
+            qubit_variable_declaration=self._attr_qubit_variable_declaration,
+            gates=self._attr_gates.copy(),
+            measure_instructions=self._attr_measure_instructions.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return GlobalBlock(
+            qubit_variable_declaration=_cloned(self._attr_qubit_variable_declaration),
+            gates=_cloned(self._attr_gates),
+            measure_instructions=_cloned(self._attr_measure_instructions)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'GlobalBlock':
+            raise ValueError('found node serialization for ' + typ + ', but expected GlobalBlock')
+
+        # Deserialize the qubit_variable_declaration field.
+        field = cbor.get('qubit_variable_declaration', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field qubit_variable_declaration')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field qubit_variable_declaration')
+        if field.get('@t', None) is None:
+            f_qubit_variable_declaration = None
+        else:
+            f_qubit_variable_declaration = Variable._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the gates field.
+        field = cbor.get('gates', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field gates')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field gates')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_gates = MultiGate()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_gates.append(Gate._deserialize(element, seq_to_ob, links))
+
+        # Deserialize the measure_instructions field.
+        field = cbor.get('measure_instructions', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field measure_instructions')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field measure_instructions')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_measure_instructions = MultiMeasureInstruction()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_measure_instructions.append(MeasureInstruction._deserialize(element, seq_to_ob, links))
+
+        # Construct the GlobalBlock node.
+        node = GlobalBlock(f_qubit_variable_declaration, f_gates, f_measure_instructions)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'GlobalBlock'}
+
+        # Serialize the qubit_variable_declaration field.
+        field = {'@T': '1'}
+        if self._attr_qubit_variable_declaration is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_qubit_variable_declaration._serialize(id_map))
+        cbor['qubit_variable_declaration'] = field
+
+        # Serialize the gates field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_gates:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['gates'] = field
+
+        # Serialize the measure_instructions field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_measure_instructions:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['measure_instructions'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiGlobalBlock(_Multiple):
+    """Wrapper for an edge with multiple GlobalBlock objects."""
+
+    _T = GlobalBlock
+
+
+_typemap['GlobalBlock'] = GlobalBlock
+
+class Identifier(Expression):
+    __slots__ = [
+        '_attr_name',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+    ):
+        super().__init__()
+        self.name = name
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Str):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
+            val = cqasm.v3x.primitives.Str(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = cqasm.v3x.primitives.Str()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Identifier):
+            return False
+        if self.name != other.name:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Identifier(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        s.append(str(self.name) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Identifier(
+            name=self._attr_name
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Identifier(
+            name=_cloned(self._attr_name)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Identifier':
+            raise ValueError('found node serialization for ' + typ + ', but expected Identifier')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
+            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
+        else:
+            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
+
+        # Construct the Identifier node.
+        node = Identifier(f_name)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Identifier'}
+
+        # Serialize the name field.
+        if hasattr(self._attr_name, 'serialize_cbor'):
+            cbor['name'] = self._attr_name.serialize_cbor()
+        else:
+            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIdentifier(_Multiple):
+    """Wrapper for an edge with multiple Identifier objects."""
+
+    _T = Identifier
+
+
+_typemap['Identifier'] = Identifier
+
+class Index(Expression):
+    __slots__ = [
+        '_attr_expr',
+        '_attr_indices',
+    ]
+
+    def __init__(
+        self,
+        expr=None,
+        indices=None,
+    ):
+        super().__init__()
+        self.expr = expr
+        self.indices = indices
+
+    @property
+    def expr(self):
+        return self._attr_expr
+
+    @expr.setter
+    def expr(self, val):
+        if val is None:
+            del self.expr
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('expr must be of type Expression')
+            val = Expression(val)
+        self._attr_expr = val
+
+    @expr.deleter
+    def expr(self):
+        self._attr_expr = None
+
+    @property
+    def indices(self):
+        return self._attr_indices
+
+    @indices.setter
+    def indices(self, val):
+        if val is None:
+            del self.indices
+            return
+        if not isinstance(val, IndexList):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('indices must be of type IndexList')
+            val = IndexList(val)
+        self._attr_indices = val
+
+    @indices.deleter
+    def indices(self):
+        self._attr_indices = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Index):
+            return False
+        if self.expr != other.expr:
+            return False
+        if self.indices != other.indices:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Index(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('expr: ')
+        if self.expr is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('indices: ')
+        if self.indices is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.indices.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_expr is not None:
+            self._attr_expr.find_reachable(id_map)
+        if self._attr_indices is not None:
+            self._attr_indices.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_expr is None:
+            raise NotWellFormed('expr is required but not set')
+        if self._attr_expr is not None:
+            self._attr_expr.check_complete(id_map)
+        if self._attr_indices is None:
+            raise NotWellFormed('indices is required but not set')
+        if self._attr_indices is not None:
+            self._attr_indices.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Index(
+            expr=self._attr_expr,
+            indices=self._attr_indices
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Index(
+            expr=_cloned(self._attr_expr),
+            indices=_cloned(self._attr_indices)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Index':
+            raise ValueError('found node serialization for ' + typ + ', but expected Index')
+
+        # Deserialize the expr field.
+        field = cbor.get('expr', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field expr')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field expr')
+        if field.get('@t', None) is None:
+            f_expr = None
+        else:
+            f_expr = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the indices field.
+        field = cbor.get('indices', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field indices')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field indices')
+        if field.get('@t', None) is None:
+            f_indices = None
+        else:
+            f_indices = IndexList._deserialize(field, seq_to_ob, links)
+
+        # Construct the Index node.
+        node = Index(f_expr, f_indices)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Index'}
+
+        # Serialize the expr field.
+        field = {'@T': '1'}
+        if self._attr_expr is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_expr._serialize(id_map))
+        cbor['expr'] = field
+
+        # Serialize the indices field.
+        field = {'@T': '1'}
+        if self._attr_indices is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_indices._serialize(id_map))
+        cbor['indices'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIndex(_Multiple):
+    """Wrapper for an edge with multiple Index objects."""
+
+    _T = Index
+
+
+_typemap['Index'] = Index
+
+class IndexEntry(Node):
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'IndexItem':
+            return IndexItem._deserialize(cbor, seq_to_ob, links)
+        if typ == 'IndexRange':
+            return IndexRange._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'IndexEntry'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIndexEntry(_Multiple):
+    """Wrapper for an edge with multiple IndexEntry objects."""
+
+    _T = IndexEntry
+
+
+_typemap['IndexEntry'] = IndexEntry
+
+class IndexItem(IndexEntry):
+    """Zero based."""
+
+    __slots__ = [
+        '_attr_index',
+    ]
+
+    def __init__(
+        self,
+        index=None,
+    ):
+        super().__init__()
+        self.index = index
+
+    @property
+    def index(self):
+        return self._attr_index
+
+    @index.setter
+    def index(self, val):
+        if val is None:
+            del self.index
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('index must be of type Expression')
+            val = Expression(val)
+        self._attr_index = val
+
+    @index.deleter
+    def index(self):
+        self._attr_index = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, IndexItem):
+            return False
+        if self.index != other.index:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('IndexItem(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('index: ')
+        if self.index is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.index.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_index is not None:
+            self._attr_index.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_index is None:
+            raise NotWellFormed('index is required but not set')
+        if self._attr_index is not None:
+            self._attr_index.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return IndexItem(
+            index=self._attr_index
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return IndexItem(
+            index=_cloned(self._attr_index)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'IndexItem':
+            raise ValueError('found node serialization for ' + typ + ', but expected IndexItem')
+
+        # Deserialize the index field.
+        field = cbor.get('index', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field index')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field index')
+        if field.get('@t', None) is None:
+            f_index = None
+        else:
+            f_index = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the IndexItem node.
+        node = IndexItem(f_index)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'IndexItem'}
+
+        # Serialize the index field.
+        field = {'@T': '1'}
+        if self._attr_index is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_index._serialize(id_map))
+        cbor['index'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIndexItem(_Multiple):
+    """Wrapper for an edge with multiple IndexItem objects."""
+
+    _T = IndexItem
+
+
+_typemap['IndexItem'] = IndexItem
+
+class IndexList(Node):
+    __slots__ = [
+        '_attr_items',
+    ]
+
+    def __init__(
+        self,
+        items=None,
+    ):
+        super().__init__()
+        self.items = items
+
+    @property
+    def items(self):
+        return self._attr_items
+
+    @items.setter
+    def items(self, val):
+        if val is None:
+            del self.items
+            return
+        if not isinstance(val, MultiIndexEntry):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('items must be of type MultiIndexEntry')
+            val = MultiIndexEntry(val)
+        self._attr_items = val
+
+    @items.deleter
+    def items(self):
+        self._attr_items = MultiIndexEntry()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, IndexList):
+            return False
+        if self.items != other.items:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('IndexList(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('items: ')
+        if not self.items:
+            s.append('!MISSING\n')
+        else:
+            s.append('[\n')
+            for child in self.items:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        for el in self._attr_items:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if not self._attr_items:
+            raise NotWellFormed('items needs at least one node but has zero')
+        for child in self._attr_items:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return IndexList(
+            items=self._attr_items.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return IndexList(
+            items=_cloned(self._attr_items)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'IndexList':
+            raise ValueError('found node serialization for ' + typ + ', but expected IndexList')
+
+        # Deserialize the items field.
+        field = cbor.get('items', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field items')
+        if field.get('@T') != '+':
+            raise ValueError('unexpected edge type for field items')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_items = MultiIndexEntry()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_items.append(IndexEntry._deserialize(element, seq_to_ob, links))
+
+        # Construct the IndexList node.
+        node = IndexList(f_items)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'IndexList'}
+
+        # Serialize the items field.
+        field = {'@T': '+'}
+        lst = []
+        for el in self._attr_items:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['items'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIndexList(_Multiple):
+    """Wrapper for an edge with multiple IndexList objects."""
+
+    _T = IndexList
+
+
+_typemap['IndexList'] = IndexList
+
+class IndexRange(IndexEntry):
+    """ Inclusive."""
+
+    __slots__ = [
+        '_attr_first',
+        '_attr_last',
+    ]
+
+    def __init__(
+        self,
+        first=None,
+        last=None,
+    ):
+        super().__init__()
+        self.first = first
+        self.last = last
+
+    @property
+    def first(self):
+        return self._attr_first
+
+    @first.setter
+    def first(self, val):
+        if val is None:
+            del self.first
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('first must be of type Expression')
+            val = Expression(val)
+        self._attr_first = val
+
+    @first.deleter
+    def first(self):
+        self._attr_first = None
+
+    @property
+    def last(self):
+        return self._attr_last
+
+    @last.setter
+    def last(self, val):
+        if val is None:
+            del self.last
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('last must be of type Expression')
+            val = Expression(val)
+        self._attr_last = val
+
+    @last.deleter
+    def last(self):
+        self._attr_last = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, IndexRange):
+            return False
+        if self.first != other.first:
+            return False
+        if self.last != other.last:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('IndexRange(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('first: ')
+        if self.first is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.first.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('last: ')
+        if self.last is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.last.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_first is not None:
+            self._attr_first.find_reachable(id_map)
+        if self._attr_last is not None:
+            self._attr_last.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_first is None:
+            raise NotWellFormed('first is required but not set')
+        if self._attr_first is not None:
+            self._attr_first.check_complete(id_map)
+        if self._attr_last is None:
+            raise NotWellFormed('last is required but not set')
+        if self._attr_last is not None:
+            self._attr_last.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return IndexRange(
+            first=self._attr_first,
+            last=self._attr_last
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return IndexRange(
+            first=_cloned(self._attr_first),
+            last=_cloned(self._attr_last)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'IndexRange':
+            raise ValueError('found node serialization for ' + typ + ', but expected IndexRange')
+
+        # Deserialize the first field.
+        field = cbor.get('first', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field first')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field first')
+        if field.get('@t', None) is None:
+            f_first = None
+        else:
+            f_first = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the last field.
+        field = cbor.get('last', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field last')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field last')
+        if field.get('@t', None) is None:
+            f_last = None
+        else:
+            f_last = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the IndexRange node.
+        node = IndexRange(f_first, f_last)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'IndexRange'}
+
+        # Serialize the first field.
+        field = {'@T': '1'}
+        if self._attr_first is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_first._serialize(id_map))
+        cbor['first'] = field
+
+        # Serialize the last field.
+        field = {'@T': '1'}
+        if self._attr_last is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_last._serialize(id_map))
+        cbor['last'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIndexRange(_Multiple):
+    """Wrapper for an edge with multiple IndexRange objects."""
+
+    _T = IndexRange
+
+
+_typemap['IndexRange'] = IndexRange
+
+class IntegerLiteral(Expression):
+    __slots__ = [
+        '_attr_value',
+    ]
+
+    def __init__(
+        self,
+        value=None,
+    ):
+        super().__init__()
+        self.value = value
+
+    @property
+    def value(self):
+        return self._attr_value
+
+    @value.setter
+    def value(self, val):
+        if val is None:
+            del self.value
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Int):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('value must be of type cqasm.v3x.primitives.Int')
+            val = cqasm.v3x.primitives.Int(val)
+        self._attr_value = val
+
+    @value.deleter
+    def value(self):
+        self._attr_value = cqasm.v3x.primitives.Int()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, IntegerLiteral):
+            return False
+        if self.value != other.value:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('IntegerLiteral(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('value: ')
+        s.append(str(self.value) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return IntegerLiteral(
+            value=self._attr_value
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return IntegerLiteral(
+            value=_cloned(self._attr_value)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'IntegerLiteral':
+            raise ValueError('found node serialization for ' + typ + ', but expected IntegerLiteral')
+
+        # Deserialize the value field.
+        field = cbor.get('value', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field value')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_value = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the IntegerLiteral node.
+        node = IntegerLiteral(f_value)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'IntegerLiteral'}
+
+        # Serialize the value field.
+        if hasattr(self._attr_value, 'serialize_cbor'):
+            cbor['value'] = self._attr_value.serialize_cbor()
+        else:
+            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_value)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIntegerLiteral(_Multiple):
+    """Wrapper for an edge with multiple IntegerLiteral objects."""
+
+    _T = IntegerLiteral
+
+
+_typemap['IntegerLiteral'] = IntegerLiteral
+
+class Keyword(Node):
+    __slots__ = [
+        '_attr_name',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+    ):
+        super().__init__()
+        self.name = name
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Str):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
+            val = cqasm.v3x.primitives.Str(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = cqasm.v3x.primitives.Str()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Keyword):
+            return False
+        if self.name != other.name:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Keyword(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        s.append(str(self.name) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Keyword(
+            name=self._attr_name
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Keyword(
+            name=_cloned(self._attr_name)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Keyword':
+            raise ValueError('found node serialization for ' + typ + ', but expected Keyword')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
+            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
+        else:
+            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
+
+        # Construct the Keyword node.
+        node = Keyword(f_name)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Keyword'}
+
+        # Serialize the name field.
+        if hasattr(self._attr_name, 'serialize_cbor'):
+            cbor['name'] = self._attr_name.serialize_cbor()
+        else:
+            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiKeyword(_Multiple):
+    """Wrapper for an edge with multiple Keyword objects."""
+
+    _T = Keyword
+
+
+_typemap['Keyword'] = Keyword
+
+class LogicalExpression(BinaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'LogicalAndExpression':
+            return LogicalAndExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalXorExpression':
+            return LogicalXorExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'LogicalOrExpression':
+            return LogicalOrExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'LogicalExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiLogicalExpression(_Multiple):
+    """Wrapper for an edge with multiple LogicalExpression objects."""
+
+    _T = LogicalExpression
+
+
+_typemap['LogicalExpression'] = LogicalExpression
+
+class LogicalAndExpression(LogicalExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, LogicalAndExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('LogicalAndExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return LogicalAndExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return LogicalAndExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'LogicalAndExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected LogicalAndExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the LogicalAndExpression node.
+        node = LogicalAndExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'LogicalAndExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiLogicalAndExpression(_Multiple):
+    """Wrapper for an edge with multiple LogicalAndExpression objects."""
+
+    _T = LogicalAndExpression
+
+
+_typemap['LogicalAndExpression'] = LogicalAndExpression
+
+class LogicalNotExpression(UnaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        expr=None,
+    ):
+        super().__init__(expr=expr)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, LogicalNotExpression):
+            return False
+        if self.expr != other.expr:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('LogicalNotExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('expr: ')
+        if self.expr is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_expr is not None:
+            self._attr_expr.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_expr is None:
+            raise NotWellFormed('expr is required but not set')
+        if self._attr_expr is not None:
+            self._attr_expr.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return LogicalNotExpression(
+            expr=self._attr_expr
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return LogicalNotExpression(
+            expr=_cloned(self._attr_expr)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'LogicalNotExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected LogicalNotExpression')
+
+        # Deserialize the expr field.
+        field = cbor.get('expr', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field expr')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field expr')
+        if field.get('@t', None) is None:
+            f_expr = None
+        else:
+            f_expr = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the LogicalNotExpression node.
+        node = LogicalNotExpression(f_expr)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'LogicalNotExpression'}
+
+        # Serialize the expr field.
+        field = {'@T': '1'}
+        if self._attr_expr is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_expr._serialize(id_map))
+        cbor['expr'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiLogicalNotExpression(_Multiple):
+    """Wrapper for an edge with multiple LogicalNotExpression objects."""
+
+    _T = LogicalNotExpression
+
+
+_typemap['LogicalNotExpression'] = LogicalNotExpression
+
+class LogicalOrExpression(LogicalExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, LogicalOrExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('LogicalOrExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return LogicalOrExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return LogicalOrExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'LogicalOrExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected LogicalOrExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the LogicalOrExpression node.
+        node = LogicalOrExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'LogicalOrExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiLogicalOrExpression(_Multiple):
+    """Wrapper for an edge with multiple LogicalOrExpression objects."""
+
+    _T = LogicalOrExpression
+
+
+_typemap['LogicalOrExpression'] = LogicalOrExpression
+
+class LogicalXorExpression(LogicalExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, LogicalXorExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('LogicalXorExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return LogicalXorExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return LogicalXorExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'LogicalXorExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected LogicalXorExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the LogicalXorExpression node.
+        node = LogicalXorExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'LogicalXorExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiLogicalXorExpression(_Multiple):
+    """Wrapper for an edge with multiple LogicalXorExpression objects."""
+
+    _T = LogicalXorExpression
+
+
+_typemap['LogicalXorExpression'] = LogicalXorExpression
+
+class MeasureInstruction(Instruction):
+    __slots__ = [
+        '_attr_name',
+        '_attr_operand',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+        operand=None,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+        self.name = name
+        self.operand = operand
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, Identifier):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type Identifier')
+            val = Identifier(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = None
+
+    @property
+    def operand(self):
+        return self._attr_operand
+
+    @operand.setter
+    def operand(self, val):
+        if val is None:
+            del self.operand
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operand must be of type Expression')
+            val = Expression(val)
+        self._attr_operand = val
+
+    @operand.deleter
+    def operand(self):
+        self._attr_operand = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, MeasureInstruction):
+            return False
+        if self.name != other.name:
+            return False
+        if self.operand != other.operand:
+            return False
+        if self.annotations != other.annotations:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('MeasureInstruction(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        if self.name is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('operand: ')
+        if self.operand is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.operand.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('annotations: ')
+        if not self.annotations:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.annotations:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_name is not None:
+            self._attr_name.find_reachable(id_map)
+        if self._attr_operand is not None:
+            self._attr_operand.find_reachable(id_map)
+        for el in self._attr_annotations:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_name is None:
+            raise NotWellFormed('name is required but not set')
+        if self._attr_name is not None:
+            self._attr_name.check_complete(id_map)
+        if self._attr_operand is None:
+            raise NotWellFormed('operand is required but not set')
+        if self._attr_operand is not None:
+            self._attr_operand.check_complete(id_map)
+        for child in self._attr_annotations:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return MeasureInstruction(
+            name=self._attr_name,
+            operand=self._attr_operand,
+            annotations=self._attr_annotations.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return MeasureInstruction(
+            name=_cloned(self._attr_name),
+            operand=_cloned(self._attr_operand),
+            annotations=_cloned(self._attr_annotations)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'MeasureInstruction':
+            raise ValueError('found node serialization for ' + typ + ', but expected MeasureInstruction')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field name')
+        if field.get('@t', None) is None:
+            f_name = None
+        else:
+            f_name = Identifier._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the operand field.
+        field = cbor.get('operand', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operand')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field operand')
+        if field.get('@t', None) is None:
+            f_operand = None
+        else:
+            f_operand = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the annotations field.
+        field = cbor.get('annotations', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field annotations')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field annotations')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_annotations = MultiAnnotationData()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
+
+        # Construct the MeasureInstruction node.
+        node = MeasureInstruction(f_name, f_operand, f_annotations)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'MeasureInstruction'}
+
+        # Serialize the name field.
+        field = {'@T': '1'}
+        if self._attr_name is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_name._serialize(id_map))
+        cbor['name'] = field
+
+        # Serialize the operand field.
+        field = {'@T': '1'}
+        if self._attr_operand is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_operand._serialize(id_map))
+        cbor['operand'] = field
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiMeasureInstruction(_Multiple):
+    """Wrapper for an edge with multiple MeasureInstruction objects."""
+
+    _T = MeasureInstruction
+
+
+_typemap['MeasureInstruction'] = MeasureInstruction
+
+class ModuloExpression(ArithmeticExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ModuloExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ModuloExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ModuloExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ModuloExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ModuloExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected ModuloExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the ModuloExpression node.
+        node = ModuloExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ModuloExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiModuloExpression(_Multiple):
+    """Wrapper for an edge with multiple ModuloExpression objects."""
+
+    _T = ModuloExpression
+
+
+_typemap['ModuloExpression'] = ModuloExpression
+
+class PowerExpression(ArithmeticExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, PowerExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('PowerExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return PowerExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return PowerExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'PowerExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected PowerExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the PowerExpression node.
+        node = PowerExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'PowerExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiPowerExpression(_Multiple):
+    """Wrapper for an edge with multiple PowerExpression objects."""
+
+    _T = PowerExpression
+
+
+_typemap['PowerExpression'] = PowerExpression
+
+class ProductExpression(ArithmeticExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ProductExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ProductExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ProductExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ProductExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ProductExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected ProductExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the ProductExpression node.
+        node = ProductExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ProductExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiProductExpression(_Multiple):
+    """Wrapper for an edge with multiple ProductExpression objects."""
+
+    _T = ProductExpression
+
+
+_typemap['ProductExpression'] = ProductExpression
+
+class Root(Node):
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Program':
+            return Program._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Root'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiRoot(_Multiple):
+    """Wrapper for an edge with multiple Root objects."""
+
+    _T = Root
+
+
+_typemap['Root'] = Root
+
+class Program(Root):
+    __slots__ = [
+        '_attr_version',
+        '_attr_block',
+    ]
+
+    def __init__(
+        self,
+        version=None,
+        block=None,
+    ):
+        super().__init__()
+        self.version = version
+        self.block = block
+
+    @property
+    def version(self):
+        return self._attr_version
+
+    @version.setter
+    def version(self, val):
+        if val is None:
+            del self.version
+            return
+        if not isinstance(val, Version):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('version must be of type Version')
+            val = Version(val)
+        self._attr_version = val
+
+    @version.deleter
+    def version(self):
+        self._attr_version = None
+
+    @property
+    def block(self):
+        return self._attr_block
+
+    @block.setter
+    def block(self, val):
+        if val is None:
+            del self.block
+            return
+        if not isinstance(val, GlobalBlock):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('block must be of type GlobalBlock')
+            val = GlobalBlock(val)
+        self._attr_block = val
+
+    @block.deleter
+    def block(self):
+        self._attr_block = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Program):
+            return False
+        if self.version != other.version:
+            return False
+        if self.block != other.block:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Program(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('version: ')
+        if self.version is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.version.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('block: ')
+        if self.block is None:
+            s.append('-\n')
+        else:
+            s.append('<\n')
+            s.append(self.block.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_version is not None:
+            self._attr_version.find_reachable(id_map)
+        if self._attr_block is not None:
+            self._attr_block.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_version is None:
+            raise NotWellFormed('version is required but not set')
+        if self._attr_version is not None:
+            self._attr_version.check_complete(id_map)
+        if self._attr_block is not None:
+            self._attr_block.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Program(
+            version=self._attr_version,
+            block=self._attr_block
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Program(
+            version=_cloned(self._attr_version),
+            block=_cloned(self._attr_block)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Program':
+            raise ValueError('found node serialization for ' + typ + ', but expected Program')
+
+        # Deserialize the version field.
+        field = cbor.get('version', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field version')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field version')
+        if field.get('@t', None) is None:
+            f_version = None
+        else:
+            f_version = Version._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the block field.
+        field = cbor.get('block', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field block')
+        if field.get('@T') != '?':
+            raise ValueError('unexpected edge type for field block')
+        if field.get('@t', None) is None:
+            f_block = None
+        else:
+            f_block = GlobalBlock._deserialize(field, seq_to_ob, links)
+
+        # Construct the Program node.
+        node = Program(f_version, f_block)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Program'}
+
+        # Serialize the version field.
+        field = {'@T': '1'}
+        if self._attr_version is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_version._serialize(id_map))
+        cbor['version'] = field
+
+        # Serialize the block field.
+        field = {'@T': '?'}
+        if self._attr_block is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_block._serialize(id_map))
+        cbor['block'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiProgram(_Multiple):
+    """Wrapper for an edge with multiple Program objects."""
+
+    _T = Program
+
+
+_typemap['Program'] = Program
+
+class ShiftExpression(BinaryExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'ShiftLeftExpression':
+            return ShiftLeftExpression._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ShiftRightExpression':
+            return ShiftRightExpression._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ShiftExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiShiftExpression(_Multiple):
+    """Wrapper for an edge with multiple ShiftExpression objects."""
+
+    _T = ShiftExpression
+
+
+_typemap['ShiftExpression'] = ShiftExpression
+
+class ShiftLeftExpression(ShiftExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ShiftLeftExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ShiftLeftExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ShiftLeftExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ShiftLeftExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ShiftLeftExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected ShiftLeftExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the ShiftLeftExpression node.
+        node = ShiftLeftExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ShiftLeftExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiShiftLeftExpression(_Multiple):
+    """Wrapper for an edge with multiple ShiftLeftExpression objects."""
+
+    _T = ShiftLeftExpression
+
+
+_typemap['ShiftLeftExpression'] = ShiftLeftExpression
+
+class ShiftRightExpression(ShiftExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ShiftRightExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ShiftRightExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ShiftRightExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ShiftRightExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ShiftRightExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected ShiftRightExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the ShiftRightExpression node.
+        node = ShiftRightExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ShiftRightExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiShiftRightExpression(_Multiple):
+    """Wrapper for an edge with multiple ShiftRightExpression objects."""
+
+    _T = ShiftRightExpression
+
+
+_typemap['ShiftRightExpression'] = ShiftRightExpression
+
+class SubtractionExpression(ArithmeticExpression):
+    __slots__ = []
+
+    def __init__(
+        self,
+        lhs=None,
+        rhs=None,
+    ):
+        super().__init__(lhs=lhs, rhs=rhs)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, SubtractionExpression):
+            return False
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('SubtractionExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return SubtractionExpression(
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return SubtractionExpression(
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'SubtractionExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected SubtractionExpression')
+
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field rhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field rhs')
+        if field.get('@t', None) is None:
+            f_rhs = None
+        else:
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the SubtractionExpression node.
+        node = SubtractionExpression(f_lhs, f_rhs)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'SubtractionExpression'}
+
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
+        field = {'@T': '1'}
+        if self._attr_rhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiSubtractionExpression(_Multiple):
+    """Wrapper for an edge with multiple SubtractionExpression objects."""
+
+    _T = SubtractionExpression
+
+
+_typemap['SubtractionExpression'] = SubtractionExpression
+
+class TernaryConditionalExpression(Expression):
+    __slots__ = [
+        '_attr_cond',
+        '_attr_if_true',
+        '_attr_if_false',
+    ]
+
+    def __init__(
+        self,
+        cond=None,
+        if_true=None,
+        if_false=None,
+    ):
+        super().__init__()
+        self.cond = cond
+        self.if_true = if_true
+        self.if_false = if_false
+
+    @property
+    def cond(self):
+        return self._attr_cond
+
+    @cond.setter
+    def cond(self, val):
+        if val is None:
+            del self.cond
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('cond must be of type Expression')
+            val = Expression(val)
+        self._attr_cond = val
+
+    @cond.deleter
+    def cond(self):
+        self._attr_cond = None
+
+    @property
+    def if_true(self):
+        return self._attr_if_true
+
+    @if_true.setter
+    def if_true(self, val):
+        if val is None:
+            del self.if_true
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('if_true must be of type Expression')
+            val = Expression(val)
+        self._attr_if_true = val
+
+    @if_true.deleter
+    def if_true(self):
+        self._attr_if_true = None
+
+    @property
+    def if_false(self):
+        return self._attr_if_false
+
+    @if_false.setter
+    def if_false(self, val):
+        if val is None:
+            del self.if_false
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('if_false must be of type Expression')
+            val = Expression(val)
+        self._attr_if_false = val
+
+    @if_false.deleter
+    def if_false(self):
+        self._attr_if_false = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, TernaryConditionalExpression):
+            return False
+        if self.cond != other.cond:
+            return False
+        if self.if_true != other.if_true:
+            return False
+        if self.if_false != other.if_false:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('TernaryConditionalExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('cond: ')
+        if self.cond is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.cond.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('if_true: ')
+        if self.if_true is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.if_true.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('if_false: ')
+        if self.if_false is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.if_false.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_cond is not None:
+            self._attr_cond.find_reachable(id_map)
+        if self._attr_if_true is not None:
+            self._attr_if_true.find_reachable(id_map)
+        if self._attr_if_false is not None:
+            self._attr_if_false.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_cond is None:
+            raise NotWellFormed('cond is required but not set')
+        if self._attr_cond is not None:
+            self._attr_cond.check_complete(id_map)
+        if self._attr_if_true is None:
+            raise NotWellFormed('if_true is required but not set')
+        if self._attr_if_true is not None:
+            self._attr_if_true.check_complete(id_map)
+        if self._attr_if_false is None:
+            raise NotWellFormed('if_false is required but not set')
+        if self._attr_if_false is not None:
+            self._attr_if_false.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return TernaryConditionalExpression(
+            cond=self._attr_cond,
+            if_true=self._attr_if_true,
+            if_false=self._attr_if_false
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return TernaryConditionalExpression(
+            cond=_cloned(self._attr_cond),
+            if_true=_cloned(self._attr_if_true),
+            if_false=_cloned(self._attr_if_false)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'TernaryConditionalExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected TernaryConditionalExpression')
+
+        # Deserialize the cond field.
+        field = cbor.get('cond', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field cond')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field cond')
+        if field.get('@t', None) is None:
+            f_cond = None
+        else:
+            f_cond = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the if_true field.
+        field = cbor.get('if_true', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field if_true')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field if_true')
+        if field.get('@t', None) is None:
+            f_if_true = None
+        else:
+            f_if_true = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the if_false field.
+        field = cbor.get('if_false', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field if_false')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field if_false')
+        if field.get('@t', None) is None:
+            f_if_false = None
+        else:
+            f_if_false = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the TernaryConditionalExpression node.
+        node = TernaryConditionalExpression(f_cond, f_if_true, f_if_false)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'TernaryConditionalExpression'}
+
+        # Serialize the cond field.
+        field = {'@T': '1'}
+        if self._attr_cond is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_cond._serialize(id_map))
+        cbor['cond'] = field
+
+        # Serialize the if_true field.
+        field = {'@T': '1'}
+        if self._attr_if_true is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_if_true._serialize(id_map))
+        cbor['if_true'] = field
+
+        # Serialize the if_false field.
+        field = {'@T': '1'}
+        if self._attr_if_false is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_if_false._serialize(id_map))
+        cbor['if_false'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiTernaryConditionalExpression(_Multiple):
+    """Wrapper for an edge with multiple TernaryConditionalExpression objects.
+    """
+
+    _T = TernaryConditionalExpression
+
+
+_typemap['TernaryConditionalExpression'] = TernaryConditionalExpression
+
+class Type(Node):
+    __slots__ = [
+        '_attr_name',
+        '_attr_size',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+        size=None,
+    ):
+        super().__init__()
+        self.name = name
+        self.size = size
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, Keyword):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type Keyword')
+            val = Keyword(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = None
+
+    @property
+    def size(self):
+        return self._attr_size
+
+    @size.setter
+    def size(self, val):
+        if val is None:
+            del self.size
+            return
+        if not isinstance(val, IntegerLiteral):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('size must be of type IntegerLiteral')
+            val = IntegerLiteral(val)
+        self._attr_size = val
+
+    @size.deleter
+    def size(self):
+        self._attr_size = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Type):
+            return False
+        if self.name != other.name:
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Type(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        if self.name is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('size: ')
+        if self.size is None:
+            s.append('-\n')
+        else:
+            s.append('<\n')
+            s.append(self.size.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_name is not None:
+            self._attr_name.find_reachable(id_map)
+        if self._attr_size is not None:
+            self._attr_size.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_name is None:
+            raise NotWellFormed('name is required but not set')
+        if self._attr_name is not None:
+            self._attr_name.check_complete(id_map)
+        if self._attr_size is not None:
+            self._attr_size.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Type(
+            name=self._attr_name,
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Type(
+            name=_cloned(self._attr_name),
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Type':
+            raise ValueError('found node serialization for ' + typ + ', but expected Type')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field name')
+        if field.get('@t', None) is None:
+            f_name = None
+        else:
+            f_name = Keyword._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if field.get('@T') != '?':
+            raise ValueError('unexpected edge type for field size')
+        if field.get('@t', None) is None:
+            f_size = None
+        else:
+            f_size = IntegerLiteral._deserialize(field, seq_to_ob, links)
+
+        # Construct the Type node.
+        node = Type(f_name, f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Type'}
+
+        # Serialize the name field.
+        field = {'@T': '1'}
+        if self._attr_name is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_name._serialize(id_map))
+        cbor['name'] = field
+
+        # Serialize the size field.
+        field = {'@T': '?'}
+        if self._attr_size is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_size._serialize(id_map))
+        cbor['size'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiType(_Multiple):
+    """Wrapper for an edge with multiple Type objects."""
+
+    _T = Type
+
+
+_typemap['Type'] = Type
+
+class UnaryMinusExpression(UnaryExpression):
+    """Two's complement."""
+
+    __slots__ = []
+
+    def __init__(
+        self,
+        expr=None,
+    ):
+        super().__init__(expr=expr)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, UnaryMinusExpression):
+            return False
+        if self.expr != other.expr:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('UnaryMinusExpression(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('expr: ')
+        if self.expr is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.expr.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_expr is not None:
+            self._attr_expr.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_expr is None:
+            raise NotWellFormed('expr is required but not set')
+        if self._attr_expr is not None:
+            self._attr_expr.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return UnaryMinusExpression(
+            expr=self._attr_expr
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return UnaryMinusExpression(
+            expr=_cloned(self._attr_expr)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'UnaryMinusExpression':
+            raise ValueError('found node serialization for ' + typ + ', but expected UnaryMinusExpression')
+
+        # Deserialize the expr field.
+        field = cbor.get('expr', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field expr')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field expr')
+        if field.get('@t', None) is None:
+            f_expr = None
+        else:
+            f_expr = Expression._deserialize(field, seq_to_ob, links)
+
+        # Construct the UnaryMinusExpression node.
+        node = UnaryMinusExpression(f_expr)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'UnaryMinusExpression'}
+
+        # Serialize the expr field.
+        field = {'@T': '1'}
+        if self._attr_expr is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_expr._serialize(id_map))
+        cbor['expr'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiUnaryMinusExpression(_Multiple):
+    """Wrapper for an edge with multiple UnaryMinusExpression objects."""
+
+    _T = UnaryMinusExpression
+
+
+_typemap['UnaryMinusExpression'] = UnaryMinusExpression
+
+class Variable(BlockStatement):
+    """One variable declaration of some type."""
+
+    __slots__ = [
+        '_attr_name',
+        '_attr_typ',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+        typ=None,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+        self.name = name
+        self.typ = typ
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, Identifier):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type Identifier')
+            val = Identifier(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = None
+
+    @property
+    def typ(self):
+        return self._attr_typ
+
+    @typ.setter
+    def typ(self, val):
+        if val is None:
+            del self.typ
+            return
+        if not isinstance(val, Type):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('typ must be of type Type')
+            val = Type(val)
+        self._attr_typ = val
+
+    @typ.deleter
+    def typ(self):
+        self._attr_typ = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Variable):
+            return False
+        if self.name != other.name:
+            return False
+        if self.typ != other.typ:
+            return False
+        if self.annotations != other.annotations:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Variable(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        if self.name is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.name.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('typ: ')
+        if self.typ is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.typ.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('annotations: ')
+        if not self.annotations:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.annotations:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_name is not None:
+            self._attr_name.find_reachable(id_map)
+        if self._attr_typ is not None:
+            self._attr_typ.find_reachable(id_map)
+        for el in self._attr_annotations:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_name is None:
+            raise NotWellFormed('name is required but not set')
+        if self._attr_name is not None:
+            self._attr_name.check_complete(id_map)
+        if self._attr_typ is None:
+            raise NotWellFormed('typ is required but not set')
+        if self._attr_typ is not None:
+            self._attr_typ.check_complete(id_map)
+        for child in self._attr_annotations:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Variable(
+            name=self._attr_name,
+            typ=self._attr_typ,
+            annotations=self._attr_annotations.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Variable(
+            name=_cloned(self._attr_name),
+            typ=_cloned(self._attr_typ),
+            annotations=_cloned(self._attr_annotations)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Variable':
+            raise ValueError('found node serialization for ' + typ + ', but expected Variable')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field name')
+        if field.get('@t', None) is None:
+            f_name = None
+        else:
+            f_name = Identifier._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the typ field.
+        field = cbor.get('typ', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field typ')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field typ')
+        if field.get('@t', None) is None:
+            f_typ = None
+        else:
+            f_typ = Type._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the annotations field.
+        field = cbor.get('annotations', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field annotations')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field annotations')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_annotations = MultiAnnotationData()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
+
+        # Construct the Variable node.
+        node = Variable(f_name, f_typ, f_annotations)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Variable'}
+
+        # Serialize the name field.
+        field = {'@T': '1'}
+        if self._attr_name is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_name._serialize(id_map))
+        cbor['name'] = field
+
+        # Serialize the typ field.
+        field = {'@T': '1'}
+        if self._attr_typ is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_typ._serialize(id_map))
+        cbor['typ'] = field
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiVariable(_Multiple):
+    """Wrapper for an edge with multiple Variable objects."""
+
+    _T = Variable
+
+
+_typemap['Variable'] = Variable
+
+class Version(Node):
+    __slots__ = [
+        '_attr_items',
+    ]
+
+    def __init__(
+        self,
+        items=None,
+    ):
+        super().__init__()
+        self.items = items
+
+    @property
+    def items(self):
+        return self._attr_items
+
+    @items.setter
+    def items(self, val):
+        if val is None:
+            del self.items
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Version):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('items must be of type cqasm.v3x.primitives.Version')
+            val = cqasm.v3x.primitives.Version(val)
+        self._attr_items = val
+
+    @items.deleter
+    def items(self):
+        self._attr_items = cqasm.v3x.primitives.Version()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Version):
+            return False
+        if self.items != other.items:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Version(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('items: ')
+        s.append(str(self.items) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Version(
+            items=self._attr_items
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Version(
+            items=_cloned(self._attr_items)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Version':
+            raise ValueError('found node serialization for ' + typ + ', but expected Version')
+
+        # Deserialize the items field.
+        field = cbor.get('items', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field items')
+        if hasattr(cqasm.v3x.primitives.Version, 'deserialize_cbor'):
+            f_items = cqasm.v3x.primitives.Version.deserialize_cbor(field)
+        else:
+            f_items = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Version, field)
+
+        # Construct the Version node.
+        node = Version(f_items)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Version'}
+
+        # Serialize the items field.
+        if hasattr(self._attr_items, 'serialize_cbor'):
+            cbor['items'] = self._attr_items.serialize_cbor()
+        else:
+            cbor['items'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Version, self._attr_items)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiVersion(_Multiple):
+    """Wrapper for an edge with multiple Version objects."""
+
+    _T = Version
+
+
+_typemap['Version'] = Version
+
```

## cqasm/v3x/instruction.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-import cqasm.v3x.types
-
-
-class Instruction(object):
-    def __init__(self, name, types=None):
-        super().__init__()
-        self._name = str(name)
-        if types is None:
-            self._types = ()
-        else:
-            for typ in types:
-                if not isinstance(typ, cqasm.v3x.types.Node):
-                    raise TypeError('types must be an iterable of cqasm.v3x.types.Node if specified')
-            self._types = tuple(types)
-
-    @property
-    def name(self):
-        return self._name
-
-    @property
-    def types(self):
-        return self._types
-
-    def __str__(self):
-        return '{}({})'.format(self._name, ', '.join(map(str, self._types)))
-
-
-class InstructionRef(object):
-    def __init__(self, *args, **kwargs):
-        if not args and not kwargs:
-            self._data = None
-        elif len(args) == 1 and not kwargs and (isinstance(args[0], Instruction) or args[0] is None):
-            self._data = args[0]
-        else:
-            self._data = Instruction(*args, **kwargs)
-
-    @property
-    def data(self):
-        return self._data
-
-    def __str__(self):
-        return 'unresolved' if self._data is None else str(self._data)
+import cqasm.v3x.types
+
+
+class Instruction(object):
+    def __init__(self, name, types=None):
+        super().__init__()
+        self._name = str(name)
+        if types is None:
+            self._types = ()
+        else:
+            for typ in types:
+                if not isinstance(typ, cqasm.v3x.types.Node):
+                    raise TypeError('types must be an iterable of cqasm.v3x.types.Node if specified')
+            self._types = tuple(types)
+
+    @property
+    def name(self):
+        return self._name
+
+    @property
+    def types(self):
+        return self._types
+
+    def __str__(self):
+        return '{}({})'.format(self._name, ', '.join(map(str, self._types)))
+
+
+class InstructionRef(object):
+    def __init__(self, *args, **kwargs):
+        if not args and not kwargs:
+            self._data = None
+        elif len(args) == 1 and not kwargs and (isinstance(args[0], Instruction) or args[0] is None):
+            self._data = args[0]
+        else:
+            self._data = Instruction(*args, **kwargs)
+
+    @property
+    def data(self):
+        return self._data
+
+    def __str__(self):
+        return 'unresolved' if self._data is None else str(self._data)
```

## cqasm/v3x/primitives.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-import cqasm.v3x.instruction
-import cqasm.v3x.types
-
-Str = str
-Bool = bool
-Int = int
-Float = float
-Complex = complex
-
-
-class Version(tuple):
-    """cQASM file version number."""
-
-    def __new__(cls, elements):
-        if isinstance(elements, str):
-            elements = elements.split('.')
-        return super(Version, cls).__new__(cls, tuple(map(int, elements)))
-
-
-def serialize(typ, val):
-    if isinstance(typ, str):
-        return None
-    elif typ is Str:
-        return {'x': val}
-    elif typ is Bool:
-        return {'x': val}
-    elif typ is Int:
-        return {'x': val}
-    elif typ is Float:
-        return {'x': val}
-    elif typ is Version:
-        return {'x': list(val)}
-    elif typ is cqasm.v3x.instruction.InstructionRef:
-        if val.data is None:
-            return {}
-        else:
-            return {
-                'n': val.data.name,
-                't': [x.serialize() for x in val.data.types]
-            }
-    else:
-        assert False
-
-
-def deserialize(typ, val):
-    if isinstance(typ, str):
-        return None
-    elif typ is Str:
-        return Str(val['x'])
-    elif typ is Bool:
-        return Bool(val['x'])
-    elif typ is Int:
-        return Int(val['x'])
-    elif typ is Float:
-        return Float(val['x'])
-    elif typ is Version:
-        return Version(val['x'])
-    elif typ is cqasm.v3x.instruction.InstructionRef:
-        if 'n' in val:
-            return cqasm.v3x.instruction.InstructionRef(
-                val['n'],
-                [cqasm.v3x.types.Node.deserialize(x) for x in val['t']]
-            )
-        else:
-            return cqasm.v3x.instruction.InstructionRef()
-    else:
-        assert False
+import cqasm.v3x.instruction
+import cqasm.v3x.types
+
+Str = str
+Bool = bool
+Int = int
+Float = float
+Complex = complex
+
+
+class Version(tuple):
+    """cQASM file version number."""
+
+    def __new__(cls, elements):
+        if isinstance(elements, str):
+            elements = elements.split('.')
+        return super(Version, cls).__new__(cls, tuple(map(int, elements)))
+
+
+def serialize(typ, val):
+    if isinstance(typ, str):
+        return None
+    elif typ is Str:
+        return {'x': val}
+    elif typ is Bool:
+        return {'x': val}
+    elif typ is Int:
+        return {'x': val}
+    elif typ is Float:
+        return {'x': val}
+    elif typ is Version:
+        return {'x': list(val)}
+    elif typ is cqasm.v3x.instruction.InstructionRef:
+        if val.data is None:
+            return {}
+        else:
+            return {
+                'n': val.data.name,
+                't': [x.serialize() for x in val.data.types]
+            }
+    else:
+        assert False
+
+
+def deserialize(typ, val):
+    if isinstance(typ, str):
+        return None
+    elif typ is Str:
+        return Str(val['x'])
+    elif typ is Bool:
+        return Bool(val['x'])
+    elif typ is Int:
+        return Int(val['x'])
+    elif typ is Float:
+        return Float(val['x'])
+    elif typ is Version:
+        return Version(val['x'])
+    elif typ is cqasm.v3x.instruction.InstructionRef:
+        if 'n' in val:
+            return cqasm.v3x.instruction.InstructionRef(
+                val['n'],
+                [cqasm.v3x.types.Node.deserialize(x) for x in val['t']]
+            )
+        else:
+            return cqasm.v3x.instruction.InstructionRef()
+    else:
+        assert False
```

## cqasm/v3x/semantic.py

 * *Ordering differences only*

```diff
@@ -1,2358 +1,2358 @@
-import functools
-import struct
-import cqasm.v3x.instruction
-import cqasm.v3x.primitives
-import cqasm.v3x.types
-import cqasm.v3x.values
-
-
-_typemap = {}
-
-
-def _cbor_read_intlike(cbor, offset, info):
-    """Parses the additional information and reads any additional bytes it
-    specifies the existence of, and returns the encoded integer. offset
-    should point to the byte immediately following the initial byte. Returns
-    the encoded integer and the offset immediately following the object."""
-
-    # Info less than 24 is a shorthand for the integer itself.
-    if info < 24:
-        return info, offset
-
-    # 24 is 8-bit following the info byte.
-    if info == 24:
-        return cbor[offset], offset + 1
-
-    # 25 is 16-bit following the info byte.
-    if info == 25:
-        val, = struct.unpack('>H', cbor[offset:offset+2])
-        return val, offset + 2
-
-    # 26 is 32-bit following the info byte.
-    if info == 26:
-        val, = struct.unpack('>I', cbor[offset:offset+4])
-        return val, offset + 4
-
-    # 27 is 64-bit following the info byte.
-    if info == 27:
-        val, = struct.unpack('>Q', cbor[offset:offset+8])
-        return val, offset + 8
-
-    # Info greater than or equal to 28 is illegal. Note that 31 is used for
-    # indefinite lengths, so this must be checked prior to calling this
-    # method.
-    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
-
-
-def _sub_cbor_to_py(cbor, offset):
-    """Converts the CBOR object starting at cbor[offset] to its Python
-    representation for as far as tree-gen supports CBOR. Returns this Python
-    representation and the offset immediately following the CBOR representation
-    thereof. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    # Read the initial byte.
-    initial = cbor[offset]
-    typ = initial >> 5
-    info = initial & 0x1F
-    offset += 1
-
-    # Handle unsigned integer (0) and negative integer (1).
-    if typ <= 1:
-        value, offset = _cbor_read_intlike(cbor, offset, info)
-        if typ == 1:
-            value = -1 - value
-        return value, offset
-
-    # Handle byte string (2) and UTF-8 string (3).
-    if typ <= 3:
-
-        # Gather components of the string in here.
-        if info == 31:
-
-            # Handle indefinite length strings. These consist of a
-            # break-terminated (0xFF) list of definite-length strings of the
-            # same type.
-            value = []
-            while True:
-                sub_initial = cbor[offset]; offset += 1
-                if sub_initial == 0xFF:
-                    break
-                sub_typ = sub_initial >> 5
-                sub_info = sub_initial & 0x1F
-                if sub_typ != typ:
-                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
-
-                # Seek past definite-length string component. The size in
-                # bytes is encoded as an integer.
-                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
-                value.append(cbor[offset:offset + size])
-                offset += size
-            value = b''.join(value)
-
-        else:
-
-            # Handle definite-length strings. The size in bytes is encoded as
-            # an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            value = cbor[offset:offset + size]
-            offset += size
-
-        if typ == 3:
-            value = value.decode('UTF-8')
-        return value, offset
-
-    # Handle array (4) and map (5).
-    if typ <= 5:
-
-        # Create result container.
-        container = [] if typ == 4 else {}
-
-        # Handle indefinite length arrays and maps.
-        if info == 31:
-
-            # Read objects/object pairs until we encounter a break.
-            while cbor[offset] != 0xFF:
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-            # Seek past the break.
-            offset += 1
-
-        else:
-
-            # Handle definite-length arrays and maps. The amount of
-            # objects/object pairs is encoded as an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            for _ in range(size):
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-        return container, offset
-
-    # Handle semantic tags.
-    if typ == 6:
-
-        # We don't use semantic tags for anything, but ignoring them is
-        # legal and reading past them is easy enough.
-        _, offset = _cbor_read_intlike(cbor, offset, info)
-        return _sub_cbor_to_py(cbor, offset)
-
-    # Handle major type 7. Here, the type is defined by the additional info.
-    # Additional info 24 is reserved for having the type specified by the
-    # next byte, but all such values are unassigned.
-    if info == 20:
-        # false
-        return False, offset
-
-    if info == 21:
-        # true
-        return True, offset
-
-    if info == 22:
-        # null
-        return None, offset
-
-    if info == 23:
-        # Undefined value.
-        raise ValueError('invalid CBOR: undefined value is not supported')
-
-    if info == 25:
-        # Half-precision float.
-        raise ValueError('invalid CBOR: half-precision float is not supported')
-
-    if info == 26:
-        # Single-precision float.
-        raise ValueError('invalid CBOR: single-precision float is not supported')
-
-    if info == 27:
-        # Double-precision float.
-        value, = struct.unpack('>d', cbor[offset:offset+8])
-        return value, offset + 8
-
-    if info == 31:
-        # Break value used for indefinite-length objects.
-        raise ValueError('invalid CBOR: unexpected break')
-
-    raise ValueError('invalid CBOR: unknown type code')
-
-
-def _cbor_to_py(cbor):
-    """Converts the given CBOR object (bytes) to its Python representation for
-    as far as tree-gen supports CBOR. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    value, length = _sub_cbor_to_py(cbor, 0)
-    if length < len(cbor):
-        raise ValueError('invalid CBOR: garbage at the end')
-    return value
-
-
-class _Cbor(bytes):
-    """Marker class indicating that this bytes object represents CBOR."""
-    pass
-
-
-def _cbor_write_intlike(value, major=0):
-    """Converts the given integer to its minimal representation in CBOR. The
-    major code can be overridden to write lengths for strings, arrays, and
-    maps."""
-
-    # Negative integers use major code 1.
-    if value < 0:
-        major = 1
-        value = -1 - value
-    initial = major << 5
-
-    # Use the minimal representation.
-    if value < 24:
-        return struct.pack('>B', initial | value)
-    if value < 0x100:
-        return struct.pack('>BB', initial | 24, value)
-    if value < 0x10000:
-        return struct.pack('>BH', initial | 25, value)
-    if value < 0x100000000:
-        return struct.pack('>BI', initial | 26, value)
-    if value < 0x10000000000000000:
-        return struct.pack('>BQ', initial | 27, value)
-
-    raise ValueError('integer too large for CBOR (bigint not supported)')
-
-
-def _py_to_cbor(value, type_converter=None):
-    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
-    that takes a value and either converts it to a primitive for serialization,
-    converts it to a _Cbor object manually, or raises a TypeError if no
-    conversion is known. If no type_converter is specified, a TypeError is
-    raised in all cases the type_converter would otherwise be called. The cbor
-    serialization is returned using a _Cbor object, which is just a marker class
-    behaving just like bytes."""
-    if isinstance(value, _Cbor):
-        return value
-
-    if isinstance(value, int):
-        return _Cbor(_cbor_write_intlike(value))
-
-    if isinstance(value, float):
-        return _Cbor(struct.pack('>Bd', 0xFB, value))
-
-    if isinstance(value, str):
-        value = value.encode('UTF-8')
-        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
-
-    if isinstance(value, bytes):
-        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
-
-    if value is False:
-        return _Cbor(b'\xF4')
-
-    if value is True:
-        return _Cbor(b'\xF5')
-
-    if value is None:
-        return _Cbor(b'\xF6')
-
-    if isinstance(value, (list, tuple)):
-        cbor = [_cbor_write_intlike(len(value), 4)]
-        for val in value:
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if isinstance(value, dict):
-        cbor = [_cbor_write_intlike(len(value), 5)]
-        for key, val in sorted(value.items()):
-            if not isinstance(key, str):
-                raise TypeError('dict keys must be strings')
-            cbor.append(_py_to_cbor(key, type_converter))
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if type_converter is not None:
-        return _py_to_cbor(type_converter(value))
-
-    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
-
-
-class NotWellFormed(ValueError):
-    """Exception class for well-formedness checks."""
-
-    def __init__(self, msg):
-        super().__init__('not well-formed: ' + str(msg))
-
-
-class Node(object):
-    """Base class for nodes."""
-
-    __slots__ = ['_annot']
-
-    def __init__(self):
-        super().__init__()
-        self._annot = {}
-
-    def __getitem__(self, key):
-        """Returns the annotation object with the specified key, or raises
-        KeyError if not found."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        return self._annot[key]
-
-    def __setitem__(self, key, val):
-        """Assigns the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        self._annot[key] = val
-
-    def __delitem__(self, key):
-        """Deletes the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        del self._annot[key]
-
-    def __contains__(self, key):
-        """Returns whether an annotation exists for the specified key."""
-        return key in self._annot
-
-    @staticmethod
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it. Note that this is overridden
-        by the actual node class implementations; this base function does very
-        little."""
-        if id_map is None:
-            id_map = {}
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes. Note that this is
-        overridden by the actual node class implementations; this base function
-        always raises an exception."""
-        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
-
-    def check_well_formed(self):
-        """Checks whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links).
-
-        If it isn't well-formed, a NotWellFormed is thrown."""
-        self.check_complete()
-
-    def is_well_formed(self):
-        """Returns whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links)."""
-        try:
-            self.check_well_formed()
-            return True
-        except NotWellFormed:
-            return False
-
-    def copy(self):
-        """Returns a shallow copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
-
-    def clone(self):
-        """Returns a deep copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
-
-    @classmethod
-    def deserialize(cls, cbor):
-        """Attempts to deserialize the given cbor object (either as bytes or as
-        its Python primitive representation) into a node of this type."""
-        if isinstance(cbor, bytes):
-            cbor = _cbor_to_py(cbor)
-        seq_to_ob = {}
-        links = []
-        root = cls._deserialize(cbor, seq_to_ob, links)
-        for link_setter, seq in links:
-            ob = seq_to_ob.get(seq, None)
-            if ob is None:
-                raise ValueError('found link to nonexistent object')
-            link_setter(ob)
-        return root
-
-    def serialize(self):
-        """Serializes this node into its cbor representation in the form of a
-        bytes object."""
-        id_map = self.find_reachable()
-        self.check_complete(id_map)
-        return _py_to_cbor(self._serialize(id_map))
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        node_type = _typemap.get(cbor.get('@t'), None)
-        if node_type is None:
-            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
-        return node_type._deserialize(cbor, seq_to_ob, links)
-
-
-@functools.total_ordering
-class _Multiple(object):
-    """Base class for the Any* and Many* edge helper classes. Inheriting
-    classes must set the class constant _T to the node type they are made
-    for."""
-
-    __slots__ = ['_l']
-
-    def __init__(self,  *args, **kwargs):
-        super().__init__()
-        self._l = list(*args, **kwargs)
-        for idx, val in enumerate(self._l):
-            if not isinstance(val, self._T):
-                raise TypeError(
-                    'object {!r} at index {:d} is not an instance of {!r}'
-                    .format(val, idx, self._T))
-
-    def __repr__(self):
-        return '{}({!r})'.format(type(self).__name__, self._l)
-
-    def clone(self):
-        return self.__class__(map(lambda node: node.clone(), self._l))
-
-    def __len__(self):
-        return len(self._l)
-
-    def __getitem__(self, idx):
-        return self._l[idx]
-
-    def __setitem__(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, idx, self._T))
-        self._l[idx] = val
-
-    def __delitem__(self, idx):
-        del self._l[idx]
-
-    def __iter__(self):
-        return iter(self._l)
-
-    def __reversed__(self):
-        return reversed(self._l)
-
-    def __contains__(self, val):
-        return val in self._l
-
-    def append(self, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.append(val)
-
-    def extend(self, iterable):
-        for val in iterable:
-            self.append(val)
-
-    def insert(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.insert(idx, val)
-
-    def remote(self, val):
-        self._l.remove(val)
-
-    def pop(self, idx=-1):
-        return self._l.pop(idx)
-
-    def clear(self):
-        self._l.clear()
-
-    def idx(self, val, start=0, end=-1):
-        return self._l.idx(val, start, end)
-
-    def count(self, val):
-        return self._l.count(val)
-
-    def sort(self, key=None, reverse=False):
-        self._l.sort(key=key, reverse=reverse)
-
-    def reverse(self):
-        self._l.reverse()
-
-    def copy(self):
-        return self.__class__(self)
-
-    def __eq__(self, other):
-        if not isinstance(other, _Multiple):
-            return False
-        return self._l == other._l
-
-    def __lt__(self, other):
-        return self._l < other._l
-
-    def __iadd__(self, other):
-        self.extend(other)
-
-    def __add__(self, other):
-        copy = self.copy()
-        copy += other
-        return copy
-
-    def __imul__(self, other):
-        self._l *= other
-
-    def __mul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-    def __rmul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-
-class MultiNode(_Multiple):
-    """Wrapper for an edge with multiple Node objects."""
-
-    _T = Node
-
-
-def _cloned(obj):
-    """Attempts to clone the given object by calling its clone() method, if it
-    has one."""
-    if hasattr(obj, 'clone'):
-        return obj.clone()
-    return obj
-
-
-class Annotated(Node):
-    """Represents a node that carries annotation data."""
-
-    __slots__ = [
-        '_attr_annotations',
-    ]
-
-    def __init__(
-        self,
-        annotations=None,
-    ):
-        super().__init__()
-        self.annotations = annotations
-
-    @property
-    def annotations(self):
-        return self._attr_annotations
-
-    @annotations.setter
-    def annotations(self, val):
-        if val is None:
-            del self.annotations
-            return
-        if not isinstance(val, MultiAnnotationData):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('annotations must be of type MultiAnnotationData')
-            val = MultiAnnotationData(val)
-        self._attr_annotations = val
-
-    @annotations.deleter
-    def annotations(self):
-        self._attr_annotations = MultiAnnotationData()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Variable':
-            return Variable._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Instruction':
-            return Instruction._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Annotated'}
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiAnnotated(_Multiple):
-    """Wrapper for an edge with multiple Annotated objects."""
-
-    _T = Annotated
-
-
-_typemap['Annotated'] = Annotated
-
-class AnnotationData(Node):
-    """Represents an annotation."""
-
-    __slots__ = [
-        '_attr_interface',
-        '_attr_operation',
-        '_attr_operands',
-    ]
-
-    def __init__(
-        self,
-        interface=None,
-        operation=None,
-        operands=None,
-    ):
-        super().__init__()
-        self.interface = interface
-        self.operation = operation
-        self.operands = operands
-
-    @property
-    def interface(self):
-        """The interface this annotation is intended for. If a target doesn't
-        support an interface, it should silently ignore the annotation."""
-        return self._attr_interface
-
-    @interface.setter
-    def interface(self, val):
-        if val is None:
-            del self.interface
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Str):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('interface must be of type cqasm.v3x.primitives.Str')
-            val = cqasm.v3x.primitives.Str(val)
-        self._attr_interface = val
-
-    @interface.deleter
-    def interface(self):
-        self._attr_interface = cqasm.v3x.primitives.Str()
-
-    @property
-    def operation(self):
-        """The operation within the interface that this annotation is intended
-        for. If a target supports the corresponding interface but not the
-        operation, it should throw an error."""
-        return self._attr_operation
-
-    @operation.setter
-    def operation(self, val):
-        if val is None:
-            del self.operation
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Str):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operation must be of type cqasm.v3x.primitives.Str')
-            val = cqasm.v3x.primitives.Str(val)
-        self._attr_operation = val
-
-    @operation.deleter
-    def operation(self):
-        self._attr_operation = cqasm.v3x.primitives.Str()
-
-    @property
-    def operands(self):
-        """Any operands attached to the annotation."""
-        return self._attr_operands
-
-    @operands.setter
-    def operands(self, val):
-        if val is None:
-            del self.operands
-            return
-        if not isinstance(val, cqasm.v3x.values.MultiNode):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operands must be of type cqasm.v3x.values.MultiNode')
-            val = cqasm.v3x.values.MultiNode(val)
-        self._attr_operands = val
-
-    @operands.deleter
-    def operands(self):
-        self._attr_operands = cqasm.v3x.values.MultiNode()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, AnnotationData):
-            return False
-        if self.interface != other.interface:
-            return False
-        if self.operation != other.operation:
-            return False
-        if self.operands != other.operands:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('AnnotationData(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('interface: ')
-        s.append(str(self.interface) + '\n')
-        s.append('  '*indent)
-        s.append('operation: ')
-        s.append(str(self.operation) + '\n')
-        s.append('  '*indent)
-        s.append('operands: ')
-        if not self.operands:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.operands:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        for el in self._attr_operands:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        for child in self._attr_operands:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return AnnotationData(
-            interface=self._attr_interface,
-            operation=self._attr_operation,
-            operands=self._attr_operands.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return AnnotationData(
-            interface=_cloned(self._attr_interface),
-            operation=_cloned(self._attr_operation),
-            operands=_cloned(self._attr_operands)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'AnnotationData':
-            raise ValueError('found node serialization for ' + typ + ', but expected AnnotationData')
-
-        # Deserialize the interface field.
-        field = cbor.get('interface', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field interface')
-        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
-            f_interface = cqasm.v3x.primitives.Str.deserialize_cbor(field)
-        else:
-            f_interface = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
-
-        # Deserialize the operation field.
-        field = cbor.get('operation', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operation')
-        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
-            f_operation = cqasm.v3x.primitives.Str.deserialize_cbor(field)
-        else:
-            f_operation = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
-
-        # Deserialize the operands field.
-        field = cbor.get('operands', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operands')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field operands')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_operands = cqasm.v3x.values.MultiNode()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_operands.append(cqasm.v3x.values.Node._deserialize(element, seq_to_ob, links))
-
-        # Construct the AnnotationData node.
-        node = AnnotationData(f_interface, f_operation, f_operands)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'AnnotationData'}
-
-        # Serialize the interface field.
-        if hasattr(self._attr_interface, 'serialize_cbor'):
-            cbor['interface'] = self._attr_interface.serialize_cbor()
-        else:
-            cbor['interface'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_interface)
-
-        # Serialize the operation field.
-        if hasattr(self._attr_operation, 'serialize_cbor'):
-            cbor['operation'] = self._attr_operation.serialize_cbor()
-        else:
-            cbor['operation'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_operation)
-
-        # Serialize the operands field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_operands:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['operands'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiAnnotationData(_Multiple):
-    """Wrapper for an edge with multiple AnnotationData objects."""
-
-    _T = AnnotationData
-
-
-_typemap['AnnotationData'] = AnnotationData
-
-class Block(Node):
-    __slots__ = [
-        '_attr_statements',
-    ]
-
-    def __init__(
-        self,
-        statements=None,
-    ):
-        super().__init__()
-        self.statements = statements
-
-    @property
-    def statements(self):
-        return self._attr_statements
-
-    @statements.setter
-    def statements(self, val):
-        if val is None:
-            del self.statements
-            return
-        if not isinstance(val, MultiStatement):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('statements must be of type MultiStatement')
-            val = MultiStatement(val)
-        self._attr_statements = val
-
-    @statements.deleter
-    def statements(self):
-        self._attr_statements = MultiStatement()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Block):
-            return False
-        if self.statements != other.statements:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Block(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('statements: ')
-        if not self.statements:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.statements:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        for el in self._attr_statements:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        for child in self._attr_statements:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Block(
-            statements=self._attr_statements.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Block(
-            statements=_cloned(self._attr_statements)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Block':
-            raise ValueError('found node serialization for ' + typ + ', but expected Block')
-
-        # Deserialize the statements field.
-        field = cbor.get('statements', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field statements')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field statements')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_statements = MultiStatement()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_statements.append(Statement._deserialize(element, seq_to_ob, links))
-
-        # Construct the Block node.
-        node = Block(f_statements)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Block'}
-
-        # Serialize the statements field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_statements:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['statements'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBlock(_Multiple):
-    """Wrapper for an edge with multiple Block objects."""
-
-    _T = Block
-
-
-_typemap['Block'] = Block
-
-class Statement(Annotated):
-    __slots__ = []
-
-    def __init__(
-        self,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Instruction':
-            return Instruction._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Statement'}
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiStatement(_Multiple):
-    """Wrapper for an edge with multiple Statement objects."""
-
-    _T = Statement
-
-
-_typemap['Statement'] = Statement
-
-class Instruction(Statement):
-    """Regular instruction (a gate, or a measure instruction)."""
-
-    __slots__ = [
-        '_attr_instruction_ref',
-        '_attr_name',
-        '_attr_operands',
-    ]
-
-    def __init__(
-        self,
-        instruction_ref=None,
-        name=None,
-        operands=None,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-        self.instruction_ref = instruction_ref
-        self.name = name
-        self.operands = operands
-
-    @property
-    def instruction_ref(self):
-        return self._attr_instruction_ref
-
-    @instruction_ref.setter
-    def instruction_ref(self, val):
-        if val is None:
-            del self.instruction_ref
-            return
-        if not isinstance(val, cqasm.v3x.instruction.InstructionRef):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('instruction_ref must be of type cqasm.v3x.instruction.InstructionRef')
-            val = cqasm.v3x.instruction.InstructionRef(val)
-        self._attr_instruction_ref = val
-
-    @instruction_ref.deleter
-    def instruction_ref(self):
-        self._attr_instruction_ref = cqasm.v3x.instruction.InstructionRef()
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Str):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
-            val = cqasm.v3x.primitives.Str(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = cqasm.v3x.primitives.Str()
-
-    @property
-    def operands(self):
-        return self._attr_operands
-
-    @operands.setter
-    def operands(self, val):
-        if val is None:
-            del self.operands
-            return
-        if not isinstance(val, cqasm.v3x.values.MultiValueBase):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('operands must be of type cqasm.v3x.values.MultiValueBase')
-            val = cqasm.v3x.values.MultiValueBase(val)
-        self._attr_operands = val
-
-    @operands.deleter
-    def operands(self):
-        self._attr_operands = cqasm.v3x.values.MultiValueBase()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Instruction):
-            return False
-        if self.instruction_ref != other.instruction_ref:
-            return False
-        if self.name != other.name:
-            return False
-        if self.operands != other.operands:
-            return False
-        if self.annotations != other.annotations:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Instruction(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('instruction_ref: ')
-        s.append(str(self.instruction_ref) + '\n')
-        s.append('  '*indent)
-        s.append('name: ')
-        s.append(str(self.name) + '\n')
-        s.append('  '*indent)
-        s.append('operands: ')
-        if not self.operands:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.operands:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        s.append('  '*indent)
-        s.append('annotations: ')
-        if not self.annotations:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.annotations:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        for el in self._attr_operands:
-            el.find_reachable(id_map)
-        for el in self._attr_annotations:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        for child in self._attr_operands:
-            child.check_complete(id_map)
-        for child in self._attr_annotations:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Instruction(
-            instruction_ref=self._attr_instruction_ref,
-            name=self._attr_name,
-            operands=self._attr_operands.copy(),
-            annotations=self._attr_annotations.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Instruction(
-            instruction_ref=_cloned(self._attr_instruction_ref),
-            name=_cloned(self._attr_name),
-            operands=_cloned(self._attr_operands),
-            annotations=_cloned(self._attr_annotations)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Instruction':
-            raise ValueError('found node serialization for ' + typ + ', but expected Instruction')
-
-        # Deserialize the instruction_ref field.
-        field = cbor.get('instruction_ref', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field instruction_ref')
-        if hasattr(cqasm.v3x.instruction.InstructionRef, 'deserialize_cbor'):
-            f_instruction_ref = cqasm.v3x.instruction.InstructionRef.deserialize_cbor(field)
-        else:
-            f_instruction_ref = cqasm.v3x.primitives.deserialize(cqasm.v3x.instruction.InstructionRef, field)
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
-            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
-        else:
-            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
-
-        # Deserialize the operands field.
-        field = cbor.get('operands', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operands')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field operands')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_operands = cqasm.v3x.values.MultiValueBase()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_operands.append(cqasm.v3x.values.ValueBase._deserialize(element, seq_to_ob, links))
-
-        # Deserialize the annotations field.
-        field = cbor.get('annotations', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field annotations')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field annotations')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_annotations = MultiAnnotationData()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
-
-        # Construct the Instruction node.
-        node = Instruction(f_instruction_ref, f_name, f_operands, f_annotations)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Instruction'}
-
-        # Serialize the instruction_ref field.
-        if hasattr(self._attr_instruction_ref, 'serialize_cbor'):
-            cbor['instruction_ref'] = self._attr_instruction_ref.serialize_cbor()
-        else:
-            cbor['instruction_ref'] = cqasm.v3x.primitives.serialize(cqasm.v3x.instruction.InstructionRef, self._attr_instruction_ref)
-
-        # Serialize the name field.
-        if hasattr(self._attr_name, 'serialize_cbor'):
-            cbor['name'] = self._attr_name.serialize_cbor()
-        else:
-            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
-
-        # Serialize the operands field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_operands:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['operands'] = field
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiInstruction(_Multiple):
-    """Wrapper for an edge with multiple Instruction objects."""
-
-    _T = Instruction
-
-
-_typemap['Instruction'] = Instruction
-
-class Program(Node):
-    __slots__ = [
-        '_attr_api_version',
-        '_attr_version',
-        '_attr_qubit_variable_declaration',
-        '_attr_block',
-    ]
-
-    def __init__(
-        self,
-        api_version=None,
-        version=None,
-        qubit_variable_declaration=None,
-        block=None,
-    ):
-        super().__init__()
-        self.api_version = api_version
-        self.version = version
-        self.qubit_variable_declaration = qubit_variable_declaration
-        self.block = block
-
-    @property
-    def api_version(self):
-        """API version. This may be greater than or equal to the file version.
-        This controls which fields of the tree are used, where such usage
-        depends on the version."""
-        return self._attr_api_version
-
-    @api_version.setter
-    def api_version(self, val):
-        if val is None:
-            del self.api_version
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Version):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('api_version must be of type cqasm.v3x.primitives.Version')
-            val = cqasm.v3x.primitives.Version(val)
-        self._attr_api_version = val
-
-    @api_version.deleter
-    def api_version(self):
-        self._attr_api_version = cqasm.v3x.primitives.Version()
-
-    @property
-    def version(self):
-        """File version."""
-        return self._attr_version
-
-    @version.setter
-    def version(self, val):
-        if val is None:
-            del self.version
-            return
-        if not isinstance(val, Version):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('version must be of type Version')
-            val = Version(val)
-        self._attr_version = val
-
-    @version.deleter
-    def version(self):
-        self._attr_version = None
-
-    @property
-    def qubit_variable_declaration(self):
-        """Qubit variable."""
-        return self._attr_qubit_variable_declaration
-
-    @qubit_variable_declaration.setter
-    def qubit_variable_declaration(self, val):
-        if val is None:
-            del self.qubit_variable_declaration
-            return
-        if not isinstance(val, Variable):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('qubit_variable_declaration must be of type Variable')
-            val = Variable(val)
-        self._attr_qubit_variable_declaration = val
-
-    @qubit_variable_declaration.deleter
-    def qubit_variable_declaration(self):
-        self._attr_qubit_variable_declaration = None
-
-    @property
-    def block(self):
-        """Global scope block."""
-        return self._attr_block
-
-    @block.setter
-    def block(self, val):
-        if val is None:
-            del self.block
-            return
-        if not isinstance(val, Block):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('block must be of type Block')
-            val = Block(val)
-        self._attr_block = val
-
-    @block.deleter
-    def block(self):
-        self._attr_block = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Program):
-            return False
-        if self.api_version != other.api_version:
-            return False
-        if self.version != other.version:
-            return False
-        if self.qubit_variable_declaration != other.qubit_variable_declaration:
-            return False
-        if self.block != other.block:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Program(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('api_version: ')
-        s.append(str(self.api_version) + '\n')
-        s.append('  '*indent)
-        s.append('version: ')
-        if self.version is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.version.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('qubit_variable_declaration: ')
-        if self.qubit_variable_declaration is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.qubit_variable_declaration.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('block: ')
-        if self.block is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.block.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_version is not None:
-            self._attr_version.find_reachable(id_map)
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.find_reachable(id_map)
-        if self._attr_block is not None:
-            self._attr_block.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_version is None:
-            raise NotWellFormed('version is required but not set')
-        if self._attr_version is not None:
-            self._attr_version.check_complete(id_map)
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.check_complete(id_map)
-        if self._attr_block is not None:
-            self._attr_block.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Program(
-            api_version=self._attr_api_version,
-            version=self._attr_version,
-            qubit_variable_declaration=self._attr_qubit_variable_declaration,
-            block=self._attr_block
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Program(
-            api_version=_cloned(self._attr_api_version),
-            version=_cloned(self._attr_version),
-            qubit_variable_declaration=_cloned(self._attr_qubit_variable_declaration),
-            block=_cloned(self._attr_block)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Program':
-            raise ValueError('found node serialization for ' + typ + ', but expected Program')
-
-        # Deserialize the api_version field.
-        field = cbor.get('api_version', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field api_version')
-        if hasattr(cqasm.v3x.primitives.Version, 'deserialize_cbor'):
-            f_api_version = cqasm.v3x.primitives.Version.deserialize_cbor(field)
-        else:
-            f_api_version = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Version, field)
-
-        # Deserialize the version field.
-        field = cbor.get('version', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field version')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field version')
-        if field.get('@t', None) is None:
-            f_version = None
-        else:
-            f_version = Version._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the qubit_variable_declaration field.
-        field = cbor.get('qubit_variable_declaration', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field qubit_variable_declaration')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field qubit_variable_declaration')
-        if field.get('@t', None) is None:
-            f_qubit_variable_declaration = None
-        else:
-            f_qubit_variable_declaration = Variable._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the block field.
-        field = cbor.get('block', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field block')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field block')
-        if field.get('@t', None) is None:
-            f_block = None
-        else:
-            f_block = Block._deserialize(field, seq_to_ob, links)
-
-        # Construct the Program node.
-        node = Program(f_api_version, f_version, f_qubit_variable_declaration, f_block)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Program'}
-
-        # Serialize the api_version field.
-        if hasattr(self._attr_api_version, 'serialize_cbor'):
-            cbor['api_version'] = self._attr_api_version.serialize_cbor()
-        else:
-            cbor['api_version'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Version, self._attr_api_version)
-
-        # Serialize the version field.
-        field = {'@T': '1'}
-        if self._attr_version is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_version._serialize(id_map))
-        cbor['version'] = field
-
-        # Serialize the qubit_variable_declaration field.
-        field = {'@T': '?'}
-        if self._attr_qubit_variable_declaration is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_qubit_variable_declaration._serialize(id_map))
-        cbor['qubit_variable_declaration'] = field
-
-        # Serialize the block field.
-        field = {'@T': '?'}
-        if self._attr_block is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_block._serialize(id_map))
-        cbor['block'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiProgram(_Multiple):
-    """Wrapper for an edge with multiple Program objects."""
-
-    _T = Program
-
-
-_typemap['Program'] = Program
-
-class Variable(Annotated):
-    __slots__ = [
-        '_attr_name',
-        '_attr_typ',
-    ]
-
-    def __init__(
-        self,
-        name=None,
-        typ=None,
-        annotations=None,
-    ):
-        super().__init__(annotations=annotations)
-        self.name = name
-        self.typ = typ
-
-    @property
-    def name(self):
-        return self._attr_name
-
-    @name.setter
-    def name(self, val):
-        if val is None:
-            del self.name
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Str):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
-            val = cqasm.v3x.primitives.Str(val)
-        self._attr_name = val
-
-    @name.deleter
-    def name(self):
-        self._attr_name = cqasm.v3x.primitives.Str()
-
-    @property
-    def typ(self):
-        return self._attr_typ
-
-    @typ.setter
-    def typ(self, val):
-        if val is None:
-            del self.typ
-            return
-        if not isinstance(val, cqasm.v3x.types.TypeBase):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('typ must be of type cqasm.v3x.types.TypeBase')
-            val = cqasm.v3x.types.TypeBase(val)
-        self._attr_typ = val
-
-    @typ.deleter
-    def typ(self):
-        self._attr_typ = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Variable):
-            return False
-        if self.name != other.name:
-            return False
-        if self.typ != other.typ:
-            return False
-        if self.annotations != other.annotations:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Variable(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('name: ')
-        s.append(str(self.name) + '\n')
-        s.append('  '*indent)
-        s.append('typ: ')
-        if self.typ is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.typ.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('annotations: ')
-        if not self.annotations:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.annotations:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        if self._attr_typ is not None:
-            self._attr_typ.find_reachable(id_map)
-        for el in self._attr_annotations:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_typ is None:
-            raise NotWellFormed('typ is required but not set')
-        if self._attr_typ is not None:
-            self._attr_typ.check_complete(id_map)
-        for child in self._attr_annotations:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Variable(
-            name=self._attr_name,
-            typ=self._attr_typ,
-            annotations=self._attr_annotations.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Variable(
-            name=_cloned(self._attr_name),
-            typ=_cloned(self._attr_typ),
-            annotations=_cloned(self._attr_annotations)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Variable':
-            raise ValueError('found node serialization for ' + typ + ', but expected Variable')
-
-        # Deserialize the name field.
-        field = cbor.get('name', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field name')
-        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
-            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
-        else:
-            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
-
-        # Deserialize the typ field.
-        field = cbor.get('typ', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field typ')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field typ')
-        if field.get('@t', None) is None:
-            f_typ = None
-        else:
-            f_typ = cqasm.v3x.types.TypeBase._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the annotations field.
-        field = cbor.get('annotations', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field annotations')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field annotations')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_annotations = MultiAnnotationData()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
-
-        # Construct the Variable node.
-        node = Variable(f_name, f_typ, f_annotations)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Variable'}
-
-        # Serialize the name field.
-        if hasattr(self._attr_name, 'serialize_cbor'):
-            cbor['name'] = self._attr_name.serialize_cbor()
-        else:
-            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
-
-        # Serialize the typ field.
-        field = {'@T': '1'}
-        if self._attr_typ is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_typ._serialize(id_map))
-        cbor['typ'] = field
-
-        # Serialize the annotations field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_annotations:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['annotations'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiVariable(_Multiple):
-    """Wrapper for an edge with multiple Variable objects."""
-
-    _T = Variable
-
-
-_typemap['Variable'] = Variable
-
-class Version(Node):
-    __slots__ = [
-        '_attr_items',
-    ]
-
-    def __init__(
-        self,
-        items=None,
-    ):
-        super().__init__()
-        self.items = items
-
-    @property
-    def items(self):
-        return self._attr_items
-
-    @items.setter
-    def items(self, val):
-        if val is None:
-            del self.items
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Version):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('items must be of type cqasm.v3x.primitives.Version')
-            val = cqasm.v3x.primitives.Version(val)
-        self._attr_items = val
-
-    @items.deleter
-    def items(self):
-        self._attr_items = cqasm.v3x.primitives.Version()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Version):
-            return False
-        if self.items != other.items:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Version(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('items: ')
-        s.append(str(self.items) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Version(
-            items=self._attr_items
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Version(
-            items=_cloned(self._attr_items)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Version':
-            raise ValueError('found node serialization for ' + typ + ', but expected Version')
-
-        # Deserialize the items field.
-        field = cbor.get('items', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field items')
-        if hasattr(cqasm.v3x.primitives.Version, 'deserialize_cbor'):
-            f_items = cqasm.v3x.primitives.Version.deserialize_cbor(field)
-        else:
-            f_items = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Version, field)
-
-        # Construct the Version node.
-        node = Version(f_items)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Version'}
-
-        # Serialize the items field.
-        if hasattr(self._attr_items, 'serialize_cbor'):
-            cbor['items'] = self._attr_items.serialize_cbor()
-        else:
-            cbor['items'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Version, self._attr_items)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiVersion(_Multiple):
-    """Wrapper for an edge with multiple Version objects."""
-
-    _T = Version
-
-
-_typemap['Version'] = Version
-
+import functools
+import struct
+import cqasm.v3x.instruction
+import cqasm.v3x.primitives
+import cqasm.v3x.types
+import cqasm.v3x.values
+
+
+_typemap = {}
+
+
+def _cbor_read_intlike(cbor, offset, info):
+    """Parses the additional information and reads any additional bytes it
+    specifies the existence of, and returns the encoded integer. offset
+    should point to the byte immediately following the initial byte. Returns
+    the encoded integer and the offset immediately following the object."""
+
+    # Info less than 24 is a shorthand for the integer itself.
+    if info < 24:
+        return info, offset
+
+    # 24 is 8-bit following the info byte.
+    if info == 24:
+        return cbor[offset], offset + 1
+
+    # 25 is 16-bit following the info byte.
+    if info == 25:
+        val, = struct.unpack('>H', cbor[offset:offset+2])
+        return val, offset + 2
+
+    # 26 is 32-bit following the info byte.
+    if info == 26:
+        val, = struct.unpack('>I', cbor[offset:offset+4])
+        return val, offset + 4
+
+    # 27 is 64-bit following the info byte.
+    if info == 27:
+        val, = struct.unpack('>Q', cbor[offset:offset+8])
+        return val, offset + 8
+
+    # Info greater than or equal to 28 is illegal. Note that 31 is used for
+    # indefinite lengths, so this must be checked prior to calling this
+    # method.
+    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
+
+
+def _sub_cbor_to_py(cbor, offset):
+    """Converts the CBOR object starting at cbor[offset] to its Python
+    representation for as far as tree-gen supports CBOR. Returns this Python
+    representation and the offset immediately following the CBOR representation
+    thereof. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    # Read the initial byte.
+    initial = cbor[offset]
+    typ = initial >> 5
+    info = initial & 0x1F
+    offset += 1
+
+    # Handle unsigned integer (0) and negative integer (1).
+    if typ <= 1:
+        value, offset = _cbor_read_intlike(cbor, offset, info)
+        if typ == 1:
+            value = -1 - value
+        return value, offset
+
+    # Handle byte string (2) and UTF-8 string (3).
+    if typ <= 3:
+
+        # Gather components of the string in here.
+        if info == 31:
+
+            # Handle indefinite length strings. These consist of a
+            # break-terminated (0xFF) list of definite-length strings of the
+            # same type.
+            value = []
+            while True:
+                sub_initial = cbor[offset]; offset += 1
+                if sub_initial == 0xFF:
+                    break
+                sub_typ = sub_initial >> 5
+                sub_info = sub_initial & 0x1F
+                if sub_typ != typ:
+                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
+
+                # Seek past definite-length string component. The size in
+                # bytes is encoded as an integer.
+                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
+                value.append(cbor[offset:offset + size])
+                offset += size
+            value = b''.join(value)
+
+        else:
+
+            # Handle definite-length strings. The size in bytes is encoded as
+            # an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            value = cbor[offset:offset + size]
+            offset += size
+
+        if typ == 3:
+            value = value.decode('UTF-8')
+        return value, offset
+
+    # Handle array (4) and map (5).
+    if typ <= 5:
+
+        # Create result container.
+        container = [] if typ == 4 else {}
+
+        # Handle indefinite length arrays and maps.
+        if info == 31:
+
+            # Read objects/object pairs until we encounter a break.
+            while cbor[offset] != 0xFF:
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+            # Seek past the break.
+            offset += 1
+
+        else:
+
+            # Handle definite-length arrays and maps. The amount of
+            # objects/object pairs is encoded as an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            for _ in range(size):
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+        return container, offset
+
+    # Handle semantic tags.
+    if typ == 6:
+
+        # We don't use semantic tags for anything, but ignoring them is
+        # legal and reading past them is easy enough.
+        _, offset = _cbor_read_intlike(cbor, offset, info)
+        return _sub_cbor_to_py(cbor, offset)
+
+    # Handle major type 7. Here, the type is defined by the additional info.
+    # Additional info 24 is reserved for having the type specified by the
+    # next byte, but all such values are unassigned.
+    if info == 20:
+        # false
+        return False, offset
+
+    if info == 21:
+        # true
+        return True, offset
+
+    if info == 22:
+        # null
+        return None, offset
+
+    if info == 23:
+        # Undefined value.
+        raise ValueError('invalid CBOR: undefined value is not supported')
+
+    if info == 25:
+        # Half-precision float.
+        raise ValueError('invalid CBOR: half-precision float is not supported')
+
+    if info == 26:
+        # Single-precision float.
+        raise ValueError('invalid CBOR: single-precision float is not supported')
+
+    if info == 27:
+        # Double-precision float.
+        value, = struct.unpack('>d', cbor[offset:offset+8])
+        return value, offset + 8
+
+    if info == 31:
+        # Break value used for indefinite-length objects.
+        raise ValueError('invalid CBOR: unexpected break')
+
+    raise ValueError('invalid CBOR: unknown type code')
+
+
+def _cbor_to_py(cbor):
+    """Converts the given CBOR object (bytes) to its Python representation for
+    as far as tree-gen supports CBOR. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    value, length = _sub_cbor_to_py(cbor, 0)
+    if length < len(cbor):
+        raise ValueError('invalid CBOR: garbage at the end')
+    return value
+
+
+class _Cbor(bytes):
+    """Marker class indicating that this bytes object represents CBOR."""
+    pass
+
+
+def _cbor_write_intlike(value, major=0):
+    """Converts the given integer to its minimal representation in CBOR. The
+    major code can be overridden to write lengths for strings, arrays, and
+    maps."""
+
+    # Negative integers use major code 1.
+    if value < 0:
+        major = 1
+        value = -1 - value
+    initial = major << 5
+
+    # Use the minimal representation.
+    if value < 24:
+        return struct.pack('>B', initial | value)
+    if value < 0x100:
+        return struct.pack('>BB', initial | 24, value)
+    if value < 0x10000:
+        return struct.pack('>BH', initial | 25, value)
+    if value < 0x100000000:
+        return struct.pack('>BI', initial | 26, value)
+    if value < 0x10000000000000000:
+        return struct.pack('>BQ', initial | 27, value)
+
+    raise ValueError('integer too large for CBOR (bigint not supported)')
+
+
+def _py_to_cbor(value, type_converter=None):
+    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
+    that takes a value and either converts it to a primitive for serialization,
+    converts it to a _Cbor object manually, or raises a TypeError if no
+    conversion is known. If no type_converter is specified, a TypeError is
+    raised in all cases the type_converter would otherwise be called. The cbor
+    serialization is returned using a _Cbor object, which is just a marker class
+    behaving just like bytes."""
+    if isinstance(value, _Cbor):
+        return value
+
+    if isinstance(value, int):
+        return _Cbor(_cbor_write_intlike(value))
+
+    if isinstance(value, float):
+        return _Cbor(struct.pack('>Bd', 0xFB, value))
+
+    if isinstance(value, str):
+        value = value.encode('UTF-8')
+        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
+
+    if isinstance(value, bytes):
+        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
+
+    if value is False:
+        return _Cbor(b'\xF4')
+
+    if value is True:
+        return _Cbor(b'\xF5')
+
+    if value is None:
+        return _Cbor(b'\xF6')
+
+    if isinstance(value, (list, tuple)):
+        cbor = [_cbor_write_intlike(len(value), 4)]
+        for val in value:
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if isinstance(value, dict):
+        cbor = [_cbor_write_intlike(len(value), 5)]
+        for key, val in sorted(value.items()):
+            if not isinstance(key, str):
+                raise TypeError('dict keys must be strings')
+            cbor.append(_py_to_cbor(key, type_converter))
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if type_converter is not None:
+        return _py_to_cbor(type_converter(value))
+
+    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
+
+
+class NotWellFormed(ValueError):
+    """Exception class for well-formedness checks."""
+
+    def __init__(self, msg):
+        super().__init__('not well-formed: ' + str(msg))
+
+
+class Node(object):
+    """Base class for nodes."""
+
+    __slots__ = ['_annot']
+
+    def __init__(self):
+        super().__init__()
+        self._annot = {}
+
+    def __getitem__(self, key):
+        """Returns the annotation object with the specified key, or raises
+        KeyError if not found."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        return self._annot[key]
+
+    def __setitem__(self, key, val):
+        """Assigns the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        self._annot[key] = val
+
+    def __delitem__(self, key):
+        """Deletes the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        del self._annot[key]
+
+    def __contains__(self, key):
+        """Returns whether an annotation exists for the specified key."""
+        return key in self._annot
+
+    @staticmethod
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it. Note that this is overridden
+        by the actual node class implementations; this base function does very
+        little."""
+        if id_map is None:
+            id_map = {}
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes. Note that this is
+        overridden by the actual node class implementations; this base function
+        always raises an exception."""
+        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
+
+    def check_well_formed(self):
+        """Checks whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links).
+
+        If it isn't well-formed, a NotWellFormed is thrown."""
+        self.check_complete()
+
+    def is_well_formed(self):
+        """Returns whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links)."""
+        try:
+            self.check_well_formed()
+            return True
+        except NotWellFormed:
+            return False
+
+    def copy(self):
+        """Returns a shallow copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
+
+    def clone(self):
+        """Returns a deep copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
+
+    @classmethod
+    def deserialize(cls, cbor):
+        """Attempts to deserialize the given cbor object (either as bytes or as
+        its Python primitive representation) into a node of this type."""
+        if isinstance(cbor, bytes):
+            cbor = _cbor_to_py(cbor)
+        seq_to_ob = {}
+        links = []
+        root = cls._deserialize(cbor, seq_to_ob, links)
+        for link_setter, seq in links:
+            ob = seq_to_ob.get(seq, None)
+            if ob is None:
+                raise ValueError('found link to nonexistent object')
+            link_setter(ob)
+        return root
+
+    def serialize(self):
+        """Serializes this node into its cbor representation in the form of a
+        bytes object."""
+        id_map = self.find_reachable()
+        self.check_complete(id_map)
+        return _py_to_cbor(self._serialize(id_map))
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        node_type = _typemap.get(cbor.get('@t'), None)
+        if node_type is None:
+            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
+        return node_type._deserialize(cbor, seq_to_ob, links)
+
+
+@functools.total_ordering
+class _Multiple(object):
+    """Base class for the Any* and Many* edge helper classes. Inheriting
+    classes must set the class constant _T to the node type they are made
+    for."""
+
+    __slots__ = ['_l']
+
+    def __init__(self,  *args, **kwargs):
+        super().__init__()
+        self._l = list(*args, **kwargs)
+        for idx, val in enumerate(self._l):
+            if not isinstance(val, self._T):
+                raise TypeError(
+                    'object {!r} at index {:d} is not an instance of {!r}'
+                    .format(val, idx, self._T))
+
+    def __repr__(self):
+        return '{}({!r})'.format(type(self).__name__, self._l)
+
+    def clone(self):
+        return self.__class__(map(lambda node: node.clone(), self._l))
+
+    def __len__(self):
+        return len(self._l)
+
+    def __getitem__(self, idx):
+        return self._l[idx]
+
+    def __setitem__(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, idx, self._T))
+        self._l[idx] = val
+
+    def __delitem__(self, idx):
+        del self._l[idx]
+
+    def __iter__(self):
+        return iter(self._l)
+
+    def __reversed__(self):
+        return reversed(self._l)
+
+    def __contains__(self, val):
+        return val in self._l
+
+    def append(self, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.append(val)
+
+    def extend(self, iterable):
+        for val in iterable:
+            self.append(val)
+
+    def insert(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.insert(idx, val)
+
+    def remote(self, val):
+        self._l.remove(val)
+
+    def pop(self, idx=-1):
+        return self._l.pop(idx)
+
+    def clear(self):
+        self._l.clear()
+
+    def idx(self, val, start=0, end=-1):
+        return self._l.idx(val, start, end)
+
+    def count(self, val):
+        return self._l.count(val)
+
+    def sort(self, key=None, reverse=False):
+        self._l.sort(key=key, reverse=reverse)
+
+    def reverse(self):
+        self._l.reverse()
+
+    def copy(self):
+        return self.__class__(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, _Multiple):
+            return False
+        return self._l == other._l
+
+    def __lt__(self, other):
+        return self._l < other._l
+
+    def __iadd__(self, other):
+        self.extend(other)
+
+    def __add__(self, other):
+        copy = self.copy()
+        copy += other
+        return copy
+
+    def __imul__(self, other):
+        self._l *= other
+
+    def __mul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+    def __rmul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+
+class MultiNode(_Multiple):
+    """Wrapper for an edge with multiple Node objects."""
+
+    _T = Node
+
+
+def _cloned(obj):
+    """Attempts to clone the given object by calling its clone() method, if it
+    has one."""
+    if hasattr(obj, 'clone'):
+        return obj.clone()
+    return obj
+
+
+class Annotated(Node):
+    """Represents a node that carries annotation data."""
+
+    __slots__ = [
+        '_attr_annotations',
+    ]
+
+    def __init__(
+        self,
+        annotations=None,
+    ):
+        super().__init__()
+        self.annotations = annotations
+
+    @property
+    def annotations(self):
+        return self._attr_annotations
+
+    @annotations.setter
+    def annotations(self, val):
+        if val is None:
+            del self.annotations
+            return
+        if not isinstance(val, MultiAnnotationData):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('annotations must be of type MultiAnnotationData')
+            val = MultiAnnotationData(val)
+        self._attr_annotations = val
+
+    @annotations.deleter
+    def annotations(self):
+        self._attr_annotations = MultiAnnotationData()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Variable':
+            return Variable._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Instruction':
+            return Instruction._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Annotated'}
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiAnnotated(_Multiple):
+    """Wrapper for an edge with multiple Annotated objects."""
+
+    _T = Annotated
+
+
+_typemap['Annotated'] = Annotated
+
+class AnnotationData(Node):
+    """Represents an annotation."""
+
+    __slots__ = [
+        '_attr_interface',
+        '_attr_operation',
+        '_attr_operands',
+    ]
+
+    def __init__(
+        self,
+        interface=None,
+        operation=None,
+        operands=None,
+    ):
+        super().__init__()
+        self.interface = interface
+        self.operation = operation
+        self.operands = operands
+
+    @property
+    def interface(self):
+        """The interface this annotation is intended for. If a target doesn't
+        support an interface, it should silently ignore the annotation."""
+        return self._attr_interface
+
+    @interface.setter
+    def interface(self, val):
+        if val is None:
+            del self.interface
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Str):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('interface must be of type cqasm.v3x.primitives.Str')
+            val = cqasm.v3x.primitives.Str(val)
+        self._attr_interface = val
+
+    @interface.deleter
+    def interface(self):
+        self._attr_interface = cqasm.v3x.primitives.Str()
+
+    @property
+    def operation(self):
+        """The operation within the interface that this annotation is intended
+        for. If a target supports the corresponding interface but not the
+        operation, it should throw an error."""
+        return self._attr_operation
+
+    @operation.setter
+    def operation(self, val):
+        if val is None:
+            del self.operation
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Str):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operation must be of type cqasm.v3x.primitives.Str')
+            val = cqasm.v3x.primitives.Str(val)
+        self._attr_operation = val
+
+    @operation.deleter
+    def operation(self):
+        self._attr_operation = cqasm.v3x.primitives.Str()
+
+    @property
+    def operands(self):
+        """Any operands attached to the annotation."""
+        return self._attr_operands
+
+    @operands.setter
+    def operands(self, val):
+        if val is None:
+            del self.operands
+            return
+        if not isinstance(val, cqasm.v3x.values.MultiNode):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operands must be of type cqasm.v3x.values.MultiNode')
+            val = cqasm.v3x.values.MultiNode(val)
+        self._attr_operands = val
+
+    @operands.deleter
+    def operands(self):
+        self._attr_operands = cqasm.v3x.values.MultiNode()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, AnnotationData):
+            return False
+        if self.interface != other.interface:
+            return False
+        if self.operation != other.operation:
+            return False
+        if self.operands != other.operands:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('AnnotationData(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('interface: ')
+        s.append(str(self.interface) + '\n')
+        s.append('  '*indent)
+        s.append('operation: ')
+        s.append(str(self.operation) + '\n')
+        s.append('  '*indent)
+        s.append('operands: ')
+        if not self.operands:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.operands:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        for el in self._attr_operands:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        for child in self._attr_operands:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return AnnotationData(
+            interface=self._attr_interface,
+            operation=self._attr_operation,
+            operands=self._attr_operands.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return AnnotationData(
+            interface=_cloned(self._attr_interface),
+            operation=_cloned(self._attr_operation),
+            operands=_cloned(self._attr_operands)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'AnnotationData':
+            raise ValueError('found node serialization for ' + typ + ', but expected AnnotationData')
+
+        # Deserialize the interface field.
+        field = cbor.get('interface', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field interface')
+        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
+            f_interface = cqasm.v3x.primitives.Str.deserialize_cbor(field)
+        else:
+            f_interface = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
+
+        # Deserialize the operation field.
+        field = cbor.get('operation', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operation')
+        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
+            f_operation = cqasm.v3x.primitives.Str.deserialize_cbor(field)
+        else:
+            f_operation = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
+
+        # Deserialize the operands field.
+        field = cbor.get('operands', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operands')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field operands')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_operands = cqasm.v3x.values.MultiNode()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_operands.append(cqasm.v3x.values.Node._deserialize(element, seq_to_ob, links))
+
+        # Construct the AnnotationData node.
+        node = AnnotationData(f_interface, f_operation, f_operands)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'AnnotationData'}
+
+        # Serialize the interface field.
+        if hasattr(self._attr_interface, 'serialize_cbor'):
+            cbor['interface'] = self._attr_interface.serialize_cbor()
+        else:
+            cbor['interface'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_interface)
+
+        # Serialize the operation field.
+        if hasattr(self._attr_operation, 'serialize_cbor'):
+            cbor['operation'] = self._attr_operation.serialize_cbor()
+        else:
+            cbor['operation'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_operation)
+
+        # Serialize the operands field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_operands:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['operands'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiAnnotationData(_Multiple):
+    """Wrapper for an edge with multiple AnnotationData objects."""
+
+    _T = AnnotationData
+
+
+_typemap['AnnotationData'] = AnnotationData
+
+class Block(Node):
+    __slots__ = [
+        '_attr_statements',
+    ]
+
+    def __init__(
+        self,
+        statements=None,
+    ):
+        super().__init__()
+        self.statements = statements
+
+    @property
+    def statements(self):
+        return self._attr_statements
+
+    @statements.setter
+    def statements(self, val):
+        if val is None:
+            del self.statements
+            return
+        if not isinstance(val, MultiStatement):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('statements must be of type MultiStatement')
+            val = MultiStatement(val)
+        self._attr_statements = val
+
+    @statements.deleter
+    def statements(self):
+        self._attr_statements = MultiStatement()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Block):
+            return False
+        if self.statements != other.statements:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Block(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('statements: ')
+        if not self.statements:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.statements:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        for el in self._attr_statements:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        for child in self._attr_statements:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Block(
+            statements=self._attr_statements.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Block(
+            statements=_cloned(self._attr_statements)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Block':
+            raise ValueError('found node serialization for ' + typ + ', but expected Block')
+
+        # Deserialize the statements field.
+        field = cbor.get('statements', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field statements')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field statements')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_statements = MultiStatement()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_statements.append(Statement._deserialize(element, seq_to_ob, links))
+
+        # Construct the Block node.
+        node = Block(f_statements)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Block'}
+
+        # Serialize the statements field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_statements:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['statements'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBlock(_Multiple):
+    """Wrapper for an edge with multiple Block objects."""
+
+    _T = Block
+
+
+_typemap['Block'] = Block
+
+class Statement(Annotated):
+    __slots__ = []
+
+    def __init__(
+        self,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Instruction':
+            return Instruction._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Statement'}
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiStatement(_Multiple):
+    """Wrapper for an edge with multiple Statement objects."""
+
+    _T = Statement
+
+
+_typemap['Statement'] = Statement
+
+class Instruction(Statement):
+    """Regular instruction (a gate, or a measure instruction)."""
+
+    __slots__ = [
+        '_attr_instruction_ref',
+        '_attr_name',
+        '_attr_operands',
+    ]
+
+    def __init__(
+        self,
+        instruction_ref=None,
+        name=None,
+        operands=None,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+        self.instruction_ref = instruction_ref
+        self.name = name
+        self.operands = operands
+
+    @property
+    def instruction_ref(self):
+        return self._attr_instruction_ref
+
+    @instruction_ref.setter
+    def instruction_ref(self, val):
+        if val is None:
+            del self.instruction_ref
+            return
+        if not isinstance(val, cqasm.v3x.instruction.InstructionRef):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('instruction_ref must be of type cqasm.v3x.instruction.InstructionRef')
+            val = cqasm.v3x.instruction.InstructionRef(val)
+        self._attr_instruction_ref = val
+
+    @instruction_ref.deleter
+    def instruction_ref(self):
+        self._attr_instruction_ref = cqasm.v3x.instruction.InstructionRef()
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Str):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
+            val = cqasm.v3x.primitives.Str(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = cqasm.v3x.primitives.Str()
+
+    @property
+    def operands(self):
+        return self._attr_operands
+
+    @operands.setter
+    def operands(self, val):
+        if val is None:
+            del self.operands
+            return
+        if not isinstance(val, cqasm.v3x.values.MultiValueBase):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('operands must be of type cqasm.v3x.values.MultiValueBase')
+            val = cqasm.v3x.values.MultiValueBase(val)
+        self._attr_operands = val
+
+    @operands.deleter
+    def operands(self):
+        self._attr_operands = cqasm.v3x.values.MultiValueBase()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Instruction):
+            return False
+        if self.instruction_ref != other.instruction_ref:
+            return False
+        if self.name != other.name:
+            return False
+        if self.operands != other.operands:
+            return False
+        if self.annotations != other.annotations:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Instruction(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('instruction_ref: ')
+        s.append(str(self.instruction_ref) + '\n')
+        s.append('  '*indent)
+        s.append('name: ')
+        s.append(str(self.name) + '\n')
+        s.append('  '*indent)
+        s.append('operands: ')
+        if not self.operands:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.operands:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        s.append('  '*indent)
+        s.append('annotations: ')
+        if not self.annotations:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.annotations:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        for el in self._attr_operands:
+            el.find_reachable(id_map)
+        for el in self._attr_annotations:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        for child in self._attr_operands:
+            child.check_complete(id_map)
+        for child in self._attr_annotations:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Instruction(
+            instruction_ref=self._attr_instruction_ref,
+            name=self._attr_name,
+            operands=self._attr_operands.copy(),
+            annotations=self._attr_annotations.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Instruction(
+            instruction_ref=_cloned(self._attr_instruction_ref),
+            name=_cloned(self._attr_name),
+            operands=_cloned(self._attr_operands),
+            annotations=_cloned(self._attr_annotations)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Instruction':
+            raise ValueError('found node serialization for ' + typ + ', but expected Instruction')
+
+        # Deserialize the instruction_ref field.
+        field = cbor.get('instruction_ref', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field instruction_ref')
+        if hasattr(cqasm.v3x.instruction.InstructionRef, 'deserialize_cbor'):
+            f_instruction_ref = cqasm.v3x.instruction.InstructionRef.deserialize_cbor(field)
+        else:
+            f_instruction_ref = cqasm.v3x.primitives.deserialize(cqasm.v3x.instruction.InstructionRef, field)
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
+            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
+        else:
+            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
+
+        # Deserialize the operands field.
+        field = cbor.get('operands', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field operands')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field operands')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_operands = cqasm.v3x.values.MultiValueBase()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_operands.append(cqasm.v3x.values.ValueBase._deserialize(element, seq_to_ob, links))
+
+        # Deserialize the annotations field.
+        field = cbor.get('annotations', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field annotations')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field annotations')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_annotations = MultiAnnotationData()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
+
+        # Construct the Instruction node.
+        node = Instruction(f_instruction_ref, f_name, f_operands, f_annotations)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Instruction'}
+
+        # Serialize the instruction_ref field.
+        if hasattr(self._attr_instruction_ref, 'serialize_cbor'):
+            cbor['instruction_ref'] = self._attr_instruction_ref.serialize_cbor()
+        else:
+            cbor['instruction_ref'] = cqasm.v3x.primitives.serialize(cqasm.v3x.instruction.InstructionRef, self._attr_instruction_ref)
+
+        # Serialize the name field.
+        if hasattr(self._attr_name, 'serialize_cbor'):
+            cbor['name'] = self._attr_name.serialize_cbor()
+        else:
+            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
+
+        # Serialize the operands field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_operands:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['operands'] = field
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiInstruction(_Multiple):
+    """Wrapper for an edge with multiple Instruction objects."""
+
+    _T = Instruction
+
+
+_typemap['Instruction'] = Instruction
+
+class Program(Node):
+    __slots__ = [
+        '_attr_api_version',
+        '_attr_version',
+        '_attr_qubit_variable_declaration',
+        '_attr_block',
+    ]
+
+    def __init__(
+        self,
+        api_version=None,
+        version=None,
+        qubit_variable_declaration=None,
+        block=None,
+    ):
+        super().__init__()
+        self.api_version = api_version
+        self.version = version
+        self.qubit_variable_declaration = qubit_variable_declaration
+        self.block = block
+
+    @property
+    def api_version(self):
+        """API version. This may be greater than or equal to the file version.
+        This controls which fields of the tree are used, where such usage
+        depends on the version."""
+        return self._attr_api_version
+
+    @api_version.setter
+    def api_version(self, val):
+        if val is None:
+            del self.api_version
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Version):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('api_version must be of type cqasm.v3x.primitives.Version')
+            val = cqasm.v3x.primitives.Version(val)
+        self._attr_api_version = val
+
+    @api_version.deleter
+    def api_version(self):
+        self._attr_api_version = cqasm.v3x.primitives.Version()
+
+    @property
+    def version(self):
+        """File version."""
+        return self._attr_version
+
+    @version.setter
+    def version(self, val):
+        if val is None:
+            del self.version
+            return
+        if not isinstance(val, Version):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('version must be of type Version')
+            val = Version(val)
+        self._attr_version = val
+
+    @version.deleter
+    def version(self):
+        self._attr_version = None
+
+    @property
+    def qubit_variable_declaration(self):
+        """Qubit variable."""
+        return self._attr_qubit_variable_declaration
+
+    @qubit_variable_declaration.setter
+    def qubit_variable_declaration(self, val):
+        if val is None:
+            del self.qubit_variable_declaration
+            return
+        if not isinstance(val, Variable):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('qubit_variable_declaration must be of type Variable')
+            val = Variable(val)
+        self._attr_qubit_variable_declaration = val
+
+    @qubit_variable_declaration.deleter
+    def qubit_variable_declaration(self):
+        self._attr_qubit_variable_declaration = None
+
+    @property
+    def block(self):
+        """Global scope block."""
+        return self._attr_block
+
+    @block.setter
+    def block(self, val):
+        if val is None:
+            del self.block
+            return
+        if not isinstance(val, Block):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('block must be of type Block')
+            val = Block(val)
+        self._attr_block = val
+
+    @block.deleter
+    def block(self):
+        self._attr_block = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Program):
+            return False
+        if self.api_version != other.api_version:
+            return False
+        if self.version != other.version:
+            return False
+        if self.qubit_variable_declaration != other.qubit_variable_declaration:
+            return False
+        if self.block != other.block:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Program(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('api_version: ')
+        s.append(str(self.api_version) + '\n')
+        s.append('  '*indent)
+        s.append('version: ')
+        if self.version is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.version.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('qubit_variable_declaration: ')
+        if self.qubit_variable_declaration is None:
+            s.append('-\n')
+        else:
+            s.append('<\n')
+            s.append(self.qubit_variable_declaration.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('block: ')
+        if self.block is None:
+            s.append('-\n')
+        else:
+            s.append('<\n')
+            s.append(self.block.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_version is not None:
+            self._attr_version.find_reachable(id_map)
+        if self._attr_qubit_variable_declaration is not None:
+            self._attr_qubit_variable_declaration.find_reachable(id_map)
+        if self._attr_block is not None:
+            self._attr_block.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_version is None:
+            raise NotWellFormed('version is required but not set')
+        if self._attr_version is not None:
+            self._attr_version.check_complete(id_map)
+        if self._attr_qubit_variable_declaration is not None:
+            self._attr_qubit_variable_declaration.check_complete(id_map)
+        if self._attr_block is not None:
+            self._attr_block.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Program(
+            api_version=self._attr_api_version,
+            version=self._attr_version,
+            qubit_variable_declaration=self._attr_qubit_variable_declaration,
+            block=self._attr_block
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Program(
+            api_version=_cloned(self._attr_api_version),
+            version=_cloned(self._attr_version),
+            qubit_variable_declaration=_cloned(self._attr_qubit_variable_declaration),
+            block=_cloned(self._attr_block)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Program':
+            raise ValueError('found node serialization for ' + typ + ', but expected Program')
+
+        # Deserialize the api_version field.
+        field = cbor.get('api_version', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field api_version')
+        if hasattr(cqasm.v3x.primitives.Version, 'deserialize_cbor'):
+            f_api_version = cqasm.v3x.primitives.Version.deserialize_cbor(field)
+        else:
+            f_api_version = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Version, field)
+
+        # Deserialize the version field.
+        field = cbor.get('version', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field version')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field version')
+        if field.get('@t', None) is None:
+            f_version = None
+        else:
+            f_version = Version._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the qubit_variable_declaration field.
+        field = cbor.get('qubit_variable_declaration', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field qubit_variable_declaration')
+        if field.get('@T') != '?':
+            raise ValueError('unexpected edge type for field qubit_variable_declaration')
+        if field.get('@t', None) is None:
+            f_qubit_variable_declaration = None
+        else:
+            f_qubit_variable_declaration = Variable._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the block field.
+        field = cbor.get('block', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field block')
+        if field.get('@T') != '?':
+            raise ValueError('unexpected edge type for field block')
+        if field.get('@t', None) is None:
+            f_block = None
+        else:
+            f_block = Block._deserialize(field, seq_to_ob, links)
+
+        # Construct the Program node.
+        node = Program(f_api_version, f_version, f_qubit_variable_declaration, f_block)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Program'}
+
+        # Serialize the api_version field.
+        if hasattr(self._attr_api_version, 'serialize_cbor'):
+            cbor['api_version'] = self._attr_api_version.serialize_cbor()
+        else:
+            cbor['api_version'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Version, self._attr_api_version)
+
+        # Serialize the version field.
+        field = {'@T': '1'}
+        if self._attr_version is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_version._serialize(id_map))
+        cbor['version'] = field
+
+        # Serialize the qubit_variable_declaration field.
+        field = {'@T': '?'}
+        if self._attr_qubit_variable_declaration is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_qubit_variable_declaration._serialize(id_map))
+        cbor['qubit_variable_declaration'] = field
+
+        # Serialize the block field.
+        field = {'@T': '?'}
+        if self._attr_block is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_block._serialize(id_map))
+        cbor['block'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiProgram(_Multiple):
+    """Wrapper for an edge with multiple Program objects."""
+
+    _T = Program
+
+
+_typemap['Program'] = Program
+
+class Variable(Annotated):
+    __slots__ = [
+        '_attr_name',
+        '_attr_typ',
+    ]
+
+    def __init__(
+        self,
+        name=None,
+        typ=None,
+        annotations=None,
+    ):
+        super().__init__(annotations=annotations)
+        self.name = name
+        self.typ = typ
+
+    @property
+    def name(self):
+        return self._attr_name
+
+    @name.setter
+    def name(self, val):
+        if val is None:
+            del self.name
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Str):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('name must be of type cqasm.v3x.primitives.Str')
+            val = cqasm.v3x.primitives.Str(val)
+        self._attr_name = val
+
+    @name.deleter
+    def name(self):
+        self._attr_name = cqasm.v3x.primitives.Str()
+
+    @property
+    def typ(self):
+        return self._attr_typ
+
+    @typ.setter
+    def typ(self, val):
+        if val is None:
+            del self.typ
+            return
+        if not isinstance(val, cqasm.v3x.types.TypeBase):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('typ must be of type cqasm.v3x.types.TypeBase')
+            val = cqasm.v3x.types.TypeBase(val)
+        self._attr_typ = val
+
+    @typ.deleter
+    def typ(self):
+        self._attr_typ = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Variable):
+            return False
+        if self.name != other.name:
+            return False
+        if self.typ != other.typ:
+            return False
+        if self.annotations != other.annotations:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Variable(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('name: ')
+        s.append(str(self.name) + '\n')
+        s.append('  '*indent)
+        s.append('typ: ')
+        if self.typ is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.typ.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('annotations: ')
+        if not self.annotations:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.annotations:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        if self._attr_typ is not None:
+            self._attr_typ.find_reachable(id_map)
+        for el in self._attr_annotations:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_typ is None:
+            raise NotWellFormed('typ is required but not set')
+        if self._attr_typ is not None:
+            self._attr_typ.check_complete(id_map)
+        for child in self._attr_annotations:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Variable(
+            name=self._attr_name,
+            typ=self._attr_typ,
+            annotations=self._attr_annotations.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Variable(
+            name=_cloned(self._attr_name),
+            typ=_cloned(self._attr_typ),
+            annotations=_cloned(self._attr_annotations)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Variable':
+            raise ValueError('found node serialization for ' + typ + ', but expected Variable')
+
+        # Deserialize the name field.
+        field = cbor.get('name', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field name')
+        if hasattr(cqasm.v3x.primitives.Str, 'deserialize_cbor'):
+            f_name = cqasm.v3x.primitives.Str.deserialize_cbor(field)
+        else:
+            f_name = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Str, field)
+
+        # Deserialize the typ field.
+        field = cbor.get('typ', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field typ')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field typ')
+        if field.get('@t', None) is None:
+            f_typ = None
+        else:
+            f_typ = cqasm.v3x.types.TypeBase._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the annotations field.
+        field = cbor.get('annotations', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field annotations')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field annotations')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_annotations = MultiAnnotationData()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
+
+        # Construct the Variable node.
+        node = Variable(f_name, f_typ, f_annotations)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Variable'}
+
+        # Serialize the name field.
+        if hasattr(self._attr_name, 'serialize_cbor'):
+            cbor['name'] = self._attr_name.serialize_cbor()
+        else:
+            cbor['name'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Str, self._attr_name)
+
+        # Serialize the typ field.
+        field = {'@T': '1'}
+        if self._attr_typ is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_typ._serialize(id_map))
+        cbor['typ'] = field
+
+        # Serialize the annotations field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_annotations:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['annotations'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiVariable(_Multiple):
+    """Wrapper for an edge with multiple Variable objects."""
+
+    _T = Variable
+
+
+_typemap['Variable'] = Variable
+
+class Version(Node):
+    __slots__ = [
+        '_attr_items',
+    ]
+
+    def __init__(
+        self,
+        items=None,
+    ):
+        super().__init__()
+        self.items = items
+
+    @property
+    def items(self):
+        return self._attr_items
+
+    @items.setter
+    def items(self, val):
+        if val is None:
+            del self.items
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Version):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('items must be of type cqasm.v3x.primitives.Version')
+            val = cqasm.v3x.primitives.Version(val)
+        self._attr_items = val
+
+    @items.deleter
+    def items(self):
+        self._attr_items = cqasm.v3x.primitives.Version()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Version):
+            return False
+        if self.items != other.items:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Version(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('items: ')
+        s.append(str(self.items) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Version(
+            items=self._attr_items
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Version(
+            items=_cloned(self._attr_items)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Version':
+            raise ValueError('found node serialization for ' + typ + ', but expected Version')
+
+        # Deserialize the items field.
+        field = cbor.get('items', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field items')
+        if hasattr(cqasm.v3x.primitives.Version, 'deserialize_cbor'):
+            f_items = cqasm.v3x.primitives.Version.deserialize_cbor(field)
+        else:
+            f_items = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Version, field)
+
+        # Construct the Version node.
+        node = Version(f_items)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Version'}
+
+        # Serialize the items field.
+        if hasattr(self._attr_items, 'serialize_cbor'):
+            cbor['items'] = self._attr_items.serialize_cbor()
+        else:
+            cbor['items'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Version, self._attr_items)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiVersion(_Multiple):
+    """Wrapper for an edge with multiple Version objects."""
+
+    _T = Version
+
+
+_typemap['Version'] = Version
+
```

## cqasm/v3x/types.py

 * *Ordering differences only*

```diff
@@ -1,1436 +1,1436 @@
-import functools
-import struct
-import cqasm.v3x.primitives
-
-
-_typemap = {}
-
-
-def _cbor_read_intlike(cbor, offset, info):
-    """Parses the additional information and reads any additional bytes it
-    specifies the existence of, and returns the encoded integer. offset
-    should point to the byte immediately following the initial byte. Returns
-    the encoded integer and the offset immediately following the object."""
-
-    # Info less than 24 is a shorthand for the integer itself.
-    if info < 24:
-        return info, offset
-
-    # 24 is 8-bit following the info byte.
-    if info == 24:
-        return cbor[offset], offset + 1
-
-    # 25 is 16-bit following the info byte.
-    if info == 25:
-        val, = struct.unpack('>H', cbor[offset:offset+2])
-        return val, offset + 2
-
-    # 26 is 32-bit following the info byte.
-    if info == 26:
-        val, = struct.unpack('>I', cbor[offset:offset+4])
-        return val, offset + 4
-
-    # 27 is 64-bit following the info byte.
-    if info == 27:
-        val, = struct.unpack('>Q', cbor[offset:offset+8])
-        return val, offset + 8
-
-    # Info greater than or equal to 28 is illegal. Note that 31 is used for
-    # indefinite lengths, so this must be checked prior to calling this
-    # method.
-    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
-
-
-def _sub_cbor_to_py(cbor, offset):
-    """Converts the CBOR object starting at cbor[offset] to its Python
-    representation for as far as tree-gen supports CBOR. Returns this Python
-    representation and the offset immediately following the CBOR representation
-    thereof. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    # Read the initial byte.
-    initial = cbor[offset]
-    typ = initial >> 5
-    info = initial & 0x1F
-    offset += 1
-
-    # Handle unsigned integer (0) and negative integer (1).
-    if typ <= 1:
-        value, offset = _cbor_read_intlike(cbor, offset, info)
-        if typ == 1:
-            value = -1 - value
-        return value, offset
-
-    # Handle byte string (2) and UTF-8 string (3).
-    if typ <= 3:
-
-        # Gather components of the string in here.
-        if info == 31:
-
-            # Handle indefinite length strings. These consist of a
-            # break-terminated (0xFF) list of definite-length strings of the
-            # same type.
-            value = []
-            while True:
-                sub_initial = cbor[offset]; offset += 1
-                if sub_initial == 0xFF:
-                    break
-                sub_typ = sub_initial >> 5
-                sub_info = sub_initial & 0x1F
-                if sub_typ != typ:
-                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
-
-                # Seek past definite-length string component. The size in
-                # bytes is encoded as an integer.
-                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
-                value.append(cbor[offset:offset + size])
-                offset += size
-            value = b''.join(value)
-
-        else:
-
-            # Handle definite-length strings. The size in bytes is encoded as
-            # an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            value = cbor[offset:offset + size]
-            offset += size
-
-        if typ == 3:
-            value = value.decode('UTF-8')
-        return value, offset
-
-    # Handle array (4) and map (5).
-    if typ <= 5:
-
-        # Create result container.
-        container = [] if typ == 4 else {}
-
-        # Handle indefinite length arrays and maps.
-        if info == 31:
-
-            # Read objects/object pairs until we encounter a break.
-            while cbor[offset] != 0xFF:
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-            # Seek past the break.
-            offset += 1
-
-        else:
-
-            # Handle definite-length arrays and maps. The amount of
-            # objects/object pairs is encoded as an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            for _ in range(size):
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-        return container, offset
-
-    # Handle semantic tags.
-    if typ == 6:
-
-        # We don't use semantic tags for anything, but ignoring them is
-        # legal and reading past them is easy enough.
-        _, offset = _cbor_read_intlike(cbor, offset, info)
-        return _sub_cbor_to_py(cbor, offset)
-
-    # Handle major type 7. Here, the type is defined by the additional info.
-    # Additional info 24 is reserved for having the type specified by the
-    # next byte, but all such values are unassigned.
-    if info == 20:
-        # false
-        return False, offset
-
-    if info == 21:
-        # true
-        return True, offset
-
-    if info == 22:
-        # null
-        return None, offset
-
-    if info == 23:
-        # Undefined value.
-        raise ValueError('invalid CBOR: undefined value is not supported')
-
-    if info == 25:
-        # Half-precision float.
-        raise ValueError('invalid CBOR: half-precision float is not supported')
-
-    if info == 26:
-        # Single-precision float.
-        raise ValueError('invalid CBOR: single-precision float is not supported')
-
-    if info == 27:
-        # Double-precision float.
-        value, = struct.unpack('>d', cbor[offset:offset+8])
-        return value, offset + 8
-
-    if info == 31:
-        # Break value used for indefinite-length objects.
-        raise ValueError('invalid CBOR: unexpected break')
-
-    raise ValueError('invalid CBOR: unknown type code')
-
-
-def _cbor_to_py(cbor):
-    """Converts the given CBOR object (bytes) to its Python representation for
-    as far as tree-gen supports CBOR. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    value, length = _sub_cbor_to_py(cbor, 0)
-    if length < len(cbor):
-        raise ValueError('invalid CBOR: garbage at the end')
-    return value
-
-
-class _Cbor(bytes):
-    """Marker class indicating that this bytes object represents CBOR."""
-    pass
-
-
-def _cbor_write_intlike(value, major=0):
-    """Converts the given integer to its minimal representation in CBOR. The
-    major code can be overridden to write lengths for strings, arrays, and
-    maps."""
-
-    # Negative integers use major code 1.
-    if value < 0:
-        major = 1
-        value = -1 - value
-    initial = major << 5
-
-    # Use the minimal representation.
-    if value < 24:
-        return struct.pack('>B', initial | value)
-    if value < 0x100:
-        return struct.pack('>BB', initial | 24, value)
-    if value < 0x10000:
-        return struct.pack('>BH', initial | 25, value)
-    if value < 0x100000000:
-        return struct.pack('>BI', initial | 26, value)
-    if value < 0x10000000000000000:
-        return struct.pack('>BQ', initial | 27, value)
-
-    raise ValueError('integer too large for CBOR (bigint not supported)')
-
-
-def _py_to_cbor(value, type_converter=None):
-    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
-    that takes a value and either converts it to a primitive for serialization,
-    converts it to a _Cbor object manually, or raises a TypeError if no
-    conversion is known. If no type_converter is specified, a TypeError is
-    raised in all cases the type_converter would otherwise be called. The cbor
-    serialization is returned using a _Cbor object, which is just a marker class
-    behaving just like bytes."""
-    if isinstance(value, _Cbor):
-        return value
-
-    if isinstance(value, int):
-        return _Cbor(_cbor_write_intlike(value))
-
-    if isinstance(value, float):
-        return _Cbor(struct.pack('>Bd', 0xFB, value))
-
-    if isinstance(value, str):
-        value = value.encode('UTF-8')
-        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
-
-    if isinstance(value, bytes):
-        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
-
-    if value is False:
-        return _Cbor(b'\xF4')
-
-    if value is True:
-        return _Cbor(b'\xF5')
-
-    if value is None:
-        return _Cbor(b'\xF6')
-
-    if isinstance(value, (list, tuple)):
-        cbor = [_cbor_write_intlike(len(value), 4)]
-        for val in value:
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if isinstance(value, dict):
-        cbor = [_cbor_write_intlike(len(value), 5)]
-        for key, val in sorted(value.items()):
-            if not isinstance(key, str):
-                raise TypeError('dict keys must be strings')
-            cbor.append(_py_to_cbor(key, type_converter))
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if type_converter is not None:
-        return _py_to_cbor(type_converter(value))
-
-    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
-
-
-class NotWellFormed(ValueError):
-    """Exception class for well-formedness checks."""
-
-    def __init__(self, msg):
-        super().__init__('not well-formed: ' + str(msg))
-
-
-class Node(object):
-    """Base class for nodes."""
-
-    __slots__ = ['_annot']
-
-    def __init__(self):
-        super().__init__()
-        self._annot = {}
-
-    def __getitem__(self, key):
-        """Returns the annotation object with the specified key, or raises
-        KeyError if not found."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        return self._annot[key]
-
-    def __setitem__(self, key, val):
-        """Assigns the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        self._annot[key] = val
-
-    def __delitem__(self, key):
-        """Deletes the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        del self._annot[key]
-
-    def __contains__(self, key):
-        """Returns whether an annotation exists for the specified key."""
-        return key in self._annot
-
-    @staticmethod
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it. Note that this is overridden
-        by the actual node class implementations; this base function does very
-        little."""
-        if id_map is None:
-            id_map = {}
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes. Note that this is
-        overridden by the actual node class implementations; this base function
-        always raises an exception."""
-        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
-
-    def check_well_formed(self):
-        """Checks whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links).
-
-        If it isn't well-formed, a NotWellFormed is thrown."""
-        self.check_complete()
-
-    def is_well_formed(self):
-        """Returns whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links)."""
-        try:
-            self.check_well_formed()
-            return True
-        except NotWellFormed:
-            return False
-
-    def copy(self):
-        """Returns a shallow copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
-
-    def clone(self):
-        """Returns a deep copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
-
-    @classmethod
-    def deserialize(cls, cbor):
-        """Attempts to deserialize the given cbor object (either as bytes or as
-        its Python primitive representation) into a node of this type."""
-        if isinstance(cbor, bytes):
-            cbor = _cbor_to_py(cbor)
-        seq_to_ob = {}
-        links = []
-        root = cls._deserialize(cbor, seq_to_ob, links)
-        for link_setter, seq in links:
-            ob = seq_to_ob.get(seq, None)
-            if ob is None:
-                raise ValueError('found link to nonexistent object')
-            link_setter(ob)
-        return root
-
-    def serialize(self):
-        """Serializes this node into its cbor representation in the form of a
-        bytes object."""
-        id_map = self.find_reachable()
-        self.check_complete(id_map)
-        return _py_to_cbor(self._serialize(id_map))
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        node_type = _typemap.get(cbor.get('@t'), None)
-        if node_type is None:
-            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
-        return node_type._deserialize(cbor, seq_to_ob, links)
-
-
-@functools.total_ordering
-class _Multiple(object):
-    """Base class for the Any* and Many* edge helper classes. Inheriting
-    classes must set the class constant _T to the node type they are made
-    for."""
-
-    __slots__ = ['_l']
-
-    def __init__(self,  *args, **kwargs):
-        super().__init__()
-        self._l = list(*args, **kwargs)
-        for idx, val in enumerate(self._l):
-            if not isinstance(val, self._T):
-                raise TypeError(
-                    'object {!r} at index {:d} is not an instance of {!r}'
-                    .format(val, idx, self._T))
-
-    def __repr__(self):
-        return '{}({!r})'.format(type(self).__name__, self._l)
-
-    def clone(self):
-        return self.__class__(map(lambda node: node.clone(), self._l))
-
-    def __len__(self):
-        return len(self._l)
-
-    def __getitem__(self, idx):
-        return self._l[idx]
-
-    def __setitem__(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, idx, self._T))
-        self._l[idx] = val
-
-    def __delitem__(self, idx):
-        del self._l[idx]
-
-    def __iter__(self):
-        return iter(self._l)
-
-    def __reversed__(self):
-        return reversed(self._l)
-
-    def __contains__(self, val):
-        return val in self._l
-
-    def append(self, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.append(val)
-
-    def extend(self, iterable):
-        for val in iterable:
-            self.append(val)
-
-    def insert(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.insert(idx, val)
-
-    def remote(self, val):
-        self._l.remove(val)
-
-    def pop(self, idx=-1):
-        return self._l.pop(idx)
-
-    def clear(self):
-        self._l.clear()
-
-    def idx(self, val, start=0, end=-1):
-        return self._l.idx(val, start, end)
-
-    def count(self, val):
-        return self._l.count(val)
-
-    def sort(self, key=None, reverse=False):
-        self._l.sort(key=key, reverse=reverse)
-
-    def reverse(self):
-        self._l.reverse()
-
-    def copy(self):
-        return self.__class__(self)
-
-    def __eq__(self, other):
-        if not isinstance(other, _Multiple):
-            return False
-        return self._l == other._l
-
-    def __lt__(self, other):
-        return self._l < other._l
-
-    def __iadd__(self, other):
-        self.extend(other)
-
-    def __add__(self, other):
-        copy = self.copy()
-        copy += other
-        return copy
-
-    def __imul__(self, other):
-        self._l *= other
-
-    def __mul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-    def __rmul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-
-class MultiNode(_Multiple):
-    """Wrapper for an edge with multiple Node objects."""
-
-    _T = Node
-
-
-def _cloned(obj):
-    """Attempts to clone the given object by calling its clone() method, if it
-    has one."""
-    if hasattr(obj, 'clone'):
-        return obj.clone()
-    return obj
-
-
-class TypeBase(Node):
-    __slots__ = [
-        '_attr_size',
-    ]
-
-    def __init__(
-        self,
-        size=None,
-    ):
-        super().__init__()
-        self.size = size
-
-    @property
-    def size(self):
-        return self._attr_size
-
-    @size.setter
-    def size(self, val):
-        if val is None:
-            del self.size
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Int):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('size must be of type cqasm.v3x.primitives.Int')
-            val = cqasm.v3x.primitives.Int(val)
-        self._attr_size = val
-
-    @size.deleter
-    def size(self):
-        self._attr_size = cqasm.v3x.primitives.Int()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'Bool':
-            return Bool._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Int':
-            return Int._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Float':
-            return Float._deserialize(cbor, seq_to_ob, links)
-        if typ == 'Qubit':
-            return Qubit._deserialize(cbor, seq_to_ob, links)
-        if typ == 'QubitArray':
-            return QubitArray._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'TypeBase'}
-
-        # Serialize the size field.
-        if hasattr(self._attr_size, 'serialize_cbor'):
-            cbor['size'] = self._attr_size.serialize_cbor()
-        else:
-            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiTypeBase(_Multiple):
-    """Wrapper for an edge with multiple TypeBase objects."""
-
-    _T = TypeBase
-
-
-_typemap['TypeBase'] = TypeBase
-
-class Bool(TypeBase):
-    """Type of a boolean."""
-
-    __slots__ = []
-
-    def __init__(
-        self,
-        size=None,
-    ):
-        super().__init__(size=size)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Bool):
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Bool(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('size: ')
-        s.append(str(self.size) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Bool(
-            size=self._attr_size
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Bool(
-            size=_cloned(self._attr_size)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Bool':
-            raise ValueError('found node serialization for ' + typ + ', but expected Bool')
-
-        # Deserialize the size field.
-        field = cbor.get('size', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field size')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the Bool node.
-        node = Bool(f_size)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Bool'}
-
-        # Serialize the size field.
-        if hasattr(self._attr_size, 'serialize_cbor'):
-            cbor['size'] = self._attr_size.serialize_cbor()
-        else:
-            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiBool(_Multiple):
-    """Wrapper for an edge with multiple Bool objects."""
-
-    _T = Bool
-
-
-_typemap['Bool'] = Bool
-
-class Float(TypeBase):
-    """Type of a float number (IEEE double)."""
-
-    __slots__ = []
-
-    def __init__(
-        self,
-        size=None,
-    ):
-        super().__init__(size=size)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Float):
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Float(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('size: ')
-        s.append(str(self.size) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Float(
-            size=self._attr_size
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Float(
-            size=_cloned(self._attr_size)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Float':
-            raise ValueError('found node serialization for ' + typ + ', but expected Float')
-
-        # Deserialize the size field.
-        field = cbor.get('size', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field size')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the Float node.
-        node = Float(f_size)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Float'}
-
-        # Serialize the size field.
-        if hasattr(self._attr_size, 'serialize_cbor'):
-            cbor['size'] = self._attr_size.serialize_cbor()
-        else:
-            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiFloat(_Multiple):
-    """Wrapper for an edge with multiple Float objects."""
-
-    _T = Float
-
-
-_typemap['Float'] = Float
-
-class Int(TypeBase):
-    """Type of an integer (signed 64-bit)."""
-
-    __slots__ = []
-
-    def __init__(
-        self,
-        size=None,
-    ):
-        super().__init__(size=size)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Int):
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Int(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('size: ')
-        s.append(str(self.size) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Int(
-            size=self._attr_size
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Int(
-            size=_cloned(self._attr_size)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Int':
-            raise ValueError('found node serialization for ' + typ + ', but expected Int')
-
-        # Deserialize the size field.
-        field = cbor.get('size', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field size')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the Int node.
-        node = Int(f_size)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Int'}
-
-        # Serialize the size field.
-        if hasattr(self._attr_size, 'serialize_cbor'):
-            cbor['size'] = self._attr_size.serialize_cbor()
-        else:
-            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiInt(_Multiple):
-    """Wrapper for an edge with multiple Int objects."""
-
-    _T = Int
-
-
-_typemap['Int'] = Int
-
-class Qubit(TypeBase):
-    __slots__ = []
-
-    def __init__(
-        self,
-        size=None,
-    ):
-        super().__init__(size=size)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, Qubit):
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('Qubit(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('size: ')
-        s.append(str(self.size) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return Qubit(
-            size=self._attr_size
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return Qubit(
-            size=_cloned(self._attr_size)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'Qubit':
-            raise ValueError('found node serialization for ' + typ + ', but expected Qubit')
-
-        # Deserialize the size field.
-        field = cbor.get('size', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field size')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the Qubit node.
-        node = Qubit(f_size)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Qubit'}
-
-        # Serialize the size field.
-        if hasattr(self._attr_size, 'serialize_cbor'):
-            cbor['size'] = self._attr_size.serialize_cbor()
-        else:
-            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiQubit(_Multiple):
-    """Wrapper for an edge with multiple Qubit objects."""
-
-    _T = Qubit
-
-
-_typemap['Qubit'] = Qubit
-
-class QubitArray(TypeBase):
-    __slots__ = []
-
-    def __init__(
-        self,
-        size=None,
-    ):
-        super().__init__(size=size)
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, QubitArray):
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('QubitArray(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('size: ')
-        s.append(str(self.size) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return QubitArray(
-            size=self._attr_size
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return QubitArray(
-            size=_cloned(self._attr_size)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'QubitArray':
-            raise ValueError('found node serialization for ' + typ + ', but expected QubitArray')
-
-        # Deserialize the size field.
-        field = cbor.get('size', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field size')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the QubitArray node.
-        node = QubitArray(f_size)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'QubitArray'}
-
-        # Serialize the size field.
-        if hasattr(self._attr_size, 'serialize_cbor'):
-            cbor['size'] = self._attr_size.serialize_cbor()
-        else:
-            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiQubitArray(_Multiple):
-    """Wrapper for an edge with multiple QubitArray objects."""
-
-    _T = QubitArray
-
-
-_typemap['QubitArray'] = QubitArray
-
+import functools
+import struct
+import cqasm.v3x.primitives
+
+
+_typemap = {}
+
+
+def _cbor_read_intlike(cbor, offset, info):
+    """Parses the additional information and reads any additional bytes it
+    specifies the existence of, and returns the encoded integer. offset
+    should point to the byte immediately following the initial byte. Returns
+    the encoded integer and the offset immediately following the object."""
+
+    # Info less than 24 is a shorthand for the integer itself.
+    if info < 24:
+        return info, offset
+
+    # 24 is 8-bit following the info byte.
+    if info == 24:
+        return cbor[offset], offset + 1
+
+    # 25 is 16-bit following the info byte.
+    if info == 25:
+        val, = struct.unpack('>H', cbor[offset:offset+2])
+        return val, offset + 2
+
+    # 26 is 32-bit following the info byte.
+    if info == 26:
+        val, = struct.unpack('>I', cbor[offset:offset+4])
+        return val, offset + 4
+
+    # 27 is 64-bit following the info byte.
+    if info == 27:
+        val, = struct.unpack('>Q', cbor[offset:offset+8])
+        return val, offset + 8
+
+    # Info greater than or equal to 28 is illegal. Note that 31 is used for
+    # indefinite lengths, so this must be checked prior to calling this
+    # method.
+    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
+
+
+def _sub_cbor_to_py(cbor, offset):
+    """Converts the CBOR object starting at cbor[offset] to its Python
+    representation for as far as tree-gen supports CBOR. Returns this Python
+    representation and the offset immediately following the CBOR representation
+    thereof. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    # Read the initial byte.
+    initial = cbor[offset]
+    typ = initial >> 5
+    info = initial & 0x1F
+    offset += 1
+
+    # Handle unsigned integer (0) and negative integer (1).
+    if typ <= 1:
+        value, offset = _cbor_read_intlike(cbor, offset, info)
+        if typ == 1:
+            value = -1 - value
+        return value, offset
+
+    # Handle byte string (2) and UTF-8 string (3).
+    if typ <= 3:
+
+        # Gather components of the string in here.
+        if info == 31:
+
+            # Handle indefinite length strings. These consist of a
+            # break-terminated (0xFF) list of definite-length strings of the
+            # same type.
+            value = []
+            while True:
+                sub_initial = cbor[offset]; offset += 1
+                if sub_initial == 0xFF:
+                    break
+                sub_typ = sub_initial >> 5
+                sub_info = sub_initial & 0x1F
+                if sub_typ != typ:
+                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
+
+                # Seek past definite-length string component. The size in
+                # bytes is encoded as an integer.
+                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
+                value.append(cbor[offset:offset + size])
+                offset += size
+            value = b''.join(value)
+
+        else:
+
+            # Handle definite-length strings. The size in bytes is encoded as
+            # an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            value = cbor[offset:offset + size]
+            offset += size
+
+        if typ == 3:
+            value = value.decode('UTF-8')
+        return value, offset
+
+    # Handle array (4) and map (5).
+    if typ <= 5:
+
+        # Create result container.
+        container = [] if typ == 4 else {}
+
+        # Handle indefinite length arrays and maps.
+        if info == 31:
+
+            # Read objects/object pairs until we encounter a break.
+            while cbor[offset] != 0xFF:
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+            # Seek past the break.
+            offset += 1
+
+        else:
+
+            # Handle definite-length arrays and maps. The amount of
+            # objects/object pairs is encoded as an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            for _ in range(size):
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+        return container, offset
+
+    # Handle semantic tags.
+    if typ == 6:
+
+        # We don't use semantic tags for anything, but ignoring them is
+        # legal and reading past them is easy enough.
+        _, offset = _cbor_read_intlike(cbor, offset, info)
+        return _sub_cbor_to_py(cbor, offset)
+
+    # Handle major type 7. Here, the type is defined by the additional info.
+    # Additional info 24 is reserved for having the type specified by the
+    # next byte, but all such values are unassigned.
+    if info == 20:
+        # false
+        return False, offset
+
+    if info == 21:
+        # true
+        return True, offset
+
+    if info == 22:
+        # null
+        return None, offset
+
+    if info == 23:
+        # Undefined value.
+        raise ValueError('invalid CBOR: undefined value is not supported')
+
+    if info == 25:
+        # Half-precision float.
+        raise ValueError('invalid CBOR: half-precision float is not supported')
+
+    if info == 26:
+        # Single-precision float.
+        raise ValueError('invalid CBOR: single-precision float is not supported')
+
+    if info == 27:
+        # Double-precision float.
+        value, = struct.unpack('>d', cbor[offset:offset+8])
+        return value, offset + 8
+
+    if info == 31:
+        # Break value used for indefinite-length objects.
+        raise ValueError('invalid CBOR: unexpected break')
+
+    raise ValueError('invalid CBOR: unknown type code')
+
+
+def _cbor_to_py(cbor):
+    """Converts the given CBOR object (bytes) to its Python representation for
+    as far as tree-gen supports CBOR. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    value, length = _sub_cbor_to_py(cbor, 0)
+    if length < len(cbor):
+        raise ValueError('invalid CBOR: garbage at the end')
+    return value
+
+
+class _Cbor(bytes):
+    """Marker class indicating that this bytes object represents CBOR."""
+    pass
+
+
+def _cbor_write_intlike(value, major=0):
+    """Converts the given integer to its minimal representation in CBOR. The
+    major code can be overridden to write lengths for strings, arrays, and
+    maps."""
+
+    # Negative integers use major code 1.
+    if value < 0:
+        major = 1
+        value = -1 - value
+    initial = major << 5
+
+    # Use the minimal representation.
+    if value < 24:
+        return struct.pack('>B', initial | value)
+    if value < 0x100:
+        return struct.pack('>BB', initial | 24, value)
+    if value < 0x10000:
+        return struct.pack('>BH', initial | 25, value)
+    if value < 0x100000000:
+        return struct.pack('>BI', initial | 26, value)
+    if value < 0x10000000000000000:
+        return struct.pack('>BQ', initial | 27, value)
+
+    raise ValueError('integer too large for CBOR (bigint not supported)')
+
+
+def _py_to_cbor(value, type_converter=None):
+    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
+    that takes a value and either converts it to a primitive for serialization,
+    converts it to a _Cbor object manually, or raises a TypeError if no
+    conversion is known. If no type_converter is specified, a TypeError is
+    raised in all cases the type_converter would otherwise be called. The cbor
+    serialization is returned using a _Cbor object, which is just a marker class
+    behaving just like bytes."""
+    if isinstance(value, _Cbor):
+        return value
+
+    if isinstance(value, int):
+        return _Cbor(_cbor_write_intlike(value))
+
+    if isinstance(value, float):
+        return _Cbor(struct.pack('>Bd', 0xFB, value))
+
+    if isinstance(value, str):
+        value = value.encode('UTF-8')
+        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
+
+    if isinstance(value, bytes):
+        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
+
+    if value is False:
+        return _Cbor(b'\xF4')
+
+    if value is True:
+        return _Cbor(b'\xF5')
+
+    if value is None:
+        return _Cbor(b'\xF6')
+
+    if isinstance(value, (list, tuple)):
+        cbor = [_cbor_write_intlike(len(value), 4)]
+        for val in value:
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if isinstance(value, dict):
+        cbor = [_cbor_write_intlike(len(value), 5)]
+        for key, val in sorted(value.items()):
+            if not isinstance(key, str):
+                raise TypeError('dict keys must be strings')
+            cbor.append(_py_to_cbor(key, type_converter))
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if type_converter is not None:
+        return _py_to_cbor(type_converter(value))
+
+    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
+
+
+class NotWellFormed(ValueError):
+    """Exception class for well-formedness checks."""
+
+    def __init__(self, msg):
+        super().__init__('not well-formed: ' + str(msg))
+
+
+class Node(object):
+    """Base class for nodes."""
+
+    __slots__ = ['_annot']
+
+    def __init__(self):
+        super().__init__()
+        self._annot = {}
+
+    def __getitem__(self, key):
+        """Returns the annotation object with the specified key, or raises
+        KeyError if not found."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        return self._annot[key]
+
+    def __setitem__(self, key, val):
+        """Assigns the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        self._annot[key] = val
+
+    def __delitem__(self, key):
+        """Deletes the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        del self._annot[key]
+
+    def __contains__(self, key):
+        """Returns whether an annotation exists for the specified key."""
+        return key in self._annot
+
+    @staticmethod
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it. Note that this is overridden
+        by the actual node class implementations; this base function does very
+        little."""
+        if id_map is None:
+            id_map = {}
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes. Note that this is
+        overridden by the actual node class implementations; this base function
+        always raises an exception."""
+        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
+
+    def check_well_formed(self):
+        """Checks whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links).
+
+        If it isn't well-formed, a NotWellFormed is thrown."""
+        self.check_complete()
+
+    def is_well_formed(self):
+        """Returns whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links)."""
+        try:
+            self.check_well_formed()
+            return True
+        except NotWellFormed:
+            return False
+
+    def copy(self):
+        """Returns a shallow copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
+
+    def clone(self):
+        """Returns a deep copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
+
+    @classmethod
+    def deserialize(cls, cbor):
+        """Attempts to deserialize the given cbor object (either as bytes or as
+        its Python primitive representation) into a node of this type."""
+        if isinstance(cbor, bytes):
+            cbor = _cbor_to_py(cbor)
+        seq_to_ob = {}
+        links = []
+        root = cls._deserialize(cbor, seq_to_ob, links)
+        for link_setter, seq in links:
+            ob = seq_to_ob.get(seq, None)
+            if ob is None:
+                raise ValueError('found link to nonexistent object')
+            link_setter(ob)
+        return root
+
+    def serialize(self):
+        """Serializes this node into its cbor representation in the form of a
+        bytes object."""
+        id_map = self.find_reachable()
+        self.check_complete(id_map)
+        return _py_to_cbor(self._serialize(id_map))
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        node_type = _typemap.get(cbor.get('@t'), None)
+        if node_type is None:
+            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
+        return node_type._deserialize(cbor, seq_to_ob, links)
+
+
+@functools.total_ordering
+class _Multiple(object):
+    """Base class for the Any* and Many* edge helper classes. Inheriting
+    classes must set the class constant _T to the node type they are made
+    for."""
+
+    __slots__ = ['_l']
+
+    def __init__(self,  *args, **kwargs):
+        super().__init__()
+        self._l = list(*args, **kwargs)
+        for idx, val in enumerate(self._l):
+            if not isinstance(val, self._T):
+                raise TypeError(
+                    'object {!r} at index {:d} is not an instance of {!r}'
+                    .format(val, idx, self._T))
+
+    def __repr__(self):
+        return '{}({!r})'.format(type(self).__name__, self._l)
+
+    def clone(self):
+        return self.__class__(map(lambda node: node.clone(), self._l))
+
+    def __len__(self):
+        return len(self._l)
+
+    def __getitem__(self, idx):
+        return self._l[idx]
+
+    def __setitem__(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, idx, self._T))
+        self._l[idx] = val
+
+    def __delitem__(self, idx):
+        del self._l[idx]
+
+    def __iter__(self):
+        return iter(self._l)
+
+    def __reversed__(self):
+        return reversed(self._l)
+
+    def __contains__(self, val):
+        return val in self._l
+
+    def append(self, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.append(val)
+
+    def extend(self, iterable):
+        for val in iterable:
+            self.append(val)
+
+    def insert(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.insert(idx, val)
+
+    def remote(self, val):
+        self._l.remove(val)
+
+    def pop(self, idx=-1):
+        return self._l.pop(idx)
+
+    def clear(self):
+        self._l.clear()
+
+    def idx(self, val, start=0, end=-1):
+        return self._l.idx(val, start, end)
+
+    def count(self, val):
+        return self._l.count(val)
+
+    def sort(self, key=None, reverse=False):
+        self._l.sort(key=key, reverse=reverse)
+
+    def reverse(self):
+        self._l.reverse()
+
+    def copy(self):
+        return self.__class__(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, _Multiple):
+            return False
+        return self._l == other._l
+
+    def __lt__(self, other):
+        return self._l < other._l
+
+    def __iadd__(self, other):
+        self.extend(other)
+
+    def __add__(self, other):
+        copy = self.copy()
+        copy += other
+        return copy
+
+    def __imul__(self, other):
+        self._l *= other
+
+    def __mul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+    def __rmul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+
+class MultiNode(_Multiple):
+    """Wrapper for an edge with multiple Node objects."""
+
+    _T = Node
+
+
+def _cloned(obj):
+    """Attempts to clone the given object by calling its clone() method, if it
+    has one."""
+    if hasattr(obj, 'clone'):
+        return obj.clone()
+    return obj
+
+
+class TypeBase(Node):
+    __slots__ = [
+        '_attr_size',
+    ]
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__()
+        self.size = size
+
+    @property
+    def size(self):
+        return self._attr_size
+
+    @size.setter
+    def size(self, val):
+        if val is None:
+            del self.size
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Int):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('size must be of type cqasm.v3x.primitives.Int')
+            val = cqasm.v3x.primitives.Int(val)
+        self._attr_size = val
+
+    @size.deleter
+    def size(self):
+        self._attr_size = cqasm.v3x.primitives.Int()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'Bool':
+            return Bool._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Int':
+            return Int._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Float':
+            return Float._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Qubit':
+            return Qubit._deserialize(cbor, seq_to_ob, links)
+        if typ == 'QubitArray':
+            return QubitArray._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'TypeBase'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiTypeBase(_Multiple):
+    """Wrapper for an edge with multiple TypeBase objects."""
+
+    _T = TypeBase
+
+
+_typemap['TypeBase'] = TypeBase
+
+class Bool(TypeBase):
+    """Type of a boolean."""
+
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Bool):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Bool(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Bool(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Bool(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Bool':
+            raise ValueError('found node serialization for ' + typ + ', but expected Bool')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the Bool node.
+        node = Bool(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Bool'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBool(_Multiple):
+    """Wrapper for an edge with multiple Bool objects."""
+
+    _T = Bool
+
+
+_typemap['Bool'] = Bool
+
+class Float(TypeBase):
+    """Type of a float number (IEEE double)."""
+
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Float):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Float(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Float(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Float(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Float':
+            raise ValueError('found node serialization for ' + typ + ', but expected Float')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the Float node.
+        node = Float(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Float'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiFloat(_Multiple):
+    """Wrapper for an edge with multiple Float objects."""
+
+    _T = Float
+
+
+_typemap['Float'] = Float
+
+class Int(TypeBase):
+    """Type of an integer (signed 64-bit)."""
+
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Int):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Int(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Int(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Int(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Int':
+            raise ValueError('found node serialization for ' + typ + ', but expected Int')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the Int node.
+        node = Int(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Int'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiInt(_Multiple):
+    """Wrapper for an edge with multiple Int objects."""
+
+    _T = Int
+
+
+_typemap['Int'] = Int
+
+class Qubit(TypeBase):
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Qubit):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Qubit(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Qubit(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Qubit(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Qubit':
+            raise ValueError('found node serialization for ' + typ + ', but expected Qubit')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the Qubit node.
+        node = Qubit(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Qubit'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiQubit(_Multiple):
+    """Wrapper for an edge with multiple Qubit objects."""
+
+    _T = Qubit
+
+
+_typemap['Qubit'] = Qubit
+
+class QubitArray(TypeBase):
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, QubitArray):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('QubitArray(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return QubitArray(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return QubitArray(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'QubitArray':
+            raise ValueError('found node serialization for ' + typ + ', but expected QubitArray')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the QubitArray node.
+        node = QubitArray(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'QubitArray'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiQubitArray(_Multiple):
+    """Wrapper for an edge with multiple QubitArray objects."""
+
+    _T = QubitArray
+
+
+_typemap['QubitArray'] = QubitArray
+
```

## cqasm/v3x/values.py

 * *Ordering differences only*

```diff
@@ -1,1714 +1,1714 @@
-import functools
-import struct
-import cqasm.v3x.primitives
-import cqasm.v3x.semantic
-
-
-_typemap = {}
-
-
-def _cbor_read_intlike(cbor, offset, info):
-    """Parses the additional information and reads any additional bytes it
-    specifies the existence of, and returns the encoded integer. offset
-    should point to the byte immediately following the initial byte. Returns
-    the encoded integer and the offset immediately following the object."""
-
-    # Info less than 24 is a shorthand for the integer itself.
-    if info < 24:
-        return info, offset
-
-    # 24 is 8-bit following the info byte.
-    if info == 24:
-        return cbor[offset], offset + 1
-
-    # 25 is 16-bit following the info byte.
-    if info == 25:
-        val, = struct.unpack('>H', cbor[offset:offset+2])
-        return val, offset + 2
-
-    # 26 is 32-bit following the info byte.
-    if info == 26:
-        val, = struct.unpack('>I', cbor[offset:offset+4])
-        return val, offset + 4
-
-    # 27 is 64-bit following the info byte.
-    if info == 27:
-        val, = struct.unpack('>Q', cbor[offset:offset+8])
-        return val, offset + 8
-
-    # Info greater than or equal to 28 is illegal. Note that 31 is used for
-    # indefinite lengths, so this must be checked prior to calling this
-    # method.
-    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
-
-
-def _sub_cbor_to_py(cbor, offset):
-    """Converts the CBOR object starting at cbor[offset] to its Python
-    representation for as far as tree-gen supports CBOR. Returns this Python
-    representation and the offset immediately following the CBOR representation
-    thereof. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    # Read the initial byte.
-    initial = cbor[offset]
-    typ = initial >> 5
-    info = initial & 0x1F
-    offset += 1
-
-    # Handle unsigned integer (0) and negative integer (1).
-    if typ <= 1:
-        value, offset = _cbor_read_intlike(cbor, offset, info)
-        if typ == 1:
-            value = -1 - value
-        return value, offset
-
-    # Handle byte string (2) and UTF-8 string (3).
-    if typ <= 3:
-
-        # Gather components of the string in here.
-        if info == 31:
-
-            # Handle indefinite length strings. These consist of a
-            # break-terminated (0xFF) list of definite-length strings of the
-            # same type.
-            value = []
-            while True:
-                sub_initial = cbor[offset]; offset += 1
-                if sub_initial == 0xFF:
-                    break
-                sub_typ = sub_initial >> 5
-                sub_info = sub_initial & 0x1F
-                if sub_typ != typ:
-                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
-
-                # Seek past definite-length string component. The size in
-                # bytes is encoded as an integer.
-                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
-                value.append(cbor[offset:offset + size])
-                offset += size
-            value = b''.join(value)
-
-        else:
-
-            # Handle definite-length strings. The size in bytes is encoded as
-            # an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            value = cbor[offset:offset + size]
-            offset += size
-
-        if typ == 3:
-            value = value.decode('UTF-8')
-        return value, offset
-
-    # Handle array (4) and map (5).
-    if typ <= 5:
-
-        # Create result container.
-        container = [] if typ == 4 else {}
-
-        # Handle indefinite length arrays and maps.
-        if info == 31:
-
-            # Read objects/object pairs until we encounter a break.
-            while cbor[offset] != 0xFF:
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-            # Seek past the break.
-            offset += 1
-
-        else:
-
-            # Handle definite-length arrays and maps. The amount of
-            # objects/object pairs is encoded as an integer.
-            size, offset = _cbor_read_intlike(cbor, offset, info)
-            for _ in range(size):
-                if typ == 4:
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container.append(value)
-                else:
-                    key, offset = _sub_cbor_to_py(cbor, offset)
-                    if not isinstance(key, str):
-                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
-                    value, offset = _sub_cbor_to_py(cbor, offset)
-                    container[key] = value
-
-        return container, offset
-
-    # Handle semantic tags.
-    if typ == 6:
-
-        # We don't use semantic tags for anything, but ignoring them is
-        # legal and reading past them is easy enough.
-        _, offset = _cbor_read_intlike(cbor, offset, info)
-        return _sub_cbor_to_py(cbor, offset)
-
-    # Handle major type 7. Here, the type is defined by the additional info.
-    # Additional info 24 is reserved for having the type specified by the
-    # next byte, but all such values are unassigned.
-    if info == 20:
-        # false
-        return False, offset
-
-    if info == 21:
-        # true
-        return True, offset
-
-    if info == 22:
-        # null
-        return None, offset
-
-    if info == 23:
-        # Undefined value.
-        raise ValueError('invalid CBOR: undefined value is not supported')
-
-    if info == 25:
-        # Half-precision float.
-        raise ValueError('invalid CBOR: half-precision float is not supported')
-
-    if info == 26:
-        # Single-precision float.
-        raise ValueError('invalid CBOR: single-precision float is not supported')
-
-    if info == 27:
-        # Double-precision float.
-        value, = struct.unpack('>d', cbor[offset:offset+8])
-        return value, offset + 8
-
-    if info == 31:
-        # Break value used for indefinite-length objects.
-        raise ValueError('invalid CBOR: unexpected break')
-
-    raise ValueError('invalid CBOR: unknown type code')
-
-
-def _cbor_to_py(cbor):
-    """Converts the given CBOR object (bytes) to its Python representation for
-    as far as tree-gen supports CBOR. Supported types:
-
-     - 0: unsigned integer (int)
-     - 1: negative integer (int)
-     - 2: byte string (bytes)
-     - 3: UTF-8 string (str)
-     - 4: array (list)
-     - 5: map (dict)
-     - 6: semantic tag (ignored)
-     - 7.20: false (bool)
-     - 7.21: true (bool)
-     - 7.22: null (NoneType)
-     - 7.27: double-precision float (float)
-
-    Both definite-length and indefinite-length notation is supported for sized
-    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
-    invalid or contains unsupported structures."""
-
-    value, length = _sub_cbor_to_py(cbor, 0)
-    if length < len(cbor):
-        raise ValueError('invalid CBOR: garbage at the end')
-    return value
-
-
-class _Cbor(bytes):
-    """Marker class indicating that this bytes object represents CBOR."""
-    pass
-
-
-def _cbor_write_intlike(value, major=0):
-    """Converts the given integer to its minimal representation in CBOR. The
-    major code can be overridden to write lengths for strings, arrays, and
-    maps."""
-
-    # Negative integers use major code 1.
-    if value < 0:
-        major = 1
-        value = -1 - value
-    initial = major << 5
-
-    # Use the minimal representation.
-    if value < 24:
-        return struct.pack('>B', initial | value)
-    if value < 0x100:
-        return struct.pack('>BB', initial | 24, value)
-    if value < 0x10000:
-        return struct.pack('>BH', initial | 25, value)
-    if value < 0x100000000:
-        return struct.pack('>BI', initial | 26, value)
-    if value < 0x10000000000000000:
-        return struct.pack('>BQ', initial | 27, value)
-
-    raise ValueError('integer too large for CBOR (bigint not supported)')
-
-
-def _py_to_cbor(value, type_converter=None):
-    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
-    that takes a value and either converts it to a primitive for serialization,
-    converts it to a _Cbor object manually, or raises a TypeError if no
-    conversion is known. If no type_converter is specified, a TypeError is
-    raised in all cases the type_converter would otherwise be called. The cbor
-    serialization is returned using a _Cbor object, which is just a marker class
-    behaving just like bytes."""
-    if isinstance(value, _Cbor):
-        return value
-
-    if isinstance(value, int):
-        return _Cbor(_cbor_write_intlike(value))
-
-    if isinstance(value, float):
-        return _Cbor(struct.pack('>Bd', 0xFB, value))
-
-    if isinstance(value, str):
-        value = value.encode('UTF-8')
-        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
-
-    if isinstance(value, bytes):
-        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
-
-    if value is False:
-        return _Cbor(b'\xF4')
-
-    if value is True:
-        return _Cbor(b'\xF5')
-
-    if value is None:
-        return _Cbor(b'\xF6')
-
-    if isinstance(value, (list, tuple)):
-        cbor = [_cbor_write_intlike(len(value), 4)]
-        for val in value:
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if isinstance(value, dict):
-        cbor = [_cbor_write_intlike(len(value), 5)]
-        for key, val in sorted(value.items()):
-            if not isinstance(key, str):
-                raise TypeError('dict keys must be strings')
-            cbor.append(_py_to_cbor(key, type_converter))
-            cbor.append(_py_to_cbor(val, type_converter))
-        return _Cbor(b''.join(cbor))
-
-    if type_converter is not None:
-        return _py_to_cbor(type_converter(value))
-
-    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
-
-
-class NotWellFormed(ValueError):
-    """Exception class for well-formedness checks."""
-
-    def __init__(self, msg):
-        super().__init__('not well-formed: ' + str(msg))
-
-
-class Node(object):
-    """Base class for nodes."""
-
-    __slots__ = ['_annot']
-
-    def __init__(self):
-        super().__init__()
-        self._annot = {}
-
-    def __getitem__(self, key):
-        """Returns the annotation object with the specified key, or raises
-        KeyError if not found."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        return self._annot[key]
-
-    def __setitem__(self, key, val):
-        """Assigns the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        self._annot[key] = val
-
-    def __delitem__(self, key):
-        """Deletes the annotation object with the specified key."""
-        if not isinstance(key, str):
-            raise TypeError('indexing a node with something other than an '
-                            'annotation key string')
-        del self._annot[key]
-
-    def __contains__(self, key):
-        """Returns whether an annotation exists for the specified key."""
-        return key in self._annot
-
-    @staticmethod
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it. Note that this is overridden
-        by the actual node class implementations; this base function does very
-        little."""
-        if id_map is None:
-            id_map = {}
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes. Note that this is
-        overridden by the actual node class implementations; this base function
-        always raises an exception."""
-        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
-
-    def check_well_formed(self):
-        """Checks whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links).
-
-        If it isn't well-formed, a NotWellFormed is thrown."""
-        self.check_complete()
-
-    def is_well_formed(self):
-        """Returns whether the tree starting at this node is well-formed. That
-        is:
-
-         - all One, Link, and Many edges have (at least) one entry;
-         - all the One entries internally stored by Any/Many have an entry;
-         - all Link and filled OptLink nodes link to a node that's reachable
-           from this node;
-         - the nodes referred to be One/Maybe only appear once in the tree
-           (except through links)."""
-        try:
-            self.check_well_formed()
-            return True
-        except NotWellFormed:
-            return False
-
-    def copy(self):
-        """Returns a shallow copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
-
-    def clone(self):
-        """Returns a deep copy of this node. Note that this is overridden by
-        the actual node class implementations; this base function always raises
-        an exception."""
-        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
-
-    @classmethod
-    def deserialize(cls, cbor):
-        """Attempts to deserialize the given cbor object (either as bytes or as
-        its Python primitive representation) into a node of this type."""
-        if isinstance(cbor, bytes):
-            cbor = _cbor_to_py(cbor)
-        seq_to_ob = {}
-        links = []
-        root = cls._deserialize(cbor, seq_to_ob, links)
-        for link_setter, seq in links:
-            ob = seq_to_ob.get(seq, None)
-            if ob is None:
-                raise ValueError('found link to nonexistent object')
-            link_setter(ob)
-        return root
-
-    def serialize(self):
-        """Serializes this node into its cbor representation in the form of a
-        bytes object."""
-        id_map = self.find_reachable()
-        self.check_complete(id_map)
-        return _py_to_cbor(self._serialize(id_map))
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        node_type = _typemap.get(cbor.get('@t'), None)
-        if node_type is None:
-            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
-        return node_type._deserialize(cbor, seq_to_ob, links)
-
-
-@functools.total_ordering
-class _Multiple(object):
-    """Base class for the Any* and Many* edge helper classes. Inheriting
-    classes must set the class constant _T to the node type they are made
-    for."""
-
-    __slots__ = ['_l']
-
-    def __init__(self,  *args, **kwargs):
-        super().__init__()
-        self._l = list(*args, **kwargs)
-        for idx, val in enumerate(self._l):
-            if not isinstance(val, self._T):
-                raise TypeError(
-                    'object {!r} at index {:d} is not an instance of {!r}'
-                    .format(val, idx, self._T))
-
-    def __repr__(self):
-        return '{}({!r})'.format(type(self).__name__, self._l)
-
-    def clone(self):
-        return self.__class__(map(lambda node: node.clone(), self._l))
-
-    def __len__(self):
-        return len(self._l)
-
-    def __getitem__(self, idx):
-        return self._l[idx]
-
-    def __setitem__(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, idx, self._T))
-        self._l[idx] = val
-
-    def __delitem__(self, idx):
-        del self._l[idx]
-
-    def __iter__(self):
-        return iter(self._l)
-
-    def __reversed__(self):
-        return reversed(self._l)
-
-    def __contains__(self, val):
-        return val in self._l
-
-    def append(self, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.append(val)
-
-    def extend(self, iterable):
-        for val in iterable:
-            self.append(val)
-
-    def insert(self, idx, val):
-        if not isinstance(val, self._T):
-            raise TypeError(
-                'object {!r} is not an instance of {!r}'
-                .format(val, self._T))
-        self._l.insert(idx, val)
-
-    def remote(self, val):
-        self._l.remove(val)
-
-    def pop(self, idx=-1):
-        return self._l.pop(idx)
-
-    def clear(self):
-        self._l.clear()
-
-    def idx(self, val, start=0, end=-1):
-        return self._l.idx(val, start, end)
-
-    def count(self, val):
-        return self._l.count(val)
-
-    def sort(self, key=None, reverse=False):
-        self._l.sort(key=key, reverse=reverse)
-
-    def reverse(self):
-        self._l.reverse()
-
-    def copy(self):
-        return self.__class__(self)
-
-    def __eq__(self, other):
-        if not isinstance(other, _Multiple):
-            return False
-        return self._l == other._l
-
-    def __lt__(self, other):
-        return self._l < other._l
-
-    def __iadd__(self, other):
-        self.extend(other)
-
-    def __add__(self, other):
-        copy = self.copy()
-        copy += other
-        return copy
-
-    def __imul__(self, other):
-        self._l *= other
-
-    def __mul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-    def __rmul__(self, other):
-        copy = self.copy()
-        copy *= other
-        return copy
-
-
-class MultiNode(_Multiple):
-    """Wrapper for an edge with multiple Node objects."""
-
-    _T = Node
-
-
-def _cloned(obj):
-    """Attempts to clone the given object by calling its clone() method, if it
-    has one."""
-    if hasattr(obj, 'clone'):
-        return obj.clone()
-    return obj
-
-
-class ValueBase(Node):
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'ConstBool':
-            return ConstBool._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ConstInt':
-            return ConstInt._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ConstFloat':
-            return ConstFloat._deserialize(cbor, seq_to_ob, links)
-        if typ == 'IndexRef':
-            return IndexRef._deserialize(cbor, seq_to_ob, links)
-        if typ == 'VariableRef':
-            return VariableRef._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ValueBase'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiValueBase(_Multiple):
-    """Wrapper for an edge with multiple ValueBase objects."""
-
-    _T = ValueBase
-
-
-_typemap['ValueBase'] = ValueBase
-
-class Constant(ValueBase):
-    """Constant value"""
-
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'ConstBool':
-            return ConstBool._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ConstInt':
-            return ConstInt._deserialize(cbor, seq_to_ob, links)
-        if typ == 'ConstFloat':
-            return ConstFloat._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Constant'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiConstant(_Multiple):
-    """Wrapper for an edge with multiple Constant objects."""
-
-    _T = Constant
-
-
-_typemap['Constant'] = Constant
-
-class ConstBool(Constant):
-    __slots__ = [
-        '_attr_value',
-    ]
-
-    def __init__(
-        self,
-        value=None,
-    ):
-        super().__init__()
-        self.value = value
-
-    @property
-    def value(self):
-        return self._attr_value
-
-    @value.setter
-    def value(self, val):
-        if val is None:
-            del self.value
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Bool):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('value must be of type cqasm.v3x.primitives.Bool')
-            val = cqasm.v3x.primitives.Bool(val)
-        self._attr_value = val
-
-    @value.deleter
-    def value(self):
-        self._attr_value = cqasm.v3x.primitives.Bool()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ConstBool):
-            return False
-        if self.value != other.value:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ConstBool(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('value: ')
-        s.append(str(self.value) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ConstBool(
-            value=self._attr_value
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ConstBool(
-            value=_cloned(self._attr_value)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ConstBool':
-            raise ValueError('found node serialization for ' + typ + ', but expected ConstBool')
-
-        # Deserialize the value field.
-        field = cbor.get('value', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field value')
-        if hasattr(cqasm.v3x.primitives.Bool, 'deserialize_cbor'):
-            f_value = cqasm.v3x.primitives.Bool.deserialize_cbor(field)
-        else:
-            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Bool, field)
-
-        # Construct the ConstBool node.
-        node = ConstBool(f_value)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ConstBool'}
-
-        # Serialize the value field.
-        if hasattr(self._attr_value, 'serialize_cbor'):
-            cbor['value'] = self._attr_value.serialize_cbor()
-        else:
-            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Bool, self._attr_value)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiConstBool(_Multiple):
-    """Wrapper for an edge with multiple ConstBool objects."""
-
-    _T = ConstBool
-
-
-_typemap['ConstBool'] = ConstBool
-
-class ConstFloat(Constant):
-    __slots__ = [
-        '_attr_value',
-    ]
-
-    def __init__(
-        self,
-        value=None,
-    ):
-        super().__init__()
-        self.value = value
-
-    @property
-    def value(self):
-        return self._attr_value
-
-    @value.setter
-    def value(self, val):
-        if val is None:
-            del self.value
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Float):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('value must be of type cqasm.v3x.primitives.Float')
-            val = cqasm.v3x.primitives.Float(val)
-        self._attr_value = val
-
-    @value.deleter
-    def value(self):
-        self._attr_value = cqasm.v3x.primitives.Float()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ConstFloat):
-            return False
-        if self.value != other.value:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ConstFloat(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('value: ')
-        s.append(str(self.value) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ConstFloat(
-            value=self._attr_value
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ConstFloat(
-            value=_cloned(self._attr_value)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ConstFloat':
-            raise ValueError('found node serialization for ' + typ + ', but expected ConstFloat')
-
-        # Deserialize the value field.
-        field = cbor.get('value', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field value')
-        if hasattr(cqasm.v3x.primitives.Float, 'deserialize_cbor'):
-            f_value = cqasm.v3x.primitives.Float.deserialize_cbor(field)
-        else:
-            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Float, field)
-
-        # Construct the ConstFloat node.
-        node = ConstFloat(f_value)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ConstFloat'}
-
-        # Serialize the value field.
-        if hasattr(self._attr_value, 'serialize_cbor'):
-            cbor['value'] = self._attr_value.serialize_cbor()
-        else:
-            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Float, self._attr_value)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiConstFloat(_Multiple):
-    """Wrapper for an edge with multiple ConstFloat objects."""
-
-    _T = ConstFloat
-
-
-_typemap['ConstFloat'] = ConstFloat
-
-class ConstInt(Constant):
-    __slots__ = [
-        '_attr_value',
-    ]
-
-    def __init__(
-        self,
-        value=None,
-    ):
-        super().__init__()
-        self.value = value
-
-    @property
-    def value(self):
-        return self._attr_value
-
-    @value.setter
-    def value(self, val):
-        if val is None:
-            del self.value
-            return
-        if not isinstance(val, cqasm.v3x.primitives.Int):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('value must be of type cqasm.v3x.primitives.Int')
-            val = cqasm.v3x.primitives.Int(val)
-        self._attr_value = val
-
-    @value.deleter
-    def value(self):
-        self._attr_value = cqasm.v3x.primitives.Int()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, ConstInt):
-            return False
-        if self.value != other.value:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('ConstInt(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('value: ')
-        s.append(str(self.value) + '\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return ConstInt(
-            value=self._attr_value
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return ConstInt(
-            value=_cloned(self._attr_value)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'ConstInt':
-            raise ValueError('found node serialization for ' + typ + ', but expected ConstInt')
-
-        # Deserialize the value field.
-        field = cbor.get('value', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field value')
-        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
-            f_value = cqasm.v3x.primitives.Int.deserialize_cbor(field)
-        else:
-            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
-
-        # Construct the ConstInt node.
-        node = ConstInt(f_value)
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'ConstInt'}
-
-        # Serialize the value field.
-        if hasattr(self._attr_value, 'serialize_cbor'):
-            cbor['value'] = self._attr_value.serialize_cbor()
-        else:
-            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_value)
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiConstInt(_Multiple):
-    """Wrapper for an edge with multiple ConstInt objects."""
-
-    _T = ConstInt
-
-
-_typemap['ConstInt'] = ConstInt
-
-class Reference(ValueBase):
-    """Reference to some storage location"""
-
-    __slots__ = []
-
-    def __init__(self):
-        super().__init__()
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ == 'IndexRef':
-            return IndexRef._deserialize(cbor, seq_to_ob, links)
-        if typ == 'VariableRef':
-            return VariableRef._deserialize(cbor, seq_to_ob, links)
-        raise ValueError('unknown or unexpected type (@t) found in node serialization')
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'Reference'}
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiReference(_Multiple):
-    """Wrapper for an edge with multiple Reference objects."""
-
-    _T = Reference
-
-
-_typemap['Reference'] = Reference
-
-class IndexRef(Reference):
-    """Represents an index for single-gate-multiple-qubit notation. The indices
-    must not repeat."""
-
-    __slots__ = [
-        '_attr_variable',
-        '_attr_indices',
-    ]
-
-    def __init__(
-        self,
-        variable=None,
-        indices=None,
-    ):
-        super().__init__()
-        self.variable = variable
-        self.indices = indices
-
-    @property
-    def variable(self):
-        return self._attr_variable
-
-    @variable.setter
-    def variable(self, val):
-        if val is None:
-            del self.variable
-            return
-        if not isinstance(val, cqasm.v3x.semantic.Variable):
-            raise TypeError('variable must be of type cqasm.v3x.semantic.Variable')
-        self._attr_variable = val
-
-    @variable.deleter
-    def variable(self):
-        self._attr_variable = None
-
-    @property
-    def indices(self):
-        return self._attr_indices
-
-    @indices.setter
-    def indices(self, val):
-        if val is None:
-            del self.indices
-            return
-        if not isinstance(val, MultiConstInt):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('indices must be of type MultiConstInt')
-            val = MultiConstInt(val)
-        self._attr_indices = val
-
-    @indices.deleter
-    def indices(self):
-        self._attr_indices = MultiConstInt()
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, IndexRef):
-            return False
-        if self.variable is not other.variable:
-            return False
-        if self.indices != other.indices:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('IndexRef(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('variable --> ')
-        if self.variable is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            if links:
-                s.append(self.variable.dump(indent + 1, annotations, links - 1) + '\n')
-            else:
-                s.append('  '*(indent+1) + '...\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('indices: ')
-        if not self.indices:
-            s.append('!MISSING\n')
-        else:
-            s.append('[\n')
-            for child in self.indices:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        for el in self._attr_indices:
-            el.find_reachable(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_variable is None:
-            raise NotWellFormed('variable is required but not set')
-        if self._attr_variable is not None:
-            if id(self._attr_variable) not in id_map:
-                raise NotWellFormed('variable links to unreachable node')
-        if not self._attr_indices:
-            raise NotWellFormed('indices needs at least one node but has zero')
-        for child in self._attr_indices:
-            child.check_complete(id_map)
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return IndexRef(
-            variable=self._attr_variable,
-            indices=self._attr_indices.copy()
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return IndexRef(
-            variable=self._attr_variable,
-            indices=_cloned(self._attr_indices)
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'IndexRef':
-            raise ValueError('found node serialization for ' + typ + ', but expected IndexRef')
-
-        # Deserialize the variable field.
-        field = cbor.get('variable', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field variable')
-        if field.get('@T') != '$':
-            raise ValueError('unexpected edge type for field variable')
-        f_variable = None
-        l_variable = field.get('@l', None)
-
-        # Deserialize the indices field.
-        field = cbor.get('indices', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field indices')
-        if field.get('@T') != '+':
-            raise ValueError('unexpected edge type for field indices')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_indices = MultiConstInt()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_indices.append(ConstInt._deserialize(element, seq_to_ob, links))
-
-        # Construct the IndexRef node.
-        node = IndexRef(f_variable, f_indices)
-
-        # Register links to be made after tree construction.
-        links.append((lambda val: IndexRef.variable.fset(node, val), l_variable))
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'IndexRef'}
-
-        # Serialize the variable field.
-        field = {'@T': '$'}
-        if self._attr_variable is None:
-            field['@l'] = None
-        else:
-            field['@l'] = id_map[id(self._attr_variable)]
-        cbor['variable'] = field
-
-        # Serialize the indices field.
-        field = {'@T': '+'}
-        lst = []
-        for el in self._attr_indices:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['indices'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiIndexRef(_Multiple):
-    """Wrapper for an edge with multiple IndexRef objects."""
-
-    _T = IndexRef
-
-
-_typemap['IndexRef'] = IndexRef
-
-class VariableRef(Reference):
-    __slots__ = [
-        '_attr_variable',
-    ]
-
-    def __init__(
-        self,
-        variable=None,
-    ):
-        super().__init__()
-        self.variable = variable
-
-    @property
-    def variable(self):
-        return self._attr_variable
-
-    @variable.setter
-    def variable(self, val):
-        if val is None:
-            del self.variable
-            return
-        if not isinstance(val, cqasm.v3x.semantic.Variable):
-            raise TypeError('variable must be of type cqasm.v3x.semantic.Variable')
-        self._attr_variable = val
-
-    @variable.deleter
-    def variable(self):
-        self._attr_variable = None
-
-    def __eq__(self, other):
-        """Equality operator. Ignores annotations!"""
-        if not isinstance(other, VariableRef):
-            return False
-        if self.variable is not other.variable:
-            return False
-        return True
-
-    def dump(self, indent=0, annotations=None, links=1):
-        """Returns a debug representation of this tree as a multiline string.
-        indent is the number of double spaces prefixed before every line.
-        annotations, if specified, must be a set-like object containing the key
-        strings of the annotations that are to be printed. links specifies the
-        maximum link recursion depth."""
-        s = ['  '*indent]
-        s.append('VariableRef(')
-        if annotations is None:
-            annotations = []
-        for key in annotations:
-            if key in self:
-                s.append(' # {}: {}'.format(key, self[key]))
-        s.append('\n')
-        indent += 1
-        s.append('  '*indent)
-        s.append('variable --> ')
-        if self.variable is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            if links:
-                s.append(self.variable.dump(indent + 1, annotations, links - 1) + '\n')
-            else:
-                s.append('  '*(indent+1) + '...\n')
-            s.append('  '*indent + '>\n')
-        indent -= 1
-        s.append('  '*indent)
-        s.append(')')
-        return ''.join(s)
-
-    __str__ = dump
-    __repr__ = dump
-
-    def find_reachable(self, id_map=None):
-        """Returns a dictionary mapping Python id() values to stable sequence
-        numbers for all nodes in the tree rooted at this node. If id_map is
-        specified, found nodes are appended to it."""
-        if id_map is None:
-            id_map = {}
-        if id(self) in id_map:
-            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
-        id_map[id(self)] = len(id_map)
-        return id_map
-
-    def check_complete(self, id_map=None):
-        """Raises NotWellFormed if the tree rooted at this node is not
-        well-formed. If id_map is specified, this tree is only a subtree in the
-        context of a larger tree, and id_map must be a dict mapping from Python
-        id() codes to tree indices for all reachable nodes."""
-        if id_map is None:
-            id_map = self.find_reachable()
-        if self._attr_variable is None:
-            raise NotWellFormed('variable is required but not set')
-        if self._attr_variable is not None:
-            if id(self._attr_variable) not in id_map:
-                raise NotWellFormed('variable links to unreachable node')
-
-    def copy(self):
-        """Returns a shallow copy of this node."""
-        return VariableRef(
-            variable=self._attr_variable
-        )
-
-    def clone(self):
-        """Returns a deep copy of this node. This mimics the C++ interface,
-        deficiencies with links included; that is, links always point to the
-        original tree. If you're not cloning a subtree in a context where this
-        is the desired behavior, you may want to use the copy.deepcopy() from
-        the stdlib instead, which should copy links correctly."""
-        return VariableRef(
-            variable=self._attr_variable
-        )
-
-    @staticmethod
-    def _deserialize(cbor, seq_to_ob, links):
-        """Attempts to deserialize the given cbor object (in Python primitive
-        representation) into a node of this type. All (sub)nodes are added to
-        the seq_to_ob dict, indexed by their cbor sequence number. All links are
-        registered in the links list by means of a two-tuple of the setter
-        function for the link field and the sequence number of the target node.
-        """
-        if not isinstance(cbor, dict):
-            raise TypeError('node description object must be a dict')
-        typ = cbor.get('@t', None)
-        if typ is None:
-            raise ValueError('type (@t) field is missing from node serialization')
-        if typ != 'VariableRef':
-            raise ValueError('found node serialization for ' + typ + ', but expected VariableRef')
-
-        # Deserialize the variable field.
-        field = cbor.get('variable', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field variable')
-        if field.get('@T') != '$':
-            raise ValueError('unexpected edge type for field variable')
-        f_variable = None
-        l_variable = field.get('@l', None)
-
-        # Construct the VariableRef node.
-        node = VariableRef(f_variable)
-
-        # Register links to be made after tree construction.
-        links.append((lambda val: VariableRef.variable.fset(node, val), l_variable))
-
-        # Deserialize annotations.
-        for key, val in cbor.items():
-            if not (key.startswith('{') and key.endswith('}')):
-                continue
-            key = key[1:-1]
-            node[key] = cqasm.v3x.primitives.deserialize(key, val)
-
-        # Register node in sequence number lookup.
-        seq = cbor.get('@i', None)
-        if not isinstance(seq, int):
-            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
-        if seq in seq_to_ob:
-            raise ValueError('duplicate sequence number %d' % seq)
-        seq_to_ob[seq] = node
-
-        return node
-
-    def _serialize(self, id_map):
-        """Serializes this node to the Python primitive representation of its
-        CBOR serialization. The tree that the node belongs to must be
-        well-formed. id_map must match Python id() calls for all nodes to unique
-        integers, to use for the sequence number representation of links."""
-        cbor = {'@i': id_map[id(self)], '@t': 'VariableRef'}
-
-        # Serialize the variable field.
-        field = {'@T': '$'}
-        if self._attr_variable is None:
-            field['@l'] = None
-        else:
-            field['@l'] = id_map[id(self._attr_variable)]
-        cbor['variable'] = field
-
-        # Serialize annotations.
-        for key, val in self._annot.items():
-            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
-
-        return cbor
-
-
-class MultiVariableRef(_Multiple):
-    """Wrapper for an edge with multiple VariableRef objects."""
-
-    _T = VariableRef
-
-
-_typemap['VariableRef'] = VariableRef
-
+import functools
+import struct
+import cqasm.v3x.primitives
+import cqasm.v3x.semantic
+
+
+_typemap = {}
+
+
+def _cbor_read_intlike(cbor, offset, info):
+    """Parses the additional information and reads any additional bytes it
+    specifies the existence of, and returns the encoded integer. offset
+    should point to the byte immediately following the initial byte. Returns
+    the encoded integer and the offset immediately following the object."""
+
+    # Info less than 24 is a shorthand for the integer itself.
+    if info < 24:
+        return info, offset
+
+    # 24 is 8-bit following the info byte.
+    if info == 24:
+        return cbor[offset], offset + 1
+
+    # 25 is 16-bit following the info byte.
+    if info == 25:
+        val, = struct.unpack('>H', cbor[offset:offset+2])
+        return val, offset + 2
+
+    # 26 is 32-bit following the info byte.
+    if info == 26:
+        val, = struct.unpack('>I', cbor[offset:offset+4])
+        return val, offset + 4
+
+    # 27 is 64-bit following the info byte.
+    if info == 27:
+        val, = struct.unpack('>Q', cbor[offset:offset+8])
+        return val, offset + 8
+
+    # Info greater than or equal to 28 is illegal. Note that 31 is used for
+    # indefinite lengths, so this must be checked prior to calling this
+    # method.
+    raise ValueError("invalid CBOR: illegal additional info for integer or object length")
+
+
+def _sub_cbor_to_py(cbor, offset):
+    """Converts the CBOR object starting at cbor[offset] to its Python
+    representation for as far as tree-gen supports CBOR. Returns this Python
+    representation and the offset immediately following the CBOR representation
+    thereof. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    # Read the initial byte.
+    initial = cbor[offset]
+    typ = initial >> 5
+    info = initial & 0x1F
+    offset += 1
+
+    # Handle unsigned integer (0) and negative integer (1).
+    if typ <= 1:
+        value, offset = _cbor_read_intlike(cbor, offset, info)
+        if typ == 1:
+            value = -1 - value
+        return value, offset
+
+    # Handle byte string (2) and UTF-8 string (3).
+    if typ <= 3:
+
+        # Gather components of the string in here.
+        if info == 31:
+
+            # Handle indefinite length strings. These consist of a
+            # break-terminated (0xFF) list of definite-length strings of the
+            # same type.
+            value = []
+            while True:
+                sub_initial = cbor[offset]; offset += 1
+                if sub_initial == 0xFF:
+                    break
+                sub_typ = sub_initial >> 5
+                sub_info = sub_initial & 0x1F
+                if sub_typ != typ:
+                    raise ValueError('invalid CBOR: illegal indefinite-length string component')
+
+                # Seek past definite-length string component. The size in
+                # bytes is encoded as an integer.
+                size, offset = _cbor_read_intlike(cbor, offset, sub_info)
+                value.append(cbor[offset:offset + size])
+                offset += size
+            value = b''.join(value)
+
+        else:
+
+            # Handle definite-length strings. The size in bytes is encoded as
+            # an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            value = cbor[offset:offset + size]
+            offset += size
+
+        if typ == 3:
+            value = value.decode('UTF-8')
+        return value, offset
+
+    # Handle array (4) and map (5).
+    if typ <= 5:
+
+        # Create result container.
+        container = [] if typ == 4 else {}
+
+        # Handle indefinite length arrays and maps.
+        if info == 31:
+
+            # Read objects/object pairs until we encounter a break.
+            while cbor[offset] != 0xFF:
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+            # Seek past the break.
+            offset += 1
+
+        else:
+
+            # Handle definite-length arrays and maps. The amount of
+            # objects/object pairs is encoded as an integer.
+            size, offset = _cbor_read_intlike(cbor, offset, info)
+            for _ in range(size):
+                if typ == 4:
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container.append(value)
+                else:
+                    key, offset = _sub_cbor_to_py(cbor, offset)
+                    if not isinstance(key, str):
+                        raise ValueError('invalid CBOR: map key is not a UTF-8 string')
+                    value, offset = _sub_cbor_to_py(cbor, offset)
+                    container[key] = value
+
+        return container, offset
+
+    # Handle semantic tags.
+    if typ == 6:
+
+        # We don't use semantic tags for anything, but ignoring them is
+        # legal and reading past them is easy enough.
+        _, offset = _cbor_read_intlike(cbor, offset, info)
+        return _sub_cbor_to_py(cbor, offset)
+
+    # Handle major type 7. Here, the type is defined by the additional info.
+    # Additional info 24 is reserved for having the type specified by the
+    # next byte, but all such values are unassigned.
+    if info == 20:
+        # false
+        return False, offset
+
+    if info == 21:
+        # true
+        return True, offset
+
+    if info == 22:
+        # null
+        return None, offset
+
+    if info == 23:
+        # Undefined value.
+        raise ValueError('invalid CBOR: undefined value is not supported')
+
+    if info == 25:
+        # Half-precision float.
+        raise ValueError('invalid CBOR: half-precision float is not supported')
+
+    if info == 26:
+        # Single-precision float.
+        raise ValueError('invalid CBOR: single-precision float is not supported')
+
+    if info == 27:
+        # Double-precision float.
+        value, = struct.unpack('>d', cbor[offset:offset+8])
+        return value, offset + 8
+
+    if info == 31:
+        # Break value used for indefinite-length objects.
+        raise ValueError('invalid CBOR: unexpected break')
+
+    raise ValueError('invalid CBOR: unknown type code')
+
+
+def _cbor_to_py(cbor):
+    """Converts the given CBOR object (bytes) to its Python representation for
+    as far as tree-gen supports CBOR. Supported types:
+
+     - 0: unsigned integer (int)
+     - 1: negative integer (int)
+     - 2: byte string (bytes)
+     - 3: UTF-8 string (str)
+     - 4: array (list)
+     - 5: map (dict)
+     - 6: semantic tag (ignored)
+     - 7.20: false (bool)
+     - 7.21: true (bool)
+     - 7.22: null (NoneType)
+     - 7.27: double-precision float (float)
+
+    Both definite-length and indefinite-length notation is supported for sized
+    objects (strings, arrays, maps). A ValueError is thrown if the CBOR is
+    invalid or contains unsupported structures."""
+
+    value, length = _sub_cbor_to_py(cbor, 0)
+    if length < len(cbor):
+        raise ValueError('invalid CBOR: garbage at the end')
+    return value
+
+
+class _Cbor(bytes):
+    """Marker class indicating that this bytes object represents CBOR."""
+    pass
+
+
+def _cbor_write_intlike(value, major=0):
+    """Converts the given integer to its minimal representation in CBOR. The
+    major code can be overridden to write lengths for strings, arrays, and
+    maps."""
+
+    # Negative integers use major code 1.
+    if value < 0:
+        major = 1
+        value = -1 - value
+    initial = major << 5
+
+    # Use the minimal representation.
+    if value < 24:
+        return struct.pack('>B', initial | value)
+    if value < 0x100:
+        return struct.pack('>BB', initial | 24, value)
+    if value < 0x10000:
+        return struct.pack('>BH', initial | 25, value)
+    if value < 0x100000000:
+        return struct.pack('>BI', initial | 26, value)
+    if value < 0x10000000000000000:
+        return struct.pack('>BQ', initial | 27, value)
+
+    raise ValueError('integer too large for CBOR (bigint not supported)')
+
+
+def _py_to_cbor(value, type_converter=None):
+    """Inverse of _cbor_to_py(). type_converter optionally specifies a function
+    that takes a value and either converts it to a primitive for serialization,
+    converts it to a _Cbor object manually, or raises a TypeError if no
+    conversion is known. If no type_converter is specified, a TypeError is
+    raised in all cases the type_converter would otherwise be called. The cbor
+    serialization is returned using a _Cbor object, which is just a marker class
+    behaving just like bytes."""
+    if isinstance(value, _Cbor):
+        return value
+
+    if isinstance(value, int):
+        return _Cbor(_cbor_write_intlike(value))
+
+    if isinstance(value, float):
+        return _Cbor(struct.pack('>Bd', 0xFB, value))
+
+    if isinstance(value, str):
+        value = value.encode('UTF-8')
+        return _Cbor(_cbor_write_intlike(len(value), 3) + value)
+
+    if isinstance(value, bytes):
+        return _Cbor(_cbor_write_intlike(len(value), 2) + value)
+
+    if value is False:
+        return _Cbor(b'\xF4')
+
+    if value is True:
+        return _Cbor(b'\xF5')
+
+    if value is None:
+        return _Cbor(b'\xF6')
+
+    if isinstance(value, (list, tuple)):
+        cbor = [_cbor_write_intlike(len(value), 4)]
+        for val in value:
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if isinstance(value, dict):
+        cbor = [_cbor_write_intlike(len(value), 5)]
+        for key, val in sorted(value.items()):
+            if not isinstance(key, str):
+                raise TypeError('dict keys must be strings')
+            cbor.append(_py_to_cbor(key, type_converter))
+            cbor.append(_py_to_cbor(val, type_converter))
+        return _Cbor(b''.join(cbor))
+
+    if type_converter is not None:
+        return _py_to_cbor(type_converter(value))
+
+    raise TypeError('unsupported type for conversion to cbor: %r' % (value,))
+
+
+class NotWellFormed(ValueError):
+    """Exception class for well-formedness checks."""
+
+    def __init__(self, msg):
+        super().__init__('not well-formed: ' + str(msg))
+
+
+class Node(object):
+    """Base class for nodes."""
+
+    __slots__ = ['_annot']
+
+    def __init__(self):
+        super().__init__()
+        self._annot = {}
+
+    def __getitem__(self, key):
+        """Returns the annotation object with the specified key, or raises
+        KeyError if not found."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        return self._annot[key]
+
+    def __setitem__(self, key, val):
+        """Assigns the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        self._annot[key] = val
+
+    def __delitem__(self, key):
+        """Deletes the annotation object with the specified key."""
+        if not isinstance(key, str):
+            raise TypeError('indexing a node with something other than an '
+                            'annotation key string')
+        del self._annot[key]
+
+    def __contains__(self, key):
+        """Returns whether an annotation exists for the specified key."""
+        return key in self._annot
+
+    @staticmethod
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it. Note that this is overridden
+        by the actual node class implementations; this base function does very
+        little."""
+        if id_map is None:
+            id_map = {}
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes. Note that this is
+        overridden by the actual node class implementations; this base function
+        always raises an exception."""
+        raise NotWellFormed('found node of abstract type ' + type(self).__name__)
+
+    def check_well_formed(self):
+        """Checks whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links).
+
+        If it isn't well-formed, a NotWellFormed is thrown."""
+        self.check_complete()
+
+    def is_well_formed(self):
+        """Returns whether the tree starting at this node is well-formed. That
+        is:
+
+         - all One, Link, and Many edges have (at least) one entry;
+         - all the One entries internally stored by Any/Many have an entry;
+         - all Link and filled OptLink nodes link to a node that's reachable
+           from this node;
+         - the nodes referred to be One/Maybe only appear once in the tree
+           (except through links)."""
+        try:
+            self.check_well_formed()
+            return True
+        except NotWellFormed:
+            return False
+
+    def copy(self):
+        """Returns a shallow copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t copy node of abstract type ' + type(self).__name__)
+
+    def clone(self):
+        """Returns a deep copy of this node. Note that this is overridden by
+        the actual node class implementations; this base function always raises
+        an exception."""
+        raise TypeError('can\'t clone node of abstract type ' + type(self).__name__)
+
+    @classmethod
+    def deserialize(cls, cbor):
+        """Attempts to deserialize the given cbor object (either as bytes or as
+        its Python primitive representation) into a node of this type."""
+        if isinstance(cbor, bytes):
+            cbor = _cbor_to_py(cbor)
+        seq_to_ob = {}
+        links = []
+        root = cls._deserialize(cbor, seq_to_ob, links)
+        for link_setter, seq in links:
+            ob = seq_to_ob.get(seq, None)
+            if ob is None:
+                raise ValueError('found link to nonexistent object')
+            link_setter(ob)
+        return root
+
+    def serialize(self):
+        """Serializes this node into its cbor representation in the form of a
+        bytes object."""
+        id_map = self.find_reachable()
+        self.check_complete(id_map)
+        return _py_to_cbor(self._serialize(id_map))
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        node_type = _typemap.get(cbor.get('@t'), None)
+        if node_type is None:
+            raise ValueError('unknown node type (@t): ' + str(cbor.get('@t')))
+        return node_type._deserialize(cbor, seq_to_ob, links)
+
+
+@functools.total_ordering
+class _Multiple(object):
+    """Base class for the Any* and Many* edge helper classes. Inheriting
+    classes must set the class constant _T to the node type they are made
+    for."""
+
+    __slots__ = ['_l']
+
+    def __init__(self,  *args, **kwargs):
+        super().__init__()
+        self._l = list(*args, **kwargs)
+        for idx, val in enumerate(self._l):
+            if not isinstance(val, self._T):
+                raise TypeError(
+                    'object {!r} at index {:d} is not an instance of {!r}'
+                    .format(val, idx, self._T))
+
+    def __repr__(self):
+        return '{}({!r})'.format(type(self).__name__, self._l)
+
+    def clone(self):
+        return self.__class__(map(lambda node: node.clone(), self._l))
+
+    def __len__(self):
+        return len(self._l)
+
+    def __getitem__(self, idx):
+        return self._l[idx]
+
+    def __setitem__(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, idx, self._T))
+        self._l[idx] = val
+
+    def __delitem__(self, idx):
+        del self._l[idx]
+
+    def __iter__(self):
+        return iter(self._l)
+
+    def __reversed__(self):
+        return reversed(self._l)
+
+    def __contains__(self, val):
+        return val in self._l
+
+    def append(self, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.append(val)
+
+    def extend(self, iterable):
+        for val in iterable:
+            self.append(val)
+
+    def insert(self, idx, val):
+        if not isinstance(val, self._T):
+            raise TypeError(
+                'object {!r} is not an instance of {!r}'
+                .format(val, self._T))
+        self._l.insert(idx, val)
+
+    def remote(self, val):
+        self._l.remove(val)
+
+    def pop(self, idx=-1):
+        return self._l.pop(idx)
+
+    def clear(self):
+        self._l.clear()
+
+    def idx(self, val, start=0, end=-1):
+        return self._l.idx(val, start, end)
+
+    def count(self, val):
+        return self._l.count(val)
+
+    def sort(self, key=None, reverse=False):
+        self._l.sort(key=key, reverse=reverse)
+
+    def reverse(self):
+        self._l.reverse()
+
+    def copy(self):
+        return self.__class__(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, _Multiple):
+            return False
+        return self._l == other._l
+
+    def __lt__(self, other):
+        return self._l < other._l
+
+    def __iadd__(self, other):
+        self.extend(other)
+
+    def __add__(self, other):
+        copy = self.copy()
+        copy += other
+        return copy
+
+    def __imul__(self, other):
+        self._l *= other
+
+    def __mul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+    def __rmul__(self, other):
+        copy = self.copy()
+        copy *= other
+        return copy
+
+
+class MultiNode(_Multiple):
+    """Wrapper for an edge with multiple Node objects."""
+
+    _T = Node
+
+
+def _cloned(obj):
+    """Attempts to clone the given object by calling its clone() method, if it
+    has one."""
+    if hasattr(obj, 'clone'):
+        return obj.clone()
+    return obj
+
+
+class ValueBase(Node):
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'ConstBool':
+            return ConstBool._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ConstInt':
+            return ConstInt._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ConstFloat':
+            return ConstFloat._deserialize(cbor, seq_to_ob, links)
+        if typ == 'IndexRef':
+            return IndexRef._deserialize(cbor, seq_to_ob, links)
+        if typ == 'VariableRef':
+            return VariableRef._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ValueBase'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiValueBase(_Multiple):
+    """Wrapper for an edge with multiple ValueBase objects."""
+
+    _T = ValueBase
+
+
+_typemap['ValueBase'] = ValueBase
+
+class Constant(ValueBase):
+    """Constant value"""
+
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'ConstBool':
+            return ConstBool._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ConstInt':
+            return ConstInt._deserialize(cbor, seq_to_ob, links)
+        if typ == 'ConstFloat':
+            return ConstFloat._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Constant'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiConstant(_Multiple):
+    """Wrapper for an edge with multiple Constant objects."""
+
+    _T = Constant
+
+
+_typemap['Constant'] = Constant
+
+class ConstBool(Constant):
+    __slots__ = [
+        '_attr_value',
+    ]
+
+    def __init__(
+        self,
+        value=None,
+    ):
+        super().__init__()
+        self.value = value
+
+    @property
+    def value(self):
+        return self._attr_value
+
+    @value.setter
+    def value(self, val):
+        if val is None:
+            del self.value
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Bool):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('value must be of type cqasm.v3x.primitives.Bool')
+            val = cqasm.v3x.primitives.Bool(val)
+        self._attr_value = val
+
+    @value.deleter
+    def value(self):
+        self._attr_value = cqasm.v3x.primitives.Bool()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ConstBool):
+            return False
+        if self.value != other.value:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ConstBool(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('value: ')
+        s.append(str(self.value) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ConstBool(
+            value=self._attr_value
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ConstBool(
+            value=_cloned(self._attr_value)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ConstBool':
+            raise ValueError('found node serialization for ' + typ + ', but expected ConstBool')
+
+        # Deserialize the value field.
+        field = cbor.get('value', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field value')
+        if hasattr(cqasm.v3x.primitives.Bool, 'deserialize_cbor'):
+            f_value = cqasm.v3x.primitives.Bool.deserialize_cbor(field)
+        else:
+            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Bool, field)
+
+        # Construct the ConstBool node.
+        node = ConstBool(f_value)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ConstBool'}
+
+        # Serialize the value field.
+        if hasattr(self._attr_value, 'serialize_cbor'):
+            cbor['value'] = self._attr_value.serialize_cbor()
+        else:
+            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Bool, self._attr_value)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiConstBool(_Multiple):
+    """Wrapper for an edge with multiple ConstBool objects."""
+
+    _T = ConstBool
+
+
+_typemap['ConstBool'] = ConstBool
+
+class ConstFloat(Constant):
+    __slots__ = [
+        '_attr_value',
+    ]
+
+    def __init__(
+        self,
+        value=None,
+    ):
+        super().__init__()
+        self.value = value
+
+    @property
+    def value(self):
+        return self._attr_value
+
+    @value.setter
+    def value(self, val):
+        if val is None:
+            del self.value
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Float):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('value must be of type cqasm.v3x.primitives.Float')
+            val = cqasm.v3x.primitives.Float(val)
+        self._attr_value = val
+
+    @value.deleter
+    def value(self):
+        self._attr_value = cqasm.v3x.primitives.Float()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ConstFloat):
+            return False
+        if self.value != other.value:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ConstFloat(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('value: ')
+        s.append(str(self.value) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ConstFloat(
+            value=self._attr_value
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ConstFloat(
+            value=_cloned(self._attr_value)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ConstFloat':
+            raise ValueError('found node serialization for ' + typ + ', but expected ConstFloat')
+
+        # Deserialize the value field.
+        field = cbor.get('value', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field value')
+        if hasattr(cqasm.v3x.primitives.Float, 'deserialize_cbor'):
+            f_value = cqasm.v3x.primitives.Float.deserialize_cbor(field)
+        else:
+            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Float, field)
+
+        # Construct the ConstFloat node.
+        node = ConstFloat(f_value)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ConstFloat'}
+
+        # Serialize the value field.
+        if hasattr(self._attr_value, 'serialize_cbor'):
+            cbor['value'] = self._attr_value.serialize_cbor()
+        else:
+            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Float, self._attr_value)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiConstFloat(_Multiple):
+    """Wrapper for an edge with multiple ConstFloat objects."""
+
+    _T = ConstFloat
+
+
+_typemap['ConstFloat'] = ConstFloat
+
+class ConstInt(Constant):
+    __slots__ = [
+        '_attr_value',
+    ]
+
+    def __init__(
+        self,
+        value=None,
+    ):
+        super().__init__()
+        self.value = value
+
+    @property
+    def value(self):
+        return self._attr_value
+
+    @value.setter
+    def value(self, val):
+        if val is None:
+            del self.value
+            return
+        if not isinstance(val, cqasm.v3x.primitives.Int):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('value must be of type cqasm.v3x.primitives.Int')
+            val = cqasm.v3x.primitives.Int(val)
+        self._attr_value = val
+
+    @value.deleter
+    def value(self):
+        self._attr_value = cqasm.v3x.primitives.Int()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, ConstInt):
+            return False
+        if self.value != other.value:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('ConstInt(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('value: ')
+        s.append(str(self.value) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return ConstInt(
+            value=self._attr_value
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return ConstInt(
+            value=_cloned(self._attr_value)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'ConstInt':
+            raise ValueError('found node serialization for ' + typ + ', but expected ConstInt')
+
+        # Deserialize the value field.
+        field = cbor.get('value', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field value')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_value = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_value = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the ConstInt node.
+        node = ConstInt(f_value)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'ConstInt'}
+
+        # Serialize the value field.
+        if hasattr(self._attr_value, 'serialize_cbor'):
+            cbor['value'] = self._attr_value.serialize_cbor()
+        else:
+            cbor['value'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_value)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiConstInt(_Multiple):
+    """Wrapper for an edge with multiple ConstInt objects."""
+
+    _T = ConstInt
+
+
+_typemap['ConstInt'] = ConstInt
+
+class Reference(ValueBase):
+    """Reference to some storage location"""
+
+    __slots__ = []
+
+    def __init__(self):
+        super().__init__()
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ == 'IndexRef':
+            return IndexRef._deserialize(cbor, seq_to_ob, links)
+        if typ == 'VariableRef':
+            return VariableRef._deserialize(cbor, seq_to_ob, links)
+        raise ValueError('unknown or unexpected type (@t) found in node serialization')
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Reference'}
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiReference(_Multiple):
+    """Wrapper for an edge with multiple Reference objects."""
+
+    _T = Reference
+
+
+_typemap['Reference'] = Reference
+
+class IndexRef(Reference):
+    """Represents an index for single-gate-multiple-qubit notation. The indices
+    must not repeat."""
+
+    __slots__ = [
+        '_attr_variable',
+        '_attr_indices',
+    ]
+
+    def __init__(
+        self,
+        variable=None,
+        indices=None,
+    ):
+        super().__init__()
+        self.variable = variable
+        self.indices = indices
+
+    @property
+    def variable(self):
+        return self._attr_variable
+
+    @variable.setter
+    def variable(self, val):
+        if val is None:
+            del self.variable
+            return
+        if not isinstance(val, cqasm.v3x.semantic.Variable):
+            raise TypeError('variable must be of type cqasm.v3x.semantic.Variable')
+        self._attr_variable = val
+
+    @variable.deleter
+    def variable(self):
+        self._attr_variable = None
+
+    @property
+    def indices(self):
+        return self._attr_indices
+
+    @indices.setter
+    def indices(self, val):
+        if val is None:
+            del self.indices
+            return
+        if not isinstance(val, MultiConstInt):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('indices must be of type MultiConstInt')
+            val = MultiConstInt(val)
+        self._attr_indices = val
+
+    @indices.deleter
+    def indices(self):
+        self._attr_indices = MultiConstInt()
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, IndexRef):
+            return False
+        if self.variable is not other.variable:
+            return False
+        if self.indices != other.indices:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('IndexRef(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('variable --> ')
+        if self.variable is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            if links:
+                s.append(self.variable.dump(indent + 1, annotations, links - 1) + '\n')
+            else:
+                s.append('  '*(indent+1) + '...\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('indices: ')
+        if not self.indices:
+            s.append('!MISSING\n')
+        else:
+            s.append('[\n')
+            for child in self.indices:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        for el in self._attr_indices:
+            el.find_reachable(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_variable is None:
+            raise NotWellFormed('variable is required but not set')
+        if self._attr_variable is not None:
+            if id(self._attr_variable) not in id_map:
+                raise NotWellFormed('variable links to unreachable node')
+        if not self._attr_indices:
+            raise NotWellFormed('indices needs at least one node but has zero')
+        for child in self._attr_indices:
+            child.check_complete(id_map)
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return IndexRef(
+            variable=self._attr_variable,
+            indices=self._attr_indices.copy()
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return IndexRef(
+            variable=self._attr_variable,
+            indices=_cloned(self._attr_indices)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'IndexRef':
+            raise ValueError('found node serialization for ' + typ + ', but expected IndexRef')
+
+        # Deserialize the variable field.
+        field = cbor.get('variable', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field variable')
+        if field.get('@T') != '$':
+            raise ValueError('unexpected edge type for field variable')
+        f_variable = None
+        l_variable = field.get('@l', None)
+
+        # Deserialize the indices field.
+        field = cbor.get('indices', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field indices')
+        if field.get('@T') != '+':
+            raise ValueError('unexpected edge type for field indices')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_indices = MultiConstInt()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_indices.append(ConstInt._deserialize(element, seq_to_ob, links))
+
+        # Construct the IndexRef node.
+        node = IndexRef(f_variable, f_indices)
+
+        # Register links to be made after tree construction.
+        links.append((lambda val: IndexRef.variable.fset(node, val), l_variable))
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'IndexRef'}
+
+        # Serialize the variable field.
+        field = {'@T': '$'}
+        if self._attr_variable is None:
+            field['@l'] = None
+        else:
+            field['@l'] = id_map[id(self._attr_variable)]
+        cbor['variable'] = field
+
+        # Serialize the indices field.
+        field = {'@T': '+'}
+        lst = []
+        for el in self._attr_indices:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['indices'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiIndexRef(_Multiple):
+    """Wrapper for an edge with multiple IndexRef objects."""
+
+    _T = IndexRef
+
+
+_typemap['IndexRef'] = IndexRef
+
+class VariableRef(Reference):
+    __slots__ = [
+        '_attr_variable',
+    ]
+
+    def __init__(
+        self,
+        variable=None,
+    ):
+        super().__init__()
+        self.variable = variable
+
+    @property
+    def variable(self):
+        return self._attr_variable
+
+    @variable.setter
+    def variable(self, val):
+        if val is None:
+            del self.variable
+            return
+        if not isinstance(val, cqasm.v3x.semantic.Variable):
+            raise TypeError('variable must be of type cqasm.v3x.semantic.Variable')
+        self._attr_variable = val
+
+    @variable.deleter
+    def variable(self):
+        self._attr_variable = None
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, VariableRef):
+            return False
+        if self.variable is not other.variable:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('VariableRef(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('variable --> ')
+        if self.variable is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            if links:
+                s.append(self.variable.dump(indent + 1, annotations, links - 1) + '\n')
+            else:
+                s.append('  '*(indent+1) + '...\n')
+            s.append('  '*indent + '>\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+        if self._attr_variable is None:
+            raise NotWellFormed('variable is required but not set')
+        if self._attr_variable is not None:
+            if id(self._attr_variable) not in id_map:
+                raise NotWellFormed('variable links to unreachable node')
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return VariableRef(
+            variable=self._attr_variable
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return VariableRef(
+            variable=self._attr_variable
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'VariableRef':
+            raise ValueError('found node serialization for ' + typ + ', but expected VariableRef')
+
+        # Deserialize the variable field.
+        field = cbor.get('variable', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field variable')
+        if field.get('@T') != '$':
+            raise ValueError('unexpected edge type for field variable')
+        f_variable = None
+        l_variable = field.get('@l', None)
+
+        # Construct the VariableRef node.
+        node = VariableRef(f_variable)
+
+        # Register links to be made after tree construction.
+        links.append((lambda val: VariableRef.variable.fset(node, val), l_variable))
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'VariableRef'}
+
+        # Serialize the variable field.
+        field = {'@T': '$'}
+        if self._attr_variable is None:
+            field['@l'] = None
+        else:
+            field['@l'] = id_map[id(self._attr_variable)]
+        cbor['variable'] = field
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiVariableRef(_Multiple):
+    """Wrapper for an edge with multiple VariableRef objects."""
+
+    _T = VariableRef
+
+
+_typemap['VariableRef'] = VariableRef
+
```

## libQasm/__init__.py

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-# Author Imran Ashraf, Jeroen van Straten
-
-import os
-from sys import version_info
-
-
-# Before we can import the dynamic modules, we have to set the linker search path appropriately.
-ld_lib_path = os.environ.get('LD_LIBRARY_PATH', '')
-if ld_lib_path:
-    ld_lib_path += ':'
-os.environ['LD_LIBRARY_PATH'] = ld_lib_path + os.path.dirname(__file__)
-del ld_lib_path, os
-
-# We only support Python 3
-if version_info[0] != 3:
-    raise EnvironmentError(
-        "sys.version_info refers does not refer to a version of Python 3. "
-        "This is not permitted. "
-        "sys.version_info = {}".format(version_info))
-del version_info
-
-# Import the SWIG-generated module.
-from .libQasm import *
-
-# __all__ = [ init, schedule, compile ]
+# Author Imran Ashraf, Jeroen van Straten
+
+import os
+from sys import version_info
+
+
+# Before we can import the dynamic modules, we have to set the linker search path appropriately.
+ld_lib_path = os.environ.get('LD_LIBRARY_PATH', '')
+if ld_lib_path:
+    ld_lib_path += ':'
+os.environ['LD_LIBRARY_PATH'] = ld_lib_path + os.path.dirname(__file__)
+del ld_lib_path, os
+
+# We only support Python 3
+if version_info[0] != 3:
+    raise EnvironmentError(
+        "sys.version_info refers does not refer to a version of Python 3. "
+        "This is not permitted. "
+        "sys.version_info = {}".format(version_info))
+del version_info
+
+# Import the SWIG-generated module.
+from .libQasm import *
+
+# __all__ = [ init, schedule, compile ]
```

## libQasm/libQasm.py

```diff
@@ -1,1082 +1,1082 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _libQasm
-else:
-    import _libQasm
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _libQasm.delete_SwigPyIterator
-
-    def value(self):
-        return _libQasm.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _libQasm.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _libQasm.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _libQasm.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _libQasm.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _libQasm.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _libQasm.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _libQasm.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _libQasm.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _libQasm.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _libQasm.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _libQasm.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _libQasm.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _libQasm.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _libQasm.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _libQasm.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _libQasm:
-_libQasm.SwigPyIterator_swigregister(SwigPyIterator)
-class ios_base(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined")
-    __repr__ = _swig_repr
-    erase_event = _libQasm.ios_base_erase_event
-    imbue_event = _libQasm.ios_base_imbue_event
-    copyfmt_event = _libQasm.ios_base_copyfmt_event
-
-    def register_callback(self, __fn, __index):
-        return _libQasm.ios_base_register_callback(self, __fn, __index)
-
-    def flags(self, *args):
-        return _libQasm.ios_base_flags(self, *args)
-
-    def setf(self, *args):
-        return _libQasm.ios_base_setf(self, *args)
-
-    def unsetf(self, __mask):
-        return _libQasm.ios_base_unsetf(self, __mask)
-
-    def precision(self, *args):
-        return _libQasm.ios_base_precision(self, *args)
-
-    def width(self, *args):
-        return _libQasm.ios_base_width(self, *args)
-
-    @staticmethod
-    def sync_with_stdio(__sync=True):
-        return _libQasm.ios_base_sync_with_stdio(__sync)
-
-    def imbue(self, __loc):
-        return _libQasm.ios_base_imbue(self, __loc)
-
-    def getloc(self):
-        return _libQasm.ios_base_getloc(self)
-
-    @staticmethod
-    def xalloc():
-        return _libQasm.ios_base_xalloc()
-
-    def iword(self, __ix):
-        return _libQasm.ios_base_iword(self, __ix)
-
-    def pword(self, __ix):
-        return _libQasm.ios_base_pword(self, __ix)
-    __swig_destroy__ = _libQasm.delete_ios_base
-
-# Register ios_base in _libQasm:
-_libQasm.ios_base_swigregister(ios_base)
-cvar = _libQasm.cvar
-ios_base.boolalpha = _libQasm.cvar.ios_base_boolalpha
-ios_base.dec = _libQasm.cvar.ios_base_dec
-ios_base.fixed = _libQasm.cvar.ios_base_fixed
-ios_base.hex = _libQasm.cvar.ios_base_hex
-ios_base.internal = _libQasm.cvar.ios_base_internal
-ios_base.left = _libQasm.cvar.ios_base_left
-ios_base.oct = _libQasm.cvar.ios_base_oct
-ios_base.right = _libQasm.cvar.ios_base_right
-ios_base.scientific = _libQasm.cvar.ios_base_scientific
-ios_base.showbase = _libQasm.cvar.ios_base_showbase
-ios_base.showpoint = _libQasm.cvar.ios_base_showpoint
-ios_base.showpos = _libQasm.cvar.ios_base_showpos
-ios_base.skipws = _libQasm.cvar.ios_base_skipws
-ios_base.unitbuf = _libQasm.cvar.ios_base_unitbuf
-ios_base.uppercase = _libQasm.cvar.ios_base_uppercase
-ios_base.adjustfield = _libQasm.cvar.ios_base_adjustfield
-ios_base.basefield = _libQasm.cvar.ios_base_basefield
-ios_base.floatfield = _libQasm.cvar.ios_base_floatfield
-ios_base.badbit = _libQasm.cvar.ios_base_badbit
-ios_base.eofbit = _libQasm.cvar.ios_base_eofbit
-ios_base.failbit = _libQasm.cvar.ios_base_failbit
-ios_base.goodbit = _libQasm.cvar.ios_base_goodbit
-ios_base.app = _libQasm.cvar.ios_base_app
-ios_base.ate = _libQasm.cvar.ios_base_ate
-ios_base.binary = _libQasm.cvar.ios_base_binary
-ios_base.ios_base_in = _libQasm.cvar.ios_base_ios_base_in
-ios_base.out = _libQasm.cvar.ios_base_out
-ios_base.trunc = _libQasm.cvar.ios_base_trunc
-ios_base.beg = _libQasm.cvar.ios_base_beg
-ios_base.cur = _libQasm.cvar.ios_base_cur
-ios_base.end = _libQasm.cvar.ios_base_end
-
-class ios(ios_base):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def rdstate(self):
-        return _libQasm.ios_rdstate(self)
-
-    def clear(self, *args):
-        return _libQasm.ios_clear(self, *args)
-
-    def setstate(self, __state):
-        return _libQasm.ios_setstate(self, __state)
-
-    def good(self):
-        return _libQasm.ios_good(self)
-
-    def eof(self):
-        return _libQasm.ios_eof(self)
-
-    def fail(self):
-        return _libQasm.ios_fail(self)
-
-    def bad(self):
-        return _libQasm.ios_bad(self)
-
-    def exceptions(self, *args):
-        return _libQasm.ios_exceptions(self, *args)
-
-    def __init__(self, __sb):
-        _libQasm.ios_swiginit(self, _libQasm.new_ios(__sb))
-    __swig_destroy__ = _libQasm.delete_ios
-
-    def tie(self, *args):
-        return _libQasm.ios_tie(self, *args)
-
-    def rdbuf(self, *args):
-        return _libQasm.ios_rdbuf(self, *args)
-
-    def copyfmt(self, __rhs):
-        return _libQasm.ios_copyfmt(self, __rhs)
-
-    def fill(self, *args):
-        return _libQasm.ios_fill(self, *args)
-
-    def imbue(self, __loc):
-        return _libQasm.ios_imbue(self, __loc)
-
-    def narrow(self, __c, __dfault):
-        return _libQasm.ios_narrow(self, __c, __dfault)
-
-    def widen(self, __c):
-        return _libQasm.ios_widen(self, __c)
-
-# Register ios in _libQasm:
-_libQasm.ios_swigregister(ios)
-class string(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def length(self):
-        return _libQasm.string_length(self)
-
-    def max_size(self):
-        return _libQasm.string_max_size(self)
-
-    def capacity(self):
-        return _libQasm.string_capacity(self)
-
-    def reserve(self, __res_arg):
-        return _libQasm.string_reserve(self, __res_arg)
-
-    def shrink_to_fit(self):
-        return _libQasm.string_shrink_to_fit(self)
-
-    def copy(self, __s, __n, __pos=0):
-        return _libQasm.string_copy(self, __s, __n, __pos)
-
-    def c_str(self):
-        return _libQasm.string_c_str(self)
-
-    def find(self, *args):
-        return _libQasm.string_find(self, *args)
-
-    def rfind(self, *args):
-        return _libQasm.string_rfind(self, *args)
-
-    def find_first_of(self, *args):
-        return _libQasm.string_find_first_of(self, *args)
-
-    def find_last_of(self, *args):
-        return _libQasm.string_find_last_of(self, *args)
-
-    def find_first_not_of(self, *args):
-        return _libQasm.string_find_first_not_of(self, *args)
-
-    def find_last_not_of(self, *args):
-        return _libQasm.string_find_last_not_of(self, *args)
-
-    def substr(self, *args):
-        return _libQasm.string_substr(self, *args)
-
-    def empty(self):
-        return _libQasm.string_empty(self)
-
-    def size(self):
-        return _libQasm.string_size(self)
-
-    def swap(self, v):
-        return _libQasm.string_swap(self, v)
-
-    def begin(self):
-        return _libQasm.string_begin(self)
-
-    def end(self):
-        return _libQasm.string_end(self)
-
-    def rbegin(self):
-        return _libQasm.string_rbegin(self)
-
-    def rend(self):
-        return _libQasm.string_rend(self)
-
-    def get_allocator(self):
-        return _libQasm.string_get_allocator(self)
-
-    def erase(self, *args):
-        return _libQasm.string_erase(self, *args)
-
-    def __init__(self, *args):
-        _libQasm.string_swiginit(self, _libQasm.new_string(*args))
-
-    def assign(self, *args):
-        return _libQasm.string_assign(self, *args)
-
-    def resize(self, *args):
-        return _libQasm.string_resize(self, *args)
-
-    def iterator(self):
-        return _libQasm.string_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _libQasm.string___nonzero__(self)
-
-    def __bool__(self):
-        return _libQasm.string___bool__(self)
-
-    def __len__(self):
-        return _libQasm.string___len__(self)
-
-    def __getslice__(self, i, j):
-        return _libQasm.string___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _libQasm.string___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _libQasm.string___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _libQasm.string___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _libQasm.string___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _libQasm.string___setitem__(self, *args)
-
-    def insert(self, *args):
-        return _libQasm.string_insert(self, *args)
-
-    def replace(self, *args):
-        return _libQasm.string_replace(self, *args)
-
-    def __iadd__(self, v):
-        return _libQasm.string___iadd__(self, v)
-
-    def __add__(self, v):
-        return _libQasm.string___add__(self, v)
-
-    def __radd__(self, v):
-        return _libQasm.string___radd__(self, v)
-
-    def __str__(self):
-        return _libQasm.string___str__(self)
-
-    def __rlshift__(self, out):
-        return _libQasm.string___rlshift__(self, out)
-
-    def __eq__(self, v):
-        return _libQasm.string___eq__(self, v)
-
-    def __ne__(self, v):
-        return _libQasm.string___ne__(self, v)
-
-    def __gt__(self, v):
-        return _libQasm.string___gt__(self, v)
-
-    def __lt__(self, v):
-        return _libQasm.string___lt__(self, v)
-
-    def __ge__(self, v):
-        return _libQasm.string___ge__(self, v)
-
-    def __le__(self, v):
-        return _libQasm.string___le__(self, v)
-    __swig_destroy__ = _libQasm.delete_string
-
-# Register string in _libQasm:
-_libQasm.string_swigregister(string)
-string.npos = _libQasm.cvar.string_npos
-
-class ostream(ios):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, __sb):
-        _libQasm.ostream_swiginit(self, _libQasm.new_ostream(__sb))
-    __swig_destroy__ = _libQasm.delete_ostream
-
-    def __lshift__(self, *args):
-        return _libQasm.ostream___lshift__(self, *args)
-
-    def put(self, __c):
-        return _libQasm.ostream_put(self, __c)
-
-    def write(self, __s, __n):
-        return _libQasm.ostream_write(self, __s, __n)
-
-    def flush(self):
-        return _libQasm.ostream_flush(self)
-
-    def tellp(self):
-        return _libQasm.ostream_tellp(self)
-
-    def seekp(self, *args):
-        return _libQasm.ostream_seekp(self, *args)
-
-# Register ostream in _libQasm:
-_libQasm.ostream_swigregister(ostream)
-cin = cvar.cin
-cout = cvar.cout
-cerr = cvar.cerr
-clog = cvar.clog
-
-class istream(ios):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, __sb):
-        _libQasm.istream_swiginit(self, _libQasm.new_istream(__sb))
-    __swig_destroy__ = _libQasm.delete_istream
-
-    def __rshift__(self, *args):
-        return _libQasm.istream___rshift__(self, *args)
-
-    def gcount(self):
-        return _libQasm.istream_gcount(self)
-
-    def get(self, *args):
-        return _libQasm.istream_get(self, *args)
-
-    def getline(self, *args):
-        return _libQasm.istream_getline(self, *args)
-
-    def ignore(self, *args):
-        return _libQasm.istream_ignore(self, *args)
-
-    def peek(self):
-        return _libQasm.istream_peek(self)
-
-    def read(self, __s, __n):
-        return _libQasm.istream_read(self, __s, __n)
-
-    def readsome(self, __s, __n):
-        return _libQasm.istream_readsome(self, __s, __n)
-
-    def putback(self, __c):
-        return _libQasm.istream_putback(self, __c)
-
-    def unget(self):
-        return _libQasm.istream_unget(self)
-
-    def sync(self):
-        return _libQasm.istream_sync(self)
-
-    def tellg(self):
-        return _libQasm.istream_tellg(self)
-
-    def seekg(self, *args):
-        return _libQasm.istream_seekg(self, *args)
-
-# Register istream in _libQasm:
-_libQasm.istream_swigregister(istream)
-class iostream(istream, ostream):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, __sb):
-        _libQasm.iostream_swiginit(self, _libQasm.new_iostream(__sb))
-    __swig_destroy__ = _libQasm.delete_iostream
-
-# Register iostream in _libQasm:
-_libQasm.iostream_swigregister(iostream)
-endl_cb_ptr = _libQasm.endl_cb_ptr
-endl = _libQasm.endl
-ends_cb_ptr = _libQasm.ends_cb_ptr
-ends = _libQasm.ends
-flush_cb_ptr = _libQasm.flush_cb_ptr
-flush = _libQasm.flush
-class vectori(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self):
-        return _libQasm.vectori_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _libQasm.vectori___nonzero__(self)
-
-    def __bool__(self):
-        return _libQasm.vectori___bool__(self)
-
-    def __len__(self):
-        return _libQasm.vectori___len__(self)
-
-    def __getslice__(self, i, j):
-        return _libQasm.vectori___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _libQasm.vectori___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _libQasm.vectori___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _libQasm.vectori___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _libQasm.vectori___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _libQasm.vectori___setitem__(self, *args)
-
-    def pop(self):
-        return _libQasm.vectori_pop(self)
-
-    def append(self, x):
-        return _libQasm.vectori_append(self, x)
-
-    def empty(self):
-        return _libQasm.vectori_empty(self)
-
-    def size(self):
-        return _libQasm.vectori_size(self)
-
-    def swap(self, v):
-        return _libQasm.vectori_swap(self, v)
-
-    def begin(self):
-        return _libQasm.vectori_begin(self)
-
-    def end(self):
-        return _libQasm.vectori_end(self)
-
-    def rbegin(self):
-        return _libQasm.vectori_rbegin(self)
-
-    def rend(self):
-        return _libQasm.vectori_rend(self)
-
-    def clear(self):
-        return _libQasm.vectori_clear(self)
-
-    def get_allocator(self):
-        return _libQasm.vectori_get_allocator(self)
-
-    def pop_back(self):
-        return _libQasm.vectori_pop_back(self)
-
-    def erase(self, *args):
-        return _libQasm.vectori_erase(self, *args)
-
-    def __init__(self, *args):
-        _libQasm.vectori_swiginit(self, _libQasm.new_vectori(*args))
-
-    def push_back(self, x):
-        return _libQasm.vectori_push_back(self, x)
-
-    def front(self):
-        return _libQasm.vectori_front(self)
-
-    def back(self):
-        return _libQasm.vectori_back(self)
-
-    def assign(self, n, x):
-        return _libQasm.vectori_assign(self, n, x)
-
-    def resize(self, *args):
-        return _libQasm.vectori_resize(self, *args)
-
-    def insert(self, *args):
-        return _libQasm.vectori_insert(self, *args)
-
-    def reserve(self, n):
-        return _libQasm.vectori_reserve(self, n)
-
-    def capacity(self):
-        return _libQasm.vectori_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectori
-
-# Register vectori in _libQasm:
-_libQasm.vectori_swigregister(vectori)
-class vectorui(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self):
-        return _libQasm.vectorui_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _libQasm.vectorui___nonzero__(self)
-
-    def __bool__(self):
-        return _libQasm.vectorui___bool__(self)
-
-    def __len__(self):
-        return _libQasm.vectorui___len__(self)
-
-    def __getslice__(self, i, j):
-        return _libQasm.vectorui___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _libQasm.vectorui___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _libQasm.vectorui___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _libQasm.vectorui___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _libQasm.vectorui___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _libQasm.vectorui___setitem__(self, *args)
-
-    def pop(self):
-        return _libQasm.vectorui_pop(self)
-
-    def append(self, x):
-        return _libQasm.vectorui_append(self, x)
-
-    def empty(self):
-        return _libQasm.vectorui_empty(self)
-
-    def size(self):
-        return _libQasm.vectorui_size(self)
-
-    def swap(self, v):
-        return _libQasm.vectorui_swap(self, v)
-
-    def begin(self):
-        return _libQasm.vectorui_begin(self)
-
-    def end(self):
-        return _libQasm.vectorui_end(self)
-
-    def rbegin(self):
-        return _libQasm.vectorui_rbegin(self)
-
-    def rend(self):
-        return _libQasm.vectorui_rend(self)
-
-    def clear(self):
-        return _libQasm.vectorui_clear(self)
-
-    def get_allocator(self):
-        return _libQasm.vectorui_get_allocator(self)
-
-    def pop_back(self):
-        return _libQasm.vectorui_pop_back(self)
-
-    def erase(self, *args):
-        return _libQasm.vectorui_erase(self, *args)
-
-    def __init__(self, *args):
-        _libQasm.vectorui_swiginit(self, _libQasm.new_vectorui(*args))
-
-    def push_back(self, x):
-        return _libQasm.vectorui_push_back(self, x)
-
-    def front(self):
-        return _libQasm.vectorui_front(self)
-
-    def back(self):
-        return _libQasm.vectorui_back(self)
-
-    def assign(self, n, x):
-        return _libQasm.vectorui_assign(self, n, x)
-
-    def resize(self, *args):
-        return _libQasm.vectorui_resize(self, *args)
-
-    def insert(self, *args):
-        return _libQasm.vectorui_insert(self, *args)
-
-    def reserve(self, n):
-        return _libQasm.vectorui_reserve(self, n)
-
-    def capacity(self):
-        return _libQasm.vectorui_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectorui
-
-# Register vectorui in _libQasm:
-_libQasm.vectorui_swigregister(vectorui)
-class vectorf(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self):
-        return _libQasm.vectorf_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _libQasm.vectorf___nonzero__(self)
-
-    def __bool__(self):
-        return _libQasm.vectorf___bool__(self)
-
-    def __len__(self):
-        return _libQasm.vectorf___len__(self)
-
-    def __getslice__(self, i, j):
-        return _libQasm.vectorf___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _libQasm.vectorf___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _libQasm.vectorf___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _libQasm.vectorf___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _libQasm.vectorf___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _libQasm.vectorf___setitem__(self, *args)
-
-    def pop(self):
-        return _libQasm.vectorf_pop(self)
-
-    def append(self, x):
-        return _libQasm.vectorf_append(self, x)
-
-    def empty(self):
-        return _libQasm.vectorf_empty(self)
-
-    def size(self):
-        return _libQasm.vectorf_size(self)
-
-    def swap(self, v):
-        return _libQasm.vectorf_swap(self, v)
-
-    def begin(self):
-        return _libQasm.vectorf_begin(self)
-
-    def end(self):
-        return _libQasm.vectorf_end(self)
-
-    def rbegin(self):
-        return _libQasm.vectorf_rbegin(self)
-
-    def rend(self):
-        return _libQasm.vectorf_rend(self)
-
-    def clear(self):
-        return _libQasm.vectorf_clear(self)
-
-    def get_allocator(self):
-        return _libQasm.vectorf_get_allocator(self)
-
-    def pop_back(self):
-        return _libQasm.vectorf_pop_back(self)
-
-    def erase(self, *args):
-        return _libQasm.vectorf_erase(self, *args)
-
-    def __init__(self, *args):
-        _libQasm.vectorf_swiginit(self, _libQasm.new_vectorf(*args))
-
-    def push_back(self, x):
-        return _libQasm.vectorf_push_back(self, x)
-
-    def front(self):
-        return _libQasm.vectorf_front(self)
-
-    def back(self):
-        return _libQasm.vectorf_back(self)
-
-    def assign(self, n, x):
-        return _libQasm.vectorf_assign(self, n, x)
-
-    def resize(self, *args):
-        return _libQasm.vectorf_resize(self, *args)
-
-    def insert(self, *args):
-        return _libQasm.vectorf_insert(self, *args)
-
-    def reserve(self, n):
-        return _libQasm.vectorf_reserve(self, n)
-
-    def capacity(self):
-        return _libQasm.vectorf_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectorf
-
-# Register vectorf in _libQasm:
-_libQasm.vectorf_swigregister(vectorf)
-class vectord(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self):
-        return _libQasm.vectord_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _libQasm.vectord___nonzero__(self)
-
-    def __bool__(self):
-        return _libQasm.vectord___bool__(self)
-
-    def __len__(self):
-        return _libQasm.vectord___len__(self)
-
-    def __getslice__(self, i, j):
-        return _libQasm.vectord___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _libQasm.vectord___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _libQasm.vectord___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _libQasm.vectord___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _libQasm.vectord___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _libQasm.vectord___setitem__(self, *args)
-
-    def pop(self):
-        return _libQasm.vectord_pop(self)
-
-    def append(self, x):
-        return _libQasm.vectord_append(self, x)
-
-    def empty(self):
-        return _libQasm.vectord_empty(self)
-
-    def size(self):
-        return _libQasm.vectord_size(self)
-
-    def swap(self, v):
-        return _libQasm.vectord_swap(self, v)
-
-    def begin(self):
-        return _libQasm.vectord_begin(self)
-
-    def end(self):
-        return _libQasm.vectord_end(self)
-
-    def rbegin(self):
-        return _libQasm.vectord_rbegin(self)
-
-    def rend(self):
-        return _libQasm.vectord_rend(self)
-
-    def clear(self):
-        return _libQasm.vectord_clear(self)
-
-    def get_allocator(self):
-        return _libQasm.vectord_get_allocator(self)
-
-    def pop_back(self):
-        return _libQasm.vectord_pop_back(self)
-
-    def erase(self, *args):
-        return _libQasm.vectord_erase(self, *args)
-
-    def __init__(self, *args):
-        _libQasm.vectord_swiginit(self, _libQasm.new_vectord(*args))
-
-    def push_back(self, x):
-        return _libQasm.vectord_push_back(self, x)
-
-    def front(self):
-        return _libQasm.vectord_front(self)
-
-    def back(self):
-        return _libQasm.vectord_back(self)
-
-    def assign(self, n, x):
-        return _libQasm.vectord_assign(self, n, x)
-
-    def resize(self, *args):
-        return _libQasm.vectord_resize(self, *args)
-
-    def insert(self, *args):
-        return _libQasm.vectord_insert(self, *args)
-
-    def reserve(self, n):
-        return _libQasm.vectord_reserve(self, n)
-
-    def capacity(self):
-        return _libQasm.vectord_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectord
-
-# Register vectord in _libQasm:
-_libQasm.vectord_swigregister(vectord)
-class vectors(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self):
-        return _libQasm.vectors_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _libQasm.vectors___nonzero__(self)
-
-    def __bool__(self):
-        return _libQasm.vectors___bool__(self)
-
-    def __len__(self):
-        return _libQasm.vectors___len__(self)
-
-    def __getslice__(self, i, j):
-        return _libQasm.vectors___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _libQasm.vectors___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _libQasm.vectors___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _libQasm.vectors___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _libQasm.vectors___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _libQasm.vectors___setitem__(self, *args)
-
-    def pop(self):
-        return _libQasm.vectors_pop(self)
-
-    def append(self, x):
-        return _libQasm.vectors_append(self, x)
-
-    def empty(self):
-        return _libQasm.vectors_empty(self)
-
-    def size(self):
-        return _libQasm.vectors_size(self)
-
-    def swap(self, v):
-        return _libQasm.vectors_swap(self, v)
-
-    def begin(self):
-        return _libQasm.vectors_begin(self)
-
-    def end(self):
-        return _libQasm.vectors_end(self)
-
-    def rbegin(self):
-        return _libQasm.vectors_rbegin(self)
-
-    def rend(self):
-        return _libQasm.vectors_rend(self)
-
-    def clear(self):
-        return _libQasm.vectors_clear(self)
-
-    def get_allocator(self):
-        return _libQasm.vectors_get_allocator(self)
-
-    def pop_back(self):
-        return _libQasm.vectors_pop_back(self)
-
-    def erase(self, *args):
-        return _libQasm.vectors_erase(self, *args)
-
-    def __init__(self, *args):
-        _libQasm.vectors_swiginit(self, _libQasm.new_vectors(*args))
-
-    def push_back(self, x):
-        return _libQasm.vectors_push_back(self, x)
-
-    def front(self):
-        return _libQasm.vectors_front(self)
-
-    def back(self):
-        return _libQasm.vectors_back(self)
-
-    def assign(self, n, x):
-        return _libQasm.vectors_assign(self, n, x)
-
-    def resize(self, *args):
-        return _libQasm.vectors_resize(self, *args)
-
-    def insert(self, *args):
-        return _libQasm.vectors_insert(self, *args)
-
-    def reserve(self, n):
-        return _libQasm.vectors_reserve(self, n)
-
-    def capacity(self):
-        return _libQasm.vectors_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectors
-
-# Register vectors in _libQasm:
-_libQasm.vectors_swigregister(vectors)
-class V3xAnalyzer(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _libQasm.V3xAnalyzer_swiginit(self, _libQasm.new_V3xAnalyzer(*args))
-    __swig_destroy__ = _libQasm.delete_V3xAnalyzer
-
-    def register_instruction(self, *args):
-        return _libQasm.V3xAnalyzer_register_instruction(self, *args)
-
-    @staticmethod
-    def parse_file(file_name):
-        return _libQasm.V3xAnalyzer_parse_file(file_name)
-
-    @staticmethod
-    def parse_file_to_json(file_name):
-        return _libQasm.V3xAnalyzer_parse_file_to_json(file_name)
-
-    @staticmethod
-    def parse_string(*args):
-        return _libQasm.V3xAnalyzer_parse_string(*args)
-
-    @staticmethod
-    def parse_string_to_json(*args):
-        return _libQasm.V3xAnalyzer_parse_string_to_json(*args)
-
-    def analyze_file(self, file_name):
-        return _libQasm.V3xAnalyzer_analyze_file(self, file_name)
-
-    def analyze_file_to_json(self, file_name):
-        return _libQasm.V3xAnalyzer_analyze_file_to_json(self, file_name)
-
-    def analyze_string(self, *args):
-        return _libQasm.V3xAnalyzer_analyze_string(self, *args)
-
-    def analyze_string_to_json(self, *args):
-        return _libQasm.V3xAnalyzer_analyze_string_to_json(self, *args)
-
-# Register V3xAnalyzer in _libQasm:
-_libQasm.V3xAnalyzer_swigregister(V3xAnalyzer)
-
+# This file was automatically generated by SWIG (https://www.swig.org).
+# Version 4.2.1
+#
+# Do not make changes to this file unless you know what you are doing - modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _libQasm
+else:
+    import _libQasm
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "this":
+            set(self, name, value)
+        elif name == "thisown":
+            self.this.own(value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _libQasm.delete_SwigPyIterator
+
+    def value(self):
+        return _libQasm.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _libQasm.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _libQasm.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _libQasm.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _libQasm.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _libQasm.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _libQasm.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _libQasm.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _libQasm.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _libQasm.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _libQasm.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _libQasm.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _libQasm.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _libQasm.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _libQasm.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _libQasm.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _libQasm:
+_libQasm.SwigPyIterator_swigregister(SwigPyIterator)
+class ios_base(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined")
+    __repr__ = _swig_repr
+    erase_event = _libQasm.ios_base_erase_event
+    imbue_event = _libQasm.ios_base_imbue_event
+    copyfmt_event = _libQasm.ios_base_copyfmt_event
+
+    def register_callback(self, __fn, __index):
+        return _libQasm.ios_base_register_callback(self, __fn, __index)
+
+    def flags(self, *args):
+        return _libQasm.ios_base_flags(self, *args)
+
+    def setf(self, *args):
+        return _libQasm.ios_base_setf(self, *args)
+
+    def unsetf(self, __mask):
+        return _libQasm.ios_base_unsetf(self, __mask)
+
+    def precision(self, *args):
+        return _libQasm.ios_base_precision(self, *args)
+
+    def width(self, *args):
+        return _libQasm.ios_base_width(self, *args)
+
+    @staticmethod
+    def sync_with_stdio(__sync=True):
+        return _libQasm.ios_base_sync_with_stdio(__sync)
+
+    def imbue(self, __loc):
+        return _libQasm.ios_base_imbue(self, __loc)
+
+    def getloc(self):
+        return _libQasm.ios_base_getloc(self)
+
+    @staticmethod
+    def xalloc():
+        return _libQasm.ios_base_xalloc()
+
+    def iword(self, __ix):
+        return _libQasm.ios_base_iword(self, __ix)
+
+    def pword(self, __ix):
+        return _libQasm.ios_base_pword(self, __ix)
+    __swig_destroy__ = _libQasm.delete_ios_base
+
+# Register ios_base in _libQasm:
+_libQasm.ios_base_swigregister(ios_base)
+cvar = _libQasm.cvar
+ios_base.boolalpha = _libQasm.cvar.ios_base_boolalpha
+ios_base.dec = _libQasm.cvar.ios_base_dec
+ios_base.fixed = _libQasm.cvar.ios_base_fixed
+ios_base.hex = _libQasm.cvar.ios_base_hex
+ios_base.internal = _libQasm.cvar.ios_base_internal
+ios_base.left = _libQasm.cvar.ios_base_left
+ios_base.oct = _libQasm.cvar.ios_base_oct
+ios_base.right = _libQasm.cvar.ios_base_right
+ios_base.scientific = _libQasm.cvar.ios_base_scientific
+ios_base.showbase = _libQasm.cvar.ios_base_showbase
+ios_base.showpoint = _libQasm.cvar.ios_base_showpoint
+ios_base.showpos = _libQasm.cvar.ios_base_showpos
+ios_base.skipws = _libQasm.cvar.ios_base_skipws
+ios_base.unitbuf = _libQasm.cvar.ios_base_unitbuf
+ios_base.uppercase = _libQasm.cvar.ios_base_uppercase
+ios_base.adjustfield = _libQasm.cvar.ios_base_adjustfield
+ios_base.basefield = _libQasm.cvar.ios_base_basefield
+ios_base.floatfield = _libQasm.cvar.ios_base_floatfield
+ios_base.badbit = _libQasm.cvar.ios_base_badbit
+ios_base.eofbit = _libQasm.cvar.ios_base_eofbit
+ios_base.failbit = _libQasm.cvar.ios_base_failbit
+ios_base.goodbit = _libQasm.cvar.ios_base_goodbit
+ios_base.app = _libQasm.cvar.ios_base_app
+ios_base.ate = _libQasm.cvar.ios_base_ate
+ios_base.binary = _libQasm.cvar.ios_base_binary
+ios_base.ios_base_in = _libQasm.cvar.ios_base_ios_base_in
+ios_base.out = _libQasm.cvar.ios_base_out
+ios_base.trunc = _libQasm.cvar.ios_base_trunc
+ios_base.beg = _libQasm.cvar.ios_base_beg
+ios_base.cur = _libQasm.cvar.ios_base_cur
+ios_base.end = _libQasm.cvar.ios_base_end
+
+class ios(ios_base):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def rdstate(self):
+        return _libQasm.ios_rdstate(self)
+
+    def clear(self, *args):
+        return _libQasm.ios_clear(self, *args)
+
+    def setstate(self, __state):
+        return _libQasm.ios_setstate(self, __state)
+
+    def good(self):
+        return _libQasm.ios_good(self)
+
+    def eof(self):
+        return _libQasm.ios_eof(self)
+
+    def fail(self):
+        return _libQasm.ios_fail(self)
+
+    def bad(self):
+        return _libQasm.ios_bad(self)
+
+    def exceptions(self, *args):
+        return _libQasm.ios_exceptions(self, *args)
+
+    def __init__(self, __sb):
+        _libQasm.ios_swiginit(self, _libQasm.new_ios(__sb))
+    __swig_destroy__ = _libQasm.delete_ios
+
+    def tie(self, *args):
+        return _libQasm.ios_tie(self, *args)
+
+    def rdbuf(self, *args):
+        return _libQasm.ios_rdbuf(self, *args)
+
+    def copyfmt(self, __rhs):
+        return _libQasm.ios_copyfmt(self, __rhs)
+
+    def fill(self, *args):
+        return _libQasm.ios_fill(self, *args)
+
+    def imbue(self, __loc):
+        return _libQasm.ios_imbue(self, __loc)
+
+    def narrow(self, __c, __dfault):
+        return _libQasm.ios_narrow(self, __c, __dfault)
+
+    def widen(self, __c):
+        return _libQasm.ios_widen(self, __c)
+
+# Register ios in _libQasm:
+_libQasm.ios_swigregister(ios)
+class string(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def length(self):
+        return _libQasm.string_length(self)
+
+    def max_size(self):
+        return _libQasm.string_max_size(self)
+
+    def capacity(self):
+        return _libQasm.string_capacity(self)
+
+    def reserve(self, __res_arg):
+        return _libQasm.string_reserve(self, __res_arg)
+
+    def shrink_to_fit(self):
+        return _libQasm.string_shrink_to_fit(self)
+
+    def copy(self, __s, __n, __pos=0):
+        return _libQasm.string_copy(self, __s, __n, __pos)
+
+    def c_str(self):
+        return _libQasm.string_c_str(self)
+
+    def find(self, *args):
+        return _libQasm.string_find(self, *args)
+
+    def rfind(self, *args):
+        return _libQasm.string_rfind(self, *args)
+
+    def find_first_of(self, *args):
+        return _libQasm.string_find_first_of(self, *args)
+
+    def find_last_of(self, *args):
+        return _libQasm.string_find_last_of(self, *args)
+
+    def find_first_not_of(self, *args):
+        return _libQasm.string_find_first_not_of(self, *args)
+
+    def find_last_not_of(self, *args):
+        return _libQasm.string_find_last_not_of(self, *args)
+
+    def substr(self, *args):
+        return _libQasm.string_substr(self, *args)
+
+    def empty(self):
+        return _libQasm.string_empty(self)
+
+    def size(self):
+        return _libQasm.string_size(self)
+
+    def swap(self, v):
+        return _libQasm.string_swap(self, v)
+
+    def begin(self):
+        return _libQasm.string_begin(self)
+
+    def end(self):
+        return _libQasm.string_end(self)
+
+    def rbegin(self):
+        return _libQasm.string_rbegin(self)
+
+    def rend(self):
+        return _libQasm.string_rend(self)
+
+    def get_allocator(self):
+        return _libQasm.string_get_allocator(self)
+
+    def erase(self, *args):
+        return _libQasm.string_erase(self, *args)
+
+    def __init__(self, *args):
+        _libQasm.string_swiginit(self, _libQasm.new_string(*args))
+
+    def assign(self, *args):
+        return _libQasm.string_assign(self, *args)
+
+    def resize(self, *args):
+        return _libQasm.string_resize(self, *args)
+
+    def iterator(self):
+        return _libQasm.string_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _libQasm.string___nonzero__(self)
+
+    def __bool__(self):
+        return _libQasm.string___bool__(self)
+
+    def __len__(self):
+        return _libQasm.string___len__(self)
+
+    def __getslice__(self, i, j):
+        return _libQasm.string___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _libQasm.string___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _libQasm.string___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _libQasm.string___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _libQasm.string___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _libQasm.string___setitem__(self, *args)
+
+    def insert(self, *args):
+        return _libQasm.string_insert(self, *args)
+
+    def replace(self, *args):
+        return _libQasm.string_replace(self, *args)
+
+    def __iadd__(self, v):
+        return _libQasm.string___iadd__(self, v)
+
+    def __add__(self, v):
+        return _libQasm.string___add__(self, v)
+
+    def __radd__(self, v):
+        return _libQasm.string___radd__(self, v)
+
+    def __str__(self):
+        return _libQasm.string___str__(self)
+
+    def __rlshift__(self, out):
+        return _libQasm.string___rlshift__(self, out)
+
+    def __eq__(self, v):
+        return _libQasm.string___eq__(self, v)
+
+    def __ne__(self, v):
+        return _libQasm.string___ne__(self, v)
+
+    def __gt__(self, v):
+        return _libQasm.string___gt__(self, v)
+
+    def __lt__(self, v):
+        return _libQasm.string___lt__(self, v)
+
+    def __ge__(self, v):
+        return _libQasm.string___ge__(self, v)
+
+    def __le__(self, v):
+        return _libQasm.string___le__(self, v)
+    __swig_destroy__ = _libQasm.delete_string
+
+# Register string in _libQasm:
+_libQasm.string_swigregister(string)
+string.npos = _libQasm.cvar.string_npos
+
+class ostream(ios):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, __sb):
+        _libQasm.ostream_swiginit(self, _libQasm.new_ostream(__sb))
+    __swig_destroy__ = _libQasm.delete_ostream
+
+    def __lshift__(self, *args):
+        return _libQasm.ostream___lshift__(self, *args)
+
+    def put(self, __c):
+        return _libQasm.ostream_put(self, __c)
+
+    def write(self, __s, __n):
+        return _libQasm.ostream_write(self, __s, __n)
+
+    def flush(self):
+        return _libQasm.ostream_flush(self)
+
+    def tellp(self):
+        return _libQasm.ostream_tellp(self)
+
+    def seekp(self, *args):
+        return _libQasm.ostream_seekp(self, *args)
+
+# Register ostream in _libQasm:
+_libQasm.ostream_swigregister(ostream)
+class istream(ios):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, __sb):
+        _libQasm.istream_swiginit(self, _libQasm.new_istream(__sb))
+    __swig_destroy__ = _libQasm.delete_istream
+
+    def __rshift__(self, *args):
+        return _libQasm.istream___rshift__(self, *args)
+
+    def gcount(self):
+        return _libQasm.istream_gcount(self)
+
+    def get(self, *args):
+        return _libQasm.istream_get(self, *args)
+
+    def getline(self, *args):
+        return _libQasm.istream_getline(self, *args)
+
+    def ignore(self, *args):
+        return _libQasm.istream_ignore(self, *args)
+
+    def peek(self):
+        return _libQasm.istream_peek(self)
+
+    def read(self, __s, __n):
+        return _libQasm.istream_read(self, __s, __n)
+
+    def readsome(self, __s, __n):
+        return _libQasm.istream_readsome(self, __s, __n)
+
+    def putback(self, __c):
+        return _libQasm.istream_putback(self, __c)
+
+    def unget(self):
+        return _libQasm.istream_unget(self)
+
+    def sync(self):
+        return _libQasm.istream_sync(self)
+
+    def tellg(self):
+        return _libQasm.istream_tellg(self)
+
+    def seekg(self, *args):
+        return _libQasm.istream_seekg(self, *args)
+
+# Register istream in _libQasm:
+_libQasm.istream_swigregister(istream)
+class iostream(istream, ostream):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, __sb):
+        _libQasm.iostream_swiginit(self, _libQasm.new_iostream(__sb))
+    __swig_destroy__ = _libQasm.delete_iostream
+
+# Register iostream in _libQasm:
+_libQasm.iostream_swigregister(iostream)
+cin = cvar.cin
+cout = cvar.cout
+cerr = cvar.cerr
+clog = cvar.clog
+
+endl_cb_ptr = _libQasm.endl_cb_ptr
+endl = _libQasm.endl
+ends_cb_ptr = _libQasm.ends_cb_ptr
+ends = _libQasm.ends
+flush_cb_ptr = _libQasm.flush_cb_ptr
+flush = _libQasm.flush
+class vectori(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self):
+        return _libQasm.vectori_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _libQasm.vectori___nonzero__(self)
+
+    def __bool__(self):
+        return _libQasm.vectori___bool__(self)
+
+    def __len__(self):
+        return _libQasm.vectori___len__(self)
+
+    def __getslice__(self, i, j):
+        return _libQasm.vectori___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _libQasm.vectori___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _libQasm.vectori___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _libQasm.vectori___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _libQasm.vectori___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _libQasm.vectori___setitem__(self, *args)
+
+    def pop(self):
+        return _libQasm.vectori_pop(self)
+
+    def append(self, x):
+        return _libQasm.vectori_append(self, x)
+
+    def empty(self):
+        return _libQasm.vectori_empty(self)
+
+    def size(self):
+        return _libQasm.vectori_size(self)
+
+    def swap(self, v):
+        return _libQasm.vectori_swap(self, v)
+
+    def begin(self):
+        return _libQasm.vectori_begin(self)
+
+    def end(self):
+        return _libQasm.vectori_end(self)
+
+    def rbegin(self):
+        return _libQasm.vectori_rbegin(self)
+
+    def rend(self):
+        return _libQasm.vectori_rend(self)
+
+    def clear(self):
+        return _libQasm.vectori_clear(self)
+
+    def get_allocator(self):
+        return _libQasm.vectori_get_allocator(self)
+
+    def pop_back(self):
+        return _libQasm.vectori_pop_back(self)
+
+    def erase(self, *args):
+        return _libQasm.vectori_erase(self, *args)
+
+    def __init__(self, *args):
+        _libQasm.vectori_swiginit(self, _libQasm.new_vectori(*args))
+
+    def push_back(self, x):
+        return _libQasm.vectori_push_back(self, x)
+
+    def front(self):
+        return _libQasm.vectori_front(self)
+
+    def back(self):
+        return _libQasm.vectori_back(self)
+
+    def assign(self, n, x):
+        return _libQasm.vectori_assign(self, n, x)
+
+    def resize(self, *args):
+        return _libQasm.vectori_resize(self, *args)
+
+    def insert(self, *args):
+        return _libQasm.vectori_insert(self, *args)
+
+    def reserve(self, n):
+        return _libQasm.vectori_reserve(self, n)
+
+    def capacity(self):
+        return _libQasm.vectori_capacity(self)
+    __swig_destroy__ = _libQasm.delete_vectori
+
+# Register vectori in _libQasm:
+_libQasm.vectori_swigregister(vectori)
+class vectorui(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self):
+        return _libQasm.vectorui_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _libQasm.vectorui___nonzero__(self)
+
+    def __bool__(self):
+        return _libQasm.vectorui___bool__(self)
+
+    def __len__(self):
+        return _libQasm.vectorui___len__(self)
+
+    def __getslice__(self, i, j):
+        return _libQasm.vectorui___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _libQasm.vectorui___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _libQasm.vectorui___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _libQasm.vectorui___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _libQasm.vectorui___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _libQasm.vectorui___setitem__(self, *args)
+
+    def pop(self):
+        return _libQasm.vectorui_pop(self)
+
+    def append(self, x):
+        return _libQasm.vectorui_append(self, x)
+
+    def empty(self):
+        return _libQasm.vectorui_empty(self)
+
+    def size(self):
+        return _libQasm.vectorui_size(self)
+
+    def swap(self, v):
+        return _libQasm.vectorui_swap(self, v)
+
+    def begin(self):
+        return _libQasm.vectorui_begin(self)
+
+    def end(self):
+        return _libQasm.vectorui_end(self)
+
+    def rbegin(self):
+        return _libQasm.vectorui_rbegin(self)
+
+    def rend(self):
+        return _libQasm.vectorui_rend(self)
+
+    def clear(self):
+        return _libQasm.vectorui_clear(self)
+
+    def get_allocator(self):
+        return _libQasm.vectorui_get_allocator(self)
+
+    def pop_back(self):
+        return _libQasm.vectorui_pop_back(self)
+
+    def erase(self, *args):
+        return _libQasm.vectorui_erase(self, *args)
+
+    def __init__(self, *args):
+        _libQasm.vectorui_swiginit(self, _libQasm.new_vectorui(*args))
+
+    def push_back(self, x):
+        return _libQasm.vectorui_push_back(self, x)
+
+    def front(self):
+        return _libQasm.vectorui_front(self)
+
+    def back(self):
+        return _libQasm.vectorui_back(self)
+
+    def assign(self, n, x):
+        return _libQasm.vectorui_assign(self, n, x)
+
+    def resize(self, *args):
+        return _libQasm.vectorui_resize(self, *args)
+
+    def insert(self, *args):
+        return _libQasm.vectorui_insert(self, *args)
+
+    def reserve(self, n):
+        return _libQasm.vectorui_reserve(self, n)
+
+    def capacity(self):
+        return _libQasm.vectorui_capacity(self)
+    __swig_destroy__ = _libQasm.delete_vectorui
+
+# Register vectorui in _libQasm:
+_libQasm.vectorui_swigregister(vectorui)
+class vectorf(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self):
+        return _libQasm.vectorf_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _libQasm.vectorf___nonzero__(self)
+
+    def __bool__(self):
+        return _libQasm.vectorf___bool__(self)
+
+    def __len__(self):
+        return _libQasm.vectorf___len__(self)
+
+    def __getslice__(self, i, j):
+        return _libQasm.vectorf___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _libQasm.vectorf___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _libQasm.vectorf___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _libQasm.vectorf___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _libQasm.vectorf___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _libQasm.vectorf___setitem__(self, *args)
+
+    def pop(self):
+        return _libQasm.vectorf_pop(self)
+
+    def append(self, x):
+        return _libQasm.vectorf_append(self, x)
+
+    def empty(self):
+        return _libQasm.vectorf_empty(self)
+
+    def size(self):
+        return _libQasm.vectorf_size(self)
+
+    def swap(self, v):
+        return _libQasm.vectorf_swap(self, v)
+
+    def begin(self):
+        return _libQasm.vectorf_begin(self)
+
+    def end(self):
+        return _libQasm.vectorf_end(self)
+
+    def rbegin(self):
+        return _libQasm.vectorf_rbegin(self)
+
+    def rend(self):
+        return _libQasm.vectorf_rend(self)
+
+    def clear(self):
+        return _libQasm.vectorf_clear(self)
+
+    def get_allocator(self):
+        return _libQasm.vectorf_get_allocator(self)
+
+    def pop_back(self):
+        return _libQasm.vectorf_pop_back(self)
+
+    def erase(self, *args):
+        return _libQasm.vectorf_erase(self, *args)
+
+    def __init__(self, *args):
+        _libQasm.vectorf_swiginit(self, _libQasm.new_vectorf(*args))
+
+    def push_back(self, x):
+        return _libQasm.vectorf_push_back(self, x)
+
+    def front(self):
+        return _libQasm.vectorf_front(self)
+
+    def back(self):
+        return _libQasm.vectorf_back(self)
+
+    def assign(self, n, x):
+        return _libQasm.vectorf_assign(self, n, x)
+
+    def resize(self, *args):
+        return _libQasm.vectorf_resize(self, *args)
+
+    def insert(self, *args):
+        return _libQasm.vectorf_insert(self, *args)
+
+    def reserve(self, n):
+        return _libQasm.vectorf_reserve(self, n)
+
+    def capacity(self):
+        return _libQasm.vectorf_capacity(self)
+    __swig_destroy__ = _libQasm.delete_vectorf
+
+# Register vectorf in _libQasm:
+_libQasm.vectorf_swigregister(vectorf)
+class vectord(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self):
+        return _libQasm.vectord_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _libQasm.vectord___nonzero__(self)
+
+    def __bool__(self):
+        return _libQasm.vectord___bool__(self)
+
+    def __len__(self):
+        return _libQasm.vectord___len__(self)
+
+    def __getslice__(self, i, j):
+        return _libQasm.vectord___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _libQasm.vectord___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _libQasm.vectord___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _libQasm.vectord___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _libQasm.vectord___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _libQasm.vectord___setitem__(self, *args)
+
+    def pop(self):
+        return _libQasm.vectord_pop(self)
+
+    def append(self, x):
+        return _libQasm.vectord_append(self, x)
+
+    def empty(self):
+        return _libQasm.vectord_empty(self)
+
+    def size(self):
+        return _libQasm.vectord_size(self)
+
+    def swap(self, v):
+        return _libQasm.vectord_swap(self, v)
+
+    def begin(self):
+        return _libQasm.vectord_begin(self)
+
+    def end(self):
+        return _libQasm.vectord_end(self)
+
+    def rbegin(self):
+        return _libQasm.vectord_rbegin(self)
+
+    def rend(self):
+        return _libQasm.vectord_rend(self)
+
+    def clear(self):
+        return _libQasm.vectord_clear(self)
+
+    def get_allocator(self):
+        return _libQasm.vectord_get_allocator(self)
+
+    def pop_back(self):
+        return _libQasm.vectord_pop_back(self)
+
+    def erase(self, *args):
+        return _libQasm.vectord_erase(self, *args)
+
+    def __init__(self, *args):
+        _libQasm.vectord_swiginit(self, _libQasm.new_vectord(*args))
+
+    def push_back(self, x):
+        return _libQasm.vectord_push_back(self, x)
+
+    def front(self):
+        return _libQasm.vectord_front(self)
+
+    def back(self):
+        return _libQasm.vectord_back(self)
+
+    def assign(self, n, x):
+        return _libQasm.vectord_assign(self, n, x)
+
+    def resize(self, *args):
+        return _libQasm.vectord_resize(self, *args)
+
+    def insert(self, *args):
+        return _libQasm.vectord_insert(self, *args)
+
+    def reserve(self, n):
+        return _libQasm.vectord_reserve(self, n)
+
+    def capacity(self):
+        return _libQasm.vectord_capacity(self)
+    __swig_destroy__ = _libQasm.delete_vectord
+
+# Register vectord in _libQasm:
+_libQasm.vectord_swigregister(vectord)
+class vectors(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self):
+        return _libQasm.vectors_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _libQasm.vectors___nonzero__(self)
+
+    def __bool__(self):
+        return _libQasm.vectors___bool__(self)
+
+    def __len__(self):
+        return _libQasm.vectors___len__(self)
+
+    def __getslice__(self, i, j):
+        return _libQasm.vectors___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _libQasm.vectors___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _libQasm.vectors___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _libQasm.vectors___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _libQasm.vectors___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _libQasm.vectors___setitem__(self, *args)
+
+    def pop(self):
+        return _libQasm.vectors_pop(self)
+
+    def append(self, x):
+        return _libQasm.vectors_append(self, x)
+
+    def empty(self):
+        return _libQasm.vectors_empty(self)
+
+    def size(self):
+        return _libQasm.vectors_size(self)
+
+    def swap(self, v):
+        return _libQasm.vectors_swap(self, v)
+
+    def begin(self):
+        return _libQasm.vectors_begin(self)
+
+    def end(self):
+        return _libQasm.vectors_end(self)
+
+    def rbegin(self):
+        return _libQasm.vectors_rbegin(self)
+
+    def rend(self):
+        return _libQasm.vectors_rend(self)
+
+    def clear(self):
+        return _libQasm.vectors_clear(self)
+
+    def get_allocator(self):
+        return _libQasm.vectors_get_allocator(self)
+
+    def pop_back(self):
+        return _libQasm.vectors_pop_back(self)
+
+    def erase(self, *args):
+        return _libQasm.vectors_erase(self, *args)
+
+    def __init__(self, *args):
+        _libQasm.vectors_swiginit(self, _libQasm.new_vectors(*args))
+
+    def push_back(self, x):
+        return _libQasm.vectors_push_back(self, x)
+
+    def front(self):
+        return _libQasm.vectors_front(self)
+
+    def back(self):
+        return _libQasm.vectors_back(self)
+
+    def assign(self, n, x):
+        return _libQasm.vectors_assign(self, n, x)
+
+    def resize(self, *args):
+        return _libQasm.vectors_resize(self, *args)
+
+    def insert(self, *args):
+        return _libQasm.vectors_insert(self, *args)
+
+    def reserve(self, n):
+        return _libQasm.vectors_reserve(self, n)
+
+    def capacity(self):
+        return _libQasm.vectors_capacity(self)
+    __swig_destroy__ = _libQasm.delete_vectors
+
+# Register vectors in _libQasm:
+_libQasm.vectors_swigregister(vectors)
+class V3xAnalyzer(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _libQasm.V3xAnalyzer_swiginit(self, _libQasm.new_V3xAnalyzer(*args))
+    __swig_destroy__ = _libQasm.delete_V3xAnalyzer
+
+    def register_instruction(self, *args):
+        return _libQasm.V3xAnalyzer_register_instruction(self, *args)
+
+    @staticmethod
+    def parse_file(file_name):
+        return _libQasm.V3xAnalyzer_parse_file(file_name)
+
+    @staticmethod
+    def parse_file_to_json(file_name):
+        return _libQasm.V3xAnalyzer_parse_file_to_json(file_name)
+
+    @staticmethod
+    def parse_string(*args):
+        return _libQasm.V3xAnalyzer_parse_string(*args)
+
+    @staticmethod
+    def parse_string_to_json(*args):
+        return _libQasm.V3xAnalyzer_parse_string_to_json(*args)
+
+    def analyze_file(self, file_name):
+        return _libQasm.V3xAnalyzer_analyze_file(self, file_name)
+
+    def analyze_file_to_json(self, file_name):
+        return _libQasm.V3xAnalyzer_analyze_file_to_json(self, file_name)
+
+    def analyze_string(self, *args):
+        return _libQasm.V3xAnalyzer_analyze_string(self, *args)
+
+    def analyze_string_to_json(self, *args):
+        return _libQasm.V3xAnalyzer_analyze_string_to_json(self, *args)
+
+# Register V3xAnalyzer in _libQasm:
+_libQasm.V3xAnalyzer_swigregister(V3xAnalyzer)
+
```

## Comparing `libqasm-0.6.2.dist-info/LICENSE.md` & `libqasm-0.6.3.dist-info/LICENSE.md`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-Copyright [2018] [QCA Lab, QuTech, TU Delft]
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
+Copyright [2018] [QCA Lab, QuTech, TU Delft]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
```

## Comparing `libqasm-0.6.2.dist-info/METADATA` & `libqasm-0.6.3.dist-info/METADATA`

 * *Files 24% similar despite different names*

```diff
@@ -1,190 +1,190 @@
-Metadata-Version: 2.1
-Name: libqasm
-Version: 0.6.2
-Summary: libQasm Python Package
-Home-page: https://github.com/QuTech-Delft/libqasm
-Author: QuTech, TU Delft
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Operating System :: MacOS
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Topic :: Scientific/Engineering
-Description-Content-Type: text/markdown
-License-File: LICENSE.md
-Requires-Dist: numpy
-
-# libQASM: Library to parse cQASM v3.0 files
-
-[![CI](https://github.com/QuTech-Delft/libqasm/workflows/Test/badge.svg)](https://github.com/qutech-delft/libqasm/actions)
-[![PyPI](https://badgen.net/pypi/v/libqasm)](https://pypi.org/project/libqasm/)
-
-## File organization
-
-For development, see:
-
-- `include`: public headers.
-- `src`: source files.
-- `test`: test files.
-- `python`: SWIG interface.
-- `res`: resource files, for testing.
-
-For build process, continuous integration, and documentation:
-
-- `conan`: Conan profiles.
-- `emscripten`: bindings and test for the emscripten binaries.
-- `scripts`: helper scripts used during the build process.
-- `.github`: GitHub Actions configuration files.
-- `doc`: documentation.
-
-Build outputs may go into:
-
-- `build/<build type>`: the C++ library output files generated by Conan.
-- `pybuild`: the Python library output files generated by `setup.py`.
-
-## Dependencies
-
-* C++ compiler with C++20 support (gcc 11, clang 14, msvc 17)
-* `CMake` >= 3.12
-* `git`
-* `Python` 3.x plus `pip`, with the following package:
-  * `conan` >= 2.0
-  
-### ARM specific dependencies
-
-We are having problems when using the `zulu-opendjk` Conan package on an ARMv8 architecture.
-`zulu-openjdk` provides the Java JRE required by the ANTLR generator.
-So, for the time being, we are installing Java manually for this platform.
-
-* `Java JRE` >= 11
-
-## Build
-
-This version of `libqasm` can only be compiled via the Conan package manager.
-You'll need to create a default profile before using it for the first time.
-
-The installation of dependencies, as well as the compilation, can be done in one go.
-
-```
-git clone https://github.com/QuTech-Delft/libqasm.git
-cd libqasm
-conan profile detect
-conan build . -pr:a=conan/profiles/tests-debug -b missing
-```
-
-Notice:
-- the `conan profile` command only has to be run only once, and not before every build.
-- the `conan build` command is building `libqasm` in Debug mode with tests using the `tests-debug` profile.
-- the `-b missing` parameter asks `conan` to build packages from sources
-in case it cannot find the binary packages for the current configuration (platform, OS, compiler, build type...). 
-
-### Build profiles
-
-A group of predefined profiles is provided under the `conan/profiles` folder.
-They follow the `[tests-](debug|release)[-compat]` naming convention. For example:
-  - `release` is a Release build without tests and compatibility with the original API.
-  - `tests-debug-compat` is a Debug build with tests and compatibility enabled.
-
-All the profiles set the C++ standard to 20. All the `tests` profiles enable Address Sanitizer.
-
-### Build options
-
-Profiles are a shorthand for command line options. The command above could be written as well as: 
-
-```
-conan build . -s:h compiler.cppstd=20 -s:h libqasm/*:build_type=Debug -o libqasm/*:build_tests=True -o libqasm/*:asan_enabled=True -b missing
-```
-
-These are the list of options that could be specified whether in a profile or in the command line:
-
-- `libqasm/*:asan_enabled={True,False}`: enables Address Sanitizer.
-- `libqasm/*:build_tests={True,False}`: builds tests or not.
-- `libqasm/*:build_type={Debug,Release}`: builds in debug or release mode.
-- `libqasm/*:shared={True,False}`: builds a shared object library instead of a static library, if applicable.
-
-## Install
-
-### From Python
-
-Install from the project root directory as follows:
-
-```
-python3 -m pip install --verbose .
-```
-
-You can test if it works by running:
-
-```
-python3 -m pytest
-```
-
-### From C++
-
-The `CMakeLists.txt` file in the root directory includes install targets:
-
-```
-conan create --version 0.5.2 . -pr=tests-debug -b missing
-```
-
-You can test if it works by doing:
-
-```
-cd test/Debug
-ctest -C Debug --output-on-failure
-```
-
-## Use from another project
-
-### From Python
-
-After installation, you should be able to use the bindings for the original API by just `import libQasm`.
-The new API doesn't have Python bindings yet.
-
-### From C++
-
-The easiest way to use `libqasm` in a CMake project is to fetch the library and then link against it.
-
-```
-include(FetchContent)
-FetchContent_Declare(cqasm
-    GIT_REPOSITORY https://github.com/QuTech-Delft/libqasm.git
-    GIT_TAG "<a given cqasm git tag>"
-)
-FetchContent_MakeAvailable(cqasm)
-target_include_directories(<your target> SYSTEM PRIVATE "${cqasm_SOURCE_DIR}/include")
-target_link_libraries(<your target> PUBLIC cqasm)
-```
-
-Note that the following dependency is required for `libqasm` to build:
-
-* `Java JRE` >= 11
-
-The original API headers are *not* included by default.
-To enable those, pass <code><nobr>-o libqasm/*:compat=True</nobr></code> as a build option to Conan.
-
-## Docker
-
-This tests the library in a container with the bare minimum requirements for `libqasm`.
-
-```
-docker build .
-```
-
-**Note for Windows users:** The above might fail on Windows to the autocrlf transformation that git does.
-If you are having trouble with this just create new clone of this repository using:
-
-```
-git clone --config core.autocrlf=input git@github.com:QuTech-Delft/libqasm.git
-```
-
-## Emscripten
-
-The generation of emscripten binaries has been tested as a cross-compilation from an ubuntu/x64 platform.
-
-```
-conan build . -pr=conan/profiles/emscripten -pr:b=conan/profiles/release -b missing
-```
-
-The output of this build lives in `build/Release/emscripten`:
-- `cqasm_emscripten.js`.
-- `cqasm_emscripten.wasm`.
+Metadata-Version: 2.1
+Name: libqasm
+Version: 0.6.3
+Summary: libQasm Python Package
+Home-page: https://github.com/QuTech-Delft/libqasm
+Author: QuTech, TU Delft
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: MacOS
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Topic :: Scientific/Engineering
+Description-Content-Type: text/markdown
+License-File: LICENSE.md
+Requires-Dist: numpy
+
+# libQASM: Library to parse cQASM v3.0 files
+
+[![CI](https://github.com/QuTech-Delft/libqasm/workflows/Test/badge.svg)](https://github.com/qutech-delft/libqasm/actions)
+[![PyPI](https://badgen.net/pypi/v/libqasm)](https://pypi.org/project/libqasm/)
+
+## File organization
+
+For development, see:
+
+- `include`: public headers.
+- `src`: source files.
+- `test`: test files.
+- `python`: SWIG interface.
+- `res`: resource files, for testing.
+
+For build process, continuous integration, and documentation:
+
+- `conan`: Conan profiles.
+- `emscripten`: bindings and test for the emscripten binaries.
+- `scripts`: helper scripts used during the build process.
+- `.github`: GitHub Actions configuration files.
+- `doc`: documentation.
+
+Build outputs may go into:
+
+- `build/<build type>`: the C++ library output files generated by Conan.
+- `pybuild`: the Python library output files generated by `setup.py`.
+
+## Dependencies
+
+* C++ compiler with C++20 support (gcc 11, clang 14, msvc 17)
+* `CMake` >= 3.12
+* `git`
+* `Python` 3.x plus `pip`, with the following package:
+  * `conan` >= 2.0
+  
+### ARM specific dependencies
+
+We are having problems when using the `zulu-opendjk` Conan package on an ARMv8 architecture.
+`zulu-openjdk` provides the Java JRE required by the ANTLR generator.
+So, for the time being, we are installing Java manually for this platform.
+
+* `Java JRE` >= 11
+
+## Build
+
+This version of `libqasm` can only be compiled via the Conan package manager.
+You'll need to create a default profile before using it for the first time.
+
+The installation of dependencies, as well as the compilation, can be done in one go.
+
+```
+git clone https://github.com/QuTech-Delft/libqasm.git
+cd libqasm
+conan profile detect
+conan build . -pr:a=conan/profiles/tests-debug -b missing
+```
+
+Notice:
+- the `conan profile` command only has to be run only once, and not before every build.
+- the `conan build` command is building `libqasm` in Debug mode with tests using the `tests-debug` profile.
+- the `-b missing` parameter asks `conan` to build packages from sources
+in case it cannot find the binary packages for the current configuration (platform, OS, compiler, build type...). 
+
+### Build profiles
+
+A group of predefined profiles is provided under the `conan/profiles` folder.
+They follow the `[tests-](debug|release)[-compat]` naming convention. For example:
+  - `release` is a Release build without tests and compatibility with the original API.
+  - `tests-debug-compat` is a Debug build with tests and compatibility enabled.
+
+All the profiles set the C++ standard to 20. All the `tests` profiles enable Address Sanitizer.
+
+### Build options
+
+Profiles are a shorthand for command line options. The command above could be written as well as: 
+
+```
+conan build . -s:h compiler.cppstd=20 -s:h libqasm/*:build_type=Debug -o libqasm/*:build_tests=True -o libqasm/*:asan_enabled=True -b missing
+```
+
+These are the list of options that could be specified whether in a profile or in the command line:
+
+- `libqasm/*:asan_enabled={True,False}`: enables Address Sanitizer.
+- `libqasm/*:build_tests={True,False}`: builds tests or not.
+- `libqasm/*:build_type={Debug,Release}`: builds in debug or release mode.
+- `libqasm/*:shared={True,False}`: builds a shared object library instead of a static library, if applicable.
+
+## Install
+
+### From Python
+
+Install from the project root directory as follows:
+
+```
+python3 -m pip install --verbose .
+```
+
+You can test if it works by running:
+
+```
+python3 -m pytest
+```
+
+### From C++
+
+The `CMakeLists.txt` file in the root directory includes install targets:
+
+```
+conan create --version 0.5.2 . -pr=tests-debug -b missing
+```
+
+You can test if it works by doing:
+
+```
+cd test/Debug
+ctest -C Debug --output-on-failure
+```
+
+## Use from another project
+
+### From Python
+
+After installation, you should be able to use the bindings for the original API by just `import libQasm`.
+The new API doesn't have Python bindings yet.
+
+### From C++
+
+The easiest way to use `libqasm` in a CMake project is to fetch the library and then link against it.
+
+```
+include(FetchContent)
+FetchContent_Declare(cqasm
+    GIT_REPOSITORY https://github.com/QuTech-Delft/libqasm.git
+    GIT_TAG "<a given cqasm git tag>"
+)
+FetchContent_MakeAvailable(cqasm)
+target_include_directories(<your target> SYSTEM PRIVATE "${cqasm_SOURCE_DIR}/include")
+target_link_libraries(<your target> PUBLIC cqasm)
+```
+
+Note that the following dependency is required for `libqasm` to build:
+
+* `Java JRE` >= 11
+
+The original API headers are *not* included by default.
+To enable those, pass <code><nobr>-o libqasm/*:compat=True</nobr></code> as a build option to Conan.
+
+## Docker
+
+This tests the library in a container with the bare minimum requirements for `libqasm`.
+
+```
+docker build .
+```
+
+**Note for Windows users:** The above might fail on Windows to the autocrlf transformation that git does.
+If you are having trouble with this just create new clone of this repository using:
+
+```
+git clone --config core.autocrlf=input git@github.com:QuTech-Delft/libqasm.git
+```
+
+## Emscripten
+
+The generation of emscripten binaries has been tested as a cross-compilation from an ubuntu/x64 platform.
+
+```
+conan build . -pr=conan/profiles/emscripten -pr:b=conan/profiles/release -b missing
+```
+
+The output of this build lives in `build/Release/emscripten`:
+- `cqasm_emscripten.js`.
+- `cqasm_emscripten.wasm`.
```

